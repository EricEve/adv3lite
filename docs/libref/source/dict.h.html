<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>dict.h</title></head><body>
<table class=ban><tr><td><h1>dict.h</h1><td align=right><a href="../file/dict.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This header defines the Dictionary intrinsic class.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>
<a name="13"></a>/* include our base class definition */
<a name="14"></a>#include "systype.h"
<a name="15"></a>
<a name="16"></a>/*
<a name="17"></a> *   The Dictionary intrinsic class is a specialized lookup table class
<a name="18"></a> *   designed for storing the vocabulary table for a parser.  Dictionary
<a name="19"></a> *   works closely with GrammarProd to supply the vocabulary tokens for the
<a name="20"></a> *   productions.
<a name="21"></a> *   
<a name="22"></a> *   The main difference between Dictionary and a more general hash table is
<a name="23"></a> *   that Dictionary tags each vocabulary word with a type; for our purposes,
<a name="24"></a> *   the type is the vocabulary property (&amp;noun, &amp;adjective, etc) that
<a name="25"></a> *   associates the word with an object.  
<a name="26"></a> */
<a name="27"></a>intrinsic class Dictionary 'dictionary2/030001': Object
<a name="28"></a>{
<a name="29"></a>    /*
<a name="30"></a>     *   Constructor:
<a name="31"></a>     *   
<a name="32"></a>     *   new Dictionary() - creates a dictionary with a default comparator,
<a name="33"></a>     *   which matches strings exactly (note that upper-case and lower-case
<a name="34"></a>     *   letters are considered distinct)
<a name="35"></a>     *   
<a name="36"></a>     *   new Dictionary(compObj) - create a dictionary with the given
<a name="37"></a>     *   comparator object.  A comparator is an object that implements the
<a name="38"></a>     *   comparator interface - see below for details.  When searching the
<a name="39"></a>     *   dictionary (with findWord, for example), we use the comparator
<a name="40"></a>     *   object to determine if the string beings sought matches a dictionary
<a name="41"></a>     *   string.  
<a name="42"></a>     */
<a name="43"></a>
<a name="44"></a>    /* 
<a name="45"></a>     *   Set the comparator object.  This defines how words are compared.
<a name="46"></a>     *   The object must provide the following methods, which comprise the
<a name="47"></a>     *   "comparator" interface.  Note that there's no class that defines
<a name="48"></a>     *   this interface; this is simply a set of methods that we define here,
<a name="49"></a>     *   and which the supplied object must define.
<a name="50"></a>     *   
<a name="51"></a>     *   calcHash(str) - returns an integer giving the hash value of the
<a name="52"></a>     *   given string.  The purpose of the hash value is to arbitrarily
<a name="53"></a>     *   partition the search space, so that we can search only a small
<a name="54"></a>     *   subset of the dictionary when looking for a particular string.  It
<a name="55"></a>     *   is desirable for hash values to distribute uniformly for a given set
<a name="56"></a>     *   of strings.  It's also highly desirable for the hash computation to
<a name="57"></a>     *   be inexpensive (i.e., to run fast), since the whole point of the
<a name="58"></a>     *   hash is to reduce the amount of time it takes to find a string; if
<a name="59"></a>     *   it takes longer to compute the hash value than it would to search
<a name="60"></a>     *   every string in the table, then we don't come out ahead using the
<a name="61"></a>     *   hash.
<a name="62"></a>     *   
<a name="63"></a>     *   matchValues(inputStr, dictStr) - compare the given input string with
<a name="64"></a>     *   the given dictionary string, and return a result indicating whether
<a name="65"></a>     *   or not they match for the purposes of the comparator.  A return
<a name="66"></a>     *   value of zero or nil indicates that the values do not match; any
<a name="67"></a>     *   other return value indicates a match.
<a name="68"></a>     *   
<a name="69"></a>     *   Typically, matchValues() will return a non-zero integer to indicate
<a name="70"></a>     *   a match and to encode additional information about the match using a
<a name="71"></a>     *   bitwise-OR'd combination of flag values.  For example, a comparator
<a name="72"></a>     *   that allows case folding could use bit flag 0x0001 to indicate any
<a name="73"></a>     *   match, and bit flag 0x0002 to indicate a match where the case of one
<a name="74"></a>     *   or more input letters did not match the case of the corresponding
<a name="75"></a>     *   letters in the dictionary string.  So, a return value of 0x0001
<a name="76"></a>     *   would indicate an exact match, and 0x0003 would indicate a match
<a name="77"></a>     *   with case differences.
<a name="78"></a>     *   
<a name="79"></a>     *   Note the asymmetry in the matchValues() arguments: we specifically
<a name="80"></a>     *   designate one string as the input string and one as the dictionary
<a name="81"></a>     *   string.  This allows for asymmetrical comparisons, which are
<a name="82"></a>     *   desirable in some cases: we sometimes want a given input string to
<a name="83"></a>     *   match a given dictionary string even when the two are not identical
<a name="84"></a>     *   character-by-character.  For example, we might want to allow the
<a name="85"></a>     *   user to type only the first six or eight characters of a string in
<a name="86"></a>     *   the dictionary, to save typing; or, we might want to allow a user to
<a name="87"></a>     *   enter unaccented letters and still match dictionary words containing
<a name="88"></a>     *   the corresponding letters with accents.  The asymmetry in the
<a name="89"></a>     *   arguments is there because we often only want these "fuzzy" match
<a name="90"></a>     *   rules to work in one direction; for the truncation example, we'd
<a name="91"></a>     *   want an input word that's a truncated version of a dictionary word
<a name="92"></a>     *   to match, but not the other way around.
<a name="93"></a>     *   
<a name="94"></a>     *   Important: Note that, although the hash value computation is up to
<a name="95"></a>     *   the implementing object to define, we impose one requirement.  It is
<a name="96"></a>     *   REQUIRED that for any two strings s1 and s2, if matchValues(s1, s2)
<a name="97"></a>     *   indicates a match (i.e., returns a value other than 0 or nil), then
<a name="98"></a>     *   calcHash(s1) MUST EQUAL calcHash(s2).  (This does NOT mean that two
<a name="99"></a>     *   strings with equal hash values must be equal, or, equivalently, that
<a name="100"></a>     *   two unequal strings must have different hash values.  Hash
<a name="101"></a>     *   collisions are explicitly allowed, so two strings that don't match
<a name="102"></a>     *   can still have the same hash value.)  
<a name="103"></a>     */
<a name="104"></a>    setComparator(compObj);
<a name="105"></a>
<a name="106"></a>    /* 
<a name="107"></a>     *   Find a word; returns a list giving the objects associated with the
<a name="108"></a>     *   string in the dictionary.  If voc_prop is specified, only objects
<a name="109"></a>     *   associated with the word by the given vocabulary property are
<a name="110"></a>     *   returned.  We match the string using the comparator defined for the
<a name="111"></a>     *   dictionary.
<a name="112"></a>     *   
<a name="113"></a>     *   The return value is a list consisting of pairs of entries.  The
<a name="114"></a>     *   first element of each pair is the matching object, and the second is
<a name="115"></a>     *   gives the comparator result for matching the word.  If we use a
<a name="116"></a>     *   StringComparator, this will be a non-zero integer value giving
<a name="117"></a>     *   information on truncation, case folding, and any equivalence
<a name="118"></a>     *   mappings defined in the comparator.  If the comparator is a custom
<a name="119"></a>     *   object, then the second element of the pair will be whatever the
<a name="120"></a>     *   custom comparator's matchValues() method returned for matching the
<a name="121"></a>     *   value for that dictionary entry.
<a name="122"></a>     *   
<a name="123"></a>     *   The reason for giving a matchValues() return value for every
<a name="124"></a>     *   individual match is that the same input string 'str' might match
<a name="125"></a>     *   multiple entries in the dictionary.  For example, the same string
<a name="126"></a>     *   might match one word exactly and one with truncation.  The match
<a name="127"></a>     *   result code lets the caller determine if some matches are "better"
<a name="128"></a>     *   than others, based on how the string matched for each individual
<a name="129"></a>     *   object entry.  
<a name="130"></a>     */
<a name="131"></a>    findWord(str, voc_prop?);
<a name="132"></a>
<a name="133"></a>    /*
<a name="134"></a>     *   Add a word to the dictionary, associating the given object with the
<a name="135"></a>     *   given string and property combination. 
<a name="136"></a>     */
<a name="137"></a>    addWord(obj, str, voc_prop);
<a name="138"></a>
<a name="139"></a>    /*
<a name="140"></a>     *   Remove the given word association from the dictionary.  This
<a name="141"></a>     *   removes only the association for the given object; other objects
<a name="142"></a>     *   associated with the same word are not affected.  
<a name="143"></a>     */
<a name="144"></a>    removeWord(obj, str, voc_prop);
<a name="145"></a>
<a name="146"></a>    /* 
<a name="147"></a>     *   Check to see if the given string 'str' is defined in the dictionary.
<a name="148"></a>     *   Returns true if the word is defined, nil if not.
<a name="149"></a>     *   
<a name="150"></a>     *   If the 'filter' argument is provided, it gives a callback function
<a name="151"></a>     *   that is invoked to determine whether or not to count a particular
<a name="152"></a>     *   word in the dictionary as a match.  The callback is invoked with one
<a name="153"></a>     *   argument: (filter)(match), where 'match' is the result of the
<a name="154"></a>     *   comparator's matchValues(str,dstr) method, where 'dstr' is a
<a name="155"></a>     *   dictionary string matching 'str'.  The filter function returns true
<a name="156"></a>     *   if the string should be counted as a match, nil if not.  The return
<a name="157"></a>     *   value of isWordDefined thus will be true if the filter function
<a name="158"></a>     *   returns true for at least one match, nil if not.  The purpose of the
<a name="159"></a>     *   filter function is to allow the caller to impose a more restrictive
<a name="160"></a>     *   condition than the dictionary's current comparator does; for
<a name="161"></a>     *   example, the caller might use the filter to determine if the
<a name="162"></a>     *   dictionary contains any matches for 'str' that match without any
<a name="163"></a>     *   truncation.  
<a name="164"></a>     */
<a name="165"></a>    isWordDefined(str, filter?);
<a name="166"></a>
<a name="167"></a>    /*
<a name="168"></a>     *   Invoke the callback func(obj, str, prop) for each word in the
<a name="169"></a>     *   dictionary.  Note that the callback can be invoked with a single
<a name="170"></a>     *   string multiple times, since the callback is invoked once per
<a name="171"></a>     *   word/object/property association; in other words, the callback is
<a name="172"></a>     *   invoked once for each association created with addWord() or during
<a name="173"></a>     *   compilation.  
<a name="174"></a>     */
<a name="175"></a>    forEachWord(func);
<a name="176"></a>
<a name="177"></a>    /*
<a name="178"></a>     *   Get a list of possible spelling corrections for the given word.
<a name="179"></a>     *   This searches the dictionary for words that match the given word
<a name="180"></a>     *   within the given maximum "edit distance".
<a name="181"></a>     *   
<a name="182"></a>     *   The return value is a list giving all of the words in the dictionary
<a name="183"></a>     *   that match the input string within the given maximum edit distance.
<a name="184"></a>     *   Any given dictionary word will appear only once in the returned
<a name="185"></a>     *   list.  The list is in arbitrary order.  Each entry consists of a
<a name="186"></a>     *   sublist, [word, dist, repl], where 'word' is a matching dictionary
<a name="187"></a>     *   word, 'dist' is the edit distance between that dictionary word and
<a name="188"></a>     *   the input string, and 'repl' is the number of character replacements
<a name="189"></a>     *   performed.  (The replacement count is included in the edit distance,
<a name="190"></a>     *   but it's called out separately because some correctors treat
<a name="191"></a>     *   replacements as heavier changes than other edits.  A caller could
<a name="192"></a>     *   use this to break ties for corrections of the same distance.
<a name="193"></a>     *   Consider "book" and "box" as corrections for "bok": both have edit
<a name="194"></a>     *   distance 1, but "book" has no replacements, while "box" has one.)
<a name="195"></a>     *   
<a name="196"></a>     *   The edit distance between two words is defined as the number of
<a name="197"></a>     *   single-character insertions, deletions, replacements, and
<a name="198"></a>     *   transpositions necessary to transform one word into another.  For
<a name="199"></a>     *   example, OPNE can be transformed into OPEN by transposing the N-E
<a name="200"></a>     *   pair, for an edit distance of 1.  XAEMINE can be transformed into
<a name="201"></a>     *   EXAMINE by inserting an E at the beginning, and then deleting the E
<a name="202"></a>     *   at the third letter, for an edit distance of 2.
<a name="203"></a>     *   
<a name="204"></a>     *   Choosing the maximum edit distance is essentially heuristic.  Higher
<a name="205"></a>     *   values make the search take longer, and yield more matches - which
<a name="206"></a>     *   increases the chances that the right match will be found, but also
<a name="207"></a>     *   increases the number of false matches to sift through.  The
<a name="208"></a>     *   literature on spelling correction suggests that 2 is a good value in
<a name="209"></a>     *   practice, across a wide range of applications, based on the most
<a name="210"></a>     *   frequent patterns of human typographical errors.  However, you'll
<a name="211"></a>     *   probably do better to vary the distance based on the word length:
<a name="212"></a>     *   perhaps 1 for words up to 4 letters, 2 for 5-7 letters, and 3 for
<a name="213"></a>     *   words of 8 letters or more.
<a name="214"></a>     *   
<a name="215"></a>     *   If the dictionary has a StringComparator object as its current
<a name="216"></a>     *   comparator, the results will take into account its case folding
<a name="217"></a>     *   setting, truncation length, and character mappings.  These
<a name="218"></a>     *   "approximations" are NOT considered to be edits, so they don't count
<a name="219"></a>     *   against the maximum edit distance.  Custom comparators (not of the
<a name="220"></a>     *   StringComparator class) are ignored: if you use a custom comparator,
<a name="221"></a>     *   this method will only find matches based on the exact text of the
<a name="222"></a>     *   dictionary words.  
<a name="223"></a>     */
<a name="224"></a>    correctSpelling(str, maxEditDistance);
<a name="225"></a>}
<a name="226"></a>
<a name="227"></a>/* 
<a name="228"></a> *   We rely on certain methods defined by the comparator interface, so
<a name="229"></a> *   export those method names.  
<a name="230"></a> */
<a name="231"></a>property calcHash, matchValues;
<a name="232"></a>export calcHash 'IfcComparator.calcHash';
<a name="233"></a>export matchValues 'IfcComparator.matchValues';
<a name="234"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

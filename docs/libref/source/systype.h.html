<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>systype.h</title></head><body>
<table class=ban><tr><td><h1>systype.h</h1><td align=right><a href="../file/systype.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   Copyright 2000, 2006 Michael J. Roberts.
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This module defines the fundamental intrinsic classes, including Object,
<a name="10"></a> *   String, Collection, List, and Iterator.  
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>
<a name="14"></a>/* ------------------------------------------------------------------------ */
<a name="15"></a>/*
<a name="16"></a> *   TADS datatype codes.  These values are returned by propType(), etc.  
<a name="17"></a> */
<a name="18"></a>#define TypeNil         1
<a name="19"></a>#define TypeTrue        2
<a name="20"></a>#define TypeObject      5
<a name="21"></a>#define TypeProp        6
<a name="22"></a>#define TypeInt         7
<a name="23"></a>#define TypeSString     8
<a name="24"></a>#define TypeDString     9
<a name="25"></a>#define TypeList        10
<a name="26"></a>#define TypeCode        11
<a name="27"></a>#define TypeFuncPtr     12
<a name="28"></a>#define TypeNativeCode  14
<a name="29"></a>#define TypeEnum        15
<a name="30"></a>#define TypeBifPtr      16
<a name="31"></a>
<a name="32"></a>
<a name="33"></a>/* ------------------------------------------------------------------------ */
<a name="34"></a>/*
<a name="35"></a> *   The root object class.  All objects descend from this class. 
<a name="36"></a> */
<a name="37"></a>intrinsic class Object 'root-object/030004'
<a name="38"></a>{
<a name="39"></a>    /* 
<a name="40"></a>     *   Determine if I'm an instance or subclass of the given class 'cls'.
<a name="41"></a>     *   Note that x.ofKind(x) returns true - an object is of its own kind.  
<a name="42"></a>     */
<a name="43"></a>    ofKind(cls);
<a name="44"></a>
<a name="45"></a>    /* get the list of direct superclasses of this object */
<a name="46"></a>    getSuperclassList();
<a name="47"></a>
<a name="48"></a>    /* determine if a property is defined or inherited by this object */
<a name="49"></a>    propDefined(prop, flags?);
<a name="50"></a>
<a name="51"></a>    /* get the type of a property defined for this object */
<a name="52"></a>    propType(prop);
<a name="53"></a>
<a name="54"></a>    /* 
<a name="55"></a>     *   Get a list of my directly-defined properties.  When called on
<a name="56"></a>     *   intrinsic class objects, this returns a list of properties defined
<a name="57"></a>     *   for instances of the class, as well as static properties of the
<a name="58"></a>     *   class.  
<a name="59"></a>     */
<a name="60"></a>    getPropList();
<a name="61"></a>
<a name="62"></a>    /* 
<a name="63"></a>     *   get parameter list information for the given method - returns a
<a name="64"></a>     *   list: [minimumArgc, optionalArgc, varargs], where minimumArgc is
<a name="65"></a>     *   the minimum number of arguments, optionalArgc is the number of
<a name="66"></a>     *   additional optional arguments, and varargs is true if the function
<a name="67"></a>     *   takes a varying number of arguments greater than or equal to the
<a name="68"></a>     *   minimum, nil if not.  
<a name="69"></a>     */
<a name="70"></a>    getPropParams(prop);
<a name="71"></a>
<a name="72"></a>    /* 
<a name="73"></a>     *   determine if I'm a "class" object - returns true if the object was
<a name="74"></a>     *   defined with the "class" keyword, nil otherwise 
<a name="75"></a>     */
<a name="76"></a>    isClass();
<a name="77"></a>
<a name="78"></a>    /* 
<a name="79"></a>     *   Determine if a property is inherited further from the given object.
<a name="80"></a>     *   definingObj is usually the value of the 'definingobj'
<a name="81"></a>     *   pseudo-variable, and origTargetObj is usually the value of the
<a name="82"></a>     *   'targetobj' pseudo-variable.  
<a name="83"></a>     */
<a name="84"></a>    propInherited(prop, origTargetObj, definingObj, flags?);
<a name="85"></a>
<a name="86"></a>    /* determine if this instance is transient */
<a name="87"></a>    isTransient();
<a name="88"></a>}
<a name="89"></a>
<a name="90"></a>/*
<a name="91"></a> *   propDefined() flags 
<a name="92"></a> */
<a name="93"></a>#define PropDefAny           1
<a name="94"></a>#define PropDefDirectly      2
<a name="95"></a>#define PropDefInherits      3
<a name="96"></a>#define PropDefGetClass      4
<a name="97"></a>
<a name="98"></a>/* export the objToString method */
<a name="99"></a>property objToString;
<a name="100"></a>export objToString 'objToString';
<a name="101"></a>
<a name="102"></a>
<a name="103"></a>/* ------------------------------------------------------------------------ */
<a name="104"></a>/*
<a name="105"></a> *   The IntrinsicClass intrinsic class.  Objects of this type represent the
<a name="106"></a> *   intrinsic classes themselves.  
<a name="107"></a> */
<a name="108"></a>intrinsic class IntrinsicClass 'intrinsic-class/030001': Object
<a name="109"></a>{
<a name="110"></a>    /*
<a name="111"></a>     *   Class method: is the given value an IntrinsicClass object?  This
<a name="112"></a>     *   returns true if so, nil if not.  
<a name="113"></a>     *   
<a name="114"></a>     *   It's not possible to determine if an object is an IntrinsicClass
<a name="115"></a>     *   object using x.ofKind(IntrinsicClass) or via x.getSuperclassList().
<a name="116"></a>     *   This is because those methods traverse the nominal class tree:
<a name="117"></a>     *   [1,2,3] is a List, and List is an Object.  However, List and Object
<a name="118"></a>     *   themselves are represented by IntrinsicClass instances, and it's
<a name="119"></a>     *   occasionally useful to know if you're dealing with such an object.
<a name="120"></a>     *   That's where this method comes in.
<a name="121"></a>     *   
<a name="122"></a>     *   This method returns nil for instances of an intrinsic class.  For
<a name="123"></a>     *   example, isIntrinsicClass([1,2,3]) returns nil, because [1,2,3] is a
<a name="124"></a>     *   List instance.  If you get the superclass list for [1,2,3], though,
<a name="125"></a>     *   that will be [List], and isIntrinsicClass(List) returns true.
<a name="126"></a>     */
<a name="127"></a>    isIntrinsicClass(obj);
<a name="128"></a>}
<a name="129"></a>
<a name="130"></a>/*
<a name="131"></a> *   Intrinsic class modifier object (for internal compiler use only) 
<a name="132"></a> */
<a name="133"></a>intrinsic class IntrinsicClassModifier 'int-class-mod/030000'
<a name="134"></a>{
<a name="135"></a>}
<a name="136"></a>
<a name="137"></a>/* ------------------------------------------------------------------------ */
<a name="138"></a>/*
<a name="139"></a> *   The native collection type - this is the base class for lists, vectors,
<a name="140"></a> *   and other objects that represent collections of values.  
<a name="141"></a> */
<a name="142"></a>intrinsic class Collection 'collection/030000': Object
<a name="143"></a>{
<a name="144"></a>    /* 
<a name="145"></a>     *   Create an iterator for the collection.  This returns a new Iterator
<a name="146"></a>     *   object that can be used to iterate over the values in the
<a name="147"></a>     *   collection.  The Iterator will use a snapshot of the collection that
<a name="148"></a>     *   will never change, even if the collection is changed after the
<a name="149"></a>     *   iterator is created.  
<a name="150"></a>     */
<a name="151"></a>    createIterator();
<a name="152"></a>
<a name="153"></a>    /*
<a name="154"></a>     *   Create a "live iterator" for the collection.  This returns a new
<a name="155"></a>     *   Iterator object that refers directly to the original collection; if
<a name="156"></a>     *   the original collection changes, the iterator will reflect the
<a name="157"></a>     *   changes in its iteration.  As a result, the iterator is not
<a name="158"></a>     *   guaranteed to visit all of the elements in the collection if the
<a name="159"></a>     *   collection changes during the course of the iteration.  If
<a name="160"></a>     *   consistent results are required, use createIterator() instead.  
<a name="161"></a>     */
<a name="162"></a>    createLiveIterator();
<a name="163"></a>}
<a name="164"></a>
<a name="165"></a>/* ------------------------------------------------------------------------ */
<a name="166"></a>/*
<a name="167"></a> *   The native iterator type - this is the base class for all iterators.
<a name="168"></a> *   This class is abstract and is thus never directly instantiated.
<a name="169"></a> *   
<a name="170"></a> *   Note that iterators can never be created directly with the 'new'
<a name="171"></a> *   operator.  Instead, iterators must be obtained from a collection via the
<a name="172"></a> *   collection's createIterator() method.  
<a name="173"></a> */
<a name="174"></a>intrinsic class Iterator 'iterator/030001': Object
<a name="175"></a>{
<a name="176"></a>    /*
<a name="177"></a>     *   Get the next item in the collection.  This returns the next item's
<a name="178"></a>     *   value, and advances the internal state in the iterator so that a
<a name="179"></a>     *   subsequent call to getNext() returns the next item after this one.
<a name="180"></a>     *   When the iterator is first created, or after calling
<a name="181"></a>     *   resetIterator(), this returns the first item in the collection.  
<a name="182"></a>     */
<a name="183"></a>    getNext();
<a name="184"></a>
<a name="185"></a>    /*
<a name="186"></a>     *   Determine if the collection is out of items.  Returns true if
<a name="187"></a>     *   getNext() will return a valid item, nil if no more items are
<a name="188"></a>     *   available.  
<a name="189"></a>     */
<a name="190"></a>    isNextAvailable();
<a name="191"></a>
<a name="192"></a>    /*
<a name="193"></a>     *   Reset to the first item.  After calling this routine, the next call
<a name="194"></a>     *   to getNext() will return the first item in the collection.  
<a name="195"></a>     */
<a name="196"></a>    resetIterator();
<a name="197"></a>
<a name="198"></a>    /*
<a name="199"></a>     *   Get the current key.  This returns the value of the key for the
<a name="200"></a>     *   current item in the collection.  For an indexed collection, this
<a name="201"></a>     *   returns the index value; for a keyed collection, this returns the
<a name="202"></a>     *   current key value.  
<a name="203"></a>     */
<a name="204"></a>    getCurKey();
<a name="205"></a>
<a name="206"></a>    /*
<a name="207"></a>     *   Get the current value.  This returns the value of the current item
<a name="208"></a>     *   in the collection. 
<a name="209"></a>     */
<a name="210"></a>    getCurVal();
<a name="211"></a>}
<a name="212"></a>
<a name="213"></a>/*
<a name="214"></a> *   Indexed object iterator - this type of iterator is used for lists,
<a name="215"></a> *   vectors, and other indexed collection objects.  
<a name="216"></a> */
<a name="217"></a>intrinsic class IndexedIterator 'indexed-iterator/030000': Iterator
<a name="218"></a>{
<a name="219"></a>}
<a name="220"></a>
<a name="221"></a>
<a name="222"></a>/* ------------------------------------------------------------------------ */
<a name="223"></a>/*
<a name="224"></a> *   AnonFuncPtr depends on Vector 
<a name="225"></a> */
<a name="226"></a>#include "vector.h"
<a name="227"></a>
<a name="228"></a>/*
<a name="229"></a> *   Anonymous function pointer intrinsic class 
<a name="230"></a> */
<a name="231"></a>intrinsic class AnonFuncPtr 'anon-func-ptr': Vector
<a name="232"></a>{
<a name="233"></a>}
<a name="234"></a>
<a name="235"></a>
<a name="236"></a>/* ------------------------------------------------------------------------ */
<a name="237"></a>/*
<a name="238"></a> *   The "TADS Object" intrinsic class.  All objects that the program
<a name="239"></a> *   defines with the "class" or "object" statements descend from this
<a name="240"></a> *   class.  
<a name="241"></a> */
<a name="242"></a>intrinsic class TadsObject 'tads-object/030005': Object
<a name="243"></a>{
<a name="244"></a>    /* 
<a name="245"></a>     *   Create an instance of this object: in other words, create a new
<a name="246"></a>     *   object whose superclass is this object.  The arguments provided are
<a name="247"></a>     *   passed to the new object's constructor.  This method returns a
<a name="248"></a>     *   reference to the new object.  
<a name="249"></a>     */
<a name="250"></a>    createInstance(...);
<a name="251"></a>
<a name="252"></a>    /*
<a name="253"></a>     *   Create a clone of this object.  This creates an exact copy, with
<a name="254"></a>     *   the same property values, as the original.  This does not call any
<a name="255"></a>     *   constructors; it merely instantiates an exact copy of the original.
<a name="256"></a>     *   
<a name="257"></a>     *   Note that the clone is a "shallow" copy, which means that any
<a name="258"></a>     *   objects it references are not themselves cloned.
<a name="259"></a>     */
<a name="260"></a>    createClone();
<a name="261"></a>
<a name="262"></a>    /*
<a name="263"></a>     *   Create a transient instance of this object.  This works just like
<a name="264"></a>     *   createInstance(), but creates a transient instance instead of an
<a name="265"></a>     *   ordinary (persistent) instance.  
<a name="266"></a>     */
<a name="267"></a>    createTransientInstance(...);
<a name="268"></a>
<a name="269"></a>    /*
<a name="270"></a>     *   Create an instance of an object based on multiple superclasses.
<a name="271"></a>     *   Each argument gives a superclass, and optionally arguments for
<a name="272"></a>     *   invoking the superclass constructor.  If an argument is given as
<a name="273"></a>     *   simply a class, then we don't invoke that superclass's constructor;
<a name="274"></a>     *   if the argument is given as a list, the first element of the list is
<a name="275"></a>     *   the class, and the remaining elements of the list are arguments for
<a name="276"></a>     *   that superclass's constructor.  The arguments are specified in the
<a name="277"></a>     *   same order they would be to define the object, so the first argument
<a name="278"></a>     *   is the dominant superclass.
<a name="279"></a>     *   
<a name="280"></a>     *   For example, suppose we created a class definition like this:
<a name="281"></a>     *   
<a name="282"></a>     *   class D: A, B, C
<a name="283"></a>     *.    construct(x, y)
<a name="284"></a>     *.    {
<a name="285"></a>     *.      inherited A(x);
<a name="286"></a>     *.      inherited C(y);
<a name="287"></a>     *.    }
<a name="288"></a>     *.  ;
<a name="289"></a>     *   
<a name="290"></a>     *   We could obtain the same effect dynamically like so:
<a name="291"></a>     *   
<a name="292"></a>     *   local d = TadsObject.createInstanceOf([A, x], B, [C, y]);
<a name="293"></a>     *   
<a name="294"></a>     *   Note that only *actual* lists are interpreted as constructor
<a name="295"></a>     *   invokers here.  A list-like object (with operator[] and length()
<a name="296"></a>     *   methods) will be treated as a simple superclass, since otherwise it
<a name="297"></a>     *   wouldn't be possible to specify the no-constructor format for such a
<a name="298"></a>     *   superclass.  
<a name="299"></a>     */
<a name="300"></a>    static createInstanceOf(...);
<a name="301"></a>
<a name="302"></a>    /*
<a name="303"></a>     *   Create a transient instance based on multiple superclasses.  This
<a name="304"></a>     *   works just like createInstanceOf(), but creates a transient
<a name="305"></a>     *   instance. 
<a name="306"></a>     */
<a name="307"></a>    static createTransientInstanceOf(...);
<a name="308"></a>
<a name="309"></a>    /*
<a name="310"></a>     *   Set the superclass list.  scList is a list giving the new
<a name="311"></a>     *   superclasses.  The superclasses must all be TadsObject objects, with
<a name="312"></a>     *   one exception: the list [TadsObject] may be passed to create an
<a name="313"></a>     *   object based directly on TadsObject.  No other intrinsic classes can
<a name="314"></a>     *   be used in the list, and objects of other types cannot be used in
<a name="315"></a>     *   the list.  
<a name="316"></a>     */
<a name="317"></a>    setSuperclassList(scList);
<a name="318"></a>
<a name="319"></a>    /* 
<a name="320"></a>     *   Get a method value.  If the property is a method, this returns a
<a name="321"></a>     *   function pointer to the method; this does NOT evaluate the method.
<a name="322"></a>     *   If the property is not a method, this returns nil.
<a name="323"></a>     *   
<a name="324"></a>     *   The returned function pointer can be called like an ordinary
<a name="325"></a>     *   function, but such a call will have no 'self' value, so the
<a name="326"></a>     *   disembodied method won't be able to refer to properties or methods
<a name="327"></a>     *   of 'self'.  The main use of this method is to get a method of one
<a name="328"></a>     *   object to assign as a method of another object using setMethod().  
<a name="329"></a>     */
<a name="330"></a>    getMethod(prop);
<a name="331"></a>
<a name="332"></a>    /*
<a name="333"></a>     *   Set a method value.  Assigns the given function (which must be a
<a name="334"></a>     *   function pointer value) to the given property of 'self'.  This
<a name="335"></a>     *   effectively adds a new method to the object.
<a name="336"></a>     *   
<a name="337"></a>     *   The function can be an ordinary named function, or a method pointer
<a name="338"></a>     *   retrieved from this object or from another object with getMethod().
<a name="339"></a>     *   Anonymous functions are NOT allowed here.  
<a name="340"></a>     */
<a name="341"></a>    setMethod(prop, func);
<a name="342"></a>}
<a name="343"></a>
<a name="344"></a>
<a name="345"></a>/* ------------------------------------------------------------------------ */
<a name="346"></a>/* 
<a name="347"></a> *   We need CharacterSet and ByteArray (for String.mapToByteArray).  (But
<a name="348"></a> *   wait to include these until after we've defined Object, since everything
<a name="349"></a> *   depends on Object.)  
<a name="350"></a> */
<a name="351"></a>#include "charset.h"
<a name="352"></a>#include "bytearr.h"
<a name="353"></a>
<a name="354"></a>/* ------------------------------------------------------------------------ */
<a name="355"></a>/*
<a name="356"></a> *   The native string type. 
<a name="357"></a> */
<a name="358"></a>intrinsic class String 'string/030008': Object
<a name="359"></a>{
<a name="360"></a>    /* get the length of the string */
<a name="361"></a>    length();
<a name="362"></a>
<a name="363"></a>    /* extract a substring */
<a name="364"></a>    substr(start, len?);
<a name="365"></a>
<a name="366"></a>    /* convert to upper case */
<a name="367"></a>    toUpper();
<a name="368"></a>
<a name="369"></a>    /* convert to lower case */
<a name="370"></a>    toLower();
<a name="371"></a>
<a name="372"></a>    /* 
<a name="373"></a>     *   Find a substring or pattern within the subject string (self),
<a name="374"></a>     *   searching the string from left to right returning the index of the
<a name="375"></a>     *   first match found.  If 'str' is a string, this searches for an exact
<a name="376"></a>     *   match to the substring.  If 'str' is a RexPattern object, this
<a name="377"></a>     *   searches for a match to the pattern.  Returns the character index of
<a name="378"></a>     *   the start of the match if found (the first character is at index 1),
<a name="379"></a>     *   or nil if no match is found.
<a name="380"></a>     *   
<a name="381"></a>     *   'index' is the optional starting index for the search.  the first
<a name="382"></a>     *   character is at index 1; a negative index specifies an offset from
<a name="383"></a>     *   the end of the string, with -1 indicating the last character, -2 the
<a name="384"></a>     *   second to last, and so on.  If 'index' is omitted, the search starts
<a name="385"></a>     *   at the first character.  Note that the search proceeds from left to
<a name="386"></a>     *   right even if 'index' is negative - a negative starting index is
<a name="387"></a>     *   just a convenience to specify an offset from the end of the string,
<a name="388"></a>     *   but the search still proceeds in the same direction.
<a name="389"></a>     *   
<a name="390"></a>     *   (Note: "left to right" in this context simply means from lower to
<a name="391"></a>     *   higher character index in the string.  We're using the term loosely,
<a name="392"></a>     *   in particular ignoring anything related to the reading order or
<a name="393"></a>     *   display direction for different languages or scripts.)
<a name="394"></a>     */
<a name="395"></a>    find(str, index?);
<a name="396"></a>
<a name="397"></a>    /* 
<a name="398"></a>     *   convert to a list of Unicode character codes, or get the Unicode
<a name="399"></a>     *   character code for the single character at the given index 
<a name="400"></a>     */
<a name="401"></a>    toUnicode(idx?);
<a name="402"></a>
<a name="403"></a>    /* htmlify a string */
<a name="404"></a>    htmlify(flags?);
<a name="405"></a>
<a name="406"></a>    /* determine if we start with the given string */
<a name="407"></a>    startsWith(str);
<a name="408"></a>
<a name="409"></a>    /* determine if we end with the given string */
<a name="410"></a>    endsWith(str);
<a name="411"></a>
<a name="412"></a>    /* 
<a name="413"></a>     *   Map to a byte array, converting to the given character set.  If
<a name="414"></a>     *   'charset' is provided, it must be an object of intrinsic class
<a name="415"></a>     *   CharacterSet, or a string giving the name of a character set.  The
<a name="416"></a>     *   characters in the string are mapped from the internal Unicode
<a name="417"></a>     *   representation to the appropriate byte representation in the given
<a name="418"></a>     *   character set.  Any unmappable characters are replaced with the
<a name="419"></a>     *   usual default/missing character for the set, as defined by the
<a name="420"></a>     *   mapping.
<a name="421"></a>     *   
<a name="422"></a>     *   If 'charset' is omitted or nil, the byte array is created simply by
<a name="423"></a>     *   treating the Unicode character code of each character in the string
<a name="424"></a>     *   as a byte value.  A byte can only hold values from 0 to 255, so a
<a name="425"></a>     *   numeric overflow error is thrown if any character code in the source
<a name="426"></a>     *   string is outside this range.
<a name="427"></a>     *   
<a name="428"></a>     */
<a name="429"></a>    mapToByteArray(charset?);
<a name="430"></a>
<a name="431"></a>    /* 
<a name="432"></a>     *   Replace one occurrence or all occurrences of the given substring
<a name="433"></a>     *   with the given new string.
<a name="434"></a>     *   
<a name="435"></a>     *   'self' is the subject string, which we search for instances of the
<a name="436"></a>     *   replacement.
<a name="437"></a>     *   
<a name="438"></a>     *   'origStr' is the string to search for within 'self'.  This is
<a name="439"></a>     *   treated as a literal text substring to find within 'self'.
<a name="440"></a>     *   'origStr' can alternatively be a RexPattern object, in which case
<a name="441"></a>     *   the regular expression is matched.
<a name="442"></a>     *   
<a name="443"></a>     *   'newStr' is the replacement text, as a string.  'newStr' can
<a name="444"></a>     *   alternatively be a function (regular or anonymous) instead of a
<a name="445"></a>     *   string.  In this case, it's invoked as 'newStr(match, index, orig)'
<a name="446"></a>     *   for each match where 'match' is the matching text, 'index' is the
<a name="447"></a>     *   index within the original subject string of the match, and 'orig' is
<a name="448"></a>     *   the full original subject string.  This function must return a
<a name="449"></a>     *   string value, which is used as the replacement text.  Using a
<a name="450"></a>     *   function allows greater flexibility in specifying the replacement,
<a name="451"></a>     *   since it can vary the replacement according to the actual text
<a name="452"></a>     *   matched and its position in the subject string.
<a name="453"></a>     *   
<a name="454"></a>     *   'flags' is a combination of ReplaceXxx flags specifying the search
<a name="455"></a>     *   options.  It's optional; if omitted, the default is ReplaceAll.
<a name="456"></a>     *   
<a name="457"></a>     *   ReplaceOnce and ReplaceAll are mutually exclusive; they mean,
<a name="458"></a>     *   respectively, that only the first occurrence of the match should be
<a name="459"></a>     *   replaced, or that every occurrence should be replaced.  ReplaceOnce
<a name="460"></a>     *   and ReplaceAll are ignored if a 'limit' value is specified (this is
<a name="461"></a>     *   true even if 'limit' is nil, which means that all occurrences are
<a name="462"></a>     *   replaced).
<a name="463"></a>     *   
<a name="464"></a>     *   'index' is the starting index within 'self' for the search.  If this
<a name="465"></a>     *   is given, we'll ignore any matches that start before the starting
<a name="466"></a>     *   index.  If 'index' is omitted, we start the search at the beginning
<a name="467"></a>     *   of the string.  If 'index' is negative, it's an index from the end
<a name="468"></a>     *   of the string: -1 is the last character, -2 the second to last, etc.
<a name="469"></a>     *   
<a name="470"></a>     *   'origStr' can be given as a list of search strings, rather than a
<a name="471"></a>     *   single string.  In this case, we'll search for each of the strings
<a name="472"></a>     *   in the list, and replace each one with 'newStr'.  If 'newStr' is
<a name="473"></a>     *   also a list, each match to an element of the 'origStr' list is
<a name="474"></a>     *   replaced with the corresponding element (at the same index) of the
<a name="475"></a>     *   'newStr' list.  If there are more 'origStr' elements than 'newStr'
<a name="476"></a>     *   elements, each match to an excess 'origStr' element is replaced with
<a name="477"></a>     *   an empty string.  This allows you to perform several replacements
<a name="478"></a>     *   with a single call.
<a name="479"></a>     *   
<a name="480"></a>     *   'limit', if specified, is an integer indicating the maximum number
<a name="481"></a>     *   of matches to replace, or nil to replace all matches.  If the limit
<a name="482"></a>     *   is reached before all matches have been replaced, no further
<a name="483"></a>     *   replacements are performed.  If this parameter is specified, it
<a name="484"></a>     *   overrides any ReplaceOnce or ReplaceAll flag.
<a name="485"></a>     *   
<a name="486"></a>     *   There are two search modes when 'origStr' is a list.  The default is
<a name="487"></a>     *   "parallel" mode.  In this mode, we search for all of the 'origStr'
<a name="488"></a>     *   elements, and replace the leftmost match.  We then search the
<a name="489"></a>     *   remainder of the string, after this first match, again searching for
<a name="490"></a>     *   all of the 'origStr' elements.  Again we replace the leftmost match.
<a name="491"></a>     *   We repeat this until we run out of matches.
<a name="492"></a>     *   
<a name="493"></a>     *   The other option is "serial" mode, which you select by including
<a name="494"></a>     *   ReplaceSerial in the flags argument.  In serial mode, we start by
<a name="495"></a>     *   searching only for the first 'origStr' element.  We replace each
<a name="496"></a>     *   occurrence throughout the string (unless we're in ReplaceOnce mode,
<a name="497"></a>     *   in which case we stop after the first replacement).  If we're in
<a name="498"></a>     *   ReplaceOnce mode and we did a replacement, we're done.  Otherwise,
<a name="499"></a>     *   we start over with the updated string, containing the replacements
<a name="500"></a>     *   so far, and search it for the second 'origStr' element, replacing
<a name="501"></a>     *   each occurrence (or just the first, in ReplaceOnce mode).  We repeat
<a name="502"></a>     *   this for each 'origStr' element.
<a name="503"></a>     *   
<a name="504"></a>     *   The key difference between the serial and parallel modes is that the
<a name="505"></a>     *   serial mode re-scans the updated string after replacing each
<a name="506"></a>     *   'origStr' element, so replacement text could itself be further
<a name="507"></a>     *   modified.  Parallel mode, in contrast, never re-scans replacement
<a name="508"></a>     *   text.  
<a name="509"></a>     */
<a name="510"></a>    findReplace(origStr, newStr, flags?, index?, limit?);
<a name="511"></a>
<a name="512"></a>    /*
<a name="513"></a>     *   Splice: delete 'del' characters starting at 'idx', and insert the
<a name="514"></a>     *   string 'ins' in their place.  'ins' is optional; if omitted, this
<a name="515"></a>     *   simply does the deletion without inserting anything.  
<a name="516"></a>     */
<a name="517"></a>    splice(idx, del, ins?);
<a name="518"></a>
<a name="519"></a>    /*
<a name="520"></a>     *   Split the string into substrings at the given delimiter, or of a
<a name="521"></a>     *   given fixed length.
<a name="522"></a>     *   
<a name="523"></a>     *   'delim' is the delimiter.  It can be one of the following:
<a name="524"></a>     *   
<a name="525"></a>     *   - A string or RexPattern, giving the delimiter where we split the
<a name="526"></a>     *   string.  We search 'self' for matches to this string or pattern, and
<a name="527"></a>     *   split it at each instance we find, returning a list of the resulting
<a name="528"></a>     *   substrings.  For example, 'one,two,three'.split(',') returns the
<a name="529"></a>     *   list ['one', 'two', 'three'].  The delimiter separates parts, so
<a name="530"></a>     *   it's not part of the returned substrings.
<a name="531"></a>     *   
<a name="532"></a>     *   - An integer, giving a substring length.  We split the string into
<a name="533"></a>     *   substrings of this exact length (except that the last element will
<a name="534"></a>     *   have whatever's left over).  For example, 'abcdefg'.split(2) returns
<a name="535"></a>     *   ['ab', 'cd', 'ef', 'g'].
<a name="536"></a>     *   
<a name="537"></a>     *   If 'delim' is omitted or nil, the default is 1, so we'll split the
<a name="538"></a>     *   string into one-character substrings.
<a name="539"></a>     *   
<a name="540"></a>     *   If 'limit' is included, it's an integer giving the maximum number of
<a name="541"></a>     *   elements to return in the result list.  If we reach the limit, we'll
<a name="542"></a>     *   stop the search and return the entire rest of the string as the last
<a name="543"></a>     *   element of the result list.  If 'limit' is 1, we simply return a
<a name="544"></a>     *   list consisting of the source string, since a limit of one element
<a name="545"></a>     *   means that we can't make any splits at all.  
<a name="546"></a>     */
<a name="547"></a>    split(delim?, limit?);
<a name="548"></a>
<a name="549"></a>    /*
<a name="550"></a>     *   Convert special characters and TADS markups to standard HTML
<a name="551"></a>     *   markups.  Returns a new string with the contents of the 'self'
<a name="552"></a>     *   string processed as described below.
<a name="553"></a>     *   
<a name="554"></a>     *   'stateobj' is an object containing the state of the output stream.
<a name="555"></a>     *   This allows an output stream to process its contents a bit at a
<a name="556"></a>     *   time, by maintaining the state of the stream from one call to the
<a name="557"></a>     *   next.  This object gives the prior state of the stream on entry, and
<a name="558"></a>     *   is updated on return to contain the new state after processing this
<a name="559"></a>     *   string.  If this is omitted or nil, a default initial starting state
<a name="560"></a>     *   is used.  The function uses the following properties of the object:
<a name="561"></a>     *   
<a name="562"></a>     *   stateobj.flags_ is an integer with a collection of flag bits giving
<a name="563"></a>     *   the current line state
<a name="564"></a>     *   
<a name="565"></a>     *   stateobj.tag_ is a string containing the text of the tag currently
<a name="566"></a>     *   in progress.  If the string ends in the middle of a tag, this will
<a name="567"></a>     *   be set on return to the text of the tag up to the end of the string,
<a name="568"></a>     *   so that the next call can resume processing the tag where the last
<a name="569"></a>     *   call left off.
<a name="570"></a>     *   
<a name="571"></a>     *   
<a name="572"></a>     *   The function makes the following conversions:
<a name="573"></a>     *   
<a name="574"></a>     *   \n -&gt; &lt;BR&gt;, or nothing at the start of a line
<a name="575"></a>     *   
<a name="576"></a>     *   \b -&gt; &lt;BR&gt; at the start of a line, or &lt;BR&gt;&lt;BR&gt; within a line
<a name="577"></a>     *   
<a name="578"></a>     *   \ (quoted space) -&gt; &amp;nbsp; if followed by a space or another quoted
<a name="579"></a>     *   space, or an ordinary space if followed by a non-space character
<a name="580"></a>     *   
<a name="581"></a>     *   \t -&gt; a sequence of &amp;nbsp; characters followed by a space, padding
<a name="582"></a>     *   to the next 8-character tab stop.  This can't take into account the
<a name="583"></a>     *   font metrics, since that's determined by the browser, so it should
<a name="584"></a>     *   only be used with a monospaced font.
<a name="585"></a>     *   
<a name="586"></a>     *   \^ -&gt; sets an internal flag to capitalize the next character
<a name="587"></a>     *   
<a name="588"></a>     *   \v -&gt; sets an internal flag to lower-case the next character
<a name="589"></a>     *   
<a name="590"></a>     *   &lt;Q&gt; ... &lt;/Q&gt; -&gt; &amp;ldquo; ... &amp;rdquo; or &amp;lsquo; ... &amp;rsquo;,
<a name="591"></a>     *   depending on the nesting level
<a name="592"></a>     *   
<a name="593"></a>     *   &lt;BR HEIGHT=N&gt; -&gt; N &lt;BR&gt; tags if at the start of a line, N+1 &lt;BR&gt;
<a name="594"></a>     *   tags if within a line
<a name="595"></a>     *   
<a name="596"></a>     *   
<a name="597"></a>     *   Note that this isn't a general-purpose HTML corrector: it doesn't
<a name="598"></a>     *   correct ill-formed markups or standardize deprecated syntax or
<a name="599"></a>     *   browser-specific syntax.  This function is specifically for
<a name="600"></a>     *   standardizing TADS-specific syntax, so that games can use the
<a name="601"></a>     *   traditional TADS syntax with the Web UI.  
<a name="602"></a>     */
<a name="603"></a>    specialsToHtml(stateobj?);
<a name="604"></a>
<a name="605"></a>    /*
<a name="606"></a>     *   Convert special characters and HTML markups to plain text, as it
<a name="607"></a>     *   would appear if written out through the regular console output
<a name="608"></a>     *   writer and displayed on a plain text terminal.  Returns a new string
<a name="609"></a>     *   with the contents of the 'self' string processed as described below.
<a name="610"></a>     *   This works very much like specialsToHtml(), but rather than
<a name="611"></a>     *   generating standard HTML output, we generate plain text output.
<a name="612"></a>     *   
<a name="613"></a>     *   'stateobj' has the same meaning asin specialsToHtml().  
<a name="614"></a>     *   
<a name="615"></a>     *   The function makes the following conversions:
<a name="616"></a>     *   
<a name="617"></a>     *   \n -&gt; \n, or nothing at the start of a line
<a name="618"></a>     *   
<a name="619"></a>     *   \b -&gt; \n at the start of a line, or \n\n within a line
<a name="620"></a>     *   
<a name="621"></a>     *   \ (quoted space) -&gt; regular space
<a name="622"></a>     *   
<a name="623"></a>     *   \^ -&gt; sets an internal flag to capitalize the next character
<a name="624"></a>     *   
<a name="625"></a>     *   \v -&gt; sets an internal flag to lower-case the next character
<a name="626"></a>     *   
<a name="627"></a>     *   &lt;Q&gt; ... &lt;/Q&gt; -&gt; "..." or '...' depending on the quote nesting level
<a name="628"></a>     *   
<a name="629"></a>     *   &lt;BR HEIGHT=n&gt; -&gt; N \n characters at the start of a line, N+1 \n
<a name="630"></a>     *   characters within a line
<a name="631"></a>     *   
<a name="632"></a>     *   &lt;P&gt; -&gt; \n at the start of a line, \n\n within a line
<a name="633"></a>     *   
<a name="634"></a>     *   &lt;TAG&gt; -&gt; nothing for all other tags
<a name="635"></a>     *   
<a name="636"></a>     *   &amp;amp; -&gt; &amp;
<a name="637"></a>     *   
<a name="638"></a>     *   &amp;lt; -&gt; &lt;
<a name="639"></a>     *   
<a name="640"></a>     *   &amp;gt; -&gt; &gt;
<a name="641"></a>     *   
<a name="642"></a>     *   &amp;quot; -&gt; "
<a name="643"></a>     *   
<a name="644"></a>     *   &amp;ldquo; and &amp;rdquo; -&gt; "
<a name="645"></a>     *   
<a name="646"></a>     *   &amp;lsquo; and &amp;rsquo; -&gt; '
<a name="647"></a>     *   
<a name="648"></a>     *   &amp;#dddd; -&gt; Unicode character dddd 
<a name="649"></a>     */
<a name="650"></a>    specialsToText(stateobj?);
<a name="651"></a>
<a name="652"></a>    /*
<a name="653"></a>     *   Encode a URL parameter string.  Spaces are encoded as "+", and all
<a name="654"></a>     *   other non-alphanumeric characters except - and _ are encoded as
<a name="655"></a>     *   "%xx" sequences.  
<a name="656"></a>     */
<a name="657"></a>    urlEncode();
<a name="658"></a>    
<a name="659"></a>    /*
<a name="660"></a>     *   Decode a URL parameter string.  This reverses the effect of
<a name="661"></a>     *   urlEncode(), returning a string with the encodings translated back
<a name="662"></a>     *   into ordinary characters.  Any sequences that do not form valid
<a name="663"></a>     *   UTF-8 characters are converted to '?'.  
<a name="664"></a>     */
<a name="665"></a>    urlDecode();
<a name="666"></a>
<a name="667"></a>    /*
<a name="668"></a>     *   Get the SHA-256 hash of the string.  This calculates the 256-bit
<a name="669"></a>     *   Secure Hash Algorithm 2 hash value, returning the hash as a
<a name="670"></a>     *   64-character string of hex digits.  The hash value is computed on
<a name="671"></a>     *   the UTF-8 representation of the string.  
<a name="672"></a>     */
<a name="673"></a>    sha256();
<a name="674"></a>
<a name="675"></a>    /*
<a name="676"></a>     *   Get the MD5 digest of the string.  This calculates the 128-bit RSA
<a name="677"></a>     *   MD5 digest value, returning the digest as a 32-character string of
<a name="678"></a>     *   hex digits.  The hash value is computed on the UTF-8 representation
<a name="679"></a>     *   of the string. 
<a name="680"></a>     */
<a name="681"></a>    digestMD5();
<a name="682"></a>
<a name="683"></a>    /*
<a name="684"></a>     *   Pack the arguments into bytes, and create a new string from the byte
<a name="685"></a>     *   values.  The characters of the new string correspond to the packed
<a name="686"></a>     *   byte values, so each character will have a Unicode character number
<a name="687"></a>     *   from 0 to 255.
<a name="688"></a>     *   
<a name="689"></a>     *   'format' is a format string describing the packed formats for the
<a name="690"></a>     *   values, and the rest of the arguments are the values to pack into
<a name="691"></a>     *   the string.  Returns a string containing the packed bytes.
<a name="692"></a>     *   
<a name="693"></a>     *   See Byte Packing in the System Manual for more details.  
<a name="694"></a>     */
<a name="695"></a>    static packBytes(format, ...);
<a name="696"></a>
<a name="697"></a>    /*
<a name="698"></a>     *   Unpack this string, interpreting the characters in the string as
<a name="699"></a>     *   byte values, and unpacking the bytes according to the format string.
<a name="700"></a>     *   Each character in the string must have a Unicode character number
<a name="701"></a>     *   from 0 to 255; if any characters are outside this range, an error is
<a name="702"></a>     *   thrown.
<a name="703"></a>     *   
<a name="704"></a>     *   This method can be used to unpack a string created with
<a name="705"></a>     *   String.packBytes().  In most cases, using the same format string
<a name="706"></a>     *   that was used to pack the bytes will re-create the original values.
<a name="707"></a>     *   This method can also be convenient for parsing plain text that's
<a name="708"></a>     *   arranged into fixed-width fields.
<a name="709"></a>     *   
<a name="710"></a>     *   'format' is the format string describing the packed byte format.
<a name="711"></a>     *   Returns a list consisting of the unpacked values.
<a name="712"></a>     *   
<a name="713"></a>     *   See Byte Packing in the System Manual for more details.  
<a name="714"></a>     */
<a name="715"></a>    unpackBytes(format);
<a name="716"></a>
<a name="717"></a>    /*
<a name="718"></a>     *   Convert each character in the string to title case, according to the
<a name="719"></a>     *   Unicode character database definitions.  Returns a new string with
<a name="720"></a>     *   the title-case version of this string.
<a name="721"></a>     *   
<a name="722"></a>     *   For most characters, title case is the same as upper case.  It
<a name="723"></a>     *   differs from upper case when a single Unicode character represents
<a name="724"></a>     *   more than one printed letter, such as the German sharp S U+00DF, or
<a name="725"></a>     *   the various "ff" and "fi" ligatures.  In these cases, the title-case
<a name="726"></a>     *   conversion consists of the upper-case version of the first letter of
<a name="727"></a>     *   the ligature followed by the lower-case versions of the remaining
<a name="728"></a>     *   characters.  Unicode doesn't define single-character title-case
<a name="729"></a>     *   equivalents of most of the ligatures, so the result is usually a
<a name="730"></a>     *   sequence of the individual characters making up the ligature.  For
<a name="731"></a>     *   example, title-casing the 'ffi' ligature character (U+FB03) produces
<a name="732"></a>     *   the three-character sequence 'F', 'f', 'i'.
<a name="733"></a>     *   
<a name="734"></a>     *   Note that this routine converts every character in the string to
<a name="735"></a>     *   title case, so it's not by itself a full title formatter - it's
<a name="736"></a>     *   simply a character case converter.
<a name="737"></a>     */
<a name="738"></a>    toTitleCase();
<a name="739"></a>
<a name="740"></a>    /*
<a name="741"></a>     *   Convert the string to "folded" case.  Returns a new string with the
<a name="742"></a>     *   case-folded version of this string.
<a name="743"></a>     *   
<a name="744"></a>     *   Folded case is used for eliminating case distinctions in sets of
<a name="745"></a>     *   strings, to allow for case-insensitive comparisons, sorting, etc.
<a name="746"></a>     *   This routine produces the case folding defined in the Unicode
<a name="747"></a>     *   character database; in most cases, the result is the same as
<a name="748"></a>     *   converting each original character to upper case and then converting
<a name="749"></a>     *   the result to lower case.  This process not only removes case
<a name="750"></a>     *   differences but also normalizes some variations in the ways certain
<a name="751"></a>     *   character sequences are rendered, such as converting the German
<a name="752"></a>     *   ess-zed U+00DF to "ss", and converting lower-case accented letters
<a name="753"></a>     *   that don't have single character upper-case equivalents to the
<a name="754"></a>     *   corresponding series of composition characters (e.g., U+01F0, a
<a name="755"></a>     *   small 'j' with a caron, turns into U+006A + U+030C, a regular small
<a name="756"></a>     *   'j' followed by a combining caron character).  Without this
<a name="757"></a>     *   normalization, the upper- and lower-case renderings of such
<a name="758"></a>     *   characters wouldn't match.
<a name="759"></a>     */
<a name="760"></a>    toFoldedCase();
<a name="761"></a>
<a name="762"></a>    /*
<a name="763"></a>     *   Compare this string to another string, using Unicode character code
<a name="764"></a>     *   points as the collation order.  Returns an integer less than zero if
<a name="765"></a>     *   this string sorts before the other string, zero if they're
<a name="766"></a>     *   identical, or greater than zero if this string sorts after the
<a name="767"></a>     *   other.  This makes the result suitable for use in a sort() callback,
<a name="768"></a>     *   for example.
<a name="769"></a>     *   
<a name="770"></a>     *   Note that if you use the result for sorting text that includes
<a name="771"></a>     *   accented Roman letters, the result order probably won't match the
<a name="772"></a>     *   dictionary order for your language.  Different languages (and even
<a name="773"></a>     *   different countries/cultures sharing a language) have different
<a name="774"></a>     *   rules for dictionary ordering, so collation is inherently language-
<a name="775"></a>     *   specific.  This routine doesn't take language differences into
<a name="776"></a>     *   account; it simply uses the fixed Unicode code point ordering.  The
<a name="777"></a>     *   Unicode ordering for accented characters is somewhat arbitrary,
<a name="778"></a>     *   because the accented Roman characters are arranged into multiple
<a name="779"></a>     *   disjoint blocks that are all separate from the unaccented
<a name="780"></a>     *   characters.  For example, A-caron sorts after Z-caron, which sorts
<a name="781"></a>     *   after A-breve, which sorts after Y-acute, which sorts after A-acute,
<a name="782"></a>     *   which sorts after plain Z. 
<a name="783"></a>     */
<a name="784"></a>    compareTo(str);
<a name="785"></a>
<a name="786"></a>    /*
<a name="787"></a>     *   Compare this string to another string, ignoring case.  The two
<a name="788"></a>     *   strings are compared on the basis of the "case folded" versions of
<a name="789"></a>     *   their characters, using the case folding rules from the Unicode
<a name="790"></a>     *   standard (the case folded version of a string is the value returned
<a name="791"></a>     *   by toFoldedCase()).  The return alue is an integer less than zero if
<a name="792"></a>     *   this string sorts before the other string, zero if they're
<a name="793"></a>     *   identical, or greater than zero if this string sorts after the
<a name="794"></a>     *   other. 
<a name="795"></a>     *   
<a name="796"></a>     *   As with compareTo(), this only produces alphabetically correct
<a name="797"></a>     *   sorting order when comparing ASCII strings.
<a name="798"></a>     */
<a name="799"></a>    compareIgnoreCase(str);
<a name="800"></a>
<a name="801"></a>    /*
<a name="802"></a>     *   Find the last instance of a substring or pattern within the string,
<a name="803"></a>     *   searching the subject string (self) from right to left (that is,
<a name="804"></a>     *   from the end of the string towards the beginning).  This works like
<a name="805"></a>     *   find(), but searches in the reverse direction.  Returns the index of
<a name="806"></a>     *   the match, or nil if no match is found.
<a name="807"></a>     *   
<a name="808"></a>     *   'str' can be a string or a RexPattern.  If it's a string, we look
<a name="809"></a>     *   for an exact match to the substring.  If it's a RexPattern, we
<a name="810"></a>     *   search for a match to the pattern.
<a name="811"></a>     *   
<a name="812"></a>     *   The optional 'index' specifies the starting index for the search.
<a name="813"></a>     *   This is the index of the character AFTER the last character that's
<a name="814"></a>     *   allowed to be included in the match.  The first character of the
<a name="815"></a>     *   string is at index 1; a negative index indicates an offset from the
<a name="816"></a>     *   end of the string, so -1 is the last character.  0 has the special
<a name="817"></a>     *   meaning of the end of the string, just past the last character in
<a name="818"></a>     *   the string, so you can use 0 (or, equivalently, self.length()+1) to
<a name="819"></a>     *   search the entire string from the end.  For a repeated search, pass
<a name="820"></a>     *   the index of the previous match, since this will find the next
<a name="821"></a>     *   earlier matching substring that doesn't overlap with the previous
<a name="822"></a>     *   match.
<a name="823"></a>     *   
<a name="824"></a>     *   (Note: "right to left" in this context simply means that the search
<a name="825"></a>     *   runs from higher to lower character index in the string.  We're
<a name="826"></a>     *   using the term loosely, in particular ignoring anything related to
<a name="827"></a>     *   the reading order or display direction for different languages or
<a name="828"></a>     *   scripts.)
<a name="829"></a>     */
<a name="830"></a>    findLast(str, index?);
<a name="831"></a>
<a name="832"></a>    /*
<a name="833"></a>     *   Find all occurrences of substring or pattern within a string,
<a name="834"></a>     *   returning a list of the results.
<a name="835"></a>     *   
<a name="836"></a>     *   'str' can be a string or RexPattern object.  If it's a string, we
<a name="837"></a>     *   look for exact matches to the substring.  If it's a RexPattern, we
<a name="838"></a>     *   search for matches to the pattern.
<a name="839"></a>     *   
<a name="840"></a>     *   'func' is an optional function used to process the results.  If this
<a name="841"></a>     *   is provided, the function is called once for each match found in the
<a name="842"></a>     *   string.  The function's return value is then placed into the result
<a name="843"></a>     *   list for the overall findAll() result.  The function is called for
<a name="844"></a>     *   each match found as follows: func(match, idx, g1, g2, ...), where
<a name="845"></a>     *   'match' is a string giving the text of the match, 'idx' is an
<a name="846"></a>     *   integer giving the index in the string (self) of the first character
<a name="847"></a>     *   of the match, and the 'gN' arguments are strings giving the text of
<a name="848"></a>     *   the correspondingly numbered capture groups (the parenthesized
<a name="849"></a>     *   groups in a regular expression match).  All of the 'func' arguments
<a name="850"></a>     *   except 'match' are optional: the function can omit them, in which
<a name="851"></a>     *   case the caller doesn't pass them.  If 'func' specifies more 'gN'
<a name="852"></a>     *   capture group parameters than were actually found in the match, nil
<a name="853"></a>     *   is passed for each extra parameter.
<a name="854"></a>     *   
<a name="855"></a>     *   The return value is a list of the results.  If no occurrences of
<a name="856"></a>     *   'str' are found, the result is an empty list.  If 'func' is
<a name="857"></a>     *   specified, each element in the return list is the return value from
<a name="858"></a>     *   calling 'func' for the corresponding match; if 'func' is omitted,
<a name="859"></a>     *   each element in the return list is a string with the text of that
<a name="860"></a>     *   match.
<a name="861"></a>     */
<a name="862"></a>    findAll(str, func?);
<a name="863"></a>
<a name="864"></a>    /*
<a name="865"></a>     *   Match the given string or RexPattern object to this string value,
<a name="866"></a>     *   starting at the start of the string or at the given index, if
<a name="867"></a>     *   specified.  If 'str' is a string, we check for a match to the
<a name="868"></a>     *   literal text of the string; if 'str' is a RexPattern, we try to
<a name="869"></a>     *   match the regular expression.  'idx' is the optional starting
<a name="870"></a>     *   position (1 is the first character; negative values are from the end
<a name="871"></a>     *   of the string, with -1 as the last character, -2 as the second to
<a name="872"></a>     *   last, etc).  If 'idx' is omitted, the default is the start of the
<a name="873"></a>     *   string.
<a name="874"></a>     *   
<a name="875"></a>     *   Returns an integer giving the length of the match found if the
<a name="876"></a>     *   string matches 'str', or nil if there's no match.
<a name="877"></a>     *   
<a name="878"></a>     *   The difference between this method and find() is that this method
<a name="879"></a>     *   only checks for a match at the given starting position, without
<a name="880"></a>     *   searching any further in the string, whereas find() searches for a
<a name="881"></a>     *   match at each subsequent character of the string until a match is
<a name="882"></a>     *   found or the string is exhausted.
<a name="883"></a>     */
<a name="884"></a>    match(str, idx?);
<a name="885"></a>}
<a name="886"></a>
<a name="887"></a>/*
<a name="888"></a> *   Flags for String.htmlify 
<a name="889"></a> */
<a name="890"></a>
<a name="891"></a>/* 
<a name="892"></a> *   translate spaces - each space in a run of multiple spaces is converted
<a name="893"></a> *   to an &amp;nbsp; sequence 
<a name="894"></a> */
<a name="895"></a>#define HtmlifyTranslateSpaces    0x0001
<a name="896"></a>
<a name="897"></a>/* translate newlines - converts each \n character to a &lt;br&gt; tag */
<a name="898"></a>#define HtmlifyTranslateNewlines  0x0002
<a name="899"></a>
<a name="900"></a>/* translate tabs - converts each \t character to a &lt;tab&gt; tag */
<a name="901"></a>#define HtmlifyTranslateTabs      0x0004
<a name="902"></a>
<a name="903"></a>/* 
<a name="904"></a> *   Translate all whitespace characters - translate all spaces, tabs, and
<a name="905"></a> *   newlines into their HTML equivalents: each space character becomes an
<a name="906"></a> *   '&amp;nbsp sequence;', each '\n' character becomes a &lt;br&gt; tag; and each
<a name="907"></a> *   '\t' character becomes a &lt;tab&gt; tag.  
<a name="908"></a> */
<a name="909"></a>#define HtmlifyTranslateWhitespace \
<a name="910"></a>    (HtmlifyTranslateSpaces | HtmlifyTranslateNewlines | HtmlifyTranslateTabs)
<a name="911"></a>
<a name="912"></a>
<a name="913"></a>/*
<a name="914"></a> *   Flags for String.findReplace 
<a name="915"></a> */
<a name="916"></a>#define ReplaceAll         0x0001
<a name="917"></a>#define ReplaceIgnoreCase  0x0002
<a name="918"></a>#define ReplaceFollowCase  0x0004
<a name="919"></a>#define ReplaceSerial      0x0008
<a name="920"></a>#define ReplaceOnce        0x0010
<a name="921"></a>
<a name="922"></a>/* property exports for specialsToHtml's state object */
<a name="923"></a>property flags_, tag_;
<a name="924"></a>export flags_ 'String.specialsToHtml.flags';
<a name="925"></a>export tag_ 'String.specialsToHtml.tag';
<a name="926"></a>
<a name="927"></a>
<a name="928"></a>/* ------------------------------------------------------------------------ */
<a name="929"></a>/*
<a name="930"></a> *   The native list type 
<a name="931"></a> */
<a name="932"></a>intrinsic class List 'list/030008': Collection
<a name="933"></a>{
<a name="934"></a>    /* 
<a name="935"></a>     *   Select a subset of the list: returns a new list consisting only
<a name="936"></a>     *   of the elements for which the callback function 'func' returns
<a name="937"></a>     *   true.  
<a name="938"></a>     */
<a name="939"></a>    subset(func);
<a name="940"></a>
<a name="941"></a>    /*
<a name="942"></a>     *   Apply the callback function to each element of this list, and
<a name="943"></a>     *   return a new list consisting of the results.  Effectively maps
<a name="944"></a>     *   the list to a new list using the given function.  Suppose the
<a name="945"></a>     *   original list is
<a name="946"></a>     *   
<a name="947"></a>     *   [x, y, z]
<a name="948"></a>     *   
<a name="949"></a>     *   Then the result list is
<a name="950"></a>     *   
<a name="951"></a>     *   [func(x), func(y), func(z)] 
<a name="952"></a>     */
<a name="953"></a>    mapAll(func);
<a name="954"></a>
<a name="955"></a>    /* get the number of elements in the list */
<a name="956"></a>    length();
<a name="957"></a>
<a name="958"></a>    /* extract a sublist */
<a name="959"></a>    sublist(start, len?);
<a name="960"></a>
<a name="961"></a>    /* intersect with another list */
<a name="962"></a>    intersect(other);
<a name="963"></a>
<a name="964"></a>    /* get the index of the first match for the given value */
<a name="965"></a>    indexOf(val);
<a name="966"></a>
<a name="967"></a>    /* car/cdr - head/tail of list */
<a name="968"></a>    car();
<a name="969"></a>    cdr();
<a name="970"></a>
<a name="971"></a>    /* 
<a name="972"></a>     *   Find the first element for which the given condition is true, and
<a name="973"></a>     *   return the index of the element.  Applies the callback function
<a name="974"></a>     *   (which encodes the condition to evaluate) to each element in
<a name="975"></a>     *   turn, starting with the first.  For each element, if the callback
<a name="976"></a>     *   returns nil, proceeds to the next element; otherwise, stops and
<a name="977"></a>     *   returns the index of the element.  If the callback never returns
<a name="978"></a>     *   true for any element, we'll return nil.  
<a name="979"></a>     */
<a name="980"></a>    indexWhich(cond);
<a name="981"></a>
<a name="982"></a>    /* 
<a name="983"></a>     *   Invoke the callback func(val) on each element, in order from first
<a name="984"></a>     *   to last.  No return value.  
<a name="985"></a>     */
<a name="986"></a>    forEach(func);
<a name="987"></a>
<a name="988"></a>    /* 
<a name="989"></a>     *   Find the first element for which the given condition is true, and
<a name="990"></a>     *   return the value of the element.  Returns nil if no item
<a name="991"></a>     *   satisfies the condition.  
<a name="992"></a>     */
<a name="993"></a>    valWhich(cond);
<a name="994"></a>
<a name="995"></a>    /* find the last element with the given value, and return its index */
<a name="996"></a>    lastIndexOf(val);
<a name="997"></a>
<a name="998"></a>    /* 
<a name="999"></a>     *   Find the last element for which the condition is true, and return
<a name="1000"></a>     *   the index of the element.  Applies the callback to each element
<a name="1001"></a>     *   in turn, starting with the last element and working backwards.
<a name="1002"></a>     *   For each element, if the callback returns nil, proceeds to the
<a name="1003"></a>     *   previous element; otherwise, stops and returns the index of the
<a name="1004"></a>     *   element.  If the callback never returns true for any element,
<a name="1005"></a>     *   we'll return nil.  
<a name="1006"></a>     */
<a name="1007"></a>    lastIndexWhich(cond);
<a name="1008"></a>
<a name="1009"></a>    /* 
<a name="1010"></a>     *   Find the last element for which the condition is true, and return
<a name="1011"></a>     *   the value of the element 
<a name="1012"></a>     */
<a name="1013"></a>    lastValWhich(cond);
<a name="1014"></a>
<a name="1015"></a>    /* count the number of elements with the given value */
<a name="1016"></a>    countOf(val);
<a name="1017"></a>
<a name="1018"></a>    /* count the number of elements for which the callback returns true */
<a name="1019"></a>    countWhich(cond);
<a name="1020"></a>
<a name="1021"></a>    /* get a new list consisting of the unique elements of this list */
<a name="1022"></a>    getUnique();
<a name="1023"></a>
<a name="1024"></a>    /* 
<a name="1025"></a>     *   append the elements of the list 'lst' to the elements of this
<a name="1026"></a>     *   list, then remove repeated elements in the result; returns a new
<a name="1027"></a>     *   list with the unique elements of the combination of the two lists 
<a name="1028"></a>     */
<a name="1029"></a>    appendUnique(lst);
<a name="1030"></a>
<a name="1031"></a>    /* 
<a name="1032"></a>     *   append an element - this works almost exactly like the
<a name="1033"></a>     *   concatation operator ('+'), but if the argument is a list, this
<a name="1034"></a>     *   simply adds the list as a new element, rather than adding each
<a name="1035"></a>     *   element of the list as a separate element 
<a name="1036"></a>     */
<a name="1037"></a>    append(val);
<a name="1038"></a>
<a name="1039"></a>    /* 
<a name="1040"></a>     *   Sort the list, returning a new list.  If the 'descending' flag is
<a name="1041"></a>     *   provided and is not nil, we'll sort the list in descending order
<a name="1042"></a>     *   rather than ascending order.
<a name="1043"></a>     *   
<a name="1044"></a>     *   If the 'comparisonFunction' argument is provided, it must be a
<a name="1045"></a>     *   callback function; the callback takes two arguments, and returns
<a name="1046"></a>     *   an integer less than zero if the first argument value is less
<a name="1047"></a>     *   than the second, zero if they're equal, and an integer greater
<a name="1048"></a>     *   than zero if the first is greater than the second.  If no
<a name="1049"></a>     *   'comparisonFunction' argument is provided, or it's provided and
<a name="1050"></a>     *   its value is nil, we'll simply compare the list elements as
<a name="1051"></a>     *   ordinary values.  The comparison function can be provided for
<a name="1052"></a>     *   caller-defined orderings, such as ordering a set of objects.  
<a name="1053"></a>     */
<a name="1054"></a>    sort(descending?, comparisonFunction?);
<a name="1055"></a>
<a name="1056"></a>    /*
<a name="1057"></a>     *   Prepend an element - this inserts the value before the first
<a name="1058"></a>     *   existing element. 
<a name="1059"></a>     */
<a name="1060"></a>    prepend(val);
<a name="1061"></a>
<a name="1062"></a>    /* 
<a name="1063"></a>     *   Insert one or more elements at the given index.  If the starting
<a name="1064"></a>     *   index is 1, the elements will be inserted before the first existing
<a name="1065"></a>     *   element.  If the index is one higher than the number of elements,
<a name="1066"></a>     *   the elements will be inserted after all existing elements.  If the
<a name="1067"></a>     *   index is negative, it counts backwards from the end of the list: -1
<a name="1068"></a>     *   inserts before the last element, -2 inserts before the second to
<a name="1069"></a>     *   last, and so on.  If the index is zero, the new elements are
<a name="1070"></a>     *   inserted after the last element.
<a name="1071"></a>     *   
<a name="1072"></a>     *   Note that a list value argument will simply be inserted as a single
<a name="1073"></a>     *   element.
<a name="1074"></a>     *   
<a name="1075"></a>     *   Returns a new list with the value(s) inserted.  
<a name="1076"></a>     */
<a name="1077"></a>    insertAt(startingIndex, val, ...);
<a name="1078"></a>
<a name="1079"></a>    /*
<a name="1080"></a>     *   Delete the element at the given index, reducing the length of the
<a name="1081"></a>     *   list by one element.  If the index is negative, it counts from the
<a name="1082"></a>     *   end of the list: -1 is the last element, -2 is the second to last,
<a name="1083"></a>     *   etc.  Returns a new list with the given element removed.  
<a name="1084"></a>     */
<a name="1085"></a>    removeElementAt(index);
<a name="1086"></a>
<a name="1087"></a>    /*
<a name="1088"></a>     *   Delete the range of elements starting at startingIndex and ending at
<a name="1089"></a>     *   endingIndex.  The elements at the ends of the range are included in
<a name="1090"></a>     *   the deletion.  If startingIndex == endingIndex, only one element is
<a name="1091"></a>     *   removed.  If either index is negative, it counts from the end of the
<a name="1092"></a>     *   list: -1 is the last element, -2 is the second to last, etc.
<a name="1093"></a>     *   Returns a new list with the given element range removed.  
<a name="1094"></a>     */
<a name="1095"></a>    removeRange(startingIndex, endingIndex);
<a name="1096"></a>
<a name="1097"></a>    /*
<a name="1098"></a>     *   Invoke the callback func(index, val) on each element, in order from
<a name="1099"></a>     *   first to last.  No return value.  
<a name="1100"></a>     */
<a name="1101"></a>    forEachAssoc(func);
<a name="1102"></a>
<a name="1103"></a>    /*
<a name="1104"></a>     *   Class method: Generate a new list.  'func' is a callback function,
<a name="1105"></a>     *   which can take zero or one argument.  'n' is the number of elements
<a name="1106"></a>     *   for the new list.  For each element, 'func' is invoked as func() if
<a name="1107"></a>     *   it takes no arguments, or func(idx) if it takes one argument, where
<a name="1108"></a>     *   'idx' is the index of the element being generated.  The return value
<a name="1109"></a>     *   of the call to 'func' is stored as the list element.  The method
<a name="1110"></a>     *   returns the resulting list.  For example, a list of the first ten
<a name="1111"></a>     *   even positive integers: List.generate({i: i*2}, 10).  
<a name="1112"></a>     */
<a name="1113"></a>    static generate(func, n);
<a name="1114"></a>
<a name="1115"></a>    /*
<a name="1116"></a>     *   Splice new values into the list.  Deletes the 'del' list items
<a name="1117"></a>     *   starting at 'idx', then inserts the extra arguments in their place.
<a name="1118"></a>     *   Returns a new list reflecting the spliced values.  To insert items
<a name="1119"></a>     *   without deleting anything, pass 0 for 'del'.  To delete items
<a name="1120"></a>     *   without inserting anything, omit any additional arguments.  
<a name="1121"></a>     */
<a name="1122"></a>    splice(idx, del, ...);
<a name="1123"></a>
<a name="1124"></a>    /*
<a name="1125"></a>     *   Combine the list elements into a string.  This converts each element
<a name="1126"></a>     *   into a string value using the usual default conversions (or throws
<a name="1127"></a>     *   an error if string conversion isn't possible), then concatenates the
<a name="1128"></a>     *   values together and returns the result.  If 'separator' is provided,
<a name="1129"></a>     *   it's a string that's interposed between elements; if this is
<a name="1130"></a>     *   omitted, the elements are concatenated together with no extra
<a name="1131"></a>     *   characters in between.  
<a name="1132"></a>     */
<a name="1133"></a>    join(sep?);
<a name="1134"></a>
<a name="1135"></a>    /*
<a name="1136"></a>     *   Get the index of the list item with the minimum value.  If 'func' is
<a name="1137"></a>     *   missing, this simply returns the index of the list element with the
<a name="1138"></a>     *   smallest value, comparing the element values as though using the '&gt;'
<a name="1139"></a>     *   and '&lt;' operators.  If 'func' is specified, it must be a function;
<a name="1140"></a>     *   it's called as func(x) for each value in the list, and the result of
<a name="1141"></a>     *   the overall call is the index of the element for which func(x)
<a name="1142"></a>     *   returns the smallest value.  For example, if you have a list of
<a name="1143"></a>     *   strings l, l.indexOfMin({x: x.length()}) returns the index of the
<a name="1144"></a>     *   shortest string in the list.  
<a name="1145"></a>     */
<a name="1146"></a>    indexOfMin(func?);
<a name="1147"></a>
<a name="1148"></a>    /*
<a name="1149"></a>     *   Get the minimum value in the list.  If 'func' is missing, this
<a name="1150"></a>     *   returns the minimum element value.  If 'func' is specified, it must
<a name="1151"></a>     *   be a function; it's called as func(x) for each value in the list,
<a name="1152"></a>     *   and the result of the overall method call is the element value x
<a name="1153"></a>     *   that minimizes func(x).  For example, if l is a list of strings,
<a name="1154"></a>     *   l.minVal({x: x.length()}) returns the shortest string.  
<a name="1155"></a>     */
<a name="1156"></a>    minVal(func?);
<a name="1157"></a>
<a name="1158"></a>    /*
<a name="1159"></a>     *   Get the index of the list item with the maximum value.  If 'func' is
<a name="1160"></a>     *   missing, this simply returns the index of the list element with the
<a name="1161"></a>     *   largest value, comparing the element values as though using the '&gt;'
<a name="1162"></a>     *   and '&lt;' operators.  If 'func' is specified, it must be a function;
<a name="1163"></a>     *   it's called as func(x) for each value in the list, and the result of
<a name="1164"></a>     *   the overall call is the index of the element for which func(x)
<a name="1165"></a>     *   returns the greatest value.  For example, if you have a list of
<a name="1166"></a>     *   strings l, l.indexOfMax({x: x.length()}) returns the index of the
<a name="1167"></a>     *   longest string in the list.  
<a name="1168"></a>     */
<a name="1169"></a>    indexOfMax(func?);
<a name="1170"></a>
<a name="1171"></a>    /*
<a name="1172"></a>     *   Get the maximum value in the list.  If 'func' is missing, this
<a name="1173"></a>     *   returns the largest element value.  If 'func' is specified, it must
<a name="1174"></a>     *   be a function; it's called as func(x) for each value in the list,
<a name="1175"></a>     *   and the result of the overall method call is the element value x
<a name="1176"></a>     *   that maximizes func(x).  For example, if l is a list of strings,
<a name="1177"></a>     *   l.maxVal({x: x.length()}) returns the longest string.  
<a name="1178"></a>     */
<a name="1179"></a>    maxVal(func?);
<a name="1180"></a>}
<a name="1181"></a>
<a name="1182"></a>/*
<a name="1183"></a> *   Sorting order flags.  These can be passed in as the first argument to
<a name="1184"></a> *   List.sort() (and Vector.sort() as well) to make the meaning of the
<a name="1185"></a> *   argument clearer.  
<a name="1186"></a> */
<a name="1187"></a>#define SortAsc    nil
<a name="1188"></a>#define SortDesc   true
<a name="1189"></a>
<a name="1190"></a>/*
<a name="1191"></a> *   Export length() as the element counter method for list-like objects in
<a name="1192"></a> *   general. 
<a name="1193"></a> */
<a name="1194"></a>export length 'length';
<a name="1195"></a>
<a name="1196"></a>
<a name="1197"></a>/* ------------------------------------------------------------------------ */
<a name="1198"></a>/*
<a name="1199"></a> *   'RexPattern' intrinsic class.  This class encapsulates a compiled
<a name="1200"></a> *   regular expression pattern.
<a name="1201"></a> *   
<a name="1202"></a> *   A RexPattern object can be passed to the regular expression functions
<a name="1203"></a> *   (rexMatch, rexSearch, rexReplace) in place of a string pattern.  Since
<a name="1204"></a> *   compiling a regular expression takes a non-trivial amount of time, it's
<a name="1205"></a> *   more efficient to compile a pattern to a RexPattern object if the same
<a name="1206"></a> *   pattern will be used in multiple searches.  
<a name="1207"></a> */
<a name="1208"></a>intrinsic class RexPattern 'regex-pattern/030000': Object
<a name="1209"></a>{
<a name="1210"></a>    /*
<a name="1211"></a>     *   Constructor:
<a name="1212"></a>     *   
<a name="1213"></a>     *   new RexPattern(patternString) - returns a RexPattern representing
<a name="1214"></a>     *   the compiled pattern string.  
<a name="1215"></a>     */
<a name="1216"></a>
<a name="1217"></a>    /* retrieve the original pattern string used to construct the object */
<a name="1218"></a>    getPatternString();
<a name="1219"></a>}
<a name="1220"></a>
<a name="1221"></a>/* ------------------------------------------------------------------------ */
<a name="1222"></a>/*
<a name="1223"></a> *   StackFrameDesc intrinsic class.  This class provides access to a stack
<a name="1224"></a> *   frame.  It lets us retrieve the values of local variables and method
<a name="1225"></a> *   context variables (self, definingobj, targetobj, targetprop).  It also
<a name="1226"></a> *   allows us to assign new values to local variables.
<a name="1227"></a> *   
<a name="1228"></a> *   To get the value of a local variable in the frame, simply use
<a name="1229"></a> *   frame[name], where 'frame' is the StackFrameDesc object for the frame,
<a name="1230"></a> *   and 'name' is a string giving the name of the local variable to
<a name="1231"></a> *   retrieve.  If the frame is active, this retrieves the live value of the
<a name="1232"></a> *   variable from the frame; otherwise it retrieves the value from a
<a name="1233"></a> *   snapshot containing the last value before the routine returned to its
<a name="1234"></a> *   caller.
<a name="1235"></a> *   
<a name="1236"></a> *   To assign a new value to a local in the frame, assign a value to
<a name="1237"></a> *   frame[name] for the desired variable name.  If the frame is active, this
<a name="1238"></a> *   updates the live variable in the stack frame, so when execution returns
<a name="1239"></a> *   to the caller the variable will have the new value.  If the frame is
<a name="1240"></a> *   inactive, it updates the snapshot we made when the routine returned to
<a name="1241"></a> *   its caller.
<a name="1242"></a> *   
<a name="1243"></a> *   This object can't be created with 'new'.  Instead, you obtain these
<a name="1244"></a> *   objects via the t3GetStackTrace() function.  That function retrieves
<a name="1245"></a> *   information on an active stack frame in the current call stack,
<a name="1246"></a> *   including the frame object.  
<a name="1247"></a> */
<a name="1248"></a>intrinsic class StackFrameDesc 'stack-frame-desc/030000'
<a name="1249"></a>{
<a name="1250"></a>    /*
<a name="1251"></a>     *   Is the stack frame active?  A stack frame is active until the
<a name="1252"></a>     *   function or method it represents returns to its caller.  When the
<a name="1253"></a>     *   routine returns, the frame becomes inactive.
<a name="1254"></a>     *   
<a name="1255"></a>     *   When the routine is about to return (so the frame is about to become
<a name="1256"></a>     *   inacive), the StackFrameDesc object makes a private snapshot of the
<a name="1257"></a>     *   variables in the frame.  Subsequent access to the locals will
<a name="1258"></a>     *   automatically use the snapshot copy, so you can continue to access
<a name="1259"></a>     *   the locals as normal without worrying about whether or not the
<a name="1260"></a>     *   actual stack frame still exists.  This allows you to continue to
<a name="1261"></a>     *   access and modify the values of the variables after the routine has
<a name="1262"></a>     *   exited.  
<a name="1263"></a>     */
<a name="1264"></a>    isActive();
<a name="1265"></a>
<a name="1266"></a>    /*
<a name="1267"></a>     *   Get a LookupTable consisting of all of the variables (local
<a name="1268"></a>     *   variables and parameters) in the frame.  Each element in the table
<a name="1269"></a>     *   is keyed by the name of a variable, and contains the current value
<a name="1270"></a>     *   of the variable.
<a name="1271"></a>     *   
<a name="1272"></a>     *   The returned lookup table is a snapshot copy of the current values
<a name="1273"></a>     *   of the variables.  If the underlying variable values in the frame
<a name="1274"></a>     *   change, the lookup table won't be affected, since it's just a
<a name="1275"></a>     *   separate copy made at the moment this routine is called.  Similarly,
<a name="1276"></a>     *   changing the value of an entry in the returned lookup table won't
<a name="1277"></a>     *   affect the actual variable in the stack frame.
<a name="1278"></a>     *   
<a name="1279"></a>     *   To retrieve the current live value of a variable in the actual stack
<a name="1280"></a>     *   frame, use frame[name], where 'frame' is the StackFrameDesc object
<a name="1281"></a>     *   for the frame, and 'name' is a string giving the variable name.  
<a name="1282"></a>     */
<a name="1283"></a>    getVars();
<a name="1284"></a>
<a name="1285"></a>    /*
<a name="1286"></a>     *   Get the value of 'self' in this frame. 
<a name="1287"></a>     */
<a name="1288"></a>    getSelf();
<a name="1289"></a>
<a name="1290"></a>    /*
<a name="1291"></a>     *   Get the value of 'definingobj' in this frame. 
<a name="1292"></a>     */
<a name="1293"></a>    getDefiningObj();
<a name="1294"></a>
<a name="1295"></a>    /*
<a name="1296"></a>     *   Get the value of 'targetobj' in this frame. 
<a name="1297"></a>     */
<a name="1298"></a>    getTargetObj();
<a name="1299"></a>
<a name="1300"></a>    /*
<a name="1301"></a>     *   Get the value of 'targetprop' in this frame. 
<a name="1302"></a>     */
<a name="1303"></a>    getTargetProp();
<a name="1304"></a>
<a name="1305"></a>    /*
<a name="1306"></a>     *   Get the value of 'invokee' in this frame. 
<a name="1307"></a>     */
<a name="1308"></a>    getInvokee();
<a name="1309"></a>}
<a name="1310"></a>
<a name="1311"></a>/*
<a name="1312"></a> *   A StackFrameRef is an internal object used with StackFrameDesc.  This
<a name="1313"></a> *   type is used internally by the VM; user code can't create an instance of
<a name="1314"></a> *   this class directly with 'new', and the class has no public methods.  
<a name="1315"></a> */
<a name="1316"></a>intrinsic class StackFrameRef 'stack-frame-ref/030000'
<a name="1317"></a>{
<a name="1318"></a>}
<a name="1319"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/01/2025 from adv3Lite version 2.1.1.14</div>
</body>
</html>

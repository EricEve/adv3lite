<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>action.t</title></head><body>
<table class=ban><tr><td><h1>action.t</h1><td align=right><a href="../file/action.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   ****************************************************************************
<a name="6"></a> *    action.t 
<a name="7"></a> *    This module forms part of the adv3Lite library 
<a name="8"></a> *    (c) 2012-13 Eric Eve
<a name="9"></a> */
<a name="10"></a>
<a name="11"></a>
<a name="12"></a>/* 
<a name="13"></a> *   The library doesn't yet provide any support for actions that take three
<a name="14"></a> *   objects (TIAActions, as they might hypothetically be called), but since the
<a name="15"></a> *   Mercury parser does we provide a number of hooks that other code could use.
<a name="16"></a> *   To this end we need to define the properties a TIAAction might use so the
<a name="17"></a> *   compiler recognizes them.
<a name="18"></a> */
<a name="19"></a>property curAobj, verAobjProp, preCondAobjProp, remapAobjProp;
<a name="20"></a>property verifyAobjDefault, preCondAobjDefault;
<a name="21"></a>
<a name="22"></a>class Action: ReplaceRedirector
<a name="23"></a>    
<a name="24"></a>    /* 
<a name="25"></a>     *   Flag; should this action be considered a failure? This should be reset
<a name="26"></a>     *   to true at the start of the action processing cycle but can be tested
<a name="27"></a>     *   later to prevent, e.g., inappropriate reporting.
<a name="28"></a>     */
<a name="29"></a>    actionFailed = nil
<a name="30"></a>    
<a name="31"></a>    
<a name="32"></a>    /* 
<a name="33"></a>     *   The execGroup() method is called by the current Command object before
<a name="34"></a>     *   it calls the action on individual objects, to allow processing of the
<a name="35"></a>     *   group of objects as a whole. By default we do nothing here in the
<a name="36"></a>     *   library.
<a name="37"></a>     */
<a name="38"></a>    execGroup(cmd) { }
<a name="39"></a>           
<a name="40"></a>    /* 
<a name="41"></a>     *   The checkAction() method calls the check routines on the objects
<a name="42"></a>     *   involved in the command (where there are objects). Subclasses such as
<a name="43"></a>     *   TAction and TIAction need to override this to carry out the appropriate
<a name="44"></a>     *   handling.
<a name="45"></a>     */
<a name="46"></a>    checkAction() { }
<a name="47"></a>    
<a name="48"></a>    
<a name="49"></a>    /* 
<a name="50"></a>     *   The main routine for handling an action. This is the method called by
<a name="51"></a>     *   the command object; the cmd parameter gives the calling Command object.
<a name="52"></a>     */
<a name="53"></a>    exec(cmd)
<a name="54"></a>    {                
<a name="55"></a>        
<a name="56"></a>        /* Resest actionFailed to nil */
<a name="57"></a>        actionFailed = nil;
<a name="58"></a>        
<a name="59"></a>        /* Reset the scope list */
<a name="60"></a>        scopeList = [];
<a name="61"></a>        
<a name="62"></a>        /* Note the current actor */
<a name="63"></a>        libGlobal.curActor = cmd.actor;
<a name="64"></a>        
<a name="65"></a>        /* Note the location of the current actor */
<a name="66"></a>        oldRoom = gActor.getOutermostRoom;
<a name="67"></a>        
<a name="68"></a>        /* 
<a name="69"></a>         *   Note whether the current actor's location starts out illuminated;
<a name="70"></a>         *   we need to know this so we can display a notification if the
<a name="71"></a>         *   illumination changes.
<a name="72"></a>         */
<a name="73"></a>        
<a name="74"></a>        wasIlluminated = oldRoom.isIlluminated();
<a name="75"></a>        
<a name="76"></a>        
<a name="77"></a>        /* execute the action-processing cycle */
<a name="78"></a>        execCycle(cmd);     
<a name="79"></a>            
<a name="80"></a>    }
<a name="81"></a>    
<a name="82"></a>    /* 
<a name="83"></a>     *   The action-processing cycle carries out the before action
<a name="84"></a>     *   notifications, then executes the action. This needs to be overridden on
<a name="85"></a>     *   various subclasses since the beforeAction notifications can occur at
<a name="86"></a>     *   different points in different kinds of action.
<a name="87"></a>     */
<a name="88"></a>    execCycle(cmd)
<a name="89"></a>    {
<a name="90"></a>        try
<a name="91"></a>        {            
<a name="92"></a>            IfDebug(actions, 
<a name="93"></a>                    "[Executing &lt;&lt;actionTab.symbolToVal(baseActionClass)&gt;&gt; 
<a name="94"></a>                    &lt;&lt; if cmd.dobj != nil&gt;&gt; : &lt;i&gt;&lt;&lt;dqinfo&gt;&gt;&lt;/i&gt;
<a name="95"></a>                    &lt;&lt;cmd.dobj.name&gt;&gt;&lt;&lt;end&gt;&gt;
<a name="96"></a>                    &lt;&lt; if cmd.iobj != nil&gt;&gt; : &lt;i&gt;&lt;&lt;iqinfo&gt;&gt;&lt;/i&gt;
<a name="97"></a>                    &lt;&lt;cmd.iobj.name&gt;&gt;&lt;&lt;end&gt;&gt; ]\n" );
<a name="98"></a>            
<a name="99"></a>            /* Carry out the before action notifications. */
<a name="100"></a>            beforeAction();
<a name="101"></a>            
<a name="102"></a>            /* Execute the main action handling. */
<a name="103"></a>            execAction(cmd);
<a name="104"></a>            
<a name="105"></a>            /* 
<a name="106"></a>             *   If the action is repeatable, make a note of it in case the
<a name="107"></a>             *   player issues an AGAIN command.
<a name="108"></a>             */
<a name="109"></a>            if(isRepeatable)
<a name="110"></a>                libGlobal.lastAction = self.createClone();
<a name="111"></a>            
<a name="112"></a>            
<a name="113"></a>        }
<a name="114"></a>        catch(ExitActionSignal ex)
<a name="115"></a>        {
<a name="116"></a>           
<a name="117"></a>        }
<a name="118"></a>        /* If an exit signal is issued we skip to here. */
<a name="119"></a>        catch(ExitSignal ex)
<a name="120"></a>        {
<a name="121"></a>            /* 
<a name="122"></a>             *   If the exit macro is used in the course of the command,
<a name="123"></a>             *   consider the command a failure.
<a name="124"></a>             */
<a name="125"></a>            actionFailed = true;
<a name="126"></a>        }
<a name="127"></a>        
<a name="128"></a>    }
<a name="129"></a>    
<a name="130"></a>    /* The main action handler. Subclasses must override. */
<a name="131"></a>    execAction(cmd)
<a name="132"></a>    {
<a name="133"></a>    }
<a name="134"></a>    
<a name="135"></a>    /* The room the actor was in when the action started */
<a name="136"></a>    oldRoom = nil
<a name="137"></a>    
<a name="138"></a>    /* Flag to indicate whether the actor's location started out illuminated */
<a name="139"></a>    wasIlluminated = nil
<a name="140"></a>    
<a name="141"></a>    /* 
<a name="142"></a>     *   A list of any PreConditions that apply to this action as a whole, as
<a name="143"></a>     *   opposed to any of its objects. This is most likely to be relevant to an
<a name="144"></a>     *   IAction.
<a name="145"></a>     */
<a name="146"></a>    preCond = nil
<a name="147"></a>    
<a name="148"></a>    checkActionPreconditions()
<a name="149"></a>    {
<a name="150"></a>        local preCondList;
<a name="151"></a>        local checkOkay = true;
<a name="152"></a>        
<a name="153"></a>        /* 
<a name="154"></a>         *   Construct a list or preCondition objects on the appropriate object
<a name="155"></a>         *   property.
<a name="156"></a>         */
<a name="157"></a>        preCondList = valToList(preCond);       
<a name="158"></a>        
<a name="159"></a>        /* Sort the list in preCondOrder */
<a name="160"></a>        preCondList = preCondList.sort(nil,
<a name="161"></a>                                       {a, b: a.preCondOrder - b.preCondOrder});
<a name="162"></a>        
<a name="163"></a>        try
<a name="164"></a>        {
<a name="165"></a>            /* Iterate through the list to see if all the checks are satisfied */
<a name="166"></a>            foreach(local cur in preCondList)              
<a name="167"></a>            {          
<a name="168"></a>                /* 
<a name="169"></a>                 *   If we fail the check method on any precondition object,
<a name="170"></a>                 *   note the failure and stop the iteration.
<a name="171"></a>                 */
<a name="172"></a>                if(cur.checkPreCondition(gActor, true) == nil)
<a name="173"></a>                {
<a name="174"></a>                    checkOkay = nil;
<a name="175"></a>                    break;
<a name="176"></a>                }                
<a name="177"></a>            }
<a name="178"></a>        }
<a name="179"></a>        /* 
<a name="180"></a>         *   Game authors aren't meant to use the exit macro in check methods,
<a name="181"></a>         *   but in case they do we handle it here.
<a name="182"></a>         */
<a name="183"></a>        catch (ExitSignal ex)
<a name="184"></a>        {
<a name="185"></a>            checkOkay = nil;
<a name="186"></a>        }
<a name="187"></a>        
<a name="188"></a>        /* 
<a name="189"></a>         *   If the check method failed on any of our precondition objects note
<a name="190"></a>         *   that the action is a failure.
<a name="191"></a>         */
<a name="192"></a>        if(checkOkay == nil)
<a name="193"></a>            actionFailed = true;
<a name="194"></a>        
<a name="195"></a>        /* 
<a name="196"></a>         *   Otherwise, if we're not an implicit action, display any pending
<a name="197"></a>         *   implicit action announcements.
<a name="198"></a>         */
<a name="199"></a>        else if(!isImplicit)
<a name="200"></a>            "&lt;&lt;buildImplicitActionAnnouncement(true, true)&gt;&gt;";
<a name="201"></a>        
<a name="202"></a>        
<a name="203"></a>        /* Return our overall check result. */
<a name="204"></a>        return checkOkay;        
<a name="205"></a>        
<a name="206"></a>    }
<a name="207"></a>    
<a name="208"></a>    
<a name="209"></a>    beforeAction()
<a name="210"></a>    {
<a name="211"></a>        
<a name="212"></a>        /* 
<a name="213"></a>         *   Check any Preconditions relating to the action as a whole (as
<a name="214"></a>         *   opposed to any of its objects.
<a name="215"></a>         */
<a name="216"></a>        if(!checkActionPreconditions())
<a name="217"></a>            exit;
<a name="218"></a>        
<a name="219"></a>        /*  
<a name="220"></a>         *   Call the before action handling on the current actor (in its
<a name="221"></a>         *   capacity as actor/
<a name="222"></a>         */
<a name="223"></a>        gActor.actorAction();
<a name="224"></a>        
<a name="225"></a>        
<a name="226"></a>        /* 
<a name="227"></a>         *   If the sceneManager is present then send a before action
<a name="228"></a>         *   notification to every currently active Scene.
<a name="229"></a>         */
<a name="230"></a>        if(defined(sceneManager) &amp;&amp; sceneManager.notifyBefore());
<a name="231"></a>        
<a name="232"></a>        /* 
<a name="233"></a>         *   Call roomBeforeAction() on the current actor's location, and
<a name="234"></a>         *   regionBeforeAction() on all the regions it's in.
<a name="235"></a>         */        
<a name="236"></a>        gActor.getOutermostRoom.notifyBefore();
<a name="237"></a>               
<a name="238"></a>        /* 
<a name="239"></a>         *   If we don't already have a scope list for the current action, build
<a name="240"></a>         *   it now.
<a name="241"></a>         */
<a name="242"></a>        if(nilToList(scopeList).length == 0)
<a name="243"></a>            buildScopeList;
<a name="244"></a>            
<a name="245"></a>        
<a name="246"></a>        /* Call the beforeAction method of every action in scope. */
<a name="247"></a>        foreach(local cur in scopeList)
<a name="248"></a>        {
<a name="249"></a>            cur.beforeAction();
<a name="250"></a>        }
<a name="251"></a>    }
<a name="252"></a>    
<a name="253"></a>    /* 
<a name="254"></a>     *   Carry out the post-action processing. This first checks to see if
<a name="255"></a>     *   there's been a change in illumination. If there has we either show a
<a name="256"></a>     *   room description (if the actor's location is now lit) or announce the
<a name="257"></a>     *   onset of darkness. We then call the after action notifications first on
<a name="258"></a>     *   the actor's current room and then on every object in scope.
<a name="259"></a>     *
<a name="260"></a>     *   Note that afterAction() is called from the current Command object.
<a name="261"></a>     */
<a name="262"></a>    afterAction()
<a name="263"></a>    {
<a name="264"></a>        /* 
<a name="265"></a>         *   If the current action is considered a failure, we don't carry out
<a name="266"></a>         *   any after action handling, since in this case there's no action to
<a name="267"></a>         *   react to.
<a name="268"></a>         */
<a name="269"></a>        if(actionFailed)
<a name="270"></a>            return;
<a name="271"></a>        
<a name="272"></a>        
<a name="273"></a>        /* 
<a name="274"></a>         *   If the actor is still in the same room s/he started out in, check
<a name="275"></a>         *   whether the current illumination level has changed, and, if so,
<a name="276"></a>         *   either show a room description or announce the onset of darkness,
<a name="277"></a>         *   as appropriate.
<a name="278"></a>         */
<a name="279"></a>        if(oldRoom == gActor.getOutermostRoom)
<a name="280"></a>        {
<a name="281"></a>            if(oldRoom.isIlluminated)
<a name="282"></a>            {
<a name="283"></a>                if(!wasIlluminated)
<a name="284"></a>                {   
<a name="285"></a>                    "&lt;.p&gt;";
<a name="286"></a>                    oldRoom.lookAroundWithin();
<a name="287"></a>                }
<a name="288"></a>            }
<a name="289"></a>            else if(wasIlluminated)
<a name="290"></a>            {
<a name="291"></a>                DMsg(onset of darkness, '\n{I} {am} plunged into darkness. ');
<a name="292"></a>            }
<a name="293"></a>        }
<a name="294"></a>        "&lt;.p&gt;";
<a name="295"></a>        
<a name="296"></a>        /* Call the afterAction notifications on all currently active scenes. */
<a name="297"></a>        if(defined(sceneManager) &amp;&amp; sceneManager.notifyAfter());
<a name="298"></a>        
<a name="299"></a>        
<a name="300"></a>        /* 
<a name="301"></a>         *   Call the afterAction notification on the current room and its
<a name="302"></a>         *   regions.
<a name="303"></a>         */
<a name="304"></a>        gActor.getOutermostRoom.notifyAfter();
<a name="305"></a>        
<a name="306"></a>        /* 
<a name="307"></a>         *   Call the afterAction notification on every object in scope. Note
<a name="308"></a>         *   that we have to recalculate the scope list here in case the action
<a name="309"></a>         *   has changed it.
<a name="310"></a>         */
<a name="311"></a>        foreach(local cur in Q.scopeList(gActor))
<a name="312"></a>        {
<a name="313"></a>            cur.afterAction();
<a name="314"></a>        }
<a name="315"></a>        
<a name="316"></a>    }
<a name="317"></a>    
<a name="318"></a>    /* 
<a name="319"></a>     *   The turnSequence() method is called from the current Command object. It
<a name="320"></a>     *   first executes any current daemons (apart from any PromptDaemons) and
<a name="321"></a>     *   then advances the turn counter. We define this on the Action class
<a name="322"></a>     *   principally to make it simple for certain kinds of Action such as
<a name="323"></a>     *   SystemActions to do nothing here (since they don't count as actions
<a name="324"></a>     *   within the game world).
<a name="325"></a>     */
<a name="326"></a>    
<a name="327"></a>    turnSequence()
<a name="328"></a>    {
<a name="329"></a>        
<a name="330"></a>        /* Execute the regionDaemon on every region in which the player character is located. */        
<a name="331"></a>        local lst = gPlayerChar.getOutermostRoom.allRegions();
<a name="332"></a>        
<a name="333"></a>        foreach(local reg in lst)
<a name="334"></a>        {
<a name="335"></a>            "&lt;.p&gt;";
<a name="336"></a>            reg.regionDaemon();
<a name="337"></a>        }
<a name="338"></a>        
<a name="339"></a>        
<a name="340"></a>        "&lt;.p&gt;";
<a name="341"></a>        /* Execute the player character's current location's roomDaemon. */
<a name="342"></a>        gPlayerChar.getOutermostRoom.roomDaemon();                 
<a name="343"></a>        
<a name="344"></a>        /* 
<a name="345"></a>         *   If the events.t module is included, execute all current Daemons and
<a name="346"></a>         *   Fuses/
<a name="347"></a>         */
<a name="348"></a>        if(defined(eventManager) &amp;&amp; eventManager.executeTurn())          
<a name="349"></a>            ;
<a name="350"></a>               
<a name="351"></a>        /* Advance the turn counter */
<a name="352"></a>        libGlobal.totalTurns += turnsTaken;           
<a name="353"></a>    }
<a name="354"></a>   
<a name="355"></a>    /* 
<a name="356"></a>     *   The number of turns this action is counted as taking. Normally, this
<a name="357"></a>     *   will be 1.
<a name="358"></a>     */
<a name="359"></a>    turnsTaken = 1
<a name="360"></a>    
<a name="361"></a>    /* Flag: is this an implicit action? By default it isn't. */
<a name="362"></a>    isImplicit = nil
<a name="363"></a>    
<a name="364"></a>    /* Can this action be Undone? By default most actions can. */
<a name="365"></a>    includeInUndo = true
<a name="366"></a>    
<a name="367"></a>    /* Flag: is this a conversational action? */
<a name="368"></a>    isConversational = nil
<a name="369"></a>    
<a name="370"></a>    
<a name="371"></a>    /* 
<a name="372"></a>     *   Is this action repeatable (with an AGAIN command)? Most actions are so
<a name="373"></a>     *   the default is true but subclasses can override to exclude actions
<a name="374"></a>     *   (such as certain system actions) that it would make no sense to repeat.
<a name="375"></a>     */
<a name="376"></a>    isRepeatable = true
<a name="377"></a>    
<a name="378"></a>    
<a name="379"></a>    /* 
<a name="380"></a>     *   If an AGAIN command is used with this command, should the command be
<a name="381"></a>     *   reparsed from scratch (because it might involve a different object) or
<a name="382"></a>     *   not (because it should act on the same objects). We generally set this
<a name="383"></a>     *   to true for actions it wouldn't normally make sense to repeat on the
<a name="384"></a>     *   same object straight away. Since this applies to the majority of
<a name="385"></a>     *   actions, we make this the default.
<a name="386"></a>     */
<a name="387"></a>    againRepeatsParse = true
<a name="388"></a>    
<a name="389"></a>    /* 
<a name="390"></a>     *   Report on the action. This is only relevant where the action has more
<a name="391"></a>     *   or one objects, so TAction must override. This is called from the
<a name="392"></a>     *   current Command object once all the objects have been acted on (in a
<a name="393"></a>     *   case where multiple direct objects have been specified, as in TAKE ALL
<a name="394"></a>     *   or TAKE RED BALL AND GREEN PEN). This allows the report routine to
<a name="395"></a>     *   summarize the action for all the objects acted upon instead of
<a name="396"></a>     *   displaying an individual report for each one.
<a name="397"></a>     */
<a name="398"></a>    reportAction()  { }
<a name="399"></a>    
<a name="400"></a>   
<a name="401"></a>    /* 
<a name="402"></a>     *   Do we have a parent action, and if so what is it? The parent action
<a name="403"></a>     *   would be the action that's using us as an implicit action or nested
<a name="404"></a>     *   action.
<a name="405"></a>     */
<a name="406"></a>    parentAction = nil
<a name="407"></a>    
<a name="408"></a>    
<a name="409"></a>    
<a name="410"></a>    /* 
<a name="411"></a>     *   Carry out the verification stage for this object in this role, and
<a name="412"></a>     *   carry out any remapping needed. This needs to be defined on Action
<a name="413"></a>     *   since there might be verification of the ActorRole.
<a name="414"></a>     */
<a name="415"></a>    verify(obj, role)
<a name="416"></a>    {
<a name="417"></a>        local remapResult;
<a name="418"></a>        local verifyProp;
<a name="419"></a>        local preCondProp;
<a name="420"></a>        local remapProp;
<a name="421"></a>        
<a name="422"></a>        
<a name="423"></a>        /* Clear out any previous verify results */
<a name="424"></a>        verifyTab = nil;
<a name="425"></a>        
<a name="426"></a>        /* 
<a name="427"></a>         *   Note which properties to use according to which role we're
<a name="428"></a>         *   verifying for. (No actions in the adv3Lite library currently use an
<a name="429"></a>         *   Accessory object but the possibility is included here to ease
<a name="430"></a>         *   subsequent extension).
<a name="431"></a>         */        
<a name="432"></a>        switch(role)
<a name="433"></a>        {
<a name="434"></a>        case DirectObject:            
<a name="435"></a>            verifyProp = verDobjProp;
<a name="436"></a>            preCondProp = preCondDobjProp;
<a name="437"></a>            remapProp = remapDobjProp;
<a name="438"></a>            break;        
<a name="439"></a>            
<a name="440"></a>        case IndirectObject:            
<a name="441"></a>            verifyProp = verIobjProp;
<a name="442"></a>            preCondProp = preCondIobjProp;
<a name="443"></a>            remapProp = remapIobjProp;
<a name="444"></a>            break;
<a name="445"></a>            
<a name="446"></a>        case AccessoryObject:
<a name="447"></a>            verifyProp = verAobjProp;
<a name="448"></a>            preCondProp = preCondAobjProp;
<a name="449"></a>            remapProp = remapAobjProp;
<a name="450"></a>            break;
<a name="451"></a>        case ActorRole:
<a name="452"></a>            verifyProp = &amp;verifyActor;
<a name="453"></a>            remapProp = &amp;remapActor;
<a name="454"></a>            preCondProp = &amp;preCondActor;
<a name="455"></a>            break;    
<a name="456"></a>        } 
<a name="457"></a>           
<a name="458"></a>        /* first check if we need to remap this action. */                 
<a name="459"></a>        remapResult = obj.(remapProp);
<a name="460"></a>        
<a name="461"></a>        /* 
<a name="462"></a>         *   the object's remap routine can return an object or a list (if it
<a name="463"></a>         *   returns anything else we ignore it). If it returns an object use
<a name="464"></a>         *   that object in place of the one we were about to verify for the
<a name="465"></a>         *   remainder of this action. If it returns a list, the list should
<a name="466"></a>         *   contain the details of an action that is to replace the current
<a name="467"></a>         *   action, so run the remapped action instead.
<a name="468"></a>         */        
<a name="469"></a>        switch(dataType(remapResult))
<a name="470"></a>        {
<a name="471"></a>        case TypeObject:
<a name="472"></a>            obj = remapResult;
<a name="473"></a>            break;
<a name="474"></a>        case TypeList:
<a name="475"></a>            /* 
<a name="476"></a>             *   If the remap result is a list, then we'll need to remap the
<a name="477"></a>             *   action to another one, but we'll leave that until all the
<a name="478"></a>             *   objects have been resolved. For the purpose of verifying this
<a name="479"></a>             *   object we'll just return a standard logical verify result to
<a name="480"></a>             *   allow the remapping to proceed at a later stage.
<a name="481"></a>             */                  
<a name="482"></a>            DMsg(remap error, '&lt;b&gt;ERROR!&lt;/b&gt; The long form of remap is no longer
<a name="483"></a>                available; please use a Doer instead. ');
<a name="484"></a>             
<a name="485"></a>        default:
<a name="486"></a>            break;
<a name="487"></a>        }
<a name="488"></a>        
<a name="489"></a>        /* 
<a name="490"></a>         *   Note which object we're currently verifying in the Action's
<a name="491"></a>         *   verifyObj property so other routines can find it (particularly a
<a name="492"></a>         *   verify routine called from a preCondition).
<a name="493"></a>         */
<a name="494"></a>        verifyObj = obj;
<a name="495"></a>        curObj = obj;
<a name="496"></a>        
<a name="497"></a>        switch(role)
<a name="498"></a>        {
<a name="499"></a>            
<a name="500"></a>        case DirectObject:
<a name="501"></a>            curDobj = obj;
<a name="502"></a>            break;
<a name="503"></a>            
<a name="504"></a>        case IndirectObject:            
<a name="505"></a>            curIobj = obj;
<a name="506"></a>            break;
<a name="507"></a>            
<a name="508"></a>        case AccessoryObject:
<a name="509"></a>            curAobj = obj;
<a name="510"></a>            break;
<a name="511"></a>        }
<a name="512"></a>        
<a name="513"></a>        /* 
<a name="514"></a>         *   if the object is a decoration then we use the catchall Default
<a name="515"></a>         *   prop, unless we're an action that bypasses it.
<a name="516"></a>         */        
<a name="517"></a>        if(obj.isDecoration 
<a name="518"></a>           &amp;&amp; obj.decorationActions.indexWhich({x: self.ofKind(x)}) == nil)
<a name="519"></a>        {
<a name="520"></a>            switch(role)
<a name="521"></a>            {
<a name="522"></a>                
<a name="523"></a>            case DirectObject:
<a name="524"></a>                verifyProp =  &amp;verifyDobjDefault;            
<a name="525"></a>                preCondProp = &amp;preCondDobjDefault;
<a name="526"></a>                break;
<a name="527"></a>                
<a name="528"></a>            case IndirectObject:            
<a name="529"></a>                verifyProp = &amp;verifyIobjDefault;            
<a name="530"></a>                preCondProp = &amp;preCondIobjDefault;
<a name="531"></a>                break;
<a name="532"></a>                
<a name="533"></a>            case AccessoryObject:
<a name="534"></a>                verifyProp = &amp;verifyAobjDefault;            
<a name="535"></a>                preCondProp = &amp;preCondAobjDefault;
<a name="536"></a>                break;
<a name="537"></a>            }          
<a name="538"></a>        }
<a name="539"></a>
<a name="540"></a>        
<a name="541"></a>        try
<a name="542"></a>        {
<a name="543"></a>            /* 
<a name="544"></a>             *   If this action defines the mmVerify method to handle multimethod verify, then call
<a name="545"></a>             *   it now. Note that this means that the same mmVerify routine will be called for
<a name="546"></a>             *   every object role (dobj &amp;&amp; iob on a TIAction), but this is what we want.
<a name="547"></a>             */
<a name="548"></a>            if(propDefined(&amp;mmVerify))
<a name="549"></a>                mmVerify(gVerifyDobj, gVerifyIobj, verifyObj);
<a name="550"></a>            
<a name="551"></a>            
<a name="552"></a>            
<a name="553"></a>            
<a name="554"></a>            /* 
<a name="555"></a>             *   Execute the appropriate verify routine on the object, provided our multimethod
<a name="556"></a>             *   didn't throw a skip signal.
<a name="557"></a>             */
<a name="558"></a>            
<a name="559"></a>            
<a name="560"></a>            obj.(verifyProp);
<a name="561"></a>        }
<a name="562"></a>       
<a name="563"></a>        
<a name="564"></a>        catch (SkipSignal ex)  {   }
<a name="565"></a>        
<a name="566"></a>        /* If we don't already have a verify table, create it */
<a name="567"></a>        if(verifyTab == nil)
<a name="568"></a>            verifyTab = new LookupTable;
<a name="569"></a>        
<a name="570"></a>        /* 
<a name="571"></a>         *   If executing this verify routine didn't create an entry for this
<a name="572"></a>         *   object in the verify table, create one now with a default 'logical'
<a name="573"></a>         *   verify result.
<a name="574"></a>         */        
<a name="575"></a>        if(verifyTab.isKeyPresent(obj) == nil)
<a name="576"></a>            verifyTab[obj] = new VerifyResult(100, '', true, obj);
<a name="577"></a>        
<a name="578"></a>        
<a name="579"></a>        /* 
<a name="580"></a>         *   Next run through all the items in our precondition list and execute
<a name="581"></a>         *   their verify methods.
<a name="582"></a>         */
<a name="583"></a>        foreach(local cur in valToList(obj.(preCondProp)))
<a name="584"></a>            cur.verifyPreCondition(obj);        
<a name="585"></a>        
<a name="586"></a>        
<a name="587"></a>        /* 
<a name="588"></a>         *   Return the entry for this object in our verify table (which may
<a name="589"></a>         *   have been altered by one of the preconditions above).
<a name="590"></a>         */
<a name="591"></a>        return verifyTab[obj];
<a name="592"></a>    }
<a name="593"></a>    
<a name="594"></a>    /* 
<a name="595"></a>     *   Flag, do we want an action that fails at the verify stage to count as a turn (in other
<a name="596"></a>     *   words, if an action fails at the verify stage, do we want to advance the turn
<a name="597"></a>     *   counter,excecute daemons, and do all the other turn sequence stuff)? By default we do,
<a name="598"></a>     *   since this has long been the standard behaviour, but game code can override this to nil
<a name="599"></a>     *   either globally on the Action class on on individual actions to cause failure at the verify
<a name="600"></a>     *   stage to abort the remainder of the turn sequence.
<a name="601"></a>     */
<a name="602"></a>    failedActionCountsAsTurn = true
<a name="603"></a>    
<a name="604"></a>    /* 
<a name="605"></a>     *   Run the verify routine on the current object in the current role to see
<a name="606"></a>     *   whether it will allow the action. If it won't, display any pending
<a name="607"></a>     *   implicit action announcements, then display the message explaining why
<a name="608"></a>     *   the action is disallowed, and finally return nil to tell our caller to
<a name="609"></a>     *   halt the action. If the verify stage does allow the action to go ahead,
<a name="610"></a>     *   return true to tell our caller that this routine has no objection.
<a name="611"></a>     */    
<a name="612"></a>    verifyObjRole(obj, role)
<a name="613"></a>    {
<a name="614"></a>        local verResult;
<a name="615"></a>        local verMsg;
<a name="616"></a>        
<a name="617"></a>        /* Make sure we start with a clean new verify table */
<a name="618"></a>        verifyTab = new LookupTable;
<a name="619"></a>        
<a name="620"></a>        verResult = verify(obj, role);
<a name="621"></a>        
<a name="622"></a>        /* 
<a name="623"></a>         *   If the verify result is one that disallows the action then display
<a name="624"></a>         *   the failure message, along with any failed implicit action message.
<a name="625"></a>         */
<a name="626"></a>        if(!verResult.allowAction)
<a name="627"></a>        {
<a name="628"></a>             /* Note our failure message */
<a name="629"></a>            verMsg = verResult.errMsg;
<a name="630"></a>            
<a name="631"></a>            /* 
<a name="632"></a>             *   If this is the direct object of the command and there's more
<a name="633"></a>             *   than one, and if the option to announce objects in verify
<a name="634"></a>             *   messages is true, then announce the name of this object to make
<a name="635"></a>             *   it clear which one is being referred to.
<a name="636"></a>             */
<a name="637"></a>            if(announceMultiVerify &amp;&amp; role == DirectObject &amp;&amp;
<a name="638"></a>               gCommand.dobjs.length &gt; 1)
<a name="639"></a>                announceObject(obj);
<a name="640"></a>            
<a name="641"></a>            /* 
<a name="642"></a>             *   If we're an implicit action add a failed implicit action report
<a name="643"></a>             *   ('trying to...').
<a name="644"></a>             */
<a name="645"></a>            if(isImplicit)
<a name="646"></a>                "&lt;&lt;buildImplicitActionAnnouncement(nil)&gt;&gt;";
<a name="647"></a>            
<a name="648"></a>            /* 
<a name="649"></a>             *   Display the failure message, unless it's identical to the
<a name="650"></a>             *   previous one.
<a name="651"></a>             */            
<a name="652"></a>            if(verMsg != lastVerifyMsg || announceMultiVerify)
<a name="653"></a>            {
<a name="654"></a>                say(verMsg);
<a name="655"></a>                "\n";
<a name="656"></a>                lastVerifyMsg = verMsg;
<a name="657"></a>            }
<a name="658"></a>            
<a name="659"></a>            /* Note that this action has failed. */
<a name="660"></a>            actionFailed = true;
<a name="661"></a>            
<a name="662"></a>            if(!failedActionCountsAsTurn)
<a name="663"></a>                abort;
<a name="664"></a>            
<a name="665"></a>            /* 
<a name="666"></a>             *   Stop the processing of the action here by telling our caller
<a name="667"></a>             *   we've failed.
<a name="668"></a>             */
<a name="669"></a>            return nil;
<a name="670"></a>        }
<a name="671"></a>        
<a name="672"></a>        /* 
<a name="673"></a>         *   If we're an implicit action and our best verify result doesn't
<a name="674"></a>         *   allow implicit actions, abort the implicit action.
<a name="675"></a>         */        
<a name="676"></a>        if(isImplicit &amp;&amp; !verResult.allowImplicit)
<a name="677"></a>            abortImplicit;
<a name="678"></a>        
<a name="679"></a>        /* 
<a name="680"></a>         *   Otherwise return true to tell our caller we're not objecting to the
<a name="681"></a>         *   action.
<a name="682"></a>         */
<a name="683"></a>        return true;
<a name="684"></a>    }
<a name="685"></a>    
<a name="686"></a>    /* The object currently being verified */    
<a name="687"></a>    verifyObj = nil
<a name="688"></a>    
<a name="689"></a>    /*
<a name="690"></a>     *   Get a message parameter object for the action.  Each action
<a name="691"></a>     *   subclass defines this to return its objects according to its own
<a name="692"></a>     *   classifications.  The default action has no objects, but
<a name="693"></a>     *   recognizes 'actor' as the current command's actor.  
<a name="694"></a>     */
<a name="695"></a>    getMessageParam(objName)
<a name="696"></a>    {
<a name="697"></a>        switch(objName)
<a name="698"></a>        {
<a name="699"></a>        case 'pc':
<a name="700"></a>            /* return the player character */
<a name="701"></a>            return gPlayerChar;
<a name="702"></a>            
<a name="703"></a>        case 'actor':
<a name="704"></a>            /* return the current actor */
<a name="705"></a>            return gActor;
<a name="706"></a>            
<a name="707"></a>        case 'cobj':
<a name="708"></a>            /* return the current object, if there is one */
<a name="709"></a>            return curObj;
<a name="710"></a>
<a name="711"></a>        default:
<a name="712"></a>            /* 
<a name="713"></a>             *   if we have an extra message parameters table, look up the
<a name="714"></a>             *   parameter name in the table 
<a name="715"></a>             */
<a name="716"></a>            if (extraMessageParams != nil)
<a name="717"></a>                return extraMessageParams[objName];
<a name="718"></a>
<a name="719"></a>            /* we don't recognize other names */
<a name="720"></a>            return nil;
<a name="721"></a>        }
<a name="722"></a>    }
<a name="723"></a>
<a name="724"></a>    /*
<a name="725"></a>     *   Define an extra message-specific parameter.  Message processors
<a name="726"></a>     *   can use this to add their own special parameters, so that they
<a name="727"></a>     *   can refer to parameters that aren't involved directly in the
<a name="728"></a>     *   command.  For example, a message for "take &lt;dobj&gt;" might want to
<a name="729"></a>     *   refer to the object containing the direct object.
<a name="730"></a>     */
<a name="731"></a>    setMessageParam(objName, obj)
<a name="732"></a>    {
<a name="733"></a>        /* 
<a name="734"></a>         *   if we don't yet have an extra message parameters table,
<a name="735"></a>         *   create a small lookup table for it 
<a name="736"></a>         */
<a name="737"></a>        if (extraMessageParams == nil)
<a name="738"></a>            extraMessageParams = new LookupTable(8, 8);
<a name="739"></a>
<a name="740"></a>        /* add the parameter to the table, indexing by the parameter name */
<a name="741"></a>        extraMessageParams[objName.toLower()] = obj;
<a name="742"></a>    }
<a name="743"></a>
<a name="744"></a>    /*
<a name="745"></a>     *   For convenience, this method allows setting any number of
<a name="746"></a>     *   name/value pairs for message parameters. 
<a name="747"></a>     */
<a name="748"></a>    setMessageParams([lst])
<a name="749"></a>    {
<a name="750"></a>        /* set each pair from the argument list */
<a name="751"></a>        for (local i = 1, local len = lst.length() ; i+1 &lt;= len ; i += 2)
<a name="752"></a>            setMessageParam(lst[i], lst[i+1]);
<a name="753"></a>    }
<a name="754"></a>
<a name="755"></a>    /*
<a name="756"></a>     *   Synthesize a global message parameter name for the given object.
<a name="757"></a>     *   We'll store the association and return the synthesized name. 
<a name="758"></a>     */
<a name="759"></a>    synthMessageParam(obj)
<a name="760"></a>    {
<a name="761"></a>        local nm;
<a name="762"></a>        
<a name="763"></a>        /* synthesize a name */
<a name="764"></a>        nm = 'synth' + toString(synthParamID++);
<a name="765"></a>
<a name="766"></a>        /* store the association */
<a name="767"></a>        setMessageParam(nm, obj);
<a name="768"></a>
<a name="769"></a>        /* return the synthesized name */
<a name="770"></a>        return nm;
<a name="771"></a>    }
<a name="772"></a>
<a name="773"></a>    /* synthesized message object parameter serial number */
<a name="774"></a>    synthParamID = 1
<a name="775"></a>
<a name="776"></a>    /*
<a name="777"></a>     *   Extra message parameters.  If a message processor wants to add
<a name="778"></a>     *   special message parameters of its own, we'll create a lookup
<a name="779"></a>     *   table for the extra parameters.  Message processors might want to
<a name="780"></a>     *   add their own special parameters to allow referring to objects
<a name="781"></a>     *   other than the main objects of the command.  
<a name="782"></a>     */
<a name="783"></a>    extraMessageParams = nil
<a name="784"></a>
<a name="785"></a>  
<a name="786"></a>    /* 
<a name="787"></a>     *   Get a list of all the objects that this action should act on if the
<a name="788"></a>     *   player typed ALL for role (DirectObject, IndirectObject, or perhaps in
<a name="789"></a>     *   some future version of the library, AccessoryObject. This is the method
<a name="790"></a>     *   that can be overridden on subclasses to give action-specific
<a name="791"></a>     *   definitions of ALL.
<a name="792"></a>     */
<a name="793"></a>    getAll(cmd, role)
<a name="794"></a>    {
<a name="795"></a>        /* by default, return everything in scope */
<a name="796"></a>        return World.scope.toList();
<a name="797"></a>    }
<a name="798"></a>    
<a name="799"></a>    /* 
<a name="800"></a>     *   Get a list of all the objects this action will act on if the player
<a name="801"></a>     *   types ALL for role (DirectObject or IndirectObject). This is the method
<a name="802"></a>     *   actually called by the Parser. We first obtain the list of objects
<a name="803"></a>     *   returned by getAll() and then filter out any objects for which
<a name="804"></a>     *   hideFromAll(action) is true for this action. Subclasses should normally
<a name="805"></a>     *   override getAll() rather than this method.
<a name="806"></a>     */
<a name="807"></a>    getAllUnhidden(cmd, role)
<a name="808"></a>    {
<a name="809"></a>        return getAll(cmd, role).subset({x: x.hideFromAll(self) == nil});
<a name="810"></a>    }
<a name="811"></a>    
<a name="812"></a>     /*
<a name="813"></a>     *   Score a set of objects in a given noun role in the action, in
<a name="814"></a>     *   order to resolve an ambiguous command.  Our job, in brief, is to
<a name="815"></a>     *   READ THE PLAYER'S MIND: we want to figure out which object or
<a name="816"></a>     *   objects the player is actually referring to when their words are
<a name="817"></a>     *   ambiguous.
<a name="818"></a>     *   
<a name="819"></a>     *   'cmd' is the Command object describing the command.  The various
<a name="820"></a>     *   object lists (dobjs, iobjs, accs) have been filled in with the
<a name="821"></a>     *   in-scope objects that match the noun phrase, but these haven't
<a name="822"></a>     *   been disambiguated yet, so there might be more objects listed than
<a name="823"></a>     *   will actually be used in the final command.
<a name="824"></a>     *   
<a name="825"></a>     *   'role' tells us the noun phrase role that we're scoring
<a name="826"></a>     *   (DirectObject, IndirectObject, AccessoryObject, TopicRole,
<a name="827"></a>     *   LiteralRole).
<a name="828"></a>     *   
<a name="829"></a>     *   'lst' is the match list.  This is a Vector containing NPMatch
<a name="830"></a>     *   objects.  There's one NPMatch for each object that we're
<a name="831"></a>     *   considering as a match for the player's noun phrase.
<a name="832"></a>     *   
<a name="833"></a>     *   For each item in the match list, we must set the NPMatch object's
<a name="834"></a>     *   'score' property to a number indicating how likely we think it is
<a name="835"></a>     *   that the player is referring to this object.  The higher the
<a name="836"></a>     *   score, the more likely we think it is.  The score value is purely
<a name="837"></a>     *   relative - the caller will pick the object or objects with the
<a name="838"></a>     *   highest score.
<a name="839"></a>     *   
<a name="840"></a>     *   
<a name="841"></a>     *   
<a name="842"></a>     *   We run through the verify routine for each object, which in turn
<a name="843"></a>     *   runs through the preconditions of that object. We take the returned
<a name="844"></a>     *   verify score to be the score for the object (or its replacement if
<a name="845"></a>     *   remapping took place).
<a name="846"></a>     *   
<a name="847"></a>     *   Next, we do any verb-specific adjustments via self.actionScore().
<a name="848"></a>     *   
<a name="849"></a>     *   Finally, we call each object's scoreObject() routine to give the
<a name="850"></a>     *   object a chance to make any adjustments for special affinities (or
<a name="851"></a>     *   aversions).  
<a name="852"></a>     */    
<a name="853"></a>    scoreObjects(cmd, role, lst)
<a name="854"></a>    {
<a name="855"></a>        local bestScore = 0;
<a name="856"></a>        local bestResult = nil;
<a name="857"></a>        local verResult;
<a name="858"></a>        
<a name="859"></a>        gAction = cmd.action;
<a name="860"></a>        gActor = cmd.actor;
<a name="861"></a>        
<a name="862"></a>        foreach (local i in lst)
<a name="863"></a>        {
<a name="864"></a>            /* get this object */
<a name="865"></a>            local obj = i.obj;
<a name="866"></a>            
<a name="867"></a>            /* 
<a name="868"></a>             *   Get the verify result by running the verify routine on the
<a name="869"></a>             *   current Command object's action for this object in this role.
<a name="870"></a>             */
<a name="871"></a>            verResult = cmd.action.verify(obj, role);
<a name="872"></a>            
<a name="873"></a>            /* 
<a name="874"></a>             *   Compute the score as being the verify result's result rank
<a name="875"></a>             *   times 100
<a name="876"></a>             */
<a name="877"></a>            i.score = verResult.resultRank * 100;
<a name="878"></a>            
<a name="879"></a>            /* 
<a name="880"></a>             *   If this score is greater than the best score we've found so
<a name="881"></a>             *   far, note the new best score and the new best verify result.
<a name="882"></a>             */
<a name="883"></a>            if(i.score &gt; bestScore)
<a name="884"></a>            {
<a name="885"></a>                bestScore = i.score;
<a name="886"></a>                bestResult = verResult;
<a name="887"></a>            }
<a name="888"></a>            
<a name="889"></a>            /* 
<a name="890"></a>             *   The verify process could result in the remapping of the
<a name="891"></a>             *   original object to a new one.
<a name="892"></a>             */
<a name="893"></a>            i.obj = verResult.myObj;
<a name="894"></a>        }
<a name="895"></a>        
<a name="896"></a>        /* 
<a name="897"></a>         *   Make a note of which object came out best in case it's needed when
<a name="898"></a>         *   we come to verify the other object.
<a name="899"></a>         */        
<a name="900"></a>        if(role == DirectObject)        
<a name="901"></a>            curDobj = bestResult.myObj;
<a name="902"></a>        
<a name="903"></a>        if(role == IndirectObject)
<a name="904"></a>            curIobj = bestResult.myObj;
<a name="905"></a>        
<a name="906"></a>        if(role == AccessoryObject)
<a name="907"></a>            curAobj = bestResult.myObj;
<a name="908"></a>        
<a name="909"></a>        
<a name="910"></a>        /* apply verb-specific adjustments */
<a name="911"></a>        foreach (local i in lst)
<a name="912"></a>            scoreObject(cmd, role, lst, i);
<a name="913"></a>        
<a name="914"></a>        /* apply object-specific adjustments */
<a name="915"></a>        foreach (local i in lst)
<a name="916"></a>            i.obj.scoreObject(cmd, role, lst, i);
<a name="917"></a>        
<a name="918"></a>    }
<a name="919"></a>    
<a name="920"></a>    
<a name="921"></a>    /* 
<a name="922"></a>     *   Wraps a list of objects in NPMatch objects so they can be run through
<a name="923"></a>     *   the scoreObjects method.
<a name="924"></a>     */
<a name="925"></a>    wrapObjectsNP(lst)
<a name="926"></a>    {
<a name="927"></a>        local nplist = [];
<a name="928"></a>        
<a name="929"></a>        foreach(local cur in lst)        
<a name="930"></a>        {            
<a name="931"></a>            nplist += new NPMatch(nil, cur, 0);
<a name="932"></a>        }
<a name="933"></a>        
<a name="934"></a>        return nplist;
<a name="935"></a>    }
<a name="936"></a>    
<a name="937"></a>    /* Build the scope list for this action. */
<a name="938"></a>    buildScopeList(whichRole = DirectObject)
<a name="939"></a>    {
<a name="940"></a>        /* Start with the scope list supplied by the Query object */
<a name="941"></a>        scopeList = Q.scopeList(gActor).toList();
<a name="942"></a>        
<a name="943"></a>        /* Add any additional items to scope as special cases if desired. */
<a name="944"></a>        addExtraScopeItems(whichRole);
<a name="945"></a>    }
<a name="946"></a>       
<a name="947"></a>    
<a name="948"></a>    
<a name="949"></a>    /* 
<a name="950"></a>     *   Add extra scope items if this action needs a wider definition of scope
<a name="951"></a>     *   than normal. By default we simply allow the current actor's current
<a name="952"></a>     *   location to add additional items to scope if it wishes to.
<a name="953"></a>     */    
<a name="954"></a>    addExtraScopeItems(role?)
<a name="955"></a>    {
<a name="956"></a>        gActor.getOutermostRoom.addExtraScopeItems(self);
<a name="957"></a>    }
<a name="958"></a>    
<a name="959"></a>    /* Our currently cached list of items in scope for this action. */         
<a name="960"></a>    scopeList = []
<a name="961"></a>    
<a name="962"></a>    /* Used by Mercury's spelling corrector code. */
<a name="963"></a>    spellingPriority = 10
<a name="964"></a>    
<a name="965"></a>    /* 
<a name="966"></a>     *   Can ALL be used with this action? By default we take our value from
<a name="967"></a>     *   gameMain.allVerbsAllowAll, though basic inventory-handling actions in
<a name="968"></a>     *   the library will override this. This property is really only relevant
<a name="969"></a>     *   on TAction and its descendents, but we define it here just to make sure
<a name="970"></a>     *   no cases are missed.
<a name="971"></a>     */
<a name="972"></a>    allowAll = (gameMain.allVerbsAllowAll)
<a name="973"></a>    
<a name="974"></a>    /* 
<a name="975"></a>     *   If we've been redirected here from another action, store a reference to
<a name="976"></a>     *   that action.
<a name="977"></a>     */
<a name="978"></a>    redirectParent = nil
<a name="979"></a>    
<a name="980"></a>    /* Does the command from which we've been redirected allow ALL? */
<a name="981"></a>    parentAllowAll = (redirectParent ? redirectParent.allowAll : nil)   
<a name="982"></a>  
<a name="983"></a>    /* 
<a name="984"></a>     *   The message to display if an action fails at the check stage (via an
<a name="985"></a>     *   exit macro) without any other explanatory text being displayed.
<a name="986"></a>     */
<a name="987"></a>    failCheckMsg = BMsg(fail check, '{I} {cannot} do that (but the author of
<a name="988"></a>        this game failed to specify why).')
<a name="989"></a>    
<a name="990"></a>    
<a name="991"></a>    /* optional command is not supported in this game */
<a name="992"></a>    commandNotPresent()
<a name="993"></a>    {
<a name="994"></a>       DMsg(command not present, '&lt;.parser&gt;That command isn&amp;rsquo;t needed
<a name="995"></a>           in this story.&lt;./parser&gt; ');
<a name="996"></a>    }
<a name="997"></a>        
<a name="998"></a>    
<a name="999"></a>    /* acknowledge a change in the score notification status */
<a name="1000"></a>    acknowledgeNotifyStatus(stat)
<a name="1001"></a>    {
<a name="1002"></a>        DMsg(acknowledge notify status, '&lt;.notification&gt;Score notifications are now
<a name="1003"></a>        &lt;&lt;stat ? 'on' : 'off'&gt;&gt;.&lt;./notification&gt; ');
<a name="1004"></a>    }
<a name="1005"></a>    
<a name="1006"></a>    /* 
<a name="1007"></a>     *   Flag: is this an action that acts on an object even if it is hidden;
<a name="1008"></a>     *   normally this will only apply to debugging actions.
<a name="1009"></a>     */
<a name="1010"></a>    unhides = nil
<a name="1011"></a>    
<a name="1012"></a>    /*  
<a name="1013"></a>     *   This does nothing in the main library but is provided as a hook for the
<a name="1014"></a>     *   objtime extension to use to add to the time taken by implicit actions.
<a name="1015"></a>     */
<a name="1016"></a>    addImplicitTime() { }
<a name="1017"></a>    
<a name="1018"></a>    /*  
<a name="1019"></a>     *   Advance the game clock time. This does nothing in the main library but
<a name="1020"></a>     *   is provided as a hook for the objtime extension to use.
<a name="1021"></a>     */
<a name="1022"></a>    advanceTime() {}
<a name="1023"></a>    
<a name="1024"></a>    /* 
<a name="1025"></a>     *   Method to get the reports to be displayed immediately after any implicit action reports
<a name="1026"></a>     *   that have been stored via a call to reportPostImplicit(). The language-specific part of the
<a name="1027"></a>     *   library should call this method to append the text it returns to the implicit action
<a name="1028"></a>     *   reports it generatees.
<a name="1029"></a>     */
<a name="1030"></a>    getPostImplicitReports()
<a name="1031"></a>    {
<a name="1032"></a>        local rep = '';
<a name="1033"></a>        foreach(local prp in gCommand.postImplicitReports)
<a name="1034"></a>        {
<a name="1035"></a>            if(dataType(prp) == TypeSString &amp;&amp; prp.length &gt; 0)
<a name="1036"></a>                rep += ('\n' + prp);
<a name="1037"></a>        }
<a name="1038"></a>        
<a name="1039"></a>        return rep;
<a name="1040"></a>    }    
<a name="1041"></a>    
<a name="1042"></a>    /* 
<a name="1043"></a>     *   Flag - do we want to duplicate objects of this action to be treated as single to be treated
<a name="1044"></a>     *   as a single object, (e.g. if tools objects includes 'hammer' and 'chisel' in its vocab abd
<a name="1045"></a>     *   the player types TAKE HAMMER AND CHISEL. We default to nil here since not all actions have
<a name="1046"></a>     *   objects.
<a name="1047"></a>     */
<a name="1048"></a>    combineDuplicateObjects = nil
<a name="1049"></a>;
<a name="1050"></a>
<a name="1051"></a>
<a name="1052"></a>/* 
<a name="1053"></a> *   The SystemAction class is for actions not affecting the game world but
<a name="1054"></a> *   rather acting on the game session, such as SAVE, RESTORE and QUIT.
<a name="1055"></a> */
<a name="1056"></a>class SystemAction: IAction
<a name="1057"></a>    /* A SystemAction is not normally undo-able */
<a name="1058"></a>    includeInUndo = nil
<a name="1059"></a>    
<a name="1060"></a>    /* A SystemAction is not normally repeatable */
<a name="1061"></a>    isRepeatable = nil
<a name="1062"></a>    
<a name="1063"></a>    /* 
<a name="1064"></a>     *   Since a SystemAction isn't an action in the game world, we don't want
<a name="1065"></a>     *   it to trigger any after action notifications.
<a name="1066"></a>     */
<a name="1067"></a>    afterAction() { }
<a name="1068"></a>    
<a name="1069"></a>    /* 
<a name="1070"></a>     *   Since a SystemAction isn't an action in the game world, we don't want
<a name="1071"></a>     *   it to count as a turn, so we don't run any Daemons or Fuses and we
<a name="1072"></a>     *   don't advance the turn count.
<a name="1073"></a>     */
<a name="1074"></a>    turnSequence() { }
<a name="1075"></a>    
<a name="1076"></a>    /* 
<a name="1077"></a>     *   A SystemAction doesn't take any turns (this is a bit belt-and-braces
<a name="1078"></a>     *   since turnSequence does nothing in any case).
<a name="1079"></a>     */
<a name="1080"></a>    turnsTaken = 0
<a name="1081"></a>    
<a name="1082"></a>    /* 
<a name="1083"></a>     *   Since this isn't an action within the game world we bypass all the
<a name="1084"></a>     *   normal pre-action handling and just execute a reduced cycle.
<a name="1085"></a>     */
<a name="1086"></a>    exec(cmd) { execCycle(cmd); }
<a name="1087"></a>    
<a name="1088"></a>    /* 
<a name="1089"></a>     *   There's no before notifications for a SystemAction so we simply execute
<a name="1090"></a>     *   the action and, if we should define it as repeatable, make a note of it
<a name="1091"></a>     *   in case the player issues an AGAIN command on the next turn.
<a name="1092"></a>     */
<a name="1093"></a>    execCycle(cmd)
<a name="1094"></a>    {
<a name="1095"></a>        try
<a name="1096"></a>        {     
<a name="1097"></a>            /* Display a message if we're debugging actions. */
<a name="1098"></a>            IfDebug(actions, 
<a name="1099"></a>                    "[Executing &lt;&lt;actionTab.symbolToVal(baseActionClass)&gt;&gt; ]\n" );
<a name="1100"></a>            
<a name="1101"></a>            /* Execute the action. */
<a name="1102"></a>            execAction(cmd);
<a name="1103"></a>            
<a name="1104"></a>            /* 
<a name="1105"></a>             *   If we're a repeatable action, note that we were the last action
<a name="1106"></a>             *   to be executed.
<a name="1107"></a>             */
<a name="1108"></a>            if(isRepeatable)
<a name="1109"></a>                libGlobal.lastAction = self.createClone();
<a name="1110"></a>        }
<a name="1111"></a>        catch(ExitActionSignal ex)
<a name="1112"></a>        {
<a name="1113"></a>        }
<a name="1114"></a>        
<a name="1115"></a>        catch(ExitSignal ex)
<a name="1116"></a>        {
<a name="1117"></a>            actionFailed = true;
<a name="1118"></a>        }
<a name="1119"></a>        
<a name="1120"></a>    }
<a name="1121"></a>    
<a name="1122"></a>     /*
<a name="1123"></a>      *   Ask for an input file.  We call the input manager, which displays the
<a name="1124"></a>      *   appropriate local file selector dialog. This is used for SystemActions
<a name="1125"></a>      *   that need a file to act on, such as SAVE, RESTORE and QUIT.
<a name="1126"></a>      */
<a name="1127"></a>    getInputFile(prompt, dialogType, fileType, flags)
<a name="1128"></a>    {
<a name="1129"></a>        return inputManager.getInputFile(prompt, dialogType, fileType, flags);
<a name="1130"></a>    }
<a name="1131"></a>;
<a name="1132"></a>
<a name="1133"></a>/* 
<a name="1134"></a> *   An IAction is an Action that doesn't directly act on any objects. At least
<a name="1135"></a> *   in this version of the library it works just like the base Action class.
<a name="1136"></a> */
<a name="1137"></a>class IAction: Action
<a name="1138"></a>    /* 
<a name="1139"></a>     *   There's usually no point in parsing an IAction again when it's repeated
<a name="1140"></a>     *   since there are no objects to have changed.
<a name="1141"></a>     */
<a name="1142"></a>    againRepeatsParse = nil
<a name="1143"></a>    
<a name="1144"></a>    /* 
<a name="1145"></a>     *   For an IAction there's no point in trying to score anything but the
<a name="1146"></a>     *   Actor object; attempting to score objects via their verify properties
<a name="1147"></a>     *   will cause a run-time error, since IActions don't define verify
<a name="1148"></a>     *   properties and the like.
<a name="1149"></a>     */
<a name="1150"></a>    scoreObjects(cmd, role, lst)
<a name="1151"></a>    {
<a name="1152"></a>        if(role == ActorRole)
<a name="1153"></a>            inherited(cmd, role, lst);
<a name="1154"></a>        else
<a name="1155"></a>        {
<a name="1156"></a>            /* apply verb-specific adjustments */
<a name="1157"></a>            foreach (local i in lst)
<a name="1158"></a>                scoreObject(cmd, role, lst, i);
<a name="1159"></a>            
<a name="1160"></a>            /* apply object-specific adjustments */
<a name="1161"></a>            foreach (local i in lst)
<a name="1162"></a>                i.obj.scoreObject(cmd, role, lst, i);
<a name="1163"></a>        }
<a name="1164"></a>    }
<a name="1165"></a>    
<a name="1166"></a>    /* 
<a name="1167"></a>     *   These methods are provided to allow an IAction to be invoked as an
<a name="1168"></a>     *   implicit action.
<a name="1169"></a>     */
<a name="1170"></a>    execResolvedAction()
<a name="1171"></a>    {
<a name="1172"></a>        /* 
<a name="1173"></a>         *   Capture the output from this action in case we don't want to
<a name="1174"></a>         *   display it (if we're an implicit action).
<a name="1175"></a>         */
<a name="1176"></a>        local str = gOutStream.captureOutput({: execAction(gCommand) });
<a name="1177"></a>        
<a name="1178"></a>        /* 
<a name="1179"></a>         *   If this action is being performed implicitly, we should display an
<a name="1180"></a>         *   implicit action report for it.
<a name="1181"></a>         */
<a name="1182"></a>        if(isImplicit)
<a name="1183"></a>            buildImplicitActionAnnouncement(!actionFailed);
<a name="1184"></a>        
<a name="1185"></a>        /* Otherwise, display the normal output from this action */
<a name="1186"></a>        else
<a name="1187"></a>            say(str);
<a name="1188"></a>    }
<a name="1189"></a>    
<a name="1190"></a>    
<a name="1191"></a>    /* Nothing to do here. */
<a name="1192"></a>    setResolvedObjects([objs]) { }
<a name="1193"></a>    
<a name="1194"></a>    /* 
<a name="1195"></a>     *   An IAction has no resolved objects, so we simply return true to
<a name="1196"></a>     *   indicate that scope is not a problem.
<a name="1197"></a>     */
<a name="1198"></a>    resolvedObjectsInScope()  { return true;  }
<a name="1199"></a>    
<a name="1200"></a>    checkAction() { checkActionPreconditions(); }
<a name="1201"></a>    
<a name="1202"></a>;
<a name="1203"></a>
<a name="1204"></a>/* 
<a name="1205"></a> *   A TravelAction is one that moves (or at least tries to move) the player
<a name="1206"></a> *   character from one place to another via a command like GO NORTH, or EAST.
<a name="1207"></a> */
<a name="1208"></a>class TravelAction: Action
<a name="1209"></a>    
<a name="1210"></a>    baseActionClass = TravelAction
<a name="1211"></a>    
<a name="1212"></a>    /* 
<a name="1213"></a>     *   Use the inherited handling but first make a note of the direction the
<a name="1214"></a>     *   actor wants to travel in.
<a name="1215"></a>     */
<a name="1216"></a>    execCycle(cmd)
<a name="1217"></a>    {
<a name="1218"></a>        /* 
<a name="1219"></a>         *   Obtain the direction from the verbProd of the current command
<a name="1220"></a>         *   object, unless this TravelAction already defines its direction
<a name="1221"></a>         */
<a name="1222"></a>        if(!predefinedDirection)
<a name="1223"></a>           direction = cmd.verbProd.dirMatch.dir; 
<a name="1224"></a>        
<a name="1225"></a>        /* Display a debug message if we're debugging actions. */
<a name="1226"></a>        IfDebug(actions, 
<a name="1227"></a>                    "[Executing &lt;&lt;actionTab.symbolToVal(baseActionClass)&gt;&gt; 
<a name="1228"></a>                    &lt;&lt;direction.name&gt;&gt;]\n" );
<a name="1229"></a>        
<a name="1230"></a>        /* Carry out the inherited handling. */
<a name="1231"></a>        inherited(cmd);
<a name="1232"></a>    }
<a name="1233"></a>    
<a name="1234"></a>    
<a name="1235"></a>    /* 
<a name="1236"></a>     *   Does this TravelAction already define a set direction on its direction
<a name="1237"></a>     *   property (so we don't need to look to what direction object the command
<a name="1238"></a>     *   refers)?
<a name="1239"></a>     */
<a name="1240"></a>    predefinedDirection = nil
<a name="1241"></a>    
<a name="1242"></a>    /* 
<a name="1243"></a>     *   Execute the travel command, first carrying out any implicit actions
<a name="1244"></a>     *   needed to facilitate travel
<a name="1245"></a>     */    
<a name="1246"></a>    
<a name="1247"></a>    execAction(cmd)
<a name="1248"></a>    {           
<a name="1249"></a>        
<a name="1250"></a>        /* 
<a name="1251"></a>         *   If the actor is not directly in the room, treat OUT as a request to get out of the
<a name="1252"></a>         *   immediate container.
<a name="1253"></a>         */             
<a name="1254"></a>        if(outOfNestedInstead)
<a name="1255"></a>            return;
<a name="1256"></a>                
<a name="1257"></a>        /* 
<a name="1258"></a>         *   Note and if necessary display any other implicit action reports that may have been
<a name="1259"></a>         *   generated prior to executing this action.
<a name="1260"></a>         */
<a name="1261"></a>        "&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;";
<a name="1262"></a>        
<a name="1263"></a>        /* Carry out the actual travel. */
<a name="1264"></a>        doTravel();
<a name="1265"></a>        
<a name="1266"></a>        
<a name="1267"></a>    }
<a name="1268"></a>    
<a name="1269"></a>    
<a name="1270"></a>    /* 
<a name="1271"></a>     *   If the actor is not directly in the room, treat OUT as a request to get out of the
<a name="1272"></a>     *   immediate container.
<a name="1273"></a>     */
<a name="1274"></a>    outOfNestedInstead()
<a name="1275"></a>    {
<a name="1276"></a>        
<a name="1277"></a>        if(!gActor.location.ofKind(Room) &amp;&amp; direction == outDir)
<a name="1278"></a>        {
<a name="1279"></a>            /* Set up a local variable to hold the action we'll use to get out. */
<a name="1280"></a>            local getOutAction;
<a name="1281"></a>            
<a name="1282"></a>            /* 
<a name="1283"></a>             *   If the actor is on something, s/he needs to get off it, other s/he needs to get out
<a name="1284"></a>             *   of it.
<a name="1285"></a>             */
<a name="1286"></a>            getOutAction = gActor.location.contType == On ? GetOff : GetOutOf;
<a name="1287"></a>            
<a name="1288"></a>            /* 
<a name="1289"></a>             *   Replace our original action (Out) with the appropriate action for getting out of
<a name="1290"></a>             *   our immediate container.
<a name="1291"></a>             */
<a name="1292"></a>            replaceAction(getOutAction, gActor.location);
<a name="1293"></a>            
<a name="1294"></a>            /* Then return true to say we've handled the command. */
<a name="1295"></a>            return true;
<a name="1296"></a>        }
<a name="1297"></a>        
<a name="1298"></a>        /* Otherwise return nil to tell our caller to carry on with the original command. */
<a name="1299"></a>        return nil;
<a name="1300"></a>    }
<a name="1301"></a>    
<a name="1302"></a>    /* 
<a name="1303"></a>     *   If the actor is not directly in the room, make him/her get out of his immediate
<a name="1304"></a>     *   container(s) before attempting travel, unless the actor is in a vehicle.
<a name="1305"></a>     */  
<a name="1306"></a>    
<a name="1307"></a>    getOutOfNested(conn)
<a name="1308"></a>    {       
<a name="1309"></a>        local stagLocs = valToList(conn.stagingLocations);
<a name="1310"></a>        
<a name="1311"></a>        if(stagLocs.length == 0)
<a name="1312"></a>            stagLocs = [Room];
<a name="1313"></a>            
<a name="1314"></a> 
<a name="1315"></a>        while(!gActor.location.ofKind(Room) &amp;&amp; 
<a name="1316"></a>              stagLocs.indexWhich({x: gActor.location.ofKind(x)}) == nil)
<a name="1317"></a>        {
<a name="1318"></a>            /* Note the actor's current location. */
<a name="1319"></a>            local loc = gActor.location;
<a name="1320"></a>            
<a name="1321"></a>            /* 
<a name="1322"></a>             *   The action needed to remove the actor from its immediate
<a name="1323"></a>             *   container.
<a name="1324"></a>             */
<a name="1325"></a>            local getOutAction = loc.contType == On ? GetOff : GetOutOf;
<a name="1326"></a>            
<a name="1327"></a>            /* 
<a name="1328"></a>             *   Try to get the actor out of his/her current location with an
<a name="1329"></a>             *   implicit action.
<a name="1330"></a>             */
<a name="1331"></a>            tryImplicitAction(getOutAction, loc);
<a name="1332"></a>            
<a name="1333"></a>            /* Note and if necessary display the implicit action report. */
<a name="1334"></a>            "&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;";
<a name="1335"></a>            
<a name="1336"></a>            
<a name="1337"></a>            /*
<a name="1338"></a>             *   if the command didn't work, quit the loop or we'll be stuck in
<a name="1339"></a>             *   it forever.
<a name="1340"></a>             */
<a name="1341"></a>            if(gActor.location == loc)
<a name="1342"></a>                exit;
<a name="1343"></a>            
<a name="1344"></a>        }
<a name="1345"></a>    }
<a name="1346"></a>        
<a name="1347"></a>        /* 
<a name="1348"></a>     *   These methods are provided to allow an IAction to be invoked as an
<a name="1349"></a>     *   implicit action.
<a name="1350"></a>     */
<a name="1351"></a>    execResolvedAction()
<a name="1352"></a>    {
<a name="1353"></a>        /* 
<a name="1354"></a>         *   Capture the output from this action in case we don't want to
<a name="1355"></a>         *   display it (if we're an implicit action).
<a name="1356"></a>         */
<a name="1357"></a>        local str = gOutStream.captureOutput({: execAction(gCommand) });
<a name="1358"></a>        
<a name="1359"></a>        /* 
<a name="1360"></a>         *   If this action is being performed implicitly, we should display an
<a name="1361"></a>         *   implicit action report for it.
<a name="1362"></a>         */
<a name="1363"></a>        if(isImplicit)
<a name="1364"></a>            buildImplicitActionAnnouncement(!actionFailed);
<a name="1365"></a>        
<a name="1366"></a>        /* Otherwise, display the normal output from this action */
<a name="1367"></a>        else
<a name="1368"></a>            say(str);
<a name="1369"></a>    }
<a name="1370"></a>        
<a name="1371"></a>       
<a name="1372"></a>    
<a name="1373"></a>    /* 
<a name="1374"></a>     *   Carry out travel in direction. For this purpose we first have to define
<a name="1375"></a>     *   what the corresponding direction property of the actor's current
<a name="1376"></a>     *   location refers to. If it's nil, no travel is possible, and we simply
<a name="1377"></a>     *   display a refusal message. If it's an object we execute its travelVia()
<a name="1378"></a>     *   method for the current actor. If it's a double-quoted string or a
<a name="1379"></a>     *   method we execute it and make a note of where the actor ends up, if the
<a name="1380"></a>     *   actor is the player character. If it's a single-quoted string we
<a name="1381"></a>     *   display it.
<a name="1382"></a>     *
<a name="1383"></a>     *   Note that we only display the various messages announcing failure of
<a name="1384"></a>     *   travel if the actor is the player character. We presumably don't want
<a name="1385"></a>     *   to see these messages as the result of NPCs trying to move around the
<a name="1386"></a>     *   map.
<a name="1387"></a>     */    
<a name="1388"></a>    doTravel()
<a name="1389"></a>    {
<a name="1390"></a>        /* Note the actor's current location. */
<a name="1391"></a>        local loc = gActor.getOutermostRoom;  
<a name="1392"></a>        
<a name="1393"></a>        /*   
<a name="1394"></a>         *   If we point to an object, assume it's a travel connector and attempt travel via the
<a name="1395"></a>         *   connector.
<a name="1396"></a>         */
<a name="1397"></a>        if(loc.propType(direction.dirProp) == TypeObject)        
<a name="1398"></a>            doTravelViaConn(loc);      
<a name="1399"></a>        
<a name="1400"></a>        /*  
<a name="1401"></a>         *   Otherwise, our direction of travel is trying to take us towards nil, a string, or a
<a name="1402"></a>         *   method, in which case call the nonTravel() function to handle it.
<a name="1403"></a>         */
<a name="1404"></a>        else
<a name="1405"></a>            nonTravel(loc, direction);
<a name="1406"></a>    }
<a name="1407"></a>    
<a name="1408"></a>    doTravelViaConn(loc)
<a name="1409"></a>    {        
<a name="1410"></a>        /* 
<a name="1411"></a>         *   Note whether the current location is illuminated, or whether it permits travel in the
<a name="1412"></a>         *   dark (in which case we treat it as illuminated for the purposes of allowing travel).
<a name="1413"></a>         */
<a name="1414"></a>        local illum = loc.allowDarkTravel || loc.isIlluminated;
<a name="1415"></a>        
<a name="1416"></a>        /* Note our connector */
<a name="1417"></a>        local conn = loc.(direction.dirProp);
<a name="1418"></a>        
<a name="1419"></a>        /* 
<a name="1420"></a>         *   If the connector is visible to the actor then attempt travel via the connector.
<a name="1421"></a>         */
<a name="1422"></a>        if(conn.isConnectorVisible)                        
<a name="1423"></a>            doVisibleTravel(conn);            
<a name="1424"></a>        
<a name="1425"></a>        /* 
<a name="1426"></a>         *   Otherwise if there's light enough to travel and the actor is the player character,
<a name="1427"></a>         *   display the standard can't travel message (as if the connector wasn't there.
<a name="1428"></a>         */
<a name="1429"></a>        else if(illum &amp;&amp; gActor == gPlayerChar)
<a name="1430"></a>            loc.cannotGoThatWay(direction);
<a name="1431"></a>        
<a name="1432"></a>        /* 
<a name="1433"></a>         *   Otherwise if the actor is the player character, display the standard message forbidding
<a name="1434"></a>         *   travel in the dark.
<a name="1435"></a>         */
<a name="1436"></a>        else if(gActor == gPlayerChar)
<a name="1437"></a>            loc.cannotGoThatWayInDark(direction);
<a name="1438"></a>    }
<a name="1439"></a>    
<a name="1440"></a>    doVisibleTravel(conn)
<a name="1441"></a>    {
<a name="1442"></a>        /* Get the actor out of any nested room they shouldn't be in. */
<a name="1443"></a>        getOutOfNested(conn);
<a name="1444"></a>        
<a name="1445"></a>       
<a name="1446"></a>                
<a name="1447"></a>        /* if the actor is the player char, just carry out the travel */
<a name="1448"></a>        if(gActor == gPlayerChar)                 
<a name="1449"></a>            conn.travelVia(gActor);        
<a name="1450"></a>        
<a name="1451"></a>        /* 
<a name="1452"></a>         *   otherwise carry out the travel and display the appropriate travel notifications.
<a name="1453"></a>         */
<a name="1454"></a>        else
<a name="1455"></a>            gActor.travelVia(conn);
<a name="1456"></a>    }       
<a name="1457"></a>    
<a name="1458"></a>    
<a name="1459"></a>    
<a name="1460"></a>    /* 
<a name="1461"></a>     *   The direction the actor wants to travel in. This is placed here by the
<a name="1462"></a>     *   execCycle method and takes the form of A Direction object, e.g.
<a name="1463"></a>     *   northDir.
<a name="1464"></a>     */
<a name="1465"></a>    direction = nil
<a name="1466"></a>    
<a name="1467"></a>    /* It's generally possible to undo a travel command. */
<a name="1468"></a>    canUndo = true
<a name="1469"></a>    
<a name="1470"></a>    checkActionPreconditions() 
<a name="1471"></a>    {
<a name="1472"></a>         /* Note the actor's current location. */
<a name="1473"></a>        local loc = gActor.getOutermostRoom;  
<a name="1474"></a>        
<a name="1475"></a>        /*   
<a name="1476"></a>         *   If we point to an object, assume it's a travel connector and attempt travel via the
<a name="1477"></a>         *   connector.
<a name="1478"></a>         */
<a name="1479"></a>        if(loc.propType(direction.dirProp) == TypeObject)        
<a name="1480"></a>        {
<a name="1481"></a>            local conn = loc.(direction.dirProp);
<a name="1482"></a>            getOutOfNested(conn);                
<a name="1483"></a>        }
<a name="1484"></a>        
<a name="1485"></a>        return inherited(); 
<a name="1486"></a>    }
<a name="1487"></a>    
<a name="1488"></a>    /* 
<a name="1489"></a>     *   A chance to do something else with the return value of a method, triggered by travel,
<a name="1490"></a>     *   defined on a direction property of a Room. loc is the room in question (where the travel
<a name="1491"></a>     *   started from), dir is the directiion of travel, dest is the destination of the travel, val
<a name="1492"></a>     *   is the return value from the method, and actor is the actor involved in the travel. By
<a name="1493"></a>     *   default we do nothing here but game code can override.
<a name="1494"></a>     */
<a name="1495"></a>    noteRetval(loc, dir, dest, val, actor)
<a name="1496"></a>    {
<a name="1497"></a>    }
<a name="1498"></a>    
<a name="1499"></a>    /* 
<a name="1500"></a>     *   Flag, do we want to display any single-quoted string returned by the travel method defined
<a name="1501"></a>     *   on the direction property corresponding to the dir direction on the room loc. dest is the
<a name="1502"></a>     *   direction of travel, val is the return value, and actor is the actor involved in the
<a name="1503"></a>     *   travel. By default we do.     
<a name="1504"></a>     */
<a name="1505"></a>    displayStrRet(loc, dir, dest, val, actor)
<a name="1506"></a>    {
<a name="1507"></a>        return actor == gPlayerChar;
<a name="1508"></a>    }
<a name="1509"></a>
<a name="1510"></a>;
<a name="1511"></a>
<a name="1512"></a>
<a name="1513"></a>
<a name="1514"></a>/* 
<a name="1515"></a> *   This function can be called from a check nethod to prevent the display of text from within the
<a name="1516"></a> *   check method halting the action. Calling it from anywhere else will have no effect. It's use is
<a name="1517"></a> *   in conjunction with the TAction class defined immediatelty below.
<a name="1518"></a> */
<a name="1519"></a>noHalt()
<a name="1520"></a>{
<a name="1521"></a>    /* 
<a name="1522"></a>     *   If we have a current gAction, set its haltOnMessageCheck property to nil. Note that this
<a name="1523"></a>     *   property is set to true near the start of TAction.check() so that it starts out true and
<a name="1524"></a>     *   remains so unless noHalt() intervenes during the course of the check() stage.
<a name="1525"></a>     */
<a name="1526"></a>    if(gAction)
<a name="1527"></a>        gAction.haltOnMessageInCheck = nil;
<a name="1528"></a>}
<a name="1529"></a>
<a name="1530"></a>
<a name="1531"></a>/* 
<a name="1532"></a> *   A TAction is an action that applies to a single direct object. Other action
<a name="1533"></a> *   classes that apply to more than one object, such as TIAction, inherit from
<a name="1534"></a> *   this class so some of the code needs to take that into account.
<a name="1535"></a> */
<a name="1536"></a>class TAction: Action    
<a name="1537"></a>   
<a name="1538"></a>    /* 
<a name="1539"></a>     *   A list of the direct objects of this action that make it to the report
<a name="1540"></a>     *   stage.
<a name="1541"></a>     */
<a name="1542"></a>    reportList = []
<a name="1543"></a>    
<a name="1544"></a>    /* 
<a name="1545"></a>     *   A list of the direct objects of this action that make it to the action
<a name="1546"></a>     *   stage.
<a name="1547"></a>     */
<a name="1548"></a>    actionList = []
<a name="1549"></a>    
<a name="1550"></a>    /* 
<a name="1551"></a>     *   A LookupTable containing the verify results for this action. This is
<a name="1552"></a>     *   keyes on the object being verified, with the value being the worst
<a name="1553"></a>     *   verify result encountered for that object so far.
<a name="1554"></a>     */
<a name="1555"></a>    verifyTab = nil
<a name="1556"></a>        
<a name="1557"></a>    
<a name="1558"></a>    /*   
<a name="1559"></a>     *   Store the last verify failure message so that if we get several
<a name="1560"></a>     *   identical ones in a row, we don't keep repeating them
<a name="1561"></a>     */
<a name="1562"></a>    lastVerifyMsg = nil
<a name="1563"></a>    
<a name="1564"></a>    /* 
<a name="1565"></a>     *   set this property to true if you want to announce the object before the
<a name="1566"></a>     *   action result when there's more than one object. If the action routine
<a name="1567"></a>     *   summarizes the result at the end you don't want to do this so you
<a name="1568"></a>     *   should then set this to nil.
<a name="1569"></a>     */
<a name="1570"></a>    announceMultiAction = nil
<a name="1571"></a>    
<a name="1572"></a>    /* The current direct object of this action */    
<a name="1573"></a>    curDobj = nil
<a name="1574"></a>   
<a name="1575"></a>    
<a name="1576"></a>    /* 
<a name="1577"></a>     *   The current object being processed (in a TAction, always the curDObj;
<a name="1578"></a>     *   in a TI Action either the curDobj or the curIOoj).
<a name="1579"></a>     */
<a name="1580"></a>    curObj = nil
<a name="1581"></a>    
<a name="1582"></a>    /* 
<a name="1583"></a>     *   Reset values to their starting state when an action is used to execute
<a name="1584"></a>     *   a new command.
<a name="1585"></a>     */    
<a name="1586"></a>    reset()
<a name="1587"></a>    {
<a name="1588"></a>        scopeList = [];
<a name="1589"></a>        reportList = [];
<a name="1590"></a>        actionList = [];
<a name="1591"></a>        verifyTab = nil;
<a name="1592"></a>        isImplicit = nil;
<a name="1593"></a>        curDobj = nil;
<a name="1594"></a>        curObj = nil;
<a name="1595"></a>        lastVerifyMsg = nil;
<a name="1596"></a>        redirectParent = nil;        
<a name="1597"></a>    }
<a name="1598"></a>       
<a name="1599"></a>    
<a name="1600"></a>    /* 
<a name="1601"></a>     *   Information to allow the DEBUG ACTIONS command to express a complete
<a name="1602"></a>     *   topic phrase
<a name="1603"></a>     */
<a name="1604"></a>    #ifdef __DEBUG
<a name="1605"></a>    dqinfo = ''
<a name="1606"></a>    iqinfo = ''
<a name="1607"></a>    aqinfo = ''
<a name="1608"></a>    #endif
<a name="1609"></a>    
<a name="1610"></a>    /* 
<a name="1611"></a>     *   Execute the command cycle for this action. This differs from the base
<a name="1612"></a>     *   Action class in not calling beforeAction directly, since the
<a name="1613"></a>     *   beforeAction() notifications occur within the execResolvedAction
<a name="1614"></a>     *   method.
<a name="1615"></a>     */    
<a name="1616"></a>    execCycle(cmd)
<a name="1617"></a>    {
<a name="1618"></a>        /* If we're debugging actions, display some debugging information. */
<a name="1619"></a>        IfDebug(actions, 
<a name="1620"></a>                "[Executing &lt;&lt;actionTab.symbolToVal(baseActionClass)&gt;&gt; :
<a name="1621"></a>                    &lt;&lt;dqinfo&gt;&gt; &lt;&lt;cmd.dobj.name&gt;&gt; &lt;&lt;if cmd.iobj != nil&gt;&gt;
<a name="1622"></a>                    : &lt;i&gt;&lt;&lt;iqinfo&gt;&gt;&lt;/i&gt; &lt;&lt;cmd.iobj.name&gt;&gt; &lt;&lt;end&gt;&gt;
<a name="1623"></a>                &lt;&lt;if cmd.acc != nil&gt;&gt;
<a name="1624"></a>                    : &lt;i&gt;&lt;&lt;aqinfo&gt;&gt;&lt;/i&gt; &lt;&lt;cmd.acc.name&gt;&gt; &lt;&lt;end&gt;&gt;]\n" );
<a name="1625"></a>        
<a name="1626"></a>        /* 
<a name="1627"></a>         *   Disallow ALL (e.g. EXAMINE ALL) if the action does not permit it.
<a name="1628"></a>         *   Since we don't want to block plural matches (for which
<a name="1629"></a>         *   cmd.matchedAll is also true) we all test for the presence of 'all'
<a name="1630"></a>         *   among the command tokens.
<a name="1631"></a>         */        
<a name="1632"></a>        if(cmd.matchedAll &amp;&amp; !(allowAll || parentAllowAll) )
<a name="1633"></a>        {
<a name="1634"></a>            DMsg(all not allowed, 'Sorry; ALL is not allowed with this command.
<a name="1635"></a>                ');
<a name="1636"></a>            abort;
<a name="1637"></a>        }
<a name="1638"></a>        
<a name="1639"></a>        try
<a name="1640"></a>        {   
<a name="1641"></a>            /* Execute the action. */
<a name="1642"></a>            execAction(cmd);
<a name="1643"></a>            
<a name="1644"></a>            /* 
<a name="1645"></a>             *   If we're a repeatable action, note that we were the last action
<a name="1646"></a>             *   performed (for use with an AGAIN command).
<a name="1647"></a>             */
<a name="1648"></a>            if(isRepeatable)
<a name="1649"></a>                libGlobal.lastAction = self.createClone();
<a name="1650"></a>          
<a name="1651"></a>        }
<a name="1652"></a>                
<a name="1653"></a>        catch(ExitSignal ex)
<a name="1654"></a>        {
<a name="1655"></a>            actionFailed = true;
<a name="1656"></a>        }
<a name="1657"></a>        
<a name="1658"></a>    }
<a name="1659"></a>    
<a name="1660"></a>    /* Execute this action */    
<a name="1661"></a>    execAction(cmd)
<a name="1662"></a>    {
<a name="1663"></a>        /* 
<a name="1664"></a>         *   Note the current direct object, which should be the direct object
<a name="1665"></a>         *   supplied by the current Command object.
<a name="1666"></a>         */        
<a name="1667"></a>        curDobj = cmd.dobj;
<a name="1668"></a>        
<a name="1669"></a>        /* 
<a name="1670"></a>         *   Note the current direct object as a possible antecedent for
<a name="1671"></a>         *   pronouns.
<a name="1672"></a>         */
<a name="1673"></a>        notePronounAntecedent(curDobj);
<a name="1674"></a>        
<a name="1675"></a>        /* Execute the action with the current direct object. */
<a name="1676"></a>        execResolvedAction();
<a name="1677"></a>    }    
<a name="1678"></a> 
<a name="1679"></a>    
<a name="1680"></a>    /* 
<a name="1681"></a>     *   Execute this action with a known direct object or objects. Call this
<a name="1682"></a>     *   method when there's no need to resolve the objects used in the command
<a name="1683"></a>     *   but we still want it to pass through every stage
<a name="1684"></a>     */    
<a name="1685"></a>    execResolvedAction()
<a name="1686"></a>    {
<a name="1687"></a>               
<a name="1688"></a>        /* Create a new LookupTable for our verify results. */
<a name="1689"></a>        verifyTab = new LookupTable;
<a name="1690"></a>        
<a name="1691"></a>        /* 
<a name="1692"></a>         *   We shouldn't really need to catch any signals here, but the author
<a name="1693"></a>         *   might put an exitAction macro in a check method, say, so we need to
<a name="1694"></a>         *   be able to handle it.
<a name="1695"></a>         */
<a name="1696"></a>        try
<a name="1697"></a>        {
<a name="1698"></a>            /* 
<a name="1699"></a>             *   Obtain the verify result for the current direct object. Note at
<a name="1700"></a>             *   this point the objects have already been resolved so we're only
<a name="1701"></a>             *   interested in whether the verify command is going to allow the
<a name="1702"></a>             *   action to go ahead. If it doesn't allow the action return nil
<a name="1703"></a>             *   to stop it here.
<a name="1704"></a>             */            
<a name="1705"></a>            if(!verifyObjRole(curDobj, DirectObject))
<a name="1706"></a>               return nil; 
<a name="1707"></a>               
<a name="1708"></a>            
<a name="1709"></a>            /* 
<a name="1710"></a>             *   If gameMain defines the option to run the before notifications
<a name="1711"></a>             *   before the check stage, run the before notifications now.
<a name="1712"></a>             */            
<a name="1713"></a>            if(gameMain.beforeRunsBeforeCheck)
<a name="1714"></a>                beforeAction();
<a name="1715"></a>            
<a name="1716"></a>            /* 
<a name="1717"></a>             *   Try the check stage. If the action fails the check stage, stop
<a name="1718"></a>             *   the action here and return nil to tell our caller this action
<a name="1719"></a>             *   has failed.
<a name="1720"></a>             */            
<a name="1721"></a>            if(!checkAction(cmd))
<a name="1722"></a>                return nil;            
<a name="1723"></a>            
<a name="1724"></a>            /* 
<a name="1725"></a>             *   If gameMain defines the option to run the before notifications
<a name="1726"></a>             *   after the check stage, run the before notifications now.
<a name="1727"></a>             */
<a name="1728"></a>            if(!gameMain.beforeRunsBeforeCheck)
<a name="1729"></a>                beforeAction();
<a name="1730"></a>            
<a name="1731"></a>            /* Carry out the action on a single direct object. */
<a name="1732"></a>            doActionOnce();
<a name="1733"></a> 
<a name="1734"></a>            /* Return true to tell our caller the action succeeded. */
<a name="1735"></a>            return true;
<a name="1736"></a>                
<a name="1737"></a>        }
<a name="1738"></a>        catch (ExitActionSignal ex)
<a name="1739"></a>        {                
<a name="1740"></a>            return nil;
<a name="1741"></a>        }         
<a name="1742"></a>        
<a name="1743"></a>    }
<a name="1744"></a>    
<a name="1745"></a>    /* 
<a name="1746"></a>     *   Flag: do we want the object name to appear before a check stage failure
<a name="1747"></a>     *   message if multiple objects are involved in the action. By default we
<a name="1748"></a>     *   do, otherwise it might not be clear which object the message referes
<a name="1749"></a>     *   to.
<a name="1750"></a>     */        
<a name="1751"></a>    announceMultiCheck = true
<a name="1752"></a>    
<a name="1753"></a>       
<a name="1754"></a>    
<a name="1755"></a>    /* 
<a name="1756"></a>     *   Run the check phase of the action, both on the direct object and on any
<a name="1757"></a>     *   preconditions.
<a name="1758"></a>     */   
<a name="1759"></a>    checkAction(cmd)
<a name="1760"></a>    {
<a name="1761"></a>        /* 
<a name="1762"></a>         *   Try the check phase of any preconditions. If that fails return nil
<a name="1763"></a>         *   to indicate failure of the entire check stage.
<a name="1764"></a>         */        
<a name="1765"></a>        if(!checkPreCond(curDobj, preCondDobjProp))
<a name="1766"></a>        {                       
<a name="1767"></a>            return nil;
<a name="1768"></a>        }
<a name="1769"></a>        
<a name="1770"></a>        /* 
<a name="1771"></a>         *   Then try the check method on the current direct object and return
<a name="1772"></a>         *   the result.
<a name="1773"></a>         */                                     
<a name="1774"></a>        return check(curDobj, checkDobjProp);
<a name="1775"></a>    }
<a name="1776"></a>    
<a name="1777"></a>     
<a name="1778"></a>    /* 
<a name="1779"></a>     *   This flag is used internally by the library to track whether the output of any text from a
<a name="1780"></a>     *   check() should stop the action, which it normally should. Game code should not directly
<a name="1781"></a>     *   override this property or change its value, other than indrectly via the noHalt() function.
<a name="1782"></a>     */         
<a name="1783"></a>    haltOnMessageInCheck = true
<a name="1784"></a>    
<a name="1785"></a>    /* 
<a name="1786"></a>     *   Call the check method (checkProp) on the appropriate object (obj).
<a name="1787"></a>     *   Return true to indicate that the action succeeds or nil otherwise
<a name="1788"></a>     */
<a name="1789"></a>    check(obj, checkProp)
<a name="1790"></a>    {
<a name="1791"></a>        local checkMsg = nil;
<a name="1792"></a>        
<a name="1793"></a>        /* Note which object is the current object of the command. */
<a name="1794"></a>        curObj = (dataType(obj) == TypeList ? obj[1] : obj);
<a name="1795"></a>        
<a name="1796"></a>        /* Run the check method on the object and capture its output */
<a name="1797"></a>        try
<a name="1798"></a>        {
<a name="1799"></a>            /* Set this flag to true - the check routine may set it to nil. */
<a name="1800"></a>            haltOnMessageInCheck = true;
<a name="1801"></a>            
<a name="1802"></a>            /* 
<a name="1803"></a>             *   If the obj Parameter has been passed as a list [dobj, iobj] we want to use a
<a name="1804"></a>             *   multimethod to  do the checking.
<a name="1805"></a>             */
<a name="1806"></a>            if(dataType(obj) == TypeList)
<a name="1807"></a>                checkMsg = gOutStream.captureOutputIgnoreExit({: self.(checkProp)(obj[1], obj[2])});
<a name="1808"></a>            
<a name="1809"></a>            else
<a name="1810"></a>                checkMsg = gOutStream.captureOutputIgnoreExit({: obj.(checkProp)});
<a name="1811"></a>            
<a name="1812"></a>            if(dataType(checkMsg) == TypeInt)
<a name="1813"></a>                return checkMsg;
<a name="1814"></a>        }
<a name="1815"></a>            
<a name="1816"></a>        
<a name="1817"></a>        /* 
<a name="1818"></a>         *   Game authors aren't meant to use the exit macro in check methods,
<a name="1819"></a>         *   but in case they do we handle it here.
<a name="1820"></a>         */
<a name="1821"></a>        catch (ExitSignal ex)
<a name="1822"></a>        {
<a name="1823"></a>            /* 
<a name="1824"></a>             *   If for some reason a check method uses exit without displaying
<a name="1825"></a>             *   a method, we supply a dummy failure message at this point.
<a name="1826"></a>             */
<a name="1827"></a>            if(checkMsg is in (nil, ''))
<a name="1828"></a>               checkMsg = failCheckMsg;
<a name="1829"></a>        }
<a name="1830"></a>        
<a name="1831"></a>        catch (SkipSignal ex)
<a name="1832"></a>        {
<a name="1833"></a>            /* 
<a name="1834"></a>             *   If for some reason a check method uses skip without displaying
<a name="1835"></a>             *   a method, we supply a dummy failure message at this point.
<a name="1836"></a>             */
<a name="1837"></a>            if(checkMsg is in (nil, ''))
<a name="1838"></a>               checkMsg = failCheckMsg;
<a name="1839"></a>        }
<a name="1840"></a>               
<a name="1841"></a>        /* 
<a name="1842"></a>         *   If the check method tried to display something then it wants to
<a name="1843"></a>         *   block the action, so we display the failure message and stop the
<a name="1844"></a>         *   action.
<a name="1845"></a>         */
<a name="1846"></a>        if(checkMsg not in (nil, ''))
<a name="1847"></a>        {           
<a name="1848"></a>            /* 
<a name="1849"></a>             *   If we passed obj as a list for use with a multi-method, replace it with the first
<a name="1850"></a>             *   elemeent in the list in case we need to call announceObj(obj).
<a name="1851"></a>             */
<a name="1852"></a>            if(dataType(obj) == TypeList)
<a name="1853"></a>                obj = obj[1];
<a name="1854"></a>            
<a name="1855"></a>            /* 
<a name="1856"></a>             *   If this action wants to announce the object of the action when it fails at the
<a name="1857"></a>             *   check stage and our Command is processing more than one direct object, and we don't
<a name="1858"></a>             *   want to report failed attempts after successful ones, announce the object.
<a name="1859"></a>             */ 
<a name="1860"></a>            if(announceMultiCheck &amp;&amp; gCommand.dobjs.length &gt; 1 &amp;&amp; !reportFailureAfterSuccess)
<a name="1861"></a>                announceObject(obj);
<a name="1862"></a>            
<a name="1863"></a>            /* 
<a name="1864"></a>             *   If we're an implicit action then add a failure message to our
<a name="1865"></a>             *   implicit action list and display the list ("first trying
<a name="1866"></a>             *   to...")
<a name="1867"></a>             */
<a name="1868"></a>            if(isImplicit)
<a name="1869"></a>                "&lt;&lt;buildImplicitActionAnnouncement(nil)&gt;&gt;";
<a name="1870"></a>            else if(haltOnMessageInCheck)
<a name="1871"></a>                /* first flush any pending implicit action reports */ 
<a name="1872"></a>                "&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;";
<a name="1873"></a>            
<a name="1874"></a>            /* 
<a name="1875"></a>             *   Display our failure message. If this command is processing more than one direct
<a name="1876"></a>             *   object, and we want to report failed attempts after successrul ones, use
<a name="1877"></a>             *   reportAfter() so that the failure reports come after the report of any actions that
<a name="1878"></a>             *   were successful, otherwise display the failure message straight away.
<a name="1879"></a>             */
<a name="1880"></a>            if(gCommand.dobjs.length &gt; 1 &amp;&amp; reportFailureAfterSuccess)
<a name="1881"></a>            {
<a name="1882"></a>                if(announceMultiCheck)
<a name="1883"></a>                    checkMsg = gOutStream.captureOutputIgnoreExit({: announceObject(obj)}) + 
<a name="1884"></a>                    checkMsg;
<a name="1885"></a>                
<a name="1886"></a>                reportAfter(checkMsg);
<a name="1887"></a>            }
<a name="1888"></a>            else
<a name="1889"></a>            {   
<a name="1890"></a>                say(checkMsg);
<a name="1891"></a>                "\n";
<a name="1892"></a>            }
<a name="1893"></a>            
<a name="1894"></a>            /* 
<a name="1895"></a>             *   Note the outcome of the action -- it failed unless haltOnMesageInCheck was set to
<a name="1896"></a>             *   nil.
<a name="1897"></a>             */
<a name="1898"></a>            actionFailed = haltOnMessageInCheck;
<a name="1899"></a>            
<a name="1900"></a>            /* 
<a name="1901"></a>             *   Return the opposite of haltOnMessageInCheck to tell our caller whether this action
<a name="1902"></a>             *   failed the check stage
<a name="1903"></a>             */
<a name="1904"></a>            return !haltOnMessageInCheck;
<a name="1905"></a>        }
<a name="1906"></a>        /* 
<a name="1907"></a>         *   Return true to tell our our caller this action passed the check
<a name="1908"></a>         *   stage on this object.
<a name="1909"></a>         */
<a name="1910"></a>        return true;
<a name="1911"></a>    }
<a name="1912"></a>    
<a name="1913"></a>    
<a name="1914"></a>    
<a name="1915"></a>    /* 
<a name="1916"></a>     *   Flag: when a command processes multiple direct objects, do we want any failed attempts to
<a name="1917"></a>     *   be reported after successful ones?
<a name="1918"></a>     */
<a name="1919"></a>    reportFailureAfterSuccess = nil
<a name="1920"></a>    
<a name="1921"></a>    /* Run the check stage on the preCondProp of obj */    
<a name="1922"></a>    checkPreCond(obj, preCondProp)
<a name="1923"></a>    {
<a name="1924"></a>        local preCondList;
<a name="1925"></a>        local checkOkay = true;
<a name="1926"></a>        
<a name="1927"></a>        /* Note which object we're checking */
<a name="1928"></a>        curObj = obj;
<a name="1929"></a>        
<a name="1930"></a>        /* 
<a name="1931"></a>         *   Construct a list or preCondition objects on the appropriate object
<a name="1932"></a>         *   property.
<a name="1933"></a>         */
<a name="1934"></a>        preCondList = valToList(obj.(preCondProp));
<a name="1935"></a>        
<a name="1936"></a>        /* Sort the list in preCondOrder */
<a name="1937"></a>        preCondList = preCondList.sort(nil,
<a name="1938"></a>                                       {a, b: a.preCondOrder - b.preCondOrder});
<a name="1939"></a>        
<a name="1940"></a>        try
<a name="1941"></a>        {
<a name="1942"></a>            /* Iterate through the list to see if all the checks are satisfied */
<a name="1943"></a>            foreach(local cur in preCondList)              
<a name="1944"></a>            {          
<a name="1945"></a>                /* 
<a name="1946"></a>                 *   If we fail the check method on any precondition object,
<a name="1947"></a>                 *   note the failure and stop the iteration.
<a name="1948"></a>                 */
<a name="1949"></a>                if(cur.checkPreCondition(obj, true) == nil)
<a name="1950"></a>                {
<a name="1951"></a>                    checkOkay = nil;
<a name="1952"></a>                    break;
<a name="1953"></a>                }                
<a name="1954"></a>            }
<a name="1955"></a>        }
<a name="1956"></a>        /* 
<a name="1957"></a>         *   Game authors aren't meant to use the exit macro in check methods,
<a name="1958"></a>         *   but in case they do we handle it here.
<a name="1959"></a>         */
<a name="1960"></a>        catch (ExitSignal ex)
<a name="1961"></a>        {
<a name="1962"></a>            checkOkay = nil;
<a name="1963"></a>        }
<a name="1964"></a>        
<a name="1965"></a>        /* 
<a name="1966"></a>         *   If the check method failed on any of our precondition objects note
<a name="1967"></a>         *   that the action is a failure.
<a name="1968"></a>         */
<a name="1969"></a>        if(checkOkay == nil)
<a name="1970"></a>            actionFailed = true;
<a name="1971"></a>        
<a name="1972"></a>        /* Return our overall check result. */
<a name="1973"></a>        return checkOkay;
<a name="1974"></a>    }
<a name="1975"></a>    
<a name="1976"></a>    /* Carry out the action phase on the direct object */
<a name="1977"></a>    doActionOnce()
<a name="1978"></a>    {
<a name="1979"></a>        local msg;
<a name="1980"></a>        
<a name="1981"></a>        /* 
<a name="1982"></a>         *   If we're iterating over several objects and we're the kind of
<a name="1983"></a>         *   action which wants to announce objects in this context, do so.
<a name="1984"></a>         */        
<a name="1985"></a>         if(announceMultiAction &amp;&amp; gCommand.dobjs.length &gt; 1)
<a name="1986"></a>            announceObject(curDobj);       
<a name="1987"></a>            
<a name="1988"></a>        
<a name="1989"></a>        /* Note that the current object is the direct object */
<a name="1990"></a>        curObj = curDobj;
<a name="1991"></a>        
<a name="1992"></a>        /* 
<a name="1993"></a>         *   If this is an implicit action, add an implicit action report describing it to the
<a name="1994"></a>         *   pending implicit action reports for this comand.S
<a name="1995"></a>         */        
<a name="1996"></a>        if(isImplicit)
<a name="1997"></a>            buildImplicitActionAnnouncement(true, nil);
<a name="1998"></a>
<a name="1999"></a>        
<a name="2000"></a>        /* 
<a name="2001"></a>         *   If the action method displays anything then we don't add this
<a name="2002"></a>         *   object to the list of objects to be reported on at the report
<a name="2003"></a>         *   stage, on the assumption that the action stage has either produced
<a name="2004"></a>         *   its own report for this object or reported on the failure of the
<a name="2005"></a>         *   action. If, however, the action is carried out silently then we'll
<a name="2006"></a>         *   add this object to the list of objects to be reported on at the
<a name="2007"></a>         *   report stage.
<a name="2008"></a>         *
<a name="2009"></a>         *   NOTE TO SELF: Don't try making this work with captureOutput(); it
<a name="2010"></a>         *   creates far more hassle than it's worth!!!!
<a name="2011"></a>         */            
<a name="2012"></a>            
<a name="2013"></a>        msg = gOutStream.watchForOutput({: doAction() });
<a name="2014"></a>        
<a name="2015"></a>        
<a name="2016"></a>        /* 
<a name="2017"></a>         *   If there's no output from the action method, add this object to the
<a name="2018"></a>         *   list of objects to be reported on at the report stage.
<a name="2019"></a>         */
<a name="2020"></a>        if(!(msg)) 
<a name="2021"></a>        {
<a name="2022"></a>            reportList += curDobj;                  
<a name="2023"></a>        }
<a name="2024"></a>       
<a name="2025"></a>        
<a name="2026"></a>        /* Note that we've carried out the action on this object. */
<a name="2027"></a>        actionList += curDobj;
<a name="2028"></a>        
<a name="2029"></a>        /* 
<a name="2030"></a>         *   Return true to tell our caller we succesfully completed the action.
<a name="2031"></a>         */
<a name="2032"></a>        return true;
<a name="2033"></a>    }
<a name="2034"></a>    
<a name="2035"></a>    doAction() 
<a name="2036"></a>    {
<a name="2037"></a>        try
<a name="2038"></a>        {
<a name="2039"></a>           curDobj.(actionDobjProp); 
<a name="2040"></a>        }
<a name="2041"></a>        catch(ExitActionSignal ex)
<a name="2042"></a>        {
<a name="2043"></a>//            actionFailed = true;
<a name="2044"></a>        }
<a name="2045"></a>    }
<a name="2046"></a>    
<a name="2047"></a>    
<a name="2048"></a>    /* 
<a name="2049"></a>     *   Flag, do we want to announce the object name before the verify message
<a name="2050"></a>     *   in cases where there's more direct object in the command? By default we
<a name="2051"></a>     *   don't since verify messages generally make it clear enough which
<a name="2052"></a>     *   objects they refer to.
<a name="2053"></a>     */
<a name="2054"></a>    announceMultiVerify = nil
<a name="2055"></a>    
<a name="2056"></a>          
<a name="2057"></a>    /* 
<a name="2058"></a>     *   Return a list of direct objects corresponding to the word ALL in the
<a name="2059"></a>     *   player's command. By default we return everything in scope that isn't a
<a name="2060"></a>     *   a Room.
<a name="2061"></a>     */
<a name="2062"></a>    getAll(cmd, role)
<a name="2063"></a>    {
<a name="2064"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="2065"></a>    }
<a name="2066"></a>    
<a name="2067"></a>    /* 
<a name="2068"></a>     *   Add a verify result to this action's verify table. This method is
<a name="2069"></a>     *   normally called by one of the macros (logical, illogical, logicalRank,
<a name="2070"></a>     *   etc.) use in an object's verify routine.
<a name="2071"></a>     */    
<a name="2072"></a>    addVerifyResult(verRes)
<a name="2073"></a>    {
<a name="2074"></a>        /* Note the object to which this verify result relates. */
<a name="2075"></a>        local obj = verRes.myObj;
<a name="2076"></a>        
<a name="2077"></a>        /* 
<a name="2078"></a>         *   If it isn't the object we're currently meant to be verifying,
<a name="2079"></a>         *   adjust it.
<a name="2080"></a>         */
<a name="2081"></a>        if(obj != verifyObj)
<a name="2082"></a>        {
<a name="2083"></a>            obj = verifyObj;
<a name="2084"></a>            verRes.myObj = obj;
<a name="2085"></a>        }
<a name="2086"></a>        
<a name="2087"></a>        /* 
<a name="2088"></a>         *   If we don't currently have a verify table for this action, create
<a name="2089"></a>         *   one
<a name="2090"></a>         */
<a name="2091"></a>        if(verifyTab == nil)
<a name="2092"></a>            verifyTab = new LookupTable();
<a name="2093"></a>        
<a name="2094"></a>        /* 
<a name="2095"></a>         *   Add this verify result to this action's verify table only if it
<a name="2096"></a>         *   doesn't already contain a verify result for the same object with a
<a name="2097"></a>         *   lower resultRank.
<a name="2098"></a>         */
<a name="2099"></a>        if(!verifyTab.isKeyPresent(obj) ||        
<a name="2100"></a>            verRes.resultRank &lt; verifyTab[obj].resultRank)   
<a name="2101"></a>            verifyTab[obj] = verRes;       
<a name="2102"></a>    } 
<a name="2103"></a>
<a name="2104"></a>    
<a name="2105"></a>    /* 
<a name="2106"></a>     *   reportAction() is called only after all the action routines have been
<a name="2107"></a>     *   run and the list of dobjs acted on is known. It only does anything if
<a name="2108"></a>     *   the action is not implicit. It can thus be used to summarize a list of
<a name="2109"></a>     *   identical actions carried out on every object in reportList or to print
<a name="2110"></a>     *   a report that is not wanted if the action is implicit. By default we
<a name="2111"></a>     *   call the dobj's reportDobjProp to handle the report.
<a name="2112"></a>     *
<a name="2113"></a>     *   Note that this method is usually called from the current Command object
<a name="2114"></a>     *   after its finished iterated over all the direct objects involved in the
<a name="2115"></a>     *   command.
<a name="2116"></a>     */    
<a name="2117"></a>    reportAction()
<a name="2118"></a>    {
<a name="2119"></a>        /* 
<a name="2120"></a>         *   If we're not an implicit action and there's something in our report
<a name="2121"></a>         *   list to report on, execute the report stage of this action.
<a name="2122"></a>         */
<a name="2123"></a>        if(!isImplicit &amp;&amp; reportList.length &gt; 0)
<a name="2124"></a>        {
<a name="2125"></a>            
<a name="2126"></a>            /* Output any pending implicit action reports */
<a name="2127"></a>            "&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;";
<a name="2128"></a>            
<a name="2129"></a>            curDobj.(reportDobjProp);            
<a name="2130"></a>        }
<a name="2131"></a>
<a name="2132"></a>    }
<a name="2133"></a>    
<a name="2134"></a>    /* install the resolved objects in the action */
<a name="2135"></a>    setResolvedObjects(dobj)
<a name="2136"></a>    {
<a name="2137"></a>        curDobj = dobj;
<a name="2138"></a>    }
<a name="2139"></a>    
<a name="2140"></a>    /* Check whether the resolved objects for this action are in scope */
<a name="2141"></a>    resolvedObjectsInScope()
<a name="2142"></a>    {
<a name="2143"></a>        buildScopeList();
<a name="2144"></a>        return scopeList.indexOf(curDobj) != nil;
<a name="2145"></a>    }
<a name="2146"></a>
<a name="2147"></a>    /*
<a name="2148"></a>     *   Get a message parameter object for the action.  We define 'dobj'
<a name="2149"></a>     *   as the direct object, in addition to any inherited targets.  
<a name="2150"></a>     */
<a name="2151"></a>    getMessageParam(objName)
<a name="2152"></a>    {
<a name="2153"></a>        switch(objName)
<a name="2154"></a>        {
<a name="2155"></a>        case 'dobj':
<a name="2156"></a>            /* return the current direct object */
<a name="2157"></a>            return curDobj;
<a name="2158"></a>            
<a name="2159"></a>        case 'cobj':
<a name="2160"></a>            /* return the current object */
<a name="2161"></a>            return curObj;
<a name="2162"></a>
<a name="2163"></a>        default:
<a name="2164"></a>            /* inherit default handling */
<a name="2165"></a>            return inherited(objName);
<a name="2166"></a>        }
<a name="2167"></a>    }
<a name="2168"></a>    
<a name="2169"></a>    /* 
<a name="2170"></a>     *   A convenience method for putting every game object in scope, which may
<a name="2171"></a>     *   be appropriate for certain commands (not least, certain debugging
<a name="2172"></a>     *   commands). It's intended to be called from addExtraScopeItems when
<a name="2173"></a>     *   needed.     */
<a name="2174"></a>    
<a name="2175"></a>    makeScopeUniversal()
<a name="2176"></a>    {
<a name="2177"></a>        /* Note the fist object of the Thing class. */
<a name="2178"></a>        local obj = firstObj(Thing);
<a name="2179"></a>        
<a name="2180"></a>        /* Create a vector to store our results. */
<a name="2181"></a>        local vec = new Vector;
<a name="2182"></a>        
<a name="2183"></a>        /* Go through every Thing in the game and add it to our vector. */
<a name="2184"></a>        do
<a name="2185"></a>        {
<a name="2186"></a>            vec.append(obj);
<a name="2187"></a>            obj = nextObj(obj, Thing);
<a name="2188"></a>        } while (obj!= nil);
<a name="2189"></a>        
<a name="2190"></a>        /* 
<a name="2191"></a>         *   Convert the vector to a list and append it to our scopeList,
<a name="2192"></a>         *   removing any duplicates.
<a name="2193"></a>         */
<a name="2194"></a>        scopeList = scopeList.appendUnique(vec.toList());
<a name="2195"></a>    }
<a name="2196"></a>    
<a name="2197"></a>    /* 
<a name="2198"></a>     *   Where an action does take objects, we'll normally want duplicate objects to be treated as a
<a name="2199"></a>     *   single object rather than having the same action attempted several times on the aame
<a name="2200"></a>     *   object.
<a name="2201"></a>     */
<a name="2202"></a>    combineDuplicateObjects = true
<a name="2203"></a>   
<a name="2204"></a>;
<a name="2205"></a>
<a name="2206"></a>/* 
<a name="2207"></a> *   A TIAction is an action that applies to both a direct object and an
<a name="2208"></a> *   indirect object. Since it inherits from TAction we only need to define the
<a name="2209"></a> *   additional methods and properties relating to the handling of indirect
<a name="2210"></a> *   objects.
<a name="2211"></a> */
<a name="2212"></a>class TIAction: TAction
<a name="2213"></a>    
<a name="2214"></a>    /* The current indirect object of this action. */
<a name="2215"></a>    curIobj = nil
<a name="2216"></a>   
<a name="2217"></a>    
<a name="2218"></a>    /* The various methods to call on the indirect object of this action. */
<a name="2219"></a>    verIobjProp = nil
<a name="2220"></a>    checkIobjProp = nil
<a name="2221"></a>    actionIobjProp = nil
<a name="2222"></a>    preCondIobjProp = nil
<a name="2223"></a>    
<a name="2224"></a>    /* 
<a name="2225"></a>     *   A list of the indirect objects that this actually actually ends up
<a name="2226"></a>     *   acting on at the action stage.
<a name="2227"></a>     */
<a name="2228"></a>    ioActionList = []
<a name="2229"></a>    
<a name="2230"></a>    /* 
<a name="2231"></a>     *   Flag: should we resolve the indirect object of this action before the
<a name="2232"></a>     *   direct object?
<a name="2233"></a>     */
<a name="2234"></a>    resolveIobjFirst = true
<a name="2235"></a>    
<a name="2236"></a>    /* Reset the action variables to their initial state. */
<a name="2237"></a>    reset()
<a name="2238"></a>    {
<a name="2239"></a>        inherited;
<a name="2240"></a>        curIobj = nil;
<a name="2241"></a>        ioActionList = [];
<a name="2242"></a>    }
<a name="2243"></a>    
<a name="2244"></a>    /* execute this action. */
<a name="2245"></a>    execAction(cmd)
<a name="2246"></a>    {
<a name="2247"></a>        /* 
<a name="2248"></a>         *   Note the current direct object of this command from the Command
<a name="2249"></a>         *   object.
<a name="2250"></a>         */
<a name="2251"></a>        curDobj = cmd.dobj;
<a name="2252"></a>        
<a name="2253"></a>        /* 
<a name="2254"></a>         *   Note the current indirect object of this command from the Command
<a name="2255"></a>         *   object.
<a name="2256"></a>         */
<a name="2257"></a>        curIobj = cmd.iobj;
<a name="2258"></a>        
<a name="2259"></a>        /* Note both objects as possible pronoun antecedents. */
<a name="2260"></a>        notePronounAntecedent(curDobj, curIobj);
<a name="2261"></a>        
<a name="2262"></a>        /* execute the resolved action. */
<a name="2263"></a>        execResolvedAction();
<a name="2264"></a>    }
<a name="2265"></a>    
<a name="2266"></a>    
<a name="2267"></a>    checkAction(cmd)
<a name="2268"></a>    {
<a name="2269"></a>        
<a name="2270"></a>        /* 
<a name="2271"></a>         *   If we don't pass the check stage on both the iobj and the dobj's
<a name="2272"></a>         *   preconditions, then return nil to tell our caller we've failed this
<a name="2273"></a>         *   stage.
<a name="2274"></a>         */
<a name="2275"></a>        if(!(checkPreCond(curIobj, preCondIobjProp) 
<a name="2276"></a>             &amp;&amp; checkPreCond(curDobj, preCondDobjProp)))           
<a name="2277"></a>            return nil;
<a name="2278"></a>        
<a name="2279"></a>        /* 
<a name="2280"></a>         *   If we don't pass the multimethod check stage (involving both objects) return nil
<a name="2281"></a>         */
<a name="2282"></a>        local mmCheckResult = check([curDobj, curIobj], &amp;mmCheck);
<a name="2283"></a>        
<a name="2284"></a>        if(mmCheckResult == nil)
<a name="2285"></a>            return nil;
<a name="2286"></a>        
<a name="2287"></a>        /* 
<a name="2288"></a>         *   If mmCheckResult is an integer (probablly 2) skip the other checks and deemed us to
<a name="2289"></a>         *   have passed the check stage.
<a name="2290"></a>         */
<a name="2291"></a>        if(dataType(mmCheckResult) == TypeInt)
<a name="2292"></a>            return true;
<a name="2293"></a>   
<a name="2294"></a>        /* 
<a name="2295"></a>         *   Return the result of running the check phase on both the indirect
<a name="2296"></a>         *   and the direct objects.
<a name="2297"></a>         */        
<a name="2298"></a>        return check(curIobj, checkIobjProp) &amp;&amp; check(curDobj, checkDobjProp);
<a name="2299"></a>        
<a name="2300"></a>        
<a name="2301"></a>    } 
<a name="2302"></a>    
<a name="2303"></a>    /* Set the resolved objects for this action. */
<a name="2304"></a>    setResolvedObjects(dobj, iobj)
<a name="2305"></a>    {
<a name="2306"></a>        curDobj = dobj;
<a name="2307"></a>        curIobj = iobj;
<a name="2308"></a>    }
<a name="2309"></a>   
<a name="2310"></a>    /* 
<a name="2311"></a>     *   Test whether both the direct and the indirect objects for this action
<a name="2312"></a>     *   are in scope.
<a name="2313"></a>     */
<a name="2314"></a>    resolvedObjectsInScope()
<a name="2315"></a>    {
<a name="2316"></a>        buildScopeList();
<a name="2317"></a>        return scopeList.indexOf(curDobj) != nil 
<a name="2318"></a>            &amp;&amp; scopeList.indexOf(curIobj) != nil;
<a name="2319"></a>    }
<a name="2320"></a>    
<a name="2321"></a>    
<a name="2322"></a>    /* 
<a name="2323"></a>     *   Carry out the report phase for this action. If there's anything in the
<a name="2324"></a>     *   ioActionList and we're not an implicit action, call the report method
<a name="2325"></a>     *   on the indirect object. Then carry out the inherited handling (which
<a name="2326"></a>     *   does the same on the direct object). Note that this method is called by
<a name="2327"></a>     *   the current Command object once its finished iterating over all the
<a name="2328"></a>     *   objects involved in the command.
<a name="2329"></a>     */
<a name="2330"></a>    reportAction()
<a name="2331"></a>    {       
<a name="2332"></a>        
<a name="2333"></a>        /* 
<a name="2334"></a>         *   Carry out the inherited handling, which executes the report stage
<a name="2335"></a>         *   on the direct object.
<a name="2336"></a>         */
<a name="2337"></a>        inherited;
<a name="2338"></a>        /* 
<a name="2339"></a>         *   If we're not an implicit action and there's something to report on,
<a name="2340"></a>         *   carry out the report stage on our indirect object.
<a name="2341"></a>         */
<a name="2342"></a>        if(!isImplicit &amp;&amp; ioActionList.length &gt; 0)
<a name="2343"></a>            curIobj.(reportIobjProp);
<a name="2344"></a>    }
<a name="2345"></a>    
<a name="2346"></a>    /* Get the message parameters relating to this action */
<a name="2347"></a>    getMessageParam(objName)
<a name="2348"></a>    {
<a name="2349"></a>        switch(objName)
<a name="2350"></a>        {
<a name="2351"></a>        case 'iobj':
<a name="2352"></a>            /* return the current indirect object */
<a name="2353"></a>            return curIobj;
<a name="2354"></a>            
<a name="2355"></a>        default:
<a name="2356"></a>            /* inherit default handling */
<a name="2357"></a>            return inherited(objName);
<a name="2358"></a>        }
<a name="2359"></a>    }
<a name="2360"></a>    
<a name="2361"></a>    
<a name="2362"></a>    /* 
<a name="2363"></a>     *   Execute this action as a resolved action, that is once its direct and
<a name="2364"></a>     *   indirect objects are known.
<a name="2365"></a>     */
<a name="2366"></a>    execResolvedAction()
<a name="2367"></a>    {        
<a name="2368"></a>        try
<a name="2369"></a>        {
<a name="2370"></a>            /* 
<a name="2371"></a>             *   If the indirect object was resolved first (before the
<a name="2372"></a>             *   direct object) then we run the verify stage on the indirect
<a name="2373"></a>             *   action first. If it fails, return nil to tell the caller it
<a name="2374"></a>             *   failed.
<a name="2375"></a>             */             
<a name="2376"></a>            if(resolveIobjFirst &amp;&amp; !verifyObjRole(curIobj, IndirectObject))
<a name="2377"></a>                return nil;
<a name="2378"></a>            
<a name="2379"></a>            /* 
<a name="2380"></a>             *   Run the verify routine on the direct object next. If it
<a name="2381"></a>             *   disallows the action, stop here and return nil.
<a name="2382"></a>             */
<a name="2383"></a>            if(!verifyObjRole(curDobj, DirectObject))
<a name="2384"></a>                return nil;
<a name="2385"></a>            
<a name="2386"></a>            /* 
<a name="2387"></a>             *   If the indirect object was resolved after the direct
<a name="2388"></a>             *   object, run the verify routines on the indirect object now, and
<a name="2389"></a>             *   return nil if they disallow the action.
<a name="2390"></a>             */
<a name="2391"></a>            if(!resolveIobjFirst &amp;&amp; !verifyObjRole(curIobj, IndirectObject))
<a name="2392"></a>                return nil;
<a name="2393"></a>            
<a name="2394"></a>            
<a name="2395"></a>            /* 
<a name="2396"></a>             *   If gameMain defines the option to run before notifications
<a name="2397"></a>             *   before the check stage, run the before notifications now.
<a name="2398"></a>             */
<a name="2399"></a>            if(gameMain.beforeRunsBeforeCheck)
<a name="2400"></a>                beforeAction();
<a name="2401"></a>            
<a name="2402"></a>            /* 
<a name="2403"></a>             *   Try the check stage on both objects. If either disallows the
<a name="2404"></a>             *   action return nil to stop the action here.
<a name="2405"></a>             */
<a name="2406"></a>            if(!checkAction(nil))
<a name="2407"></a>                return nil;
<a name="2408"></a>            
<a name="2409"></a>            /* 
<a name="2410"></a>             *   If gameMain defines the option to run before notifications
<a name="2411"></a>             *   after the check stage, run the before notifications now.
<a name="2412"></a>             */            
<a name="2413"></a>            if(!gameMain.beforeRunsBeforeCheck)
<a name="2414"></a>                beforeAction();
<a name="2415"></a>            
<a name="2416"></a>            /* Carry out the action stage on one set of objects */
<a name="2417"></a>            doActionOnce();
<a name="2418"></a>            
<a name="2419"></a>            /* Return true to tell our caller the action was a success */
<a name="2420"></a>            return true;    
<a name="2421"></a>        }
<a name="2422"></a>        
<a name="2423"></a>        catch (ExitActionSignal ex)            
<a name="2424"></a>        {
<a name="2425"></a>               
<a name="2426"></a>//            actionFailed = true;
<a name="2427"></a>            
<a name="2428"></a>            return nil;
<a name="2429"></a>        }   
<a name="2430"></a>       
<a name="2431"></a>    }
<a name="2432"></a>    
<a name="2433"></a>    /* 
<a name="2434"></a>     *   Execute the action phase of the action on both objects. Note that
<a name="2435"></a>     *   although some TIActions can operate on multiple direct objects, none
<a name="2436"></a>     *   defined in the library acts on multiple indirect objects, so there's
<a name="2437"></a>     *   only minimal support for the latter possibility.
<a name="2438"></a>     */
<a name="2439"></a>    doActionOnce()
<a name="2440"></a>    {
<a name="2441"></a>        
<a name="2442"></a>        local msgForDobj, msgForIobj, msgForMM;
<a name="2443"></a>        
<a name="2444"></a>        /* 
<a name="2445"></a>         *   If we're iterating over several objects and we're the kind of
<a name="2446"></a>         *   action which wants to announce objects in this context, do so.
<a name="2447"></a>         */        
<a name="2448"></a>        if(announceMultiAction &amp;&amp; gCommand.dobjs.length &gt; 1)
<a name="2449"></a>            announceObject(curDobj);
<a name="2450"></a>        
<a name="2451"></a>        
<a name="2452"></a>        
<a name="2453"></a>        /* 
<a name="2454"></a>         *   Note that the current object we're dealing with is the direct
<a name="2455"></a>         *   object.
<a name="2456"></a>         */
<a name="2457"></a>        curObj = curDobj;     
<a name="2458"></a>        
<a name="2459"></a>        /* 
<a name="2460"></a>         *   If this action is an implicit one construct an implicit action report to describe it
<a name="2461"></a>         *   and add it to the list of pending implicit action reports for the current command.
<a name="2462"></a>         */       
<a name="2463"></a>        if(isImplicit)
<a name="2464"></a>            buildImplicitActionAnnouncement(true, nil);
<a name="2465"></a>        
<a name="2466"></a>        
<a name="2467"></a>        msgForMM = gOutStream.watchForOutput({:mmAction(curDobj, curIobj)});
<a name="2468"></a>        
<a name="2469"></a>        if(msgForMM != 2)
<a name="2470"></a>        {
<a name="2471"></a>            /* 
<a name="2472"></a>             *   Run the action routine on the current direct object and capture the output for
<a name="2473"></a>             *   later use. If the output is null direct object can be added to the list of objects
<a name="2474"></a>             *   to be reported on at the report stage, provided the iobj action routine doesn't
<a name="2475"></a>             *   report anything either.
<a name="2476"></a>             *
<a name="2477"></a>             *   NOTE TO SELF: Don't try making this work with captureOutput(); it creates far more
<a name="2478"></a>             *   hassle than it's worth!!!!
<a name="2479"></a>             */
<a name="2480"></a>            msgForDobj =
<a name="2481"></a>                gOutStream.watchForOutput({:curDobj.(actionDobjProp)});
<a name="2482"></a>            
<a name="2483"></a>            
<a name="2484"></a>            
<a name="2485"></a>            /* Note that we've acted on this direct object. */
<a name="2486"></a>            actionList += curDobj;
<a name="2487"></a>            
<a name="2488"></a>            /* Note that the current object is now the indirect object. */
<a name="2489"></a>            curObj = curIobj;
<a name="2490"></a>            
<a name="2491"></a>            /* 
<a name="2492"></a>             *   Execute the action method on the indirect object. If it doesn't output anything,
<a name="2493"></a>             *   add the current indirect object to ioActionList in case the report phase wants to
<a name="2494"></a>             *   do anything with it, and add the dobj to the reportList if it's not already there
<a name="2495"></a>             *   so that a report method on the dobj can report on actions handled on the iobj.
<a name="2496"></a>             */        
<a name="2497"></a>            msgForIobj =
<a name="2498"></a>                gOutStream.watchForOutput({:curIobj.(actionIobjProp)});
<a name="2499"></a>        }
<a name="2500"></a>        
<a name="2501"></a>       
<a name="2502"></a>        /* 
<a name="2503"></a>         *   If neither the action stage for the direct object nor the action
<a name="2504"></a>         *   stage for the direct object produced any output then add the
<a name="2505"></a>         *   indirect object to the list of indirect objects that could be
<a name="2506"></a>         *   reported on, and add the current direct object to the list of
<a name="2507"></a>         *   direct objects to be reported on at the report stage.
<a name="2508"></a>         */
<a name="2509"></a>        if(!(msgForDobj) &amp;&amp; !(msgForIobj) &amp;&amp; !(msgForMM))
<a name="2510"></a>        {
<a name="2511"></a>            ioActionList += curIobj;
<a name="2512"></a>            
<a name="2513"></a>            reportList = reportList.appendUnique([curDobj]);            
<a name="2514"></a>        }           
<a name="2515"></a>        
<a name="2516"></a>        /* 
<a name="2517"></a>         *   Return true to tell our caller we completed the action
<a name="2518"></a>         *   successfully.
<a name="2519"></a>         */      
<a name="2520"></a>        return true;
<a name="2521"></a>    }
<a name="2522"></a>     
<a name="2523"></a>    
<a name="2524"></a>    
<a name="2525"></a>    /* 
<a name="2526"></a>     *   These three methods so nothing by default, but provide hooks for implementing multimethod
<a name="2527"></a>     *   TIAction handling. The idea is that in code that makes use of this they would call
<a name="2528"></a>     *   verifyWhateveAction, checkWhateverAction and ActionWhateverAction multimethod functions
<a name="2529"></a>     *   (depending on the particular action.
<a name="2530"></a>     */
<a name="2531"></a>//    mmVerify(dobj, iobj) { }
<a name="2532"></a>    mmCheck(dobj, iobj) { }
<a name="2533"></a>    mmAction(dobj, iobj) { }
<a name="2534"></a>    
<a name="2535"></a>;
<a name="2536"></a>
<a name="2537"></a>/* 
<a name="2538"></a> *   A LiteralAction is an action that acts on a single literal object, e.g.
<a name="2539"></a> *   TYPE HELLO
<a name="2540"></a> */
<a name="2541"></a>class LiteralAction: IAction
<a name="2542"></a>    exec(cmd)
<a name="2543"></a>    {
<a name="2544"></a>        /* Note the literal string associated with this command. */
<a name="2545"></a>        literal = cmd.dobj.name;
<a name="2546"></a>        
<a name="2547"></a>        /* carry out the inherited handling. */
<a name="2548"></a>        inherited(cmd);
<a name="2549"></a>    }
<a name="2550"></a> 
<a name="2551"></a>    /* The string literal on which this command is operating. */
<a name="2552"></a>    literal = nil
<a name="2553"></a>    
<a name="2554"></a>    /* The numerical value of our literal */
<a name="2555"></a>    num = tryNum(literal)
<a name="2556"></a>;
<a name="2557"></a>
<a name="2558"></a>
<a name="2559"></a>
<a name="2560"></a>/* 
<a name="2561"></a> *   A LiteralTAction is an action that involves one physical object and one
<a name="2562"></a> *   string, e.g. TYPE HELLO ON TERMINAL.
<a name="2563"></a> */
<a name="2564"></a>class LiteralTAction: TAction
<a name="2565"></a>    execAction(cmd)
<a name="2566"></a>    {
<a name="2567"></a>        
<a name="2568"></a>        /* 
<a name="2569"></a>         *   Determine which is the Thing-based object and which is the literal
<a name="2570"></a>         *   value and plug each into the right slot (so that the Thing ends up
<a name="2571"></a>         *   as the direct object of the command and the string as the literal).
<a name="2572"></a>         */        
<a name="2573"></a>        if(cmd.dobj.ofKind(Thing))
<a name="2574"></a>        {        
<a name="2575"></a>            curDobj = cmd.dobj;
<a name="2576"></a>            literal = cmd.iobj.name;
<a name="2577"></a>        }
<a name="2578"></a>        else
<a name="2579"></a>        {
<a name="2580"></a>            curDobj = cmd.iobj;
<a name="2581"></a>            literal = cmd.dobj.name;
<a name="2582"></a>        }
<a name="2583"></a>        
<a name="2584"></a>        /* Note the direct object as an antecedent for pronouns */
<a name="2585"></a>        notePronounAntecedent(curDobj);
<a name="2586"></a>
<a name="2587"></a>        /* Execute the resolved action (as for a TAction) */
<a name="2588"></a>        execResolvedAction();        
<a name="2589"></a>    }
<a name="2590"></a>    
<a name="2591"></a>    /* 
<a name="2592"></a>     *   Whichever object slot a verify routine is notionally trying to verify
<a name="2593"></a>     *   for given the grammatical form of the command, in practice only the
<a name="2594"></a>     *   direct object (the thing involved in the command) can be verified. E.g.
<a name="2595"></a>     *   for WRITE FOO ON BALL we treat BALL as the direct object of the command
<a name="2596"></a>     *   and FOO as the literal, even if the Parser thinks it needs to verify
<a name="2597"></a>     *   the Indirect Object to disambiguate BALL.
<a name="2598"></a>     */    
<a name="2599"></a>    verify(obj, role)
<a name="2600"></a>    {
<a name="2601"></a>        return inherited(obj, DirectObject);
<a name="2602"></a>    }
<a name="2603"></a>    
<a name="2604"></a>    
<a name="2605"></a>    /* The literal value associated with this command */
<a name="2606"></a>    literal = nil
<a name="2607"></a>    
<a name="2608"></a>    /* The numerical value of our literal */
<a name="2609"></a>    num = tryNum(literal)
<a name="2610"></a>;
<a name="2611"></a>
<a name="2612"></a>
<a name="2613"></a>/* 
<a name="2614"></a> *   A TopicTAction is an action involving one physical object and one topic,
<a name="2615"></a> *   e.g. ASK BOB ABOUT TOWER.
<a name="2616"></a> */
<a name="2617"></a>class TopicTAction: TAction
<a name="2618"></a>    execAction(cmd)
<a name="2619"></a>    {
<a name="2620"></a>        
<a name="2621"></a>        /* 
<a name="2622"></a>         *   determine which is the Thing-type object and which is the topic
<a name="2623"></a>         *   value and plug each into the right slot. We ensure that the
<a name="2624"></a>         *   physical object (the Thing) ends up as the direct object and the
<a name="2625"></a>         *   ResolvedTopic as the indirect object.
<a name="2626"></a>         */        
<a name="2627"></a>        if(cmd.dobj &amp;&amp; cmd.dobj.ofKind(Thing))
<a name="2628"></a>        {        
<a name="2629"></a>            curDobj = cmd.dobj;
<a name="2630"></a>            curIobj = cmd.iobj;
<a name="2631"></a>            curTopic = cmd.iobj;
<a name="2632"></a>        }
<a name="2633"></a>        else
<a name="2634"></a>        {
<a name="2635"></a>            curDobj = cmd.iobj;
<a name="2636"></a>            curIobj = cmd.dobj;
<a name="2637"></a>            curTopic = cmd.dobj;
<a name="2638"></a>        }
<a name="2639"></a>        
<a name="2640"></a>        /* Note the direct object as a potential pronoun antecedent. */
<a name="2641"></a>        notePronounAntecedent(curDobj);
<a name="2642"></a>
<a name="2643"></a>        /* Attempt to resolve any pronouns within the ResolvedTopic */
<a name="2644"></a>        resolvePronouns();
<a name="2645"></a>        
<a name="2646"></a>        /* Execute the action as for a TAction */
<a name="2647"></a>        execResolvedAction();       
<a name="2648"></a>        
<a name="2649"></a>    }
<a name="2650"></a>    
<a name="2651"></a>    /* 
<a name="2652"></a>     *   Although we don't have an indirect object in the conventional sense, we
<a name="2653"></a>     *   use the curIobj property to store the ResolvedTopic involved in the
<a name="2654"></a>     *   command.
<a name="2655"></a>     */
<a name="2656"></a>    curIobj = nil
<a name="2657"></a>    
<a name="2658"></a>    /*   
<a name="2659"></a>     *   We also store the current ResolvedTopic in the curTopic property so it
<a name="2660"></a>     *   can be found by the gTopic macro.
<a name="2661"></a>     */
<a name="2662"></a>    curTopic = nil
<a name="2663"></a>    
<a name="2664"></a>    /* 
<a name="2665"></a>     *   This is a bit of a kludge to deal with the fact that the Parser doesn't
<a name="2666"></a>     *   seem able to resolve pronouns within ResolvedTopics. We do it here
<a name="2667"></a>     *   instead.
<a name="2668"></a>     */    
<a name="2669"></a>    resolvePronouns()
<a name="2670"></a>    {
<a name="2671"></a>        if(curIobj == nil)
<a name="2672"></a>            return;
<a name="2673"></a>        
<a name="2674"></a>        for(local cur in valToList(curIobj.topicList), local i = 1;; ++i)
<a name="2675"></a>        {
<a name="2676"></a>            if(cur == Him &amp;&amp; curDobj.isHim)
<a name="2677"></a>                curIobj.topicList[i] = curDobj;
<a name="2678"></a>            
<a name="2679"></a>            if(cur == Her &amp;&amp; curDobj.isHer)
<a name="2680"></a>                curIobj.topicList[i] = curDobj;
<a name="2681"></a>            
<a name="2682"></a>            if(cur == It &amp;&amp; curDobj.isIt)
<a name="2683"></a>                curIobj.topicList[i] = curDobj;
<a name="2684"></a>            
<a name="2685"></a>            if(cur == Them &amp;&amp; (curDobj.plural || curDobj.ambiguouslyPlural))
<a name="2686"></a>                curIobj.topicList[i] = curDobj;
<a name="2687"></a>        }
<a name="2688"></a>    }
<a name="2689"></a>    
<a name="2690"></a>    /* 
<a name="2691"></a>     *   Whichever object slot a verify routine is notionally trying to verify
<a name="2692"></a>     *   for given the grammatical form of the command, in practice only the
<a name="2693"></a>     *   direct object (the thing involved in the command) can be verified. E.g.
<a name="2694"></a>     *   for WRITE FOO ON BALL we treat BALL as the direct object of the command
<a name="2695"></a>     *   and FOO as the literal, even if the Parser thinks it needs to verify
<a name="2696"></a>     *   the Indirect Object to disambiguate BALL.
<a name="2697"></a>     */    
<a name="2698"></a>    verify(obj, whichObj)
<a name="2699"></a>    {
<a name="2700"></a>        return inherited(obj, DirectObject);
<a name="2701"></a>    }
<a name="2702"></a>    
<a name="2703"></a>    /* 
<a name="2704"></a>     *   Is the topic the grammatical Indirect object of this command? This is
<a name="2705"></a>     *   used by Redirector.doOtherAction() to encapsulate the appropriate
<a name="2706"></a>     *   string in a ResolvedTopic. The topic is the grammatical iobj if its the
<a name="2707"></a>     *   second object involved in the commamd, e.g. ASK BOB ABOUT FIRE, where
<a name="2708"></a>     *   FIRE is the topic.
<a name="2709"></a>     */
<a name="2710"></a>    topicIsGrammaticalIobj = true
<a name="2711"></a>;
<a name="2712"></a>
<a name="2713"></a>
<a name="2714"></a>/* 
<a name="2715"></a> *   A NumericTAction is an action that involves one physical object and one
<a name="2716"></a> *   number, e.g. DIAL 1234 ON PHONR.
<a name="2717"></a> */
<a name="2718"></a>class NumericTAction: TAction
<a name="2719"></a>    execAction(cmd)
<a name="2720"></a>    {
<a name="2721"></a>        
<a name="2722"></a>        /* 
<a name="2723"></a>         *   Determine which is the Thing-based object and which is the numeric
<a name="2724"></a>         *   value and plug each into the right slot (so that the Thing ends up
<a name="2725"></a>         *   as the direct object of the command and the number as the num).
<a name="2726"></a>         */        
<a name="2727"></a>        if(cmd.dobj.ofKind(Thing))
<a name="2728"></a>        {        
<a name="2729"></a>            curDobj = cmd.dobj;
<a name="2730"></a>            num = cmd.iobj.numVal;
<a name="2731"></a>        }
<a name="2732"></a>        else
<a name="2733"></a>        {
<a name="2734"></a>            curDobj = cmd.iobj;
<a name="2735"></a>            num = cmd.dobj.numVal;
<a name="2736"></a>        }
<a name="2737"></a>        
<a name="2738"></a>        /* Note the direct object as an antecedent for pronouns */
<a name="2739"></a>        notePronounAntecedent(curDobj);
<a name="2740"></a>
<a name="2741"></a>        /* Execute the resolved action (as for a TAction) */
<a name="2742"></a>        execResolvedAction();        
<a name="2743"></a>    }
<a name="2744"></a>    
<a name="2745"></a>    /* 
<a name="2746"></a>     *   Whichever object slot a verify routine is notionally trying to verify
<a name="2747"></a>     *   for given the grammatical form of the command, in practice only the
<a name="2748"></a>     *   direct object (the thing involved in the command) can be verified. E.g.
<a name="2749"></a>     *   for WRITE FOO ON BALL we treat BALL as the direct object of the command
<a name="2750"></a>     *   and FOO as the literal, even if the Parser thinks it needs to verify
<a name="2751"></a>     *   the Indirect Object to disambiguate BALL.
<a name="2752"></a>     */    
<a name="2753"></a>    verify(obj, role)
<a name="2754"></a>    {
<a name="2755"></a>        return inherited(obj, DirectObject);
<a name="2756"></a>    }
<a name="2757"></a>    
<a name="2758"></a>    
<a name="2759"></a>    /* The numeric value associated with this command */
<a name="2760"></a>    num = nil
<a name="2761"></a>;
<a name="2762"></a>
<a name="2763"></a>
<a name="2764"></a>/* 
<a name="2765"></a> *   A TopicAction is an action referring to a single Topic (e.g. TALK ABOUT THE
<a name="2766"></a> *   TOWER). It behaves almost exactly like an IAction.
<a name="2767"></a> */
<a name="2768"></a>
<a name="2769"></a>class TopicAction: IAction    
<a name="2770"></a>    exec(cmd)
<a name="2771"></a>    {
<a name="2772"></a>        /* 
<a name="2773"></a>         *   For a TopicAction the ResolvedTopic will be in the dobj property of
<a name="2774"></a>         *   the cmd object. Store it in the curTopic property.
<a name="2775"></a>         */
<a name="2776"></a>        curTopic = cmd.dobj;
<a name="2777"></a>        
<a name="2778"></a>        /* Then carry out the inherited handling. */
<a name="2779"></a>        inherited(cmd);
<a name="2780"></a>    }
<a name="2781"></a>    
<a name="2782"></a>    
<a name="2783"></a>    /* The ResolvedTopic object associated with this action. */
<a name="2784"></a>    curTopic = nil
<a name="2785"></a>;
<a name="2786"></a>
<a name="2787"></a>
<a name="2788"></a>/*  
<a name="2789"></a> *   A NumericAction is an action referring to a single Number (e.g. Footnote
<a name="2790"></a> *   1). It behaves almost like an IAction.
<a name="2791"></a> */
<a name="2792"></a>class NumericAction: IAction
<a name="2793"></a>    exec(cmd)
<a name="2794"></a>    {
<a name="2795"></a>        /* Note the number associated with this command. */
<a name="2796"></a>        num = cmd.dobj.numVal;
<a name="2797"></a>        
<a name="2798"></a>        /* carry out the inherited handling. */
<a name="2799"></a>        inherited(cmd);
<a name="2800"></a>    }
<a name="2801"></a> 
<a name="2802"></a>    /* The number on which this command is operating. */
<a name="2803"></a>    num = nil
<a name="2804"></a>;
<a name="2805"></a>
<a name="2806"></a>
<a name="2807"></a>
<a name="2808"></a>
<a name="2809"></a>/* Try action as an implicit action with [objs] as its objects */
<a name="2810"></a>tryImplicitAction(action, [objs])
<a name="2811"></a>{
<a name="2812"></a>    
<a name="2813"></a>    local oldAction;
<a name="2814"></a>
<a name="2815"></a>    /* 
<a name="2816"></a>     *   Create a new copy of the action we're to try executing so we don't
<a name="2817"></a>     *   contaminate the properties of the same action if it'e being used
<a name="2818"></a>     *   elsewhere in the call chain.
<a name="2819"></a>     */ 
<a name="2820"></a>    action = action.createInstance();
<a name="2821"></a>    
<a name="2822"></a>    /* Our new action will be an implicit action. */
<a name="2823"></a>    action.isImplicit = true;
<a name="2824"></a>    
<a name="2825"></a>    /* Note the previous action being executed. */
<a name="2826"></a>    oldAction = gAction;
<a name="2827"></a>    
<a name="2828"></a>    /* install the resolved objects in the action */
<a name="2829"></a>    action.setResolvedObjects(objs...);
<a name="2830"></a>    
<a name="2831"></a>//    action.reportImplicitActions = action.formerReportImplicitActions;
<a name="2832"></a>       
<a name="2833"></a>    /* 
<a name="2834"></a>     *   For an implicit action, we must check the objects involved to make
<a name="2835"></a>     *   sure they're in scope.  If any of the objects aren't in scope,
<a name="2836"></a>     *   there is no way the actor would know to perform the command, so
<a name="2837"></a>     *   the command would not be implied in the first place.  Simply fail
<a name="2838"></a>     *   without trying the command.  
<a name="2839"></a>     */
<a name="2840"></a>    if (!action.resolvedObjectsInScope())
<a name="2841"></a>        return nil;
<a name="2842"></a>    
<a name="2843"></a>    /* 
<a name="2844"></a>     *   Note that the previous current action is our new action's parent action
<a name="2845"></a>     */
<a name="2846"></a>    action.parentAction = gAction;
<a name="2847"></a>    
<a name="2848"></a>    /* Make our new action the current action. */
<a name="2849"></a>    gAction = action;
<a name="2850"></a>    
<a name="2851"></a>    try
<a name="2852"></a>    {
<a name="2853"></a>        /* Execute our new action. */
<a name="2854"></a>        action.execResolvedAction();
<a name="2855"></a>             
<a name="2856"></a>        /* Provide a hook for the objtime extension to use. */
<a name="2857"></a>        action.addImplicitTime();
<a name="2858"></a>        
<a name="2859"></a>        /* 
<a name="2860"></a>         *   If all went well, return true to indicate that we were able to
<a name="2861"></a>         *   execute the action.
<a name="2862"></a>         */
<a name="2863"></a>        return true;
<a name="2864"></a>    }
<a name="2865"></a>    
<a name="2866"></a>    /*  
<a name="2867"></a>     *   If the action threw an AbortImplicitSignal this means that its verify
<a name="2868"></a>     *   routine does not allow the action to be carried out implicitly; return
<a name="2869"></a>     *   nil to signal that we weren't allowed to attempt this implicit action.
<a name="2870"></a>     */
<a name="2871"></a>    catch (AbortImplicitSignal ex)
<a name="2872"></a>    {
<a name="2873"></a>        return nil;
<a name="2874"></a>    }
<a name="2875"></a>    
<a name="2876"></a>    finally
<a name="2877"></a>    {
<a name="2878"></a>        /* Restore the original current action. */
<a name="2879"></a>        gAction = oldAction;       
<a name="2880"></a>    }
<a name="2881"></a>    
<a name="2882"></a>}
<a name="2883"></a>
<a name="2884"></a>/* 
<a name="2885"></a> *   Have an actor other than the current gActor try an implicit action (e.g. if
<a name="2886"></a> *   an npc moving as the result of an AgendaItem needs to implicitly open a
<a name="2887"></a> *   door to proceed): actor is the actor performing the action, action is the
<a name="2888"></a> *   action object to be performs, [objs] is the list of objects (if any) on
<a name="2889"></a> *   which the action is to be performed.
<a name="2890"></a> */
<a name="2891"></a>tryImplicitActorAction(actor, action, [objs])
<a name="2892"></a>{
<a name="2893"></a>    /* 
<a name="2894"></a>     *   Set up a local variable to store the result of trying the implicit
<a name="2895"></a>     *   action.
<a name="2896"></a>     */
<a name="2897"></a>    local res = nil;
<a name="2898"></a>    
<a name="2899"></a>    /*  Make a note of the current actor of the current main command. */
<a name="2900"></a>    local oldActor = gActor;
<a name="2901"></a>    
<a name="2902"></a>    
<a name="2903"></a>    try
<a name="2904"></a>    {
<a name="2905"></a>        /* Temporarily make gActor the actor passed to this function. */
<a name="2906"></a>        gActor = actor;
<a name="2907"></a>        
<a name="2908"></a>        /* Try the implicit action with this actor and store the result. */
<a name="2909"></a>        res = tryImplicitAction(action, objs...);
<a name="2910"></a>    }
<a name="2911"></a>    
<a name="2912"></a>    finally
<a name="2913"></a>    {
<a name="2914"></a>        /* Restore the original gActor */
<a name="2915"></a>        gActor = oldActor;
<a name="2916"></a>    }
<a name="2917"></a>    
<a name="2918"></a>    /* Return the result of attempting the implicit action. */
<a name="2919"></a>    return res;
<a name="2920"></a>}
<a name="2921"></a>
<a name="2922"></a>/* ------------------------------------------------------------------------ */
<a name="2923"></a>/*
<a name="2924"></a> *   Run a replacement action. 
<a name="2925"></a> */
<a name="2926"></a>replaceAction(action, [objs])
<a name="2927"></a>{
<a name="2928"></a>    /* run the replacement action as a nested action */
<a name="2929"></a>    execNestedAction(true, gActor, action, objs...);
<a name="2930"></a>
<a name="2931"></a>    /* the invoking command is done */
<a name="2932"></a>    exit;;
<a name="2933"></a>}
<a name="2934"></a>
<a name="2935"></a>/* Run a replacement action for another actor. */
<a name="2936"></a>replaceActorAction(actor, action, [objs])
<a name="2937"></a>{    
<a name="2938"></a>    
<a name="2939"></a>    /* run the replacement action as a nested action */
<a name="2940"></a>    execNestedAction(true, actor, action, objs...);
<a name="2941"></a>
<a name="2942"></a>    /* the invoking command is done */
<a name="2943"></a>    exit;
<a name="2944"></a>}
<a name="2945"></a>
<a name="2946"></a>
<a name="2947"></a>/* 
<a name="2948"></a> *   Run a nested action; execution of the parent action continues once the
<a name="2949"></a> *   nested action is complete.
<a name="2950"></a> */
<a name="2951"></a>nestedActorAction(actor, action, [objs])
<a name="2952"></a>{
<a name="2953"></a>    execNestedAction(nil, actor, action, objs...);
<a name="2954"></a>}
<a name="2955"></a>
<a name="2956"></a>/* Run a nested action for the current actor. */
<a name="2957"></a>nestedAction(action, [objs])
<a name="2958"></a>{
<a name="2959"></a>    execNestedAction(nil, gActor, action, objs...);
<a name="2960"></a>}
<a name="2961"></a>
<a name="2962"></a>
<a name="2963"></a>
<a name="2964"></a>/*
<a name="2965"></a> *   Execute a fully-constructed nested action.
<a name="2966"></a> *   
<a name="2967"></a> *   'isReplacement' indicates whether the action is a full replacement or
<a name="2968"></a> *   an ordinary nested action.  If it's a replacement, then we use the
<a name="2969"></a> *   game time taken by the replacement, and set the enclosing action
<a name="2970"></a> *   (i.e., the current gAction) to take zero time.  If it's an ordinary
<a name="2971"></a> *   nested action, then we consider the nested action to take zero time,
<a name="2972"></a> *   using the current action's time as the overall command time.  
<a name="2973"></a> *   
<a name="2974"></a> *   'isRemapping' indicates whether or not this is a remapped action.  If
<a name="2975"></a> *   we're remapping from one action to another, this will be true; for
<a name="2976"></a> *   any other kind of nested or replacement action, this should be nil.  
<a name="2977"></a> */
<a name="2978"></a>execNestedAction(isReplacement, actor, action, [objs])
<a name="2979"></a>{
<a name="2980"></a>    local oldAction;
<a name="2981"></a>    local oldActor = gActor;
<a name="2982"></a>    
<a name="2983"></a>    /* 
<a name="2984"></a>     *   Create a new instance of the desired action, so we don't override the
<a name="2985"></a>     *   current state of any similar action higher up the calling chain.
<a name="2986"></a>     */
<a name="2987"></a>    action = action.createInstance();
<a name="2988"></a>    
<a name="2989"></a>    /* Make the new action make a note of its parent action */
<a name="2990"></a>    action.parentAction = gAction;
<a name="2991"></a>    
<a name="2992"></a>    /* 
<a name="2993"></a>     *   Treat us an an implicit action if the current (parent) action is
<a name="2994"></a>     *   implicit.
<a name="2995"></a>     */
<a name="2996"></a>    action.isImplicit = gAction.isImplicit;   
<a name="2997"></a>
<a name="2998"></a>    /* Note the previous (calling) action. */
<a name="2999"></a>    oldAction = gAction;
<a name="3000"></a>    
<a name="3001"></a>    /* Set the current actor to the value of our actor parameter. */
<a name="3002"></a>    gActor = actor;
<a name="3003"></a>    
<a name="3004"></a>    /* Install the new actor on the current Command object. */
<a name="3005"></a>    gCommand.actor = actor;
<a name="3006"></a>    
<a name="3007"></a>    /* 
<a name="3008"></a>     *   Change the current Command object's action to the new action with its
<a name="3009"></a>     *   new objects.
<a name="3010"></a>     */
<a name="3011"></a>    gCommand.changeAction(action, objs.element(1), objs.element(2),
<a name="3012"></a>                          objs.element(3));
<a name="3013"></a>    
<a name="3014"></a>    /* If our objects aren't in scope we can't proceed with the action. */ 
<a name="3015"></a>    if (objs.length &gt; 0 &amp;&amp; !action.resolvedObjectsInScope())
<a name="3016"></a>        return nil;
<a name="3017"></a>    
<a name="3018"></a>    try
<a name="3019"></a>    {
<a name="3020"></a>        /* Execute the new action */
<a name="3021"></a>        action.execAction(gCommand);
<a name="3022"></a>        
<a name="3023"></a>        /* 
<a name="3024"></a>         *   In principle we only want to show the reportAction report if we're
<a name="3025"></a>         *   not a replacement action, leaving a replacement action to display
<a name="3026"></a>         *   its report in the normal course of the Command's action-processing
<a name="3027"></a>         *   cycle, but there are certain circumstances where even a replacement
<a name="3028"></a>         *   action needs to display its reportAction here, specifically (1) if
<a name="3029"></a>         *   there's been a change of actor (in which case replaceAction has
<a name="3030"></a>         *   arguably been misused) or (2) if an object announcement has just
<a name="3031"></a>         *   been displayed for the parent action, in which case we need to
<a name="3032"></a>         *   ensure that the report corresponding to the object announcement is
<a name="3033"></a>         *   displayed immediately after the object name (by displaying the
<a name="3034"></a>         *   report straight away here).
<a name="3035"></a>         */        
<a name="3036"></a>        if(!isReplacement || gActor != oldActor || 
<a name="3037"></a>         (action.parentAction.announceMultiAction &amp;&amp; gCommand.dobjs.length &gt; 1))
<a name="3038"></a>        {    
<a name="3039"></a>            /* report the outcome of the action. */
<a name="3040"></a>            action.reportAction();
<a name="3041"></a>            
<a name="3042"></a>            /* 
<a name="3043"></a>             *   If this is a replacement action, there won't be anything
<a name="3044"></a>             *   printed after reportAction displays a report so we need to
<a name="3045"></a>             *   print a newline in case there's another object.
<a name="3046"></a>             */
<a name="3047"></a>            if(isReplacement)
<a name="3048"></a>                "\n";
<a name="3049"></a>            
<a name="3050"></a>            /*   
<a name="3051"></a>             *   Empty the report list to ensure the report isn't duplicated
<a name="3052"></a>             *   later
<a name="3053"></a>             */
<a name="3054"></a>            action.reportList = [];
<a name="3055"></a>        }
<a name="3056"></a>        
<a name="3057"></a>        /* 
<a name="3058"></a>         *   Return true to indicate that the action was completed successfully.
<a name="3059"></a>         */
<a name="3060"></a>        return true;
<a name="3061"></a>    }
<a name="3062"></a>    
<a name="3063"></a>    catch (AbortImplicitSignal ex)
<a name="3064"></a>    {
<a name="3065"></a>        /* Return nil to indicate failure. */
<a name="3066"></a>        return nil;
<a name="3067"></a>    }
<a name="3068"></a>        
<a name="3069"></a>    
<a name="3070"></a>    finally
<a name="3071"></a>    {
<a name="3072"></a>        /* 
<a name="3073"></a>         *   If we're not a replacement action we need to restore the old
<a name="3074"></a>         *   gAction when we're done; and if we're a nested action and not
<a name="3075"></a>         *   implicit, then we should show our action reports (if any) before
<a name="3076"></a>         *   handing back to the main action. We also need to do this if we've
<a name="3077"></a>         *   changed actor, since unpredictable results could occur from
<a name="3078"></a>         *   substituting an action by one actor with one by another.
<a name="3079"></a>         *
<a name="3080"></a>         *   We try to avoid doing this if this is a replacement action, because
<a name="3081"></a>         *   if possible we want all aspects of the new action, including its
<a name="3082"></a>         *   reporting and after action processing.
<a name="3083"></a>         */        
<a name="3084"></a>        if(!isReplacement || gActor != oldActor)        
<a name="3085"></a>        {            
<a name="3086"></a>            /* Restore the original action on the current Command object. */
<a name="3087"></a>            gCommand.action = gCommand.originalAction;
<a name="3088"></a>            
<a name="3089"></a>            /* Restore the original current action. */
<a name="3090"></a>            gAction = oldAction;
<a name="3091"></a>            
<a name="3092"></a>            /* Restore the original actor. */
<a name="3093"></a>            gActor = oldActor;
<a name="3094"></a>            
<a name="3095"></a>            /* Restore the original actor on the Command object. */
<a name="3096"></a>            gCommand.actor = oldActor;
<a name="3097"></a>        }
<a name="3098"></a>    }
<a name="3099"></a>}
<a name="3100"></a>
<a name="3101"></a>/* 
<a name="3102"></a> *   Ask for a missing object to fulfil role in action. If findBest is true (the default), first see
<a name="3103"></a> *   if there's a uniquely best match to fill the role, and if so execute the action with that
<a name="3104"></a> *   object. Otherwise ask the player to supply an object.
<a name="3105"></a> */
<a name="3106"></a>askMissingObject(action, role, findBest = true)
<a name="3107"></a>{
<a name="3108"></a>     
<a name="3109"></a>        
<a name="3110"></a>    /* Make action the current action for the current Command. */    
<a name="3111"></a>    gCommand.action = action;
<a name="3112"></a>    gCommand.action.reset(); 
<a name="3113"></a>    
<a name="3114"></a>    /* 
<a name="3115"></a>     *   Store the current objects of the current action in the new action, in case
<a name="3116"></a>     *   action.scoreObjects() needs to refer to them below.
<a name="3117"></a>     */
<a name="3118"></a>    action.curDobj = gDobj;
<a name="3119"></a>    action.curIobj = gIobj;
<a name="3120"></a>    action.curAobj = gAobj;
<a name="3121"></a>    
<a name="3122"></a>    gCommand.dobj = action.curDobj;
<a name="3123"></a>    gCommand.iobj = action.curIobj;
<a name="3124"></a>    gCommand.acc = action.curAobj;
<a name="3125"></a>    
<a name="3126"></a>   
<a name="3127"></a>    
<a name="3128"></a>    /* 
<a name="3129"></a>     *   Make the action the original action for the current Command; we need to
<a name="3130"></a>     *   do this because otherwise the Command object will overwrite our new
<a name="3131"></a>     *   action with its original one before we're done.
<a name="3132"></a>     */
<a name="3133"></a>    gCommand.originalAction = action;
<a name="3134"></a>  
<a name="3135"></a>    /* 
<a name="3136"></a>     *   Slot the new action's verbRule into the Command's verbProd, so that the
<a name="3137"></a>     *   Command has a verbProd appropriate to the action.
<a name="3138"></a>     */
<a name="3139"></a>    gCommand.verbProd = action.verbRule;    
<a name="3140"></a>    
<a name="3141"></a>    
<a name="3142"></a>    /* 
<a name="3143"></a>     *   If we want to find the object that's the best match to the missing object, now do so.
<a name="3144"></a>     *   usually this wiil be the case but occasionally we may want to force the player to make a
<a name="3145"></a>     *   choice.
<a name="3146"></a>     */
<a name="3147"></a>    if(findBest)
<a name="3148"></a>    {
<a name="3149"></a>        
<a name="3150"></a>        /* See if we can find an obvious best object to select. */
<a name="3151"></a>        
<a name="3152"></a>        /* First get the scope list for the new action. */
<a name="3153"></a>        action.buildScopeList(role);
<a name="3154"></a>        
<a name="3155"></a>        /* 
<a name="3156"></a>         *   Then wrap the scopeList in a list of NP objects so we can use it as a parameter for
<a name="3157"></a>         *   scoreObjects().
<a name="3158"></a>         */
<a name="3159"></a>        local matchList = action.wrapObjectsNP(action.scopeList);
<a name="3160"></a>        
<a name="3161"></a>        /*   Make a note of the highest scoring object we find */
<a name="3162"></a>        local bestObj = nil;
<a name="3163"></a>        
<a name="3164"></a>        /*  
<a name="3165"></a>         *   If we found any objects we could match, determine which of them is the best match.
<a name="3166"></a>         */
<a name="3167"></a>        if(matchList.length &gt; 0)
<a name="3168"></a>        {
<a name="3169"></a>            /* Score all the objects in scope */
<a name="3170"></a>            action.scoreObjects(gCommand, role, matchList);
<a name="3171"></a>            
<a name="3172"></a>            /* Sort the list of objects in descending order of score */
<a name="3173"></a>            matchList = matchList.sort(SortDesc, {a, b: a.score - b.score});
<a name="3174"></a>            
<a name="3175"></a>            /* If there's only one object with the top score, select it */
<a name="3176"></a>            if(matchList.countWhich({o: o.score == matchList[1].score}) == 1)
<a name="3177"></a>                bestObj = matchList[1].obj;
<a name="3178"></a>        }
<a name="3179"></a>        
<a name="3180"></a>        /* 
<a name="3181"></a>         *   If we have a best object, check that the command can actually use it before finally
<a name="3182"></a>         *   selecting it.
<a name="3183"></a>         */    
<a name="3184"></a>        if(bestObj != nil)
<a name="3185"></a>        {
<a name="3186"></a>            /* 
<a name="3187"></a>             *   Obtain the verify result for the best object for this action in this role.
<a name="3188"></a>             */
<a name="3189"></a>            local verResult = action.verify(bestObj, role);
<a name="3190"></a>            
<a name="3191"></a>            /* 
<a name="3192"></a>             *   Only execute the action with the best object if the action would pass the verify
<a name="3193"></a>             *   stage and the verify stage would allow the action to be performed implicitly. That
<a name="3194"></a>             *   way we won't choose an object with a dangerous or nonObvious verify result, and we
<a name="3195"></a>             *   won't pointlessly attempt an impossible action.
<a name="3196"></a>             */
<a name="3197"></a>            if(verResult.allowAction &amp;&amp; verResult.allowImplicit)
<a name="3198"></a>            {
<a name="3199"></a>                /* 
<a name="3200"></a>                 *   Announce which object we've chosen; language-specific modules will need to
<a name="3201"></a>                 *   implement this.
<a name="3202"></a>                 */
<a name="3203"></a>                announceBestChoice(action, bestObj, role);
<a name="3204"></a>                
<a name="3205"></a>                /* 
<a name="3206"></a>                 *   Slot our best choice of object into the appropriate object property of the
<a name="3207"></a>                 *   current command object.
<a name="3208"></a>                 */
<a name="3209"></a>                gCommand.(role.objProp) = bestObj;
<a name="3210"></a>                
<a name="3211"></a>                
<a name="3212"></a>                /* Execute the new action with the new set of objects. */
<a name="3213"></a>                
<a name="3214"></a>                
<a name="3215"></a>                gCommand.execDoer([action, gCommand.dobj, gCommand.iobj]);            
<a name="3216"></a>                
<a name="3217"></a>                
<a name="3218"></a>                /* 
<a name="3219"></a>                 *   If we were able to execute the new action with the new set of objects, we're
<a name="3220"></a>                 *   done; and we don't want to continue with the original action.
<a name="3221"></a>                 */
<a name="3222"></a>                exit;
<a name="3223"></a>            }        
<a name="3224"></a>        }
<a name="3225"></a>    }
<a name="3226"></a>    
<a name="3227"></a>    
<a name="3228"></a>    /* 
<a name="3229"></a>     *   If we couldn't find an obvious best object to use, prompt the player
<a name="3230"></a>     *   for his/her choice of object
<a name="3231"></a>     */        
<a name="3232"></a>    
<a name="3233"></a>    /* 
<a name="3234"></a>     *   First create a new error for a missing object for our Command in the
<a name="3235"></a>     *   desired role.
<a name="3236"></a>     */
<a name="3237"></a>    local err = new EmptyNounError(gCommand, role);
<a name="3238"></a>    
<a name="3239"></a>
<a name="3240"></a>    /* 
<a name="3241"></a>     *   When the player's response is reparsed, we only want to resolve the
<a name="3242"></a>     *   nound for the role we're asking about here, so tell the command which
<a name="3243"></a>     *   role we want to resolve for.
<a name="3244"></a>     */    
<a name="3245"></a>    gCommand.npToResolve = role;
<a name="3246"></a>    
<a name="3247"></a>    /* 
<a name="3248"></a>     *   Display the corresponding error message (which will be a request to
<a name="3249"></a>     *   specify the missing object.
<a name="3250"></a>     */
<a name="3251"></a>    err.display();
<a name="3252"></a>    
<a name="3253"></a>    /*  
<a name="3254"></a>     *   Set the Parser's question property to a question asking for this
<a name="3255"></a>     *   missing object, so that the Parser is prepared to treat the next input
<a name="3256"></a>     *   as an answer to this question.
<a name="3257"></a>     */
<a name="3258"></a>    Parser.question = new ParseErrorQuestion(err);   
<a name="3259"></a>        
<a name="3260"></a>    
<a name="3261"></a>    /* Skip to the next command line so the player can enter a response */
<a name="3262"></a>    abort;        
<a name="3263"></a>}
<a name="3264"></a>
<a name="3265"></a>/* 
<a name="3266"></a> *   This function displays msg, which should be a message inviting the player to choose a suitable
<a name="3267"></a> *   object for action in role (DirectObject, IndirectObject or AccessoryObject). The action will
<a name="3268"></a> *   then be performed using the selected object in role.
<a name="3269"></a> */
<a name="3270"></a>askChooseObject(action, role, msg)
<a name="3271"></a>{
<a name="3272"></a>    /* 
<a name="3273"></a>     *   Store the current objects of the current action in the new action, in
<a name="3274"></a>     *   case action.scoreObjects() needs to refer to them below.
<a name="3275"></a>     */
<a name="3276"></a>    action.curDobj = gDobj;
<a name="3277"></a>    action.curIobj = gIobj;
<a name="3278"></a>    action.curAobj = gAobj;
<a name="3279"></a>    
<a name="3280"></a>    /* Make action the current action for the current Command. */
<a name="3281"></a>    gCommand.action = action;
<a name="3282"></a>    gCommand.dobj = (role == DirectObject ? nil : gDobj);
<a name="3283"></a>    gCommand.iobj = (role == IndirectObject ? nil : gIobj);
<a name="3284"></a>    gCommand.acc = (role == AccessoryObject ? nil : gAobj);
<a name="3285"></a>    
<a name="3286"></a>    if(role == DirectObject)
<a name="3287"></a>    {
<a name="3288"></a>        gCommand.dobjNPs = [];
<a name="3289"></a>        gCommand.dobjs = new Vector();        
<a name="3290"></a>    }
<a name="3291"></a>    
<a name="3292"></a>    if(role == IndirectObject)
<a name="3293"></a>    {
<a name="3294"></a>        gCommand.iobjNPs = [];
<a name="3295"></a>        gCommand.iobjs = new Vector();        
<a name="3296"></a>    }
<a name="3297"></a>    
<a name="3298"></a>    if(role == AccessoryObject)
<a name="3299"></a>    {
<a name="3300"></a>        gCommand.accNPs = [];
<a name="3301"></a>        gCommand.accs = new Vector();        
<a name="3302"></a>    }
<a name="3303"></a>    
<a name="3304"></a>    /* 
<a name="3305"></a>     *   Make the action the original action for the current Command; we need to
<a name="3306"></a>     *   do this because otherwise the Command object will overwrite our new
<a name="3307"></a>     *   action with its original one before we're done.
<a name="3308"></a>     */
<a name="3309"></a>    gCommand.originalAction = action;
<a name="3310"></a>  
<a name="3311"></a>    /* 
<a name="3312"></a>     *   Slot the new action's verbRule into the Command's verbProd, so that the
<a name="3313"></a>     *   Command has a verbProd appropriate to the action.
<a name="3314"></a>     */
<a name="3315"></a>    gCommand.verbProd = action.verbRule;
<a name="3316"></a>    
<a name="3317"></a>    local err = new EmptyNounError(gCommand, role);
<a name="3318"></a>    
<a name="3319"></a>    say(msg);
<a name="3320"></a>    
<a name="3321"></a>    Parser.question = new ParseErrorQuestion(err);
<a name="3322"></a>    
<a name="3323"></a>    abort;
<a name="3324"></a>}
<a name="3325"></a>
<a name="3326"></a>//------------------------------------------------------------------------------
<a name="3327"></a>
<a name="3328"></a>/*  
<a name="3329"></a> *   Verify Results: objects of this class are created by macros like
<a name="3330"></a> *   logicalRank() and illogical() that are used in verify routines and stored
<a name="3331"></a> *   in the verTab table of the current action.
<a name="3332"></a> */
<a name="3333"></a>class VerifyResult: object
<a name="3334"></a>    /* 
<a name="3335"></a>     *   Our resultRank; the lower this number the less likely it is that this
<a name="3336"></a>     *   action could succeed, or the more illogical it is.
<a name="3337"></a>     */
<a name="3338"></a>    resultRank = 0
<a name="3339"></a>    
<a name="3340"></a>    /* 
<a name="3341"></a>     *   The error message to display if this verify result prevents an action
<a name="3342"></a>     *   from going ahead.
<a name="3343"></a>     */
<a name="3344"></a>    errMsg = ''
<a name="3345"></a>    
<a name="3346"></a>    /* Is the action allowed to proceed according to this verify result? */
<a name="3347"></a>    allowAction = true
<a name="3348"></a>    
<a name="3349"></a>    /* Can this action be performed as an implicit action? */
<a name="3350"></a>    allowImplicit = true
<a name="3351"></a>    
<a name="3352"></a>    /* The object to which this verify result refers */
<a name="3353"></a>    myObj = nil
<a name="3354"></a>    
<a name="3355"></a>    /* The constructor for creating a new verify result. */
<a name="3356"></a>    construct(score_, errmsg_, allowAction_, myObj_, allowImplicit_ = true)
<a name="3357"></a>    {
<a name="3358"></a>        resultRank = score_;
<a name="3359"></a>        errMsg = errmsg_;
<a name="3360"></a>        allowAction = allowAction_;
<a name="3361"></a>        myObj = myObj_;
<a name="3362"></a>        allowImplicit = allowImplicit_;
<a name="3363"></a>    }
<a name="3364"></a>;
<a name="3365"></a>
<a name="3366"></a>//------------------------------------------------------------------------------
<a name="3367"></a>
<a name="3368"></a>/* Note the objects in objlist as potential pronoun antecedents */
<a name="3369"></a>notePronounAntecedent([objlist])
<a name="3370"></a>{
<a name="3371"></a>    local itList = [];
<a name="3372"></a>    local themList = [];
<a name="3373"></a>    local himList = [];
<a name="3374"></a>    local herList = [];
<a name="3375"></a>    
<a name="3376"></a>    /* 
<a name="3377"></a>     *   Go through each object in objlist and add it to the appropriate pronoun
<a name="3378"></a>     *   list
<a name="3379"></a>     */
<a name="3380"></a>    foreach(local cur in objlist)
<a name="3381"></a>    {
<a name="3382"></a>        /* 
<a name="3383"></a>         *   If we refer to a SubComponent, we're really referring to its
<a name="3384"></a>         *   location
<a name="3385"></a>         */        
<a name="3386"></a>        if(cur.ofKind(SubComponent) &amp;&amp; cur.location)
<a name="3387"></a>            cur = cur.location;
<a name="3388"></a>        
<a name="3389"></a>        /* If the object is plural or gender neutral, it's a possible antecedent for 'them' */
<a name="3390"></a>        if(cur.plural || cur.ambiguouslyPlural || cur.isGenderNeutral)
<a name="3391"></a>            themList += cur;
<a name="3392"></a>        
<a name="3393"></a>        /* 
<a name="3394"></a>         *   Add the object and any of its facets to the himList, herList and
<a name="3395"></a>         *   itList according to whether it's isHim, isHer or isIt property is
<a name="3396"></a>         *   true.
<a name="3397"></a>         */
<a name="3398"></a>        local lst = valToList(cur.getFacets) + cur;
<a name="3399"></a>        
<a name="3400"></a>        if(cur.isHim)
<a name="3401"></a>        {   
<a name="3402"></a>            for(local obj in lst)
<a name="3403"></a>                himList += obj;
<a name="3404"></a>        }
<a name="3405"></a>        
<a name="3406"></a>        if(cur.isHer)
<a name="3407"></a>        {
<a name="3408"></a>            for(local obj in lst)
<a name="3409"></a>                herList += obj;
<a name="3410"></a>        }
<a name="3411"></a>        
<a name="3412"></a>        if(cur.isIt &amp;&amp; (!cur.plural || cur.ambiguouslyPlural))
<a name="3413"></a>        {
<a name="3414"></a>            for(local obj in lst)
<a name="3415"></a>                itList += obj;        
<a name="3416"></a>        }
<a name="3417"></a>                
<a name="3418"></a>    }
<a name="3419"></a>    
<a name="3420"></a>    /* 
<a name="3421"></a>     *   If any of the lists have anything in them, use them to set the
<a name="3422"></a>     *   antecedent list on the corresponding pronoun.
<a name="3423"></a>     */
<a name="3424"></a>    if(themList.length &gt; 0)
<a name="3425"></a>        Them.setAntecedents(themList);
<a name="3426"></a>    if(itList.length &gt; 0)
<a name="3427"></a>        It.setAntecedents(itList);
<a name="3428"></a>    if(herList.length  &gt; 0)
<a name="3429"></a>        Her.setAntecedents(herList);
<a name="3430"></a>    if(himList.length &gt; 0)
<a name="3431"></a>        Him.setAntecedents(himList);
<a name="3432"></a>        
<a name="3433"></a>    
<a name="3434"></a>}
<a name="3435"></a>
<a name="3436"></a>/* The remainder of this file contains code  "borrowed" from the adv3 library */
<a name="3437"></a>
<a name="3438"></a>/* ------------------------------------------------------------------------ */
<a name="3439"></a>/*
<a name="3440"></a> *   PreSaveObject - every instance of this class is notified, via its
<a name="3441"></a> *   execute() method, just before we save the game.  This uses the
<a name="3442"></a> *   ModuleExecObject framework, so the sequencing lists (execBeforeMe,
<a name="3443"></a> *   execAfterMe) can be used to control relative ordering of execution
<a name="3444"></a> *   among instances.  
<a name="3445"></a> */
<a name="3446"></a>class PreSaveObject: ModuleExecObject
<a name="3447"></a>    /*
<a name="3448"></a>     *   Each instance must override execute() with its specific pre-save
<a name="3449"></a>     *   code. 
<a name="3450"></a>     */
<a name="3451"></a>;
<a name="3452"></a>
<a name="3453"></a>/*
<a name="3454"></a> *   PostRestoreObject - every instance of this class is notified, via its
<a name="3455"></a> *   execute() method, immediately after we restore the game. 
<a name="3456"></a> */
<a name="3457"></a>class PostRestoreObject: ModuleExecObject
<a name="3458"></a>    /* 
<a name="3459"></a>     *   note: each instance must override execute() with its post-restore
<a name="3460"></a>     *   code 
<a name="3461"></a>     */
<a name="3462"></a>
<a name="3463"></a>    /*
<a name="3464"></a>     *   The "restore code," which is the (normally integer) value passed
<a name="3465"></a>     *   as the second argument to restoreGame().  The restore code gives
<a name="3466"></a>     *   us some idea of what triggered the restoration.  By default, we
<a name="3467"></a>     *   define the following restore codes:
<a name="3468"></a>     *   
<a name="3469"></a>     *   1 - the system is restoring a game as part of interpreter
<a name="3470"></a>     *   startup, usually because the user explicitly specified a game to
<a name="3471"></a>     *   restore on the interpreter command line or via a GUI shell
<a name="3472"></a>     *   mechanism, such as double-clicking on a saved game file from the
<a name="3473"></a>     *   desktop.
<a name="3474"></a>     *   
<a name="3475"></a>     *   2 - the user is explicitly restoring a game via a RESTORE command.
<a name="3476"></a>     *   
<a name="3477"></a>     *   Games and library extensions can use their own additional restore
<a name="3478"></a>     *   codes in their calls to restoreGame().  
<a name="3479"></a>     */
<a name="3480"></a>    restoreCode = nil
<a name="3481"></a>;
<a name="3482"></a>
<a name="3483"></a>/*
<a name="3484"></a> *   PreRestartObject - every instance of this class is notified, via its
<a name="3485"></a> *   execute() method, just before we restart the game (with a RESTART
<a name="3486"></a> *   command, for example). 
<a name="3487"></a> */
<a name="3488"></a>class PreRestartObject: ModuleExecObject
<a name="3489"></a>    /* 
<a name="3490"></a>     *   Each instance must override execute() with its specific
<a name="3491"></a>     *   pre-restart code.  
<a name="3492"></a>     */
<a name="3493"></a>;
<a name="3494"></a>
<a name="3495"></a>/*
<a name="3496"></a> *   PostUndoObject - every instance of this class is notified, via its
<a name="3497"></a> *   execute() method, immediately after we perform an 'undo' command. 
<a name="3498"></a> */
<a name="3499"></a>class PostUndoObject: ModuleExecObject
<a name="3500"></a>    /* 
<a name="3501"></a>     *   Each instance must override execute() with its specific post-undo
<a name="3502"></a>     *   code.  
<a name="3503"></a>     */
<a name="3504"></a>;
<a name="3505"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 20/10/2025 from adv3Lite version 2.2.1.1</div>
</body>
</html>

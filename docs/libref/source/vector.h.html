<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>vector.h</title></head><body>
<table class=ban><tr><td><h1>vector.h</h1><td align=right><a href="../file/vector.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This header defines the Vector intrinsic class.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>
<a name="13"></a>/* include our base class definition */
<a name="14"></a>#include "systype.h"
<a name="15"></a>
<a name="16"></a>
<a name="17"></a>/*
<a name="18"></a> *   The Vector intrinsic class provides a varying-length array type.
<a name="19"></a> *   Vectors can be expanded dynamically, and values within a vector can be
<a name="20"></a> *   changed.  (In contrast, List is a constant type: a value within a list
<a name="21"></a> *   cannot be changed, and new values can't be added to a list.  Any
<a name="22"></a> *   manipulation of a List results in a new, separate List object, leaving
<a name="23"></a> *   the original unchanged.  Vector allows new values to be added and
<a name="24"></a> *   existing values to be changed in place, without creating a new object.)
<a name="25"></a> */
<a name="26"></a>intrinsic class Vector 'vector/030005': Collection
<a name="27"></a>{
<a name="28"></a>    /* 
<a name="29"></a>     *   Create a list with the same elements as the vector.  If 'start' is
<a name="30"></a>     *   specified, it's the index of the first element we store; we'll
<a name="31"></a>     *   store elements starting at index 'start'.  If 'cnt' is specified,
<a name="32"></a>     *   it gives the maximum number of elements for the new list; by
<a name="33"></a>     *   default, we'll store all of the elements from 'start' to the last
<a name="34"></a>     *   element.  
<a name="35"></a>     */
<a name="36"></a>    toList(start?, cnt?);
<a name="37"></a>
<a name="38"></a>    /* get the number of elements in the vector */
<a name="39"></a>    length();
<a name="40"></a>
<a name="41"></a>    /* 
<a name="42"></a>     *   Copy from another vector or list.  Elements are copied from the
<a name="43"></a>     *   source vector or list starting at the element given by 'src_start',
<a name="44"></a>     *   and are copied into 'self' starting at the index given by
<a name="45"></a>     *   'dst_start'.  At most 'cnt' values are copied, but we stop when we
<a name="46"></a>     *   reach the last element of either the source or destination values.
<a name="47"></a>     *   If either index is negative, it counts from the end of the vector:
<a name="48"></a>     *   -1 is the last element, -2 is the second to last, and so on.  
<a name="49"></a>     */
<a name="50"></a>    copyFrom(src, src_start, dst_start, cnt);
<a name="51"></a>
<a name="52"></a>    /* 
<a name="53"></a>     *   Fill with a given value, starting at the given element (the first
<a name="54"></a>     *   element if not specified), and running for the given number of
<a name="55"></a>     *   elements (the remaining existing elements of the vector, if not
<a name="56"></a>     *   specified).  The vector is expanded if necessary.  A negative
<a name="57"></a>     *   starting index counts backwards from the last element.  
<a name="58"></a>     */
<a name="59"></a>    fillValue(val, start?, cnt?);
<a name="60"></a>
<a name="61"></a>    /*
<a name="62"></a>     *   Select a subset of the vector.  Returns a new vector consisting
<a name="63"></a>     *   only of the elements of this vector for which the callback function
<a name="64"></a>     *   returns true.  
<a name="65"></a>     */
<a name="66"></a>    subset(func);
<a name="67"></a>
<a name="68"></a>    /*
<a name="69"></a>     *   Apply a callback function to each element of the vector.  For each
<a name="70"></a>     *   element of the vector, invokes the callback, and replaces the
<a name="71"></a>     *   element with the return value of the callback.  Modifies the vector
<a name="72"></a>     *   in-place, and returns 'self'.  
<a name="73"></a>     */
<a name="74"></a>    applyAll(func);
<a name="75"></a>
<a name="76"></a>    /* 
<a name="77"></a>     *   Find the first element for which the given condition is true.
<a name="78"></a>     *   Apply the callback function (which encodes the condition to
<a name="79"></a>     *   evaluate) to each element in turn, starting with the first.  For
<a name="80"></a>     *   each element, if the callback returns nil, proceed to the next
<a name="81"></a>     *   element; otherwise, stop and return the index of the element.  If
<a name="82"></a>     *   the callback never returns true for any element, we'll return nil.  
<a name="83"></a>     */
<a name="84"></a>    indexWhich(cond);
<a name="85"></a>
<a name="86"></a>    /* 
<a name="87"></a>     *   Invoke the callback func(val) on each element, in order from first
<a name="88"></a>     *   to last.  No return value.  
<a name="89"></a>     */
<a name="90"></a>    forEach(func);
<a name="91"></a>
<a name="92"></a>    /* 
<a name="93"></a>     *   Invoke the callback func(index, val) on each element, in order from
<a name="94"></a>     *   first to last.  No return value.  
<a name="95"></a>     */
<a name="96"></a>    forEachAssoc(func);
<a name="97"></a>
<a name="98"></a>    /*
<a name="99"></a>     *   Apply the callback function to each element of this vector, and
<a name="100"></a>     *   return a new vector consisting of the results.  Effectively maps
<a name="101"></a>     *   the vector to a new vector using the given function, leaving the
<a name="102"></a>     *   original vector unchanged.  
<a name="103"></a>     */
<a name="104"></a>    mapAll(func);
<a name="105"></a>
<a name="106"></a>    /* get the index of the first match for the given value */
<a name="107"></a>    indexOf(val);
<a name="108"></a>
<a name="109"></a>    /* 
<a name="110"></a>     *   Find the first element for which the given condition is true, and
<a name="111"></a>     *   return the value of the element.  
<a name="112"></a>     */
<a name="113"></a>    valWhich(cond);
<a name="114"></a>
<a name="115"></a>    /* find the last element with the given value, and return its index */
<a name="116"></a>    lastIndexOf(val);
<a name="117"></a>
<a name="118"></a>    /* 
<a name="119"></a>     *   Find the last element for which the condition is true, and return
<a name="120"></a>     *   the index of the element.  Applies the callback to each element in
<a name="121"></a>     *   turn, starting with the last element and working backwards.  For
<a name="122"></a>     *   each element, if the callback returns nil, proceeds to the previous
<a name="123"></a>     *   element; otherwise, stops and returns the index of the element.  If
<a name="124"></a>     *   the callback never returns true for any element, we'll return nil.  
<a name="125"></a>     */
<a name="126"></a>    lastIndexWhich(cond);
<a name="127"></a>
<a name="128"></a>    /* 
<a name="129"></a>     *   Find the last element for which the condition is true, and return
<a name="130"></a>     *   the value of the element 
<a name="131"></a>     */
<a name="132"></a>    lastValWhich(cond);
<a name="133"></a>
<a name="134"></a>    /* count the number of elements with the given value */
<a name="135"></a>    countOf(val);
<a name="136"></a>
<a name="137"></a>    /* count the number of elements for which the callback returns true */
<a name="138"></a>    countWhich(cond);
<a name="139"></a>
<a name="140"></a>    /* create a new vector consisting of the unique elements of this vector */
<a name="141"></a>    getUnique();
<a name="142"></a>
<a name="143"></a>    /*
<a name="144"></a>     *   append the elements of the list or vector 'val' to the elements of
<a name="145"></a>     *   this vector, then remove repeated elements in the result; returns a
<a name="146"></a>     *   new vector with the unique elements of the combination 
<a name="147"></a>     */
<a name="148"></a>    appendUnique(val);
<a name="149"></a>
<a name="150"></a>    /* 
<a name="151"></a>     *   Sort the vector in place; returns 'self'.  If the 'descending'
<a name="152"></a>     *   flag is provided and is not nil, we'll sort the vector in
<a name="153"></a>     *   descending order rather than ascending order.
<a name="154"></a>     *   
<a name="155"></a>     *   If the 'comparisonFunction' argument is provided, it must be a
<a name="156"></a>     *   callback function; the callback takes two arguments, and returns
<a name="157"></a>     *   an integer less than zero if the first argument value is less
<a name="158"></a>     *   than the second, zero if they're equal, and an integer greater
<a name="159"></a>     *   than zero if the first is greater than the second.  If no
<a name="160"></a>     *   'comparisonFunction' argument is provided, or it's provided and
<a name="161"></a>     *   its value is nil, we'll simply compare the vector elements as
<a name="162"></a>     *   ordinary values.  The comparison function can be provided for
<a name="163"></a>     *   caller-defined orderings, such as ordering a set of objects.  
<a name="164"></a>     */
<a name="165"></a>    sort(descending?, comparisonFunction?);
<a name="166"></a>
<a name="167"></a>    /* 
<a name="168"></a>     *   Set the length - if this is shorter than the current length,
<a name="169"></a>     *   existing items will be discarded; if it's longer, the newly added
<a name="170"></a>     *   slots will be set to nil.  Returns 'self'.
<a name="171"></a>     */
<a name="172"></a>    setLength(newElementCount);
<a name="173"></a>
<a name="174"></a>    /* 
<a name="175"></a>     *   Insert one or more elements at the given index.  If the starting
<a name="176"></a>     *   index is 1, the elements will be inserted before the first existing
<a name="177"></a>     *   element.  If the index is one higher than the number of elements,
<a name="178"></a>     *   the elements will be inserted after all existing elements.  A
<a name="179"></a>     *   negative starting index counts from the end of the vector: -1 is the
<a name="180"></a>     *   last element, -2 is the second to last, and so on.  A zero starting
<a name="181"></a>     *   index inserts after the last existing element.
<a name="182"></a>     *   
<a name="183"></a>     *   Note that a list value argument will simply be inserted as a single
<a name="184"></a>     *   element.
<a name="185"></a>     *   
<a name="186"></a>     *   Returns 'self'.  
<a name="187"></a>     */
<a name="188"></a>    insertAt(startingIndex, val, ...);
<a name="189"></a>
<a name="190"></a>    /*
<a name="191"></a>     *   Delete the element at the given index, reducing the length of the
<a name="192"></a>     *   vector by one element.  If 'index' is negative, it counts from the
<a name="193"></a>     *   end of the vector: -1 is the last element, -2 is the second to last,
<a name="194"></a>     *   and so on.  Returns 'self'.  
<a name="195"></a>     */
<a name="196"></a>    removeElementAt(index);
<a name="197"></a>
<a name="198"></a>    /*
<a name="199"></a>     *   Delete the range of elements starting at startingIndex and ending at
<a name="200"></a>     *   endingIndex.  The elements at the ends of the range are included in
<a name="201"></a>     *   the deletion.  If startingIndex == endingIndex, only one element is
<a name="202"></a>     *   removed.  If either index is negative, it counts backwards from the
<a name="203"></a>     *   last element: -1 is the last element, -2 is the second to last, and
<a name="204"></a>     *   so on.  The length of the vector is reduced by the number of
<a name="205"></a>     *   elements removed.  Returns 'self'.  
<a name="206"></a>     */
<a name="207"></a>    removeRange(startingIndex, endingIndex);
<a name="208"></a>
<a name="209"></a>    /* 
<a name="210"></a>     *   Append an element to the vector.  This works just like insertAt()
<a name="211"></a>     *   with a starting index one higher than the length of the vector.
<a name="212"></a>     *   This has almost the same effect as the '+' operator, but treats a
<a name="213"></a>     *   list value like any other value by simply inserting the list as a
<a name="214"></a>     *   single new element (rather than appending each item in the list
<a name="215"></a>     *   individually, as the '+' operator would).  
<a name="216"></a>     */
<a name="217"></a>    append(val);
<a name="218"></a>
<a name="219"></a>    /*
<a name="220"></a>     *   Prepend an element.  This works like insertAt() with a starting
<a name="221"></a>     *   index of 1. 
<a name="222"></a>     */
<a name="223"></a>    prepend(val);
<a name="224"></a>
<a name="225"></a>    /*
<a name="226"></a>     *   Append all elements from a list or vector.  This works like
<a name="227"></a>     *   append(val), except that if 'val' is a list or vector, the elements
<a name="228"></a>     *   of 'val' will be appended individually, like the '+' operator does.
<a name="229"></a>     *   The difference between this method and the '+' operator is that
<a name="230"></a>     *   this method modifies this Vector by adding the new elements
<a name="231"></a>     *   directly to the existing Vector object, whereas the '+' operator
<a name="232"></a>     *   creates a new Vector to store the result.  
<a name="233"></a>     */
<a name="234"></a>    appendAll(val);
<a name="235"></a>
<a name="236"></a>    /*
<a name="237"></a>     *   Remove an element by value.  Each element of the vector matching
<a name="238"></a>     *   the given value is removed.  The vector is modified in-place.  The
<a name="239"></a>     *   return value is 'self'.  
<a name="240"></a>     */
<a name="241"></a>    removeElement(val);
<a name="242"></a>
<a name="243"></a>    /*
<a name="244"></a>     *   Splice new values into the vector.  Deletes the 'del' elements
<a name="245"></a>     *   starting at 'idx', then inserts the extra arguments in their place.
<a name="246"></a>     *   Updates the vector in place.  To insert items without deleting
<a name="247"></a>     *   anything, pass 0 for 'del'.  To delete items without inserting
<a name="248"></a>     *   anything, omit any additional arguments.  Returns 'self'.
<a name="249"></a>     */
<a name="250"></a>    splice(idx, del, ...);
<a name="251"></a>
<a name="252"></a>    /*
<a name="253"></a>     *   Combine the vector elements into a string.  This converts each
<a name="254"></a>     *   element into a string value using the usual default conversions (or
<a name="255"></a>     *   throws an error if string conversion isn't possible), then
<a name="256"></a>     *   concatenates the values together and returns the result.  If
<a name="257"></a>     *   'separator' is provided, it's a string that's interposed between
<a name="258"></a>     *   elements; if this is omitted, the elements are concatenated together
<a name="259"></a>     *   with no extra characters in between.  
<a name="260"></a>     */
<a name="261"></a>    join(sep?);
<a name="262"></a>
<a name="263"></a>    /*
<a name="264"></a>     *   Class method: Generate a new Vector.  'func' is a callback function,
<a name="265"></a>     *   which can take zero or one argument.  'n' is the number of elements
<a name="266"></a>     *   for the new list.  For each element, 'func' is invoked as func() if
<a name="267"></a>     *   it takes no arguments, or func(idx) if it takes one argument, where
<a name="268"></a>     *   'idx' is the index of the element being generated.  The return value
<a name="269"></a>     *   of the call to 'func' is stored as the list element.  The method
<a name="270"></a>     *   returns the resulting list.  For example, a vector of the first ten
<a name="271"></a>     *   even positive integers: Vector.generate({i: i*2}, 10).  
<a name="272"></a>     */
<a name="273"></a>    static generate(func, n);
<a name="274"></a>
<a name="275"></a>    /*
<a name="276"></a>     *   Get the index of the element with the minimum value.  If 'func' is
<a name="277"></a>     *   missing, this simply returns the index of the element with the
<a name="278"></a>     *   smallest value, comparing the element values as though using the '&gt;'
<a name="279"></a>     *   and '&lt;' operators.  If 'func' is specified, it must be a function;
<a name="280"></a>     *   it's called as func(x) for each element's value, and the result of
<a name="281"></a>     *   the overall call is the index of the element for which func(x)
<a name="282"></a>     *   returns the smallest value.  For example, if you have a vector v
<a name="283"></a>     *   containing string elements, v.indexOfMin({x: x.length()}) returns
<a name="284"></a>     *   the index of the shortest string.  
<a name="285"></a>     */
<a name="286"></a>    indexOfMin(func?);
<a name="287"></a>
<a name="288"></a>    /*
<a name="289"></a>     *   Get the minimum element value.  If 'func' is missing, this simply
<a name="290"></a>     *   returns the smallest element value.  If 'func' is specified, it must
<a name="291"></a>     *   be a function; it's called as func(x) for each element value x, and
<a name="292"></a>     *   the result of the overall method call is the element value x that
<a name="293"></a>     *   minimizes func(x).  For example, if v is a vector containing string
<a name="294"></a>     *   elements, v.minVal({x: x.length()}) returns the shortest string.  
<a name="295"></a>     */
<a name="296"></a>    minVal(func?);
<a name="297"></a>
<a name="298"></a>    /*
<a name="299"></a>     *   Get the index of the element the maximum value.  If 'func' is
<a name="300"></a>     *   missing, this simply returns the index of the element with the
<a name="301"></a>     *   largest value, comparing the element values as though using the '&gt;'
<a name="302"></a>     *   and '&lt;' operators.  If 'func' is specified, it must be a function;
<a name="303"></a>     *   it's called as func(x) for each element value x, and the result of
<a name="304"></a>     *   the overall call is the index of the element for which func(x)
<a name="305"></a>     *   returns the greatest value.  For example, if you have a vector v
<a name="306"></a>     *   containing string elements, v.indexOfMax({x: x.length()}) returns
<a name="307"></a>     *   the index of the longest string.  
<a name="308"></a>     */
<a name="309"></a>    indexOfMax(func?);
<a name="310"></a>
<a name="311"></a>    /*
<a name="312"></a>     *   Get the maximum element value.  If 'func' is missing, this returns
<a name="313"></a>     *   the largest element value.  If 'func' is specified, it must be a
<a name="314"></a>     *   function; it's called as func(x) for each element value x, and the
<a name="315"></a>     *   result of the overall method call is the element value x that
<a name="316"></a>     *   maximizes func(x).  For example, if v is a vector containing string
<a name="317"></a>     *   elements, v.minVal({x: x.length()}) returns the longest string.  
<a name="318"></a>     */
<a name="319"></a>    maxVal(func?);
<a name="320"></a>}
<a name="321"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

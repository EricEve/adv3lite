<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>array.h</title></head><body>
<table class=ban><tr><td><h1>array.h</h1><td align=right><a href="../file/array.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2002 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.  
<a name="7"></a> */
<a name="8"></a>
<a name="9"></a>#ifndef _ARRAY_H_
<a name="10"></a>#define _ARRAY_H_
<a name="11"></a>
<a name="12"></a>/*
<a name="13"></a> *   'Array' intrinsic class
<a name="14"></a> */
<a name="15"></a>intrinsic class Array 'array/030006'
<a name="16"></a>{
<a name="17"></a>    /* 
<a name="18"></a>     *   Create a list with the same elements as the array.  If 'start' is
<a name="19"></a>     *   specified, it's the index of the first element we store; we'll
<a name="20"></a>     *   store elements starting at index 'start'.  If 'cnt' is specified,
<a name="21"></a>     *   it gives the maximum number of elements for the new list; by
<a name="22"></a>     *   default, we'll store all of the elements from 'start' to the last
<a name="23"></a>     *   element.  
<a name="24"></a>     */
<a name="25"></a>    toList(start?, cnt?);
<a name="26"></a>
<a name="27"></a>    /* get the number of elements in the array */
<a name="28"></a>    length();
<a name="29"></a>
<a name="30"></a>    /* 
<a name="31"></a>     *   Copy from another array or list.  Elements are copied from the
<a name="32"></a>     *   source array or list starting at the element given by
<a name="33"></a>     *   'src_start', and are copied into 'self' starting at the index
<a name="34"></a>     *   given by 'dst_start'.  At most 'cnt' values are copied, but we
<a name="35"></a>     *   stop when we reach the last element of either the source or
<a name="36"></a>     *   destination values.  
<a name="37"></a>     */
<a name="38"></a>    copyFrom(src, src_start, dst_start, cnt);
<a name="39"></a>
<a name="40"></a>    /* 
<a name="41"></a>     *   fill with a given value, starting at the given element (the first
<a name="42"></a>     *   element if not specified), and running for the given number of
<a name="43"></a>     *   elements (the remaining elements of the array, if not not
<a name="44"></a>     *   specified) 
<a name="45"></a>     */
<a name="46"></a>    fillValue(val, start?, cnt?);
<a name="47"></a>
<a name="48"></a>    /*
<a name="49"></a>     *   Select a subset of the array.  Returns a new array consisting
<a name="50"></a>     *   only of the elements of this array for which the callback
<a name="51"></a>     *   function returns true.  
<a name="52"></a>     */
<a name="53"></a>    subset(func);
<a name="54"></a>
<a name="55"></a>    /*
<a name="56"></a>     *   Apply a callback function to each element of the array.  For each
<a name="57"></a>     *   element of the array, invokes the callback, and replaces the
<a name="58"></a>     *   element with the return value of the callback.  Modifies the
<a name="59"></a>     *   array in-place, and returns 'self'. 
<a name="60"></a>     */
<a name="61"></a>    applyAll(func);
<a name="62"></a>
<a name="63"></a>    /* 
<a name="64"></a>     *   Find the first element for which the given condition is true.
<a name="65"></a>     *   Apply the callback function (which encodes the condition to
<a name="66"></a>     *   evaluate) to each element in turn, starting with the first.  For
<a name="67"></a>     *   each element, if the callback returns nil, proceed to the next
<a name="68"></a>     *   element; otherwise, stop and return the index of the element.  If
<a name="69"></a>     *   the callback never returns true for any element, we'll return
<a name="70"></a>     *   nil.  
<a name="71"></a>     */
<a name="72"></a>    indexWhich(cond);
<a name="73"></a>
<a name="74"></a>    /* 
<a name="75"></a>     *   Invoke the callback on each element, in order from first to last.
<a name="76"></a>     *   No return value.  
<a name="77"></a>     */
<a name="78"></a>    forEach(func);
<a name="79"></a>
<a name="80"></a>    /*
<a name="81"></a>     *   Apply the callback function to each element of this array, and
<a name="82"></a>     *   return a new array consisting of the results.  Effectively maps
<a name="83"></a>     *   the array to a new array using the given function, leaving the
<a name="84"></a>     *   original array unchanged.  
<a name="85"></a>     */
<a name="86"></a>    mapAll(func);
<a name="87"></a>
<a name="88"></a>    /* get the index of the first match for the given value */
<a name="89"></a>    indexOf(val);
<a name="90"></a>
<a name="91"></a>    /* 
<a name="92"></a>     *   Find the first element for which the given condition is true, and
<a name="93"></a>     *   return the value of the element.  
<a name="94"></a>     */
<a name="95"></a>    valWhich(cond);
<a name="96"></a>
<a name="97"></a>    /* find the last element with the given value, and return its index */
<a name="98"></a>    lastIndexOf(val);
<a name="99"></a>
<a name="100"></a>    /* 
<a name="101"></a>     *   Find the last element for which the condition is true, and return
<a name="102"></a>     *   the index of the element.  Applies the callback to each element
<a name="103"></a>     *   in turn, starting with the last element and working backwards.
<a name="104"></a>     *   For each element, if the callback returns nil, proceeds to the
<a name="105"></a>     *   previous element; otherwise, stops and returns the index of the
<a name="106"></a>     *   element.  If the callback never returns true for any element,
<a name="107"></a>     *   we'll return nil.  
<a name="108"></a>     */
<a name="109"></a>    lastIndexWhich(cond);
<a name="110"></a>
<a name="111"></a>    /* 
<a name="112"></a>     *   Find the last element for which the condition is true, and return
<a name="113"></a>     *   the value of the element 
<a name="114"></a>     */
<a name="115"></a>    lastValWhich(cond);
<a name="116"></a>
<a name="117"></a>    /* count the number of elements with the given value */
<a name="118"></a>    countOf(val);
<a name="119"></a>
<a name="120"></a>    /* count the number of elements for which the callback returns true */
<a name="121"></a>    countWhich(cond);
<a name="122"></a>
<a name="123"></a>    /* create a new array consisting of the unique elements of this array */
<a name="124"></a>    getUnique();
<a name="125"></a>
<a name="126"></a>    /*
<a name="127"></a>     *   append the elements of the list or array 'val' to the elements of
<a name="128"></a>     *   this array, then remove repeated elements in the result; returns
<a name="129"></a>     *   a new array with the unique elements of the combination 
<a name="130"></a>     */
<a name="131"></a>    appendUnique(val);
<a name="132"></a>
<a name="133"></a>    /* 
<a name="134"></a>     *   Sort the array in place; returns 'self'.  If the 'descending'
<a name="135"></a>     *   flag is provided and is not nil, we'll sort the array in
<a name="136"></a>     *   descending order rather than ascending order.
<a name="137"></a>     *   
<a name="138"></a>     *   If the 'comparisonFunction' argument is provided, it must be a
<a name="139"></a>     *   callback function; the callback takes two arguments, and returns
<a name="140"></a>     *   an integer less than zero if the first argument value is less
<a name="141"></a>     *   than the second, zero if they're equal, and an integer greater
<a name="142"></a>     *   than zero if the first is greater than the second.  If no
<a name="143"></a>     *   'comparisonFunction' argument is provided, or it's provided and
<a name="144"></a>     *   its value is nil, we'll simply compare the array elements as
<a name="145"></a>     *   ordinary values.  The comparison function can be provided for
<a name="146"></a>     *   caller-defined orderings, such as ordering a set of objects.  
<a name="147"></a>     */
<a name="148"></a>    sort(descending?, comparisonFunction?);
<a name="149"></a>
<a name="150"></a>    /* 
<a name="151"></a>     *   Append an element to the vector.  This works just like insertAt()
<a name="152"></a>     *   with a starting index one higher than the length of the vector.
<a name="153"></a>     *   This has almost the same effect as the '+' operator, but treats a
<a name="154"></a>     *   list value like any other value by simply inserting the list as a
<a name="155"></a>     *   single new element (rather than appending each item in the list
<a name="156"></a>     *   individually, as the '+' operator would).  
<a name="157"></a>     */
<a name="158"></a>    append(val);
<a name="159"></a>}
<a name="160"></a>
<a name="161"></a>#endif /* _ARRAY_H_ */
<a name="162"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 07/01/2025 from adv3Lite version 2.1.1.8</div>
</body>
</html>

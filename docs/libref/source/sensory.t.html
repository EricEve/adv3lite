<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>sensory.t</title></head><body>
<table class=ban><tr><td><h1>sensory.t</h1><td align=right><a href="../file/sensory.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>#include &lt;tads.h&gt;
<a name="4"></a>#include "advlite.h"
<a name="5"></a>
<a name="6"></a>/*
<a name="7"></a> *   sensory.t
<a name="8"></a> *
<a name="9"></a> *   The SENSORY EXTENSION is intended for use with the adv3Lite library. It
<a name="10"></a> *   adds slightly more sophisticated handling for smells and sounds, as well as
<a name="11"></a> *   a new SensoryEvent class which can be useful for making actors and other
<a name="12"></a> *   objects respond to sensory events.
<a name="13"></a> *
<a name="14"></a> *   VERSION 2
<a name="15"></a> *.  19-Jul-14
<a name="16"></a> *
<a name="17"></a> *   Usage: include this extension after the adv3Lite library but before your
<a name="18"></a> *   own game-specific files. Make sure that events.t is also included in your
<a name="19"></a> *   build.
<a name="20"></a> */
<a name="21"></a>
<a name="22"></a>
<a name="23"></a>sensoryID: ModuleID
<a name="24"></a>    name = 'Sensory'
<a name="25"></a>    byline = 'by Eric Eve'
<a name="26"></a>    htmlByline = 'by Eric Eve'
<a name="27"></a>    version = '2'    
<a name="28"></a>;
<a name="29"></a>
<a name="30"></a>property remoteSmellDesc;
<a name="31"></a>property remoteListenDesc;
<a name="32"></a>property tooFarAwayToHearMsg;
<a name="33"></a>property tooFarAwayToSmellMsg;
<a name="34"></a>
<a name="35"></a>
<a name="36"></a>/* 
<a name="37"></a> *   The SensoryEmanation class is the base class for sensory emanations such as
<a name="38"></a> *   smells and noises. [MODIFIED FOR SENSORY EXTENSION]
<a name="39"></a> */
<a name="40"></a>modify SensoryEmanation
<a name="41"></a>    
<a name="42"></a>    /* 
<a name="43"></a>     *   By default we vary our description according to whether the player
<a name="44"></a>     *   character can see the object whose sound or smell we represent. If you
<a name="45"></a>     *   don't these this variation, you can just override desc directly.
<a name="46"></a>     *   [MODIFIED FOR SENSORY EXTENSION]
<a name="47"></a>     */
<a name="48"></a>    desc
<a name="49"></a>    {
<a name="50"></a>        if(Q.canSee(gPlayerChar, location))
<a name="51"></a>            descWithSource;
<a name="52"></a>        else
<a name="53"></a>            descWithoutSource;
<a name="54"></a>    }
<a name="55"></a>    
<a name="56"></a>    /* 
<a name="57"></a>     *  Our description when the player character can see our source 
<a name="58"></a>     *  [DEFINED IN SENSORY EXTENSION]
<a name="59"></a>     */
<a name="60"></a>    descWithSource = nil
<a name="61"></a>    
<a name="62"></a>    /* 
<a name="63"></a>     *  Our description when the player character can't see our source 
<a name="64"></a>     *  [DEFINED IN SENSORY EXTENSION]
<a name="65"></a>     */
<a name="66"></a>    descWithoutSource = nil
<a name="67"></a>    
<a name="68"></a>    /*  
<a name="69"></a>     *   Are we actually emanating? We may not be if something stops us, e.g.
<a name="70"></a>     *   breaking a ticking clock [DEFINED IN SENSORY EXTENSION]
<a name="71"></a>     */
<a name="72"></a>    isEmanating = true
<a name="73"></a>    
<a name="74"></a>    /*  
<a name="75"></a>     *  If we're not emanating we can't be sensed at all, so we're hidden 
<a name="76"></a>     *  [DEFINED IN SENSORY EXTENSION]
<a name="77"></a>     */
<a name="78"></a>    isHidden = !isEmanating
<a name="79"></a>    
<a name="80"></a>    /* 
<a name="81"></a>     *   The emanate method is called on each turn that the player character can
<a name="82"></a>     *   sense us, and can be used to display a message announcing our presence,
<a name="83"></a>     *   such as "There's an awful stink here" or "A loud ticking noise comes
<a name="84"></a>     *   from somewhere. " [DEFINED IN SENSORY EXTENSION]
<a name="85"></a>     */
<a name="86"></a>    emanate() 
<a name="87"></a>    { 
<a name="88"></a>        /* If our schedule is nil (see below) we don't do anything at all */
<a name="89"></a>        if(schedule == nil)
<a name="90"></a>            return;
<a name="91"></a>        
<a name="92"></a>        /* Get the interval before we're due to show another message */
<a name="93"></a>        local interval = schedule[scheduleState];
<a name="94"></a>        
<a name="95"></a>        /* 
<a name="96"></a>         *   If this is nil, we don't want to show another message, so simply
<a name="97"></a>         *   end the routine here.
<a name="98"></a>         */
<a name="99"></a>        if(interval == nil)
<a name="100"></a>            return;
<a name="101"></a>        
<a name="102"></a>        /*  
<a name="103"></a>         *   If incrementing our emanation state by one makes it greater than
<a name="104"></a>         *   the its value when we last showed a message plus the interval to
<a name="105"></a>         *   the next one, show our emanation desc
<a name="106"></a>         */ 
<a name="107"></a>        if(++emanationState &gt;= lastEmanationTime + interval)
<a name="108"></a>        {
<a name="109"></a>            /* Display our emanation description */
<a name="110"></a>            emanationDesc();
<a name="111"></a>            
<a name="112"></a>            /* 
<a name="113"></a>             *   If we haven't reached the end of the emanation schedule yet,
<a name="114"></a>             *   increase our scheduleState by one.
<a name="115"></a>             */
<a name="116"></a>            if(nilToList(schedule).length &gt; scheduleState)
<a name="117"></a>                scheduleState++;
<a name="118"></a>        
<a name="119"></a>            /*  Note when we last displayed a message. */
<a name="120"></a>            lastEmanationTime = emanationState;
<a name="121"></a>            
<a name="122"></a>            /*  Note that the player character must now know about us. */
<a name="123"></a>            setKnown();
<a name="124"></a>        }
<a name="125"></a>    }
<a name="126"></a>    
<a name="127"></a>    /* 
<a name="128"></a>     *   The message to display to announce our presence. This is overridden on
<a name="129"></a>     *   our subclasses.[DEFINED IN SENSORY EXTENSION]
<a name="130"></a>     */
<a name="131"></a>    emanationDesc() { }
<a name="132"></a>    
<a name="133"></a>    /*  
<a name="134"></a>     *   A counter to keep track of when we're next due to display an emanation
<a name="135"></a>     *   message [DEFINED IN SENSORY EXTENSION]
<a name="136"></a>     */
<a name="137"></a>    emanationState = 0
<a name="138"></a>    
<a name="139"></a>    /*  
<a name="140"></a>     *  A counter to keep track of where we are in our emanation schedule. 
<a name="141"></a>     *  [DEFINED IN SENSORY EXTENSION]
<a name="142"></a>     */
<a name="143"></a>    scheduleState = 1
<a name="144"></a>    
<a name="145"></a>    /*  
<a name="146"></a>     *  The last time we emanated, relevant to when we started emanating 
<a name="147"></a>     *  [DEFINED IN SENSORY EXTENSION]
<a name="148"></a>     */
<a name="149"></a>    lastEmanationTime = 0
<a name="150"></a>    
<a name="151"></a>    /*  
<a name="152"></a>     *   Our emanation schedule. If this is just nil we won't show any emanation
<a name="153"></a>     *   meessages at all. Otherwise this should be a list of numbers. The first
<a name="154"></a>     *   number is the first interval between emanations, the second number the
<a name="155"></a>     *   second interval and so on. When we get to the end of the list we keep
<a name="156"></a>     *   using the last number in the list as the interval. If the last entry in
<a name="157"></a>     *   the list is nil we stop showing emanation messages. This can be used to
<a name="158"></a>     *   reduce the frequency of messages to model the player character becoming
<a name="159"></a>     *   less aware of us. [DEFINED IN SENSORY EXTENSION]
<a name="160"></a>     */
<a name="161"></a>    schedule = [1]
<a name="162"></a>
<a name="163"></a>    /*  Reset all out counters to their initial states [DEFINED IN SENSORY EXTENSION] */
<a name="164"></a>    reset()
<a name="165"></a>    {
<a name="166"></a>        emanationState = 0;
<a name="167"></a>        scheduleState = 1;
<a name="168"></a>        if(ofKind(Script))
<a name="169"></a>            curScriptState = 1;
<a name="170"></a>        lastEmanationTime = 0;
<a name="171"></a>    }
<a name="172"></a>       
<a name="173"></a>    /* 
<a name="174"></a>     *   The message to display when the player tries to do something with us
<a name="175"></a>     *   other than sense us. [DEFINED IN SENSORY EXTENSION]
<a name="176"></a>     */
<a name="177"></a>    notImportantMsg = BMsg(cannot do to sensory, '{I} {can\'t} do that to {a
<a name="178"></a>        cobj}. ')
<a name="179"></a>;
<a name="180"></a>
<a name="181"></a>/* An Odor is a SensoryEmanation representing a Smell [MODIFIED FOR SENSORY EXTENSION]*/
<a name="182"></a>modify Odor
<a name="183"></a>        
<a name="184"></a>    /*   
<a name="185"></a>     *   The message to be displayed to show that there's a smell here. The
<a name="186"></a>     *   default implementation should be serviceable in many cases, but game
<a name="187"></a>     *   code can easily override this method if something different is
<a name="188"></a>     *   required. By default we execute our script if we are one, otherwise we use
<a name="189"></a>	 *   our own smellDesc or remoteSmellDesc as appropriate.
<a name="190"></a>	 *   [DEFINED IN SENSORY EXTENSION]
<a name="191"></a>     */
<a name="192"></a>    emanationDesc()
<a name="193"></a>    { 
<a name="194"></a>        /* 
<a name="195"></a>         *   If we're mixed in with an EventList class, display the next item
<a name="196"></a>         *   from our eventList.
<a name="197"></a>         */
<a name="198"></a>        if(ofKind(Script))
<a name="199"></a>            doScript();
<a name="200"></a>        /*  
<a name="201"></a>         *   Otherwise use our location's smellDesc or remoteSmellDesc, as
<a name="202"></a>         *   appropriate
<a name="203"></a>         */
<a name="204"></a>        else
<a name="205"></a>        {
<a name="206"></a>            if(!location.isIn(gPlayerChar.getOutermostRoom) 
<a name="207"></a>               &amp;&amp; location.propDefined(&amp;remoteSmellDesc))
<a name="208"></a>                location.remoteSmellDesc(gPlayerChar);
<a name="209"></a>            else
<a name="210"></a>                location.smellDesc;
<a name="211"></a>        }
<a name="212"></a>    }
<a name="213"></a>    
<a name="214"></a>    /* 
<a name="215"></a>     *   Only carry out the inherited handling if the player hasn't issued a
<a name="216"></a>     *   SMELL command on this turn, otherwise there's the risk of duplicate
<a name="217"></a>     *   messages. [DEFINED IN SENSORY EXTENSION]
<a name="218"></a>     */
<a name="219"></a>    emanate()
<a name="220"></a>    {
<a name="221"></a>        if(!gActionIn(Smell, SmellSomething))
<a name="222"></a>            inherited;
<a name="223"></a>    }    
<a name="224"></a>;
<a name="225"></a>
<a name="226"></a>/*  
<a name="227"></a> *   A SimpleOdor is an object representing a free-standing smell directly
<a name="228"></a> *   present in a location rather than attached to any specific object. It can
<a name="229"></a> *   be used to display atmospheric smells either according to its schedule or
<a name="230"></a> *   in response to a SMELL command. [DEFINED IN SENSORY EXTENSION]
<a name="231"></a> */
<a name="232"></a>class SimpleOdor: Odor
<a name="233"></a>    /*  
<a name="234"></a>     *   Unless this is overridden, our desc property simply executes our
<a name="235"></a>     *   script. [DEFINED IN SENSORY EXTENSION]
<a name="236"></a>     */
<a name="237"></a>    desc() { doScript(); }
<a name="238"></a>    
<a name="239"></a>    /* The smellDesc of a SimpleOdor is simply its desc.[DEFINED IN SENSORY EXTENSION] */
<a name="240"></a>    smellDesc = desc
<a name="241"></a>      
<a name="242"></a>    /* 
<a name="243"></a>     *   A SimpleOdor is a prominent smell by default, since we want it to show
<a name="244"></a>     *   up in response to a SMELL command. [DEFINED IN SENSORY EXTENSION]
<a name="245"></a>     */
<a name="246"></a>    isProminentSmell = true
<a name="247"></a>    
<a name="248"></a>	/*   
<a name="249"></a>     *   The message to be displayed to show that there's a smell here. 
<a name="250"></a>     *   We display either our own smellDesc or our remoteSmellDesc,
<a name="251"></a>     *   as appropriate.
<a name="252"></a>     *   DEFINED IN SENSORY EXTENSION]
<a name="253"></a>     */
<a name="254"></a>    emanationDesc()
<a name="255"></a>    { 
<a name="256"></a>        
<a name="257"></a>        if(!isIn(gRoom) &amp;&amp; propDefined(&amp;remoteSmellDesc))
<a name="258"></a>            remoteSmellDesc(gPlayerChar);
<a name="259"></a>        else
<a name="260"></a>            smellDesc;        
<a name="261"></a>    }
<a name="262"></a>    
<a name="263"></a>;
<a name="264"></a>
<a name="265"></a>/* An Noise is a SensoryEmanation representing a Sound [MODIFIED FOR SENSORY EXTENSION] */
<a name="266"></a>modify Noise   
<a name="267"></a>    
<a name="268"></a>    /*   
<a name="269"></a>     *   The message to be displayed to show that there's a sound here. The
<a name="270"></a>     *   default implementation should be serviceable in many cases, but game
<a name="271"></a>     *   code can easily override this method if something different is
<a name="272"></a>     *   required. By default we execute our script if we are one, otherwise we use
<a name="273"></a>	 *   our own listenDesc or remoteListenDesc as appropriate.
<a name="274"></a>	 *   [DEFINED IN SENSORY EXTENSION]
<a name="275"></a>     */
<a name="276"></a>    emanationDesc()
<a name="277"></a>    { 
<a name="278"></a>        /* 
<a name="279"></a>         *   If we're mixed in with an EventList class, display the next item
<a name="280"></a>         *   from our eventList.
<a name="281"></a>         */
<a name="282"></a>        if(ofKind(Script))
<a name="283"></a>            doScript();
<a name="284"></a>        /*  
<a name="285"></a>         *   Otherwise use our location's listenDesc, or remoteListenDesc, as
<a name="286"></a>         *   appropriate
<a name="287"></a>         */
<a name="288"></a>        else
<a name="289"></a>        {
<a name="290"></a>            if(!location.isIn(gPlayerChar.getOutermostRoom) 
<a name="291"></a>               &amp;&amp; location.propDefined(&amp;remoteListenDesc))
<a name="292"></a>                location.remoteListenDesc(gPlayerChar);
<a name="293"></a>            else
<a name="294"></a>                location.listenDesc;
<a name="295"></a>        }
<a name="296"></a>    }
<a name="297"></a>    
<a name="298"></a>    /* 
<a name="299"></a>     *   Only carry out the inherited handling if the player hasn't issued a
<a name="300"></a>     *   LISTEN command on this turn, otherwise there's the risk of duplicate
<a name="301"></a>     *   messages. [DEFINED IN SENSORY EXTENSION]
<a name="302"></a>     */
<a name="303"></a>    emanate()
<a name="304"></a>    {
<a name="305"></a>        if(!gActionIn(Listen, ListenTo))
<a name="306"></a>            inherited;
<a name="307"></a>    }  
<a name="308"></a>;
<a name="309"></a>
<a name="310"></a>/*  
<a name="311"></a> *   A SimpleNoise is an object representing a free-standing sound directly
<a name="312"></a> *   present in a location rather than attached to any specific object. It can
<a name="313"></a> *   be used to display atmospheric sounds either according to its schedule or
<a name="314"></a> *   in response to a LISTEN command. [DEFINED IN SENSORY EXTENSION]
<a name="315"></a> */
<a name="316"></a>class SimpleNoise: Noise
<a name="317"></a>    /*  
<a name="318"></a>     *   Unless this is overridden, our desc property simply executes our
<a name="319"></a>     *   script. [DEFINED IN SENSORY EXTENSION]
<a name="320"></a>     */
<a name="321"></a>    desc() { doScript(); }
<a name="322"></a>    
<a name="323"></a>    /* The listenDesc of a SimpleNoise is simply its desc.[DEFINED IN SENSORY EXTENSION]  */
<a name="324"></a>    listenDesc = desc
<a name="325"></a>     
<a name="326"></a>    /* 
<a name="327"></a>     *   A SimpleNoise is a prominent noise by default, since we want it to show
<a name="328"></a>     *   up in response to a LISTEN command.
<a name="329"></a>     */
<a name="330"></a>    isProminentNoise = true
<a name="331"></a> 
<a name="332"></a>    /*   
<a name="333"></a>     *   The message to be displayed to show that there's a noise here. 
<a name="334"></a>     *   We display either our own listenDesc or our remoteListenDesc,
<a name="335"></a>     *   as appropriate.
<a name="336"></a>     *   [DEFINED IN SENSORY EXTENSION]
<a name="337"></a>     */
<a name="338"></a>    emanationDesc()
<a name="339"></a>    { 
<a name="340"></a>        
<a name="341"></a>        if(!isIn(gRoom) &amp;&amp; propDefined(&amp;remoteListenDesc))
<a name="342"></a>            remoteListenDesc(gPlayerChar);
<a name="343"></a>        else
<a name="344"></a>            listenDesc;        
<a name="345"></a>    }
<a name="346"></a>;
<a name="347"></a>
<a name="348"></a>
<a name="349"></a>/* 
<a name="350"></a> *  The object which drives emanation messages for Odors and Noises 
<a name="351"></a> *  [DEFINED IN SENSORY EXTENSION]
<a name="352"></a> */
<a name="353"></a>emanationControl: InitObject
<a name="354"></a>    /* Set up our Daemon at the start of play. [DEFINED IN SENSORY EXTENSION] */
<a name="355"></a>    execute()
<a name="356"></a>    {
<a name="357"></a>        new Daemon(self, &amp;emanate, 1);
<a name="358"></a>    }
<a name="359"></a>    
<a name="360"></a>    /* 
<a name="361"></a>     *   Each turn, execute the emanate() method for every item in our list of
<a name="362"></a>     *   emanations. [DEFINED IN SENSORY EXTENSION]
<a name="363"></a>     */
<a name="364"></a>    emanate()
<a name="365"></a>    {
<a name="366"></a>        /* Get a list of items potentially due to emanate */
<a name="367"></a>        local lst = buildEmanationList;
<a name="368"></a>        
<a name="369"></a>        /* Make every item in our list execute its emanate method */
<a name="370"></a>        for(local e in lst)
<a name="371"></a>            e.emanate();      
<a name="372"></a>    }
<a name="373"></a>    
<a name="374"></a>    
<a name="375"></a>    /*  
<a name="376"></a>     *   Construct a list of SensoryEmanations that can currently be sensed by
<a name="377"></a>     *   the player character. [DEFINED IN SENSORY EXTENSION]
<a name="378"></a>     */
<a name="379"></a>    buildEmanationList   
<a name="380"></a>    {
<a name="381"></a>        local pc = gPlayerChar;
<a name="382"></a>        
<a name="383"></a>        /* 
<a name="384"></a>         *   First get a list of all the SensoryEmanations in the player
<a name="385"></a>         *   character's current room that can be sensed by the player character
<a name="386"></a>         */
<a name="387"></a>        local lst = pc.getOutermostRoom.allContents.subset(
<a name="388"></a>            {o: canSense(pc, o)});
<a name="389"></a>        
<a name="390"></a>        /*  
<a name="391"></a>         *   If the SenseRegion class is defined then add all the
<a name="392"></a>         *   SensoryEmanations that can be sensed in remote locations
<a name="393"></a>         */
<a name="394"></a>        if(defined(SenseRegion))
<a name="395"></a>        {
<a name="396"></a>            /* Set up an empty list of remote SensoryEmanations */
<a name="397"></a>            local remoteLst = [];
<a name="398"></a>            
<a name="399"></a>            /* 
<a name="400"></a>             *   For each room that's audible from the player character's
<a name="401"></a>             *   current location, all all the currently emanating Noises that
<a name="402"></a>             *   the player character can hear.
<a name="403"></a>             */
<a name="404"></a>            foreach(local rm in valToList(pc.getOutermostRoom.audibleRooms))
<a name="405"></a>                remoteLst += rm.allContents.subset(
<a name="406"></a>                    {o: o.isEmanating &amp;&amp; o.ofKind(Noise) &amp;&amp; Q.canHear(pc, o)});
<a name="407"></a>            
<a name="408"></a>            /* 
<a name="409"></a>             *   For each room that's audible from the player character's
<a name="410"></a>             *   current location, all all the currently emanating Odors that
<a name="411"></a>             *   the player character can smell.
<a name="412"></a>             */
<a name="413"></a>            foreach(local rm in valToList(pc.getOutermostRoom.smellableRooms))
<a name="414"></a>                remoteLst += rm.allContents.subset(
<a name="415"></a>                    {o: o.isEmanating &amp;&amp; o.ofKind(Odor) &amp;&amp; Q.canSmell(pc, o)});
<a name="416"></a>            
<a name="417"></a>            /* 
<a name="418"></a>             *   Add the remote list to the local list, ensuring that each item
<a name="419"></a>             *   appears only once.
<a name="420"></a>             */
<a name="421"></a>            lst = lst.appendUnique(remoteLst);    
<a name="422"></a>        }
<a name="423"></a>        
<a name="424"></a>        /* Return the resulting list. */
<a name="425"></a>        return lst;    
<a name="426"></a>    }
<a name="427"></a>        
<a name="428"></a>    /* 
<a name="429"></a>     *   The pc can sense o if o is currently emanating and its a Noise the pc
<a name="430"></a>     *   can currently hear or an Odor the pc can currently smell. [DEFINED IN SENSORY EXTENSION]
<a name="431"></a>     */   
<a name="432"></a>    canSense(pc, o)
<a name="433"></a>    {
<a name="434"></a>        return o.isEmanating &amp;&amp; ((o.ofKind(Noise) &amp;&amp; Q.canHear(pc, o))
<a name="435"></a>                                  || (o.ofKind(Odor) &amp;&amp; Q.canSmell(pc, o)));
<a name="436"></a>    }   
<a name="437"></a>;
<a name="438"></a>
<a name="439"></a>/* 
<a name="440"></a> *   A SensoryEvent is a brief event in time, such as a sudden noise, to which
<a name="441"></a> *   other actors or objects in the vicinity may react. [DEFINED IN SENSORY EXTENSION]
<a name="442"></a> */
<a name="443"></a>class SensoryEvent: object
<a name="444"></a>    /* 
<a name="445"></a>     *   We call the trigger event method of a SensoryEvent to simulate the
<a name="446"></a>     *   occurrence of that event. The obj parameter is the object associated
<a name="447"></a>     *   with the event, for example the source of a sudden explosion.
<a name="448"></a>	 *   [DEFINED IN SENSORY EXTENSION]
<a name="449"></a>     */    
<a name="450"></a>    triggerEvent(obj)
<a name="451"></a>    {
<a name="452"></a>        /* 
<a name="453"></a>         *   Construct a list containing all the items in the player character's
<a name="454"></a>         *   current room that the pc can sense via the relevant sense
<a name="455"></a>         */
<a name="456"></a>        local notifyList = obj.getOutermostRoom.allContents.subset({
<a name="457"></a>            o: Q.(senseProp)(o, obj) });
<a name="458"></a>                
<a name="459"></a>        /* 
<a name="460"></a>         *   Add any items from remote locations that meet the same conditions,
<a name="461"></a>         *   making the list unique so we don't get any duplicates.
<a name="462"></a>         */
<a name="463"></a>        notifyList = notifyList.appendUnique(remoteList(obj));
<a name="464"></a>        
<a name="465"></a>        /*  
<a name="466"></a>         *   Notify every item in our notification list that this event has just
<a name="467"></a>         *   occurred.
<a name="468"></a>         */
<a name="469"></a>        for(local cur in notifyList)
<a name="470"></a>            cur.(notifyProp)(self, obj);
<a name="471"></a>        
<a name="472"></a>        /*  
<a name="473"></a>         *   Presumablty obj has just made its presence known to the player
<a name="474"></a>         *   character, even if it wasn't before.
<a name="475"></a>         */
<a name="476"></a>        obj.setKnown();
<a name="477"></a>    }
<a name="478"></a>    
<a name="479"></a>    /* 
<a name="480"></a>     *   A property pointer to the property on each notified object that needs
<a name="481"></a>     *   to be executed when it's notified of this SensoryEvent (e.g.
<a name="482"></a>     *   &amp;notifySoundEvent). [DEFINED IN SENSORY EXTENSION]
<a name="483"></a>     */
<a name="484"></a>    notifyProp = nil
<a name="485"></a>    
<a name="486"></a>    /*   
<a name="487"></a>     *   The property pointer relating to the Q method that needs to be called
<a name="488"></a>     *   to determined whethet this SensoryEvent can be sensed (e.g. &amp;canHear).
<a name="489"></a>	 *   [DEFINED IN SENSORY EXTENSION]
<a name="490"></a>     */
<a name="491"></a>    senseProp = nil
<a name="492"></a>    
<a name="493"></a>    /*   
<a name="494"></a>     *   The property pointer to the property of Room defining which list of
<a name="495"></a>     *   rooms also needs to be checked for remote items that might sense this
<a name="496"></a>     *   event (e.g. &amp;audibleRooms). [DEFINED IN SENSORY EXTENSION]
<a name="497"></a>     */
<a name="498"></a>    remoteProp = nil
<a name="499"></a>    
<a name="500"></a>    /*  Construct a list of notifiable objects in remote locations  [DEFINED IN SENSORY EXTENSION]*/
<a name="501"></a>    remoteList(obj)
<a name="502"></a>    {
<a name="503"></a>        /* Start with an empty list */
<a name="504"></a>        local lst = [];
<a name="505"></a>        
<a name="506"></a>        /* 
<a name="507"></a>         *   If the SenseRegion class isn't present, there's no point trying to
<a name="508"></a>         *   look for objects in remote rooms.
<a name="509"></a>         */
<a name="510"></a>        if(defined(SenseRegion))
<a name="511"></a>        {
<a name="512"></a>           /* 
<a name="513"></a>            *   Got through each room in the appropriate list of remote rooms
<a name="514"></a>            *   that can be sensed from us through the appropriate sense to
<a name="515"></a>            *   build a list of all their contents which can be senses via the
<a name="516"></a>            *   appropriate sense.
<a name="517"></a>            */
<a name="518"></a>            for(local rm in valToList(obj.getOutermostRoom.(remoteProp)))
<a name="519"></a>                lst = lst.appendUnique(rm.allContents.({
<a name="520"></a>                    o: Q.(senseProp)(o, obj) }));
<a name="521"></a>        }
<a name="522"></a>        
<a name="523"></a>        /* Return the resulting list */
<a name="524"></a>        return lst;
<a name="525"></a>    }
<a name="526"></a>;
<a name="527"></a>
<a name="528"></a>/* 
<a name="529"></a> *   A SoundEvent represents any sudden noise to which other objects or people
<a name="530"></a> *   might react. [DEFINED IN SENSORY EXTENSION]
<a name="531"></a> */
<a name="532"></a>class SoundEvent: SensoryEvent    
<a name="533"></a>    notifyProp = &amp;notifySoundEvent
<a name="534"></a>    senseProp = &amp;canHear
<a name="535"></a>    remoteProp = &amp;audibleRooms
<a name="536"></a>    
<a name="537"></a>;
<a name="538"></a>
<a name="539"></a>/* 
<a name="540"></a> *   A SoundEvent represents any sudden smell to which other objects or people
<a name="541"></a> *   might react. [DEFINED IN SENSORY EXTENSION]
<a name="542"></a> */
<a name="543"></a>class SmellEvent: SensoryEvent    
<a name="544"></a>    notifyProp = &amp;notifySmellEvent
<a name="545"></a>    senseProp = &amp;canSmell
<a name="546"></a>    remoteProp = &amp;smellableRooms
<a name="547"></a>;
<a name="548"></a>
<a name="549"></a>
<a name="550"></a>/* 
<a name="551"></a> *   A SightEvent represents any visible event to which other objects or people
<a name="552"></a> *   might react. [DEFINED IN SENSORY EXTENSION]
<a name="553"></a> */
<a name="554"></a>class SightEvent: SensoryEvent    
<a name="555"></a>    notifyProp = &amp;notifySightEvent
<a name="556"></a>    senseProp = &amp;canSee
<a name="557"></a>    remoteProp = &amp;visibleRooms
<a name="558"></a>;
<a name="559"></a>
<a name="560"></a>/*  Modifications to Thing to work with the &lt;i&gt;SENSORY EXTENSION&lt;/i&gt; */
<a name="561"></a>modify Thing
<a name="562"></a>    /* 
<a name="563"></a>     *   The methods that define our reactions to SoundEvents, SmellEvents and
<a name="564"></a>     *   SightEvents respectively. By default all three methods defer to a
<a name="565"></a>     *   common handler. [DEFINED IN SENSORY EXTENSION]
<a name="566"></a>     */    
<a name="567"></a>    notifySoundEvent(event, source) { notifyEvent(event, source); }
<a name="568"></a>	
<a name="569"></a>	/*  Our reaction to a SmellEvent. By default we defer to the common handler. */
<a name="570"></a>    notifySmellEvent(event, source) { notifyEvent(event, source); }
<a name="571"></a>	
<a name="572"></a>	/*  Our reaction to a SightEvent. By default we defer to the common handler. */
<a name="573"></a>    notifySightEvent(event, source) { notifyEvent(event, source); }
<a name="574"></a>        
<a name="575"></a>    /* 
<a name="576"></a>     *   Our common handler for SensoryEvents; it may often be more convenient
<a name="577"></a>     *   to use this than to write separate handlers for each kind of
<a name="578"></a>     *   SensoryEvent, since in any case the event parameter (containing the
<a name="579"></a>     *   SensoryEvent that's just been triggered) tells us what kind of
<a name="580"></a>     *   SensoryEvent it is. The source parameter is the object associated with
<a name="581"></a>     *   the event. [DEFINED IN SENSORY EXTENSION]
<a name="582"></a>     */
<a name="583"></a>    notifyEvent(event, source) {  }   
<a name="584"></a>    
<a name="585"></a>    /*   
<a name="586"></a>     *   By default we split our smellDesc into smellDescWithoutSource (when the
<a name="587"></a>     *   player character can't see us) and smellDescWithSource (when the pc
<a name="588"></a>     *   can). If we don't need this distinction we can override this method
<a name="589"></a>     *   directly. [MODIFIED FOR SENSORY EXTENSION]
<a name="590"></a>     */
<a name="591"></a>    smellDesc()
<a name="592"></a>    {
<a name="593"></a>      if(Q.canSee(gActor, self))
<a name="594"></a>            smellDescWithSource;
<a name="595"></a>        else
<a name="596"></a>            smellDescWithoutSource;   
<a name="597"></a>    }
<a name="598"></a>  
<a name="599"></a>    /* 
<a name="600"></a>     *  The response to SMELLing this object when the actor can see us. 
<a name="601"></a>     *  [DEFINED IN SENSORY EXTENSION]
<a name="602"></a>     */
<a name="603"></a>    smellDescWithSource = nil
<a name="604"></a>
<a name="605"></a>    /* 
<a name="606"></a>     *  The response to SMELLing this object when the actor can't see us. 
<a name="607"></a>     *  [DEFINED IN SENSORY EXTENSION]
<a name="608"></a>     */
<a name="609"></a>    smellDescWithoutSource = nil
<a name="610"></a>    
<a name="611"></a>    /*   
<a name="612"></a>     *   By default we split our listenDesc into listenDescWithoutSource (when
<a name="613"></a>     *   the player character can't hear us) and listenDescWithSource (when the
<a name="614"></a>     *   pc can). If we don't need this distinction we can override this method
<a name="615"></a>     *   directly. [MODIFIED FOR SENSORY EXTENSION]
<a name="616"></a>     */
<a name="617"></a>    listenDesc()
<a name="618"></a>    {
<a name="619"></a>      if(Q.canSee(gActor, self) )
<a name="620"></a>            listenDescWithSource;
<a name="621"></a>        else
<a name="622"></a>            listenDescWithoutSource;   
<a name="623"></a>    }
<a name="624"></a>  
<a name="625"></a>    /* 
<a name="626"></a>     *  The response to LISTENing TO this object when the actor can see us. 
<a name="627"></a>     *  [DEFINED IN SENSORY EXTENSION]
<a name="628"></a>     */
<a name="629"></a>    listenDescWithSource = nil
<a name="630"></a>    
<a name="631"></a>    /* 
<a name="632"></a>     *   The response to LISTENing TO this object when the actor can't see us. 
<a name="633"></a>     *   [DEFINED IN SENSORY EXTENSION]
<a name="634"></a>     */
<a name="635"></a>    listenDescWithoutSource = nil    
<a name="636"></a>    
<a name="637"></a>    /* 
<a name="638"></a> 	 * [MODIFIED FOR SENSORY EXTENSION] 
<a name="639"></a>	 * If I have an associated Noise object which isn't emanating, assume
<a name="640"></a>	 * I have fallen silent, otherwise carry out the inherited handling.
<a name="641"></a>	 */
<a name="642"></a>    dobjFor(ListenTo)
<a name="643"></a>    {
<a name="644"></a>        action()
<a name="645"></a>        {
<a name="646"></a>            /* 
<a name="647"></a>             *   If I have an associated Noise object which isn't emanating,
<a name="648"></a>             *   then assume I have fallen silent.
<a name="649"></a>             */
<a name="650"></a>            
<a name="651"></a>            if(soundObj != nil &amp;&amp; !soundObj.isEmanating)
<a name="652"></a>                say(hearNothingMsg);          
<a name="653"></a>            else
<a name="654"></a>                inherited;
<a name="655"></a>        }
<a name="656"></a>    }
<a name="657"></a>    
<a name="658"></a>    /* 
<a name="659"></a> 	 * [MODIFIED FOR SENSORY EXTENSION] 
<a name="660"></a>	 * If I have an associated Odor object which isn't emanating, assume
<a name="661"></a>	 * I no longer smell of anything, otherwise carry out the inherited handling.
<a name="662"></a>	 */
<a name="663"></a>    dobjFor(SmellSomething)
<a name="664"></a>    {
<a name="665"></a>        action()
<a name="666"></a>        {
<a name="667"></a>            /* 
<a name="668"></a>             *   If I have an associated Odor object which isn't emanating,
<a name="669"></a>             *   then assume I no longer smell.
<a name="670"></a>             */            
<a name="671"></a>            if(smellObj != nil &amp;&amp; !smellObj.isEmanating)
<a name="672"></a>                say(smellNothingMsg);          
<a name="673"></a>            else
<a name="674"></a>                inherited;
<a name="675"></a>        }
<a name="676"></a>    }
<a name="677"></a>    
<a name="678"></a>    /* 
<a name="679"></a>     *   We don't have a prominent smell if we have an associated Odor object
<a name="680"></a>     *   that isn't emanating. [MODIFIED FOR SENSORY EXTENSION]
<a name="681"></a>     */
<a name="682"></a>    isProminentSmell
<a name="683"></a>    {
<a name="684"></a>        if(smellObj &amp;&amp; !smellObj.isEmanating)
<a name="685"></a>            return nil;
<a name="686"></a>        return true;
<a name="687"></a>    }
<a name="688"></a>    
<a name="689"></a>    /* 
<a name="690"></a>     *   We don't have a prominent noise if we have an associated Noise object
<a name="691"></a>     *   that isn't emanating. [MODIFIED FOR SENSORY EXTENSION]
<a name="692"></a>     */
<a name="693"></a>    isProminentNoise
<a name="694"></a>    {
<a name="695"></a>        if(soundObj &amp;&amp; !soundObj.isEmanating)
<a name="696"></a>            return nil;
<a name="697"></a>        
<a name="698"></a>        return true;
<a name="699"></a>    }
<a name="700"></a>    
<a name="701"></a>    /* Our associated Odor object, if we have one [SENSORY EXTENSION]*/
<a name="702"></a>    smellObj = (contents.valWhich({o: o.ofKind(Odor)}))
<a name="703"></a>    
<a name="704"></a>    /* Our associated Noise object, if we have one. [SENSORY EXTENSION]*/            
<a name="705"></a>    soundObj = (contents.valWhich({o: o.ofKind(Noise)}))
<a name="706"></a>;
<a name="707"></a>
<a name="708"></a>/* MODIFICATIONS FOR SENSORY EXTENSION */
<a name="709"></a>modify Room
<a name="710"></a>    /* 
<a name="711"></a>     *   Reset every SensoryEmanation in this room to its initial state when the
<a name="712"></a>     *   player character leaves this room. [MODIFIED FOR SENSORY EXTENSION]
<a name="713"></a>     */
<a name="714"></a>    notifyDeparture(traveler, dest)
<a name="715"></a>    {
<a name="716"></a>        inherited(traveler, dest);
<a name="717"></a>        
<a name="718"></a>        if(traveler == gPlayerChar)
<a name="719"></a>        {
<a name="720"></a>            local lst = allContents.subset({o: o.ofKind(SensoryEmanation)});             
<a name="721"></a>            
<a name="722"></a>            /* 
<a name="723"></a>             *   If the SenseRegion class is included, then we need to deal with
<a name="724"></a>             *   SensoryEmanations in remote rooms.
<a name="725"></a>             */
<a name="726"></a>            if(defined(SenseRegion))
<a name="727"></a>            {
<a name="728"></a>                local sp = defined(scopeProbe_) ? scopeProbe_ : object: Thing {};
<a name="729"></a>                try
<a name="730"></a>                {                    
<a name="731"></a>                    sp.moveInto(dest);
<a name="732"></a>                    
<a name="733"></a>                    /* First add all the Noises in the remote rooms we can hear */
<a name="734"></a>                    for(local rm in getOutermostRoom.audibleRooms)
<a name="735"></a>                        lst.appendUnique(rm.allContents.subset({o:
<a name="736"></a>                            o.ofKind(Noise)}));
<a name="737"></a>                    
<a name="738"></a>                    /* Then add all the Odors in the remote rooms we can smell */
<a name="739"></a>                    for(local rm in getOutermostRoom.smellableRooms)
<a name="740"></a>                        lst.appendUnique(rm.allContents.subset({o:
<a name="741"></a>                            o.ofKind(Odor)}));
<a name="742"></a>                    
<a name="743"></a>                    /* 
<a name="744"></a>                     *   Finally remove all the Odors that can't be smelled from
<a name="745"></a>                     *   the destination and all the Noises than can't be heard
<a name="746"></a>                     *   from the destination.
<a name="747"></a>                     */
<a name="748"></a>                    
<a name="749"></a>                    lst = lst.subset({o: (o.ofKind(Noise) &amp;&amp;
<a name="750"></a>                                          !Q.canHear(sp, o)) 
<a name="751"></a>                                     || (o.ofKind(Odor) 
<a name="752"></a>                                         &amp;&amp; !Q.canSmell(sp, o))});
<a name="753"></a>                }
<a name="754"></a>                finally
<a name="755"></a>                {
<a name="756"></a>                    
<a name="757"></a>                    sp.moveInto(nil);
<a name="758"></a>                }
<a name="759"></a>            }
<a name="760"></a>                
<a name="761"></a>            /* Reset every SensoryEmanation in our list */
<a name="762"></a>            lst.forEach({o: o.reset() });
<a name="763"></a>        }
<a name="764"></a>    }
<a name="765"></a>;
<a name="766"></a>                                       
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

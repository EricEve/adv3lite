<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>httpreq.h</title></head><body>
<table class=ban><tr><td><h1>httpreq.h</h1><td align=right><a href="../file/httpreq.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   Copyright 2010 Michael J. Roberts.
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This module defines the HTTPRequest intrinsic class.  This class
<a name="10"></a> *   represents a request sent from a network client to the byte-code program
<a name="11"></a> *   via the program's HTTP server object.
<a name="12"></a> *   
<a name="13"></a> *   See the HTTPServer object for details on setting up an HTTP server
<a name="14"></a> *   within the program.
<a name="15"></a> *   
<a name="16"></a> *   HTTPRequest objects are not created with 'new'.  Instead, the system
<a name="17"></a> *   creates them when HTTP requests arrive, and returns them to the
<a name="18"></a> *   byte-code program via the netEvent() built-in function.  
<a name="19"></a> */
<a name="20"></a>
<a name="21"></a>/*
<a name="22"></a> *   HTTP Request object.  This object represents an HTTP protocol request
<a name="23"></a> *   from a client to one of our servers.  HTTPRequest objects are created by
<a name="24"></a> *   the HTTPServer object as requests arrive, and are passed to the byte
<a name="25"></a> *   code program as network events, via the getNetEvent() function.  The
<a name="26"></a> *   program uses the object to get information on the request and to send
<a name="27"></a> *   back the reply.  
<a name="28"></a> */
<a name="29"></a>intrinsic class HTTPRequest 'http-request/030001': Object
<a name="30"></a>{
<a name="31"></a>    /*
<a name="32"></a>     *   Get the HTTPServer object.  This is the server that received the
<a name="33"></a>     *   network request that 'self' represents. 
<a name="34"></a>     */
<a name="35"></a>    getServer();
<a name="36"></a>
<a name="37"></a>    /*
<a name="38"></a>     *   Get the verb.  This is the HTTP verb that the client sent with the
<a name="39"></a>     *   request to indicate what action to perform.  The standard HTTP verbs
<a name="40"></a>     *   are GET (this is the most common request type; it simply retrieves a
<a name="41"></a>     *   resource from the server), POST (used to submit form data), OPTIONS,
<a name="42"></a>     *   HEAD, PUT, DELETE, TRACE, CONNECT, and PATCH.  If the client sends a
<a name="43"></a>     *   non-standard verb, the system simply passes it through to the
<a name="44"></a>     *   request, allowing you to write a custom server for a custom client;
<a name="45"></a>     *   however, this isn't recommended, since proxies and firewalls often
<a name="46"></a>     *   block what they consider ill-formed requests.  
<a name="47"></a>     */
<a name="48"></a>    getVerb();
<a name="49"></a>
<a name="50"></a>    /*
<a name="51"></a>     *   Get the query string.  This is the portion of the URL after the
<a name="52"></a>     *   server address.  For example, if the client web browser navigated to
<a name="53"></a>     *   the URL "http://www.tads.org:1234/path/resource?a=1&amp;b=2" would
<a name="54"></a>     *   return "/path/resource?a=1&amp;b=2".
<a name="55"></a>     *   
<a name="56"></a>     *   This is the raw query string, exactly as the client sent it.  Any
<a name="57"></a>     *   '%xx' character sequences are still present in this version of the
<a name="58"></a>     *   string.  
<a name="59"></a>     */
<a name="60"></a>    getQuery();
<a name="61"></a>
<a name="62"></a>    /*
<a name="63"></a>     *   Parse the query string.  This returns a LookupTable containing the
<a name="64"></a>     *   parsed elements of the query.  The element table[1] is the base
<a name="65"></a>     *   resource name: this is the part of the query string up to the first
<a name="66"></a>     *   '?', if any, or the entire query string if there are no parameters.
<a name="67"></a>     *   If there are any parameters, they're entered in the table under the
<a name="68"></a>     *   parameter names as keys.  For example, for this query string:
<a name="69"></a>     *   
<a name="70"></a>     *.     http://www.tads.org:1234/path/resource?a=one&amp;b=two&amp;c=three&amp;d
<a name="71"></a>     *   
<a name="72"></a>     *   we'd generate this table:
<a name="73"></a>     *   
<a name="74"></a>     *.     table[1] = '/path/resource'
<a name="75"></a>     *.     table['a'] = 'one'
<a name="76"></a>     *.     table['b'] = 'two'
<a name="77"></a>     *.     table['c'] = 'three'
<a name="78"></a>     *.     table['d'] = ''
<a name="79"></a>     *   
<a name="80"></a>     *   For all of the strings (including the base resource name, the
<a name="81"></a>     *   parameter names, and the parameter values), any '%xx' sequences are
<a name="82"></a>     *   converted into the corresponding character values.  For example, if
<a name="83"></a>     *   the base resource name is '/C%C3%A1fe', the resource name will be
<a name="84"></a>     *   parsed to 'Cï¿½fe' (%C3%A1 is the percent-encoded representation of
<a name="85"></a>     *   the UTF-8 character small A with acute accent).  
<a name="86"></a>     */
<a name="87"></a>    parseQuery();
<a name="88"></a>
<a name="89"></a>    /*
<a name="90"></a>     *   Get a parameter from the query string.  This parses the query string
<a name="91"></a>     *   and returns the parameter with the specified name, if present, or
<a name="92"></a>     *   nil if not.  This does the same parsing as parseQuery(), but it
<a name="93"></a>     *   returns just the specified parameter value rather than building a
<a name="94"></a>     *   lookup table with all of the parameters.  This is more efficient
<a name="95"></a>     *   than parseQuery() if you're just looking up one or two parameters,
<a name="96"></a>     *   since it avoids building the whole table, but it's less efficient if
<a name="97"></a>     *   you're looking up many parameters because this routine has to
<a name="98"></a>     *   re-parse the query string on each call.  
<a name="99"></a>     */
<a name="100"></a>    getQueryParam(name);
<a name="101"></a>
<a name="102"></a>    /*
<a name="103"></a>     *   Get the headers sent with the request by the client.  This returns a
<a name="104"></a>     *   LookupTable object: the keys are the header names, and the values
<a name="105"></a>     *   are the corresponding header values.  For example, for a POST, there
<a name="106"></a>     *   might be a 'Content-type' key with the corresponding value
<a name="107"></a>     *   'application/x-www-form-urlencoded'.
<a name="108"></a>     *   
<a name="109"></a>     *   The element table[1] contains the HTTP request line - the first line
<a name="110"></a>     *   of the request, which isn't technically a header.  This line
<a name="111"></a>     *   contains the verb, the query string, and (optionally) the HTTP
<a name="112"></a>     *   version string (in that order, with spaces separating the elements).
<a name="113"></a>     *   The method includes this so that you can inspect the unparsed
<a name="114"></a>     *   request line, if desired.  
<a name="115"></a>     */
<a name="116"></a>    getHeaders();
<a name="117"></a>
<a name="118"></a>    /*
<a name="119"></a>     *   Look up a cookie.  This looks for the given cookie name in the
<a name="120"></a>     *   cookies sent by the client, and returns a string containing the
<a name="121"></a>     *   cookie's text if found.  If the cookie isn't found, returns nil.  
<a name="122"></a>     */
<a name="123"></a>    getCookie(name);
<a name="124"></a>
<a name="125"></a>    /*
<a name="126"></a>     *   Get the cookies sent with the request by the client.  This returns a
<a name="127"></a>     *   LookupTable of the cookies, with each key set to a cookie name and
<a name="128"></a>     *   the corresponding value set to the cookie's text.  Cookies are
<a name="129"></a>     *   assumed to contain only plan ASCII characters; any 8-bit characters
<a name="130"></a>     *   in a cookie's name or value will be replaced by '?' characters.  
<a name="131"></a>     */
<a name="132"></a>    getCookies();
<a name="133"></a>
<a name="134"></a>    /*
<a name="135"></a>     *   Get the form data-entry field values.  This returns a LookupTable
<a name="136"></a>     *   containing the field values sent with the request.  Each key in the
<a name="137"></a>     *   table is a field name (given by the NAME property of the HTML
<a name="138"></a>     *   &lt;INPUT&gt; tag for the field), and each corresponding value is a string
<a name="139"></a>     *   giving the value of the field as entered by the user.
<a name="140"></a>     *   
<a name="141"></a>     *   If the form includes uploaded files (via &lt;INPUT TYPE=FILE&gt;), the
<a name="142"></a>     *   value of each file field will be a FileUpload object instead of a
<a name="143"></a>     *   string.  The 'file' property of this object contains a File object,
<a name="144"></a>     *   opened in read-only mode, that can be used to retrieve the contents
<a name="145"></a>     *   of the uploaded file.  Other properties of object provide the
<a name="146"></a>     *   client-side name of the file and the MIME type specified by the
<a name="147"></a>     *   browser.
<a name="148"></a>     *   
<a name="149"></a>     *   This method is a convenience function that parses the message body
<a name="150"></a>     *   information.  You can obtain the raw information on the posted data
<a name="151"></a>     *   via the getHeader() method.
<a name="152"></a>     *   
<a name="153"></a>     *   This method recognizes form data as a message body with content-type
<a name="154"></a>     *   application/x-www-form-urlencoded or multipart/form-data.  If the
<a name="155"></a>     *   request doesn't have a message body at all, or has a message body
<a name="156"></a>     *   with a different content-type, this method assumes that the request
<a name="157"></a>     *   has no posted form data and returns nil.  We return nil rather than
<a name="158"></a>     *   an empty lookup table so that the caller can tell that this doesn't
<a name="159"></a>     *   appear to be a form submission request at all.  
<a name="160"></a>     */
<a name="161"></a>    getFormFields();
<a name="162"></a>
<a name="163"></a>    /*
<a name="164"></a>     *   Get the body of the request, if any.  Some types of HTTP requests,
<a name="165"></a>     *   such as POST and PUT, contain a message body.  This returns the raw,
<a name="166"></a>     *   unparsed message body.  Returns a File object, open with read-only
<a name="167"></a>     *   access. If there's no message body at all, this returns nil.
<a name="168"></a>     *   
<a name="169"></a>     *   If the body is a text type, the file will be open in text mode, with
<a name="170"></a>     *   the character mapping set according to the content type passed from
<a name="171"></a>     *   the client; otherwise it's open in raw binary mode.
<a name="172"></a>     *   
<a name="173"></a>     *   The message body retrieved here is the raw request payload, without
<a name="174"></a>     *   any processing.  There are two standard structured body types that
<a name="175"></a>     *   are frequently used with POSTs, both of which require further
<a name="176"></a>     *   parsing.  First is MIME type application/x-www-form-urlencoded,
<a name="177"></a>     *   which is used to represent a basic HTML form, and encodes the data
<a name="178"></a>     *   entry fields in a form; this type can be parsed via the
<a name="179"></a>     *   getFormFields() method.  Second is multipart/form-data, which is
<a name="180"></a>     *   used to POST forms that include uploaded files; this can be parsed
<a name="181"></a>     *   with getFormFields() to retrieve the data fields, and getUploads()
<a name="182"></a>     *   to get the uploaded file data.  
<a name="183"></a>     */
<a name="184"></a>    getBody();
<a name="185"></a>
<a name="186"></a>    /*
<a name="187"></a>     *   Get the network address of the client.  This returns a list:
<a name="188"></a>     *   ['ip-address', port], where 'ip-address' is a string with the IP
<a name="189"></a>     *   address of the client, in decimal notation ('192.168.1.15', for
<a name="190"></a>     *   example), and 'port' is an integer giving the network port number on
<a name="191"></a>     *   the client side.  
<a name="192"></a>     */
<a name="193"></a>    getClientAddress();
<a name="194"></a>
<a name="195"></a>    /*
<a name="196"></a>     *   Set a cookie in the reply.  This sets a cookie with the given name
<a name="197"></a>     *   and value, both given as strings.  The value string starts with the
<a name="198"></a>     *   text to set for the cookie, and can be followed by additional
<a name="199"></a>     *   parameters, delimited by semicolons:
<a name="200"></a>     *   
<a name="201"></a>     *.   expires=Fri, 31-Dec-2010 23:59:59 GMT  - set expiration date
<a name="202"></a>     *.   domain=.tads.org                       - scope cookie to domain
<a name="203"></a>     *.   path=/                                 - scope cookie within site
<a name="204"></a>     *.   httponly                               - hide cookie from Javascript
<a name="205"></a>     *.   secure                                 - only send via https://
<a name="206"></a>     *   
<a name="207"></a>     *   (These are all defined by the HTTP protocol, not by TADS.  For
<a name="208"></a>     *   details, refer to any HTTP reference book or web site.)
<a name="209"></a>     *   
<a name="210"></a>     *   A cookie without an expiration date is a session cookie: it
<a name="211"></a>     *   implicitly expires as soon as the browser application terminates.
<a name="212"></a>     *   The presence of an expiration date makes the cookie persistent,
<a name="213"></a>     *   meaning it's to be stored on disk until the given expiration date
<a name="214"></a>     *   and should survive even after the browser is closed.
<a name="215"></a>     *   
<a name="216"></a>     *   To send a cookie, you must call this BEFORE sending the reply or
<a name="217"></a>     *   starting to send a chunked reply.  This is a limitation of the
<a name="218"></a>     *   protocol, since the cookies must be sent at the start of the reply
<a name="219"></a>     *   with the headers.  Calling this routine doesn't actually send
<a name="220"></a>     *   anything immediately to the client, but simply stores the cookie
<a name="221"></a>     *   with the pending request, to be sent with the reply.  
<a name="222"></a>     */
<a name="223"></a>    setCookie(name, value);
<a name="224"></a>
<a name="225"></a>    /*
<a name="226"></a>     *   Send the reply to the request.
<a name="227"></a>     *   
<a name="228"></a>     *   'body' is the content of the reply.  For example, for a request for
<a name="229"></a>     *   an HTML page, this would contain the HTML text of the page.  This
<a name="230"></a>     *   can be a string or StringBuffer, in which case the string is sent as
<a name="231"></a>     *   UTF-8 data; a ByteArray, in which case the raw bytes of the byte
<a name="232"></a>     *   array are sent exactly as given; an integer, in which case the body
<a name="233"></a>     *   will be a default HTML page automatically generated for the
<a name="234"></a>     *   corresponding HTML status code; a File object opened with read
<a name="235"></a>     *   access, in which case the contents of the file will be sent; or nil,
<a name="236"></a>     *   in which case no message body is sent at all (just the status code
<a name="237"></a>     *   and the headers).  A file open in text mode will be sent as text,
<a name="238"></a>     *   and raw mode will be sent as binary.  "Data" mode isn't allowed.
<a name="239"></a>     *   Note that if a file is used, this will send the entire contents of
<a name="240"></a>     *   the file, regardless of the current seek position, and the routine
<a name="241"></a>     *   will have the side effect of setting the file's seek position to end
<a name="242"></a>     *   of file upon return.
<a name="243"></a>     *   
<a name="244"></a>     *   'contentType' is an optional string giving the MIME type of the
<a name="245"></a>     *   reply body.  This is used to generate a Content-type header in the
<a name="246"></a>     *   reply.  If this is omitted, the server generates a default MIME type
<a name="247"></a>     *   according to the type of the 'body' argument.  If 'body' is given as
<a name="248"></a>     *   a string, and the string starts with &lt;HTML (ignoring any initial
<a name="249"></a>     *   whitespace), the default content type is "text/html"; if the string
<a name="250"></a>     *   starts with &lt;?XML, the default type is "text/xml"; otherwise the
<a name="251"></a>     *   default type is "text/plain".  If 'body' is a ByteArray, the server
<a name="252"></a>     *   checks the first few bytes for signature strings for a few known
<a name="253"></a>     *   types (JPEG, PNG, MP3, Ogg, MIDI), and uses the corresponding MIME
<a name="254"></a>     *   type if matched; otherwise the MIME type is set to
<a name="255"></a>     *   "application/octet-stream".  'contentType' is ignored when the
<a name="256"></a>     *   'body' argument is an integer (because in this case the body is
<a name="257"></a>     *   known to be HTML), or hwen it's nil (since there's no body at all in
<a name="258"></a>     *   this case).
<a name="259"></a>     *   
<a name="260"></a>     *   When the 'body' is a string, the server automatically adds the
<a name="261"></a>     *   "charset" parameter to the Content-type header with value "utf-8".
<a name="262"></a>     *   
<a name="263"></a>     *   'status' is an optional HTTP status code.  This can be a string, in
<a name="264"></a>     *   which case it must have the standard format for an HTTP status code,
<a name="265"></a>     *   which consists of a decimal status code number followed by the text
<a name="266"></a>     *   description of the code: for example, "404 Not Found.  This argument
<a name="267"></a>     *   can alternatively be a simple integer giving one of the standard
<a name="268"></a>     *   HTTP status code numbers, in which case we'll automatically add the
<a name="269"></a>     *   corresponding status code text.  If this argument is omitted, AND
<a name="270"></a>     *   the 'body' is given as an integer, the 'body' value will be used as
<a name="271"></a>     *   the status code.  If this is omitted and there's a non-integer
<a name="272"></a>     *   'body' argument, we use "200 OK" as the default status code.
<a name="273"></a>     *   
<a name="274"></a>     *   'headers' is an optional list of header strings.  Each element of
<a name="275"></a>     *   the list is a string giving one header, in the standard format
<a name="276"></a>     *   "Name: Value".  If this is omitted, the reply will contain only the
<a name="277"></a>     *   standard headers synthesized by the server.
<a name="278"></a>     *   
<a name="279"></a>     *   The server automatically generates certain headers with each reply.
<a name="280"></a>     *   These should not be specified in the 'headers' argument.  The
<a name="281"></a>     *   standard headers are:
<a name="282"></a>     *   
<a name="283"></a>     *.     Content-type: per the 'contentType' argument
<a name="284"></a>     *.     Content-length: length in bytes of 'body'
<a name="285"></a>     *   
<a name="286"></a>     *   After sending the reply, the request is completed, and no further
<a name="287"></a>     *   reply can be sent.  
<a name="288"></a>     */
<a name="289"></a>    sendReply(body, contentType?, status?, headers?);
<a name="290"></a>
<a name="291"></a>    /*
<a name="292"></a>     *   Start a chunked reply.  This sends the initial headers of a reply
<a name="293"></a>     *   that will be generated in pieces.  This is an alternative to sending
<a name="294"></a>     *   the entire reply as a single string via sendReply(), for situations
<a name="295"></a>     *   where you're generating the reply algorithmically and want to send a
<a name="296"></a>     *   little bit at a time, rather than buffering up the entire reply in a
<a name="297"></a>     *   string or StringBuffer to send all at once.  This is particularly
<a name="298"></a>     *   useful for cases where the reply will take a while to generate,
<a name="299"></a>     *   since it allows the client to interpret partial data before the
<a name="300"></a>     *   entire reply is completed; and for very large reply bodies, where it
<a name="301"></a>     *   would consume a lot of memory to buffer the whole reply.
<a name="302"></a>     *   
<a name="303"></a>     *   This routine doesn't send any initial data, but simply begins the
<a name="304"></a>     *   reply process.  For this reason, the content type must be specified:
<a name="305"></a>     *   there's no way for the routine to infer the content type here since
<a name="306"></a>     *   we don't have any body data to look at.  The content type, result
<a name="307"></a>     *   code, and headers arguments work as they do with sendReply().
<a name="308"></a>     *   
<a name="309"></a>     *   After calling this routine, call sendReplyChunk() as many times as
<a name="310"></a>     *   needed to send the pieces of the reply.  After sending all of the
<a name="311"></a>     *   pieces, call endChunkedReply() to finish the reply.  
<a name="312"></a>     */
<a name="313"></a>    startChunkedReply(contentType, resultCode?, headers?);
<a name="314"></a>
<a name="315"></a>    /*
<a name="316"></a>     *   Send a piece of a chunked reply.  This can be called any number of
<a name="317"></a>     *   times after calling startChunkedReply() to send the pieces of a
<a name="318"></a>     *   chunked reply.
<a name="319"></a>     *   
<a name="320"></a>     *   'body' can be a string or StringBuffer, in which case the string
<a name="321"></a>     *   data are sent as UTF-8 text; or a ByteArray, in which case the raw
<a name="322"></a>     *   bytes are sent.  
<a name="323"></a>     */
<a name="324"></a>    sendReplyChunk(body);
<a name="325"></a>
<a name="326"></a>    /*
<a name="327"></a>     *   Finish a chunked reply.  This completes a chunked reply started with
<a name="328"></a>     *   startChunkedReply().  After calling this routine, the request is
<a name="329"></a>     *   completed, and no further reply can be sent.
<a name="330"></a>     *   
<a name="331"></a>     *   'headers' is an optional list of additional headers to send with the
<a name="332"></a>     *   end of the reply.  The HTTP chunked reply mechanism allows a server
<a name="333"></a>     *   to send headers at the beginning of the reply (which corresponds to
<a name="334"></a>     *   the startChunkedReply() call), at the end of the reply (in this
<a name="335"></a>     *   routine), or both.  This accommodates situations where the server
<a name="336"></a>     *   might not be able to determine the final value for a header until
<a name="337"></a>     *   after generating full reply.  If this argument is included, it works
<a name="338"></a>     *   just like the 'headers' argument to sendReply().  
<a name="339"></a>     */
<a name="340"></a>    endChunkedReply(headers?);
<a name="341"></a>
<a name="342"></a>    /*
<a name="343"></a>     *   Send the reply to the request asynchronously.  This works like
<a name="344"></a>     *   sendReply(), except that this method starts a new background thread
<a name="345"></a>     *   to handle the data transfer and then immediately returns.  This
<a name="346"></a>     *   allows the caller to continue servicing other requests while the
<a name="347"></a>     *   data transfer proceeds, which is important when sending a large file
<a name="348"></a>     *   (such as a large image or audio file) as the reply body.  Most
<a name="349"></a>     *   browsers allow the user to continue interacting with the displayed
<a name="350"></a>     *   page while images and audio files are transfered in the background,
<a name="351"></a>     *   so it's likely that the browser will generate new requests during
<a name="352"></a>     *   the time it takes to send a single large reply body.  When you use
<a name="353"></a>     *   sendReply(), the server won't be able to service any of those new
<a name="354"></a>     *   requests until the reply is fully sent, so the browser will appear
<a name="355"></a>     *   unresponsive for the duration of the reply data transfer.  Using
<a name="356"></a>     *   sendReplyAsync() allows you to service new requests immediately,
<a name="357"></a>     *   without waiting for the data transfer to complete.
<a name="358"></a>     *   
<a name="359"></a>     *   The parameters are the same as for sendReply().  If 'body' is a
<a name="360"></a>     *   File, this function opens its own separate handle to the file, so
<a name="361"></a>     *   you're free to close the File object immediately, or to continue to
<a name="362"></a>     *   use it for other operations.  Note that if you continue writing to
<a name="363"></a>     *   the file after calling this method, it's unpredictable whether the
<a name="364"></a>     *   reply data will contain the original or updated data (or a mix of
<a name="365"></a>     *   new and old data), since the reply data transfer is handled in a
<a name="366"></a>     *   separate thread that runs in parallel with the main program.
<a name="367"></a>     *   
<a name="368"></a>     *   When the reply data transfer is completed, or if it fails, the
<a name="369"></a>     *   system posts a NetEvent of type NetEvReplyDone to the network
<a name="370"></a>     *   message queue.  The event contains the original HTTPRequest object,
<a name="371"></a>     *   to allow you to relate the event back to the request that generated
<a name="372"></a>     *   the reply, and status information indicating whether or not the
<a name="373"></a>     *   transfer was successful.
<a name="374"></a>     */
<a name="375"></a>    sendReplyAsync(body, contentType?, status?, headers?);
<a name="376"></a>}
<a name="377"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 03/03/2025 from adv3Lite version 2.2.0.3</div>
</body>
</html>

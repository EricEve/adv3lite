<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>debug.t</title></head><body>
<table class=ban><tr><td><h1>debug.t</h1><td align=right><a href="../file/debug.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   ************************************************************************
<a name="6"></a> *   debug.t This module forms part of the adv3Lite library, and defines a
<a name="7"></a> *   number of commands that can be used for debugging purposes.
<a name="8"></a> *
<a name="9"></a> *   (c) 2012-13 Eric Eve (but based partly on code borrowed from the Mercury
<a name="10"></a> *   library (c) Michael J. Roberts).
<a name="11"></a> *
<a name="12"></a> *
<a name="13"></a> */
<a name="14"></a>
<a name="15"></a>
<a name="16"></a>/* We only include any of the code in this module in debug builds */
<a name="17"></a>#ifdef __DEBUG
<a name="18"></a>
<a name="19"></a>DebugCtl: object
<a name="20"></a>    /*
<a name="21"></a>     *   Debug mode options.  Each debug function has an associated ID key,
<a name="22"></a>     *   which is just a string identifying it.  This is a lookup table
<a name="23"></a>     *   that keeps a true/nil value for each key, saying whether the
<a name="24"></a>     *   function is enabled or disabled.  This lets the developer turn
<a name="25"></a>     *   debugging displays on and off individually, so that you don't have
<a name="26"></a>     *   to look at piles of debug output not relevant to the task you're
<a name="27"></a>     *   currently working on.  
<a name="28"></a>     */
<a name="29"></a>    enabled = static (new LookupTable(32, 64))
<a name="30"></a>
<a name="31"></a>    /* list of all debugging options */
<a name="32"></a>    all = ['spelling', 'messages', 'actions', 'doers']
<a name="33"></a>
<a name="34"></a>    /* show the current status */
<a name="35"></a>    status()
<a name="36"></a>    {
<a name="37"></a>        "Debugging options:\n";
<a name="38"></a>        local opts = all.sort(SortAsc);
<a name="39"></a>        foreach (local opt in opts)
<a name="40"></a>            "\t&lt;&lt;opt&gt;&gt; = &lt;&lt;enabled[opt] ? 'on' : 'off'&gt;&gt;\n";
<a name="41"></a>    }
<a name="42"></a>    
<a name="43"></a>    /* LookupTable used to avoid duplicate debug message reports */
<a name="44"></a>    messageIDs = static (new LookupTable(32, 64))    
<a name="45"></a>;
<a name="46"></a>
<a name="47"></a>/*
<a name="48"></a> *   Debug options.  This is the general verb for performing various
<a name="49"></a> *   debugging operations while running the game.  The Debug Action parses
<a name="50"></a> *   the options string to carry out the command.  
<a name="51"></a> */
<a name="52"></a>VerbRule(Debug)
<a name="53"></a>    'debug' literalDobj
<a name="54"></a>    : VerbProduction
<a name="55"></a>    action = Debug
<a name="56"></a>    verbPhrase = 'debug/debugging'
<a name="57"></a>    missingQ = 'which debug option do you want to set'
<a name="58"></a>;
<a name="59"></a>
<a name="60"></a>/* The Debug Action with various options */
<a name="61"></a>DefineSystemAction(Debug)
<a name="62"></a>    execAction(cmd)
<a name="63"></a>    {
<a name="64"></a>        gLiteral = cmd.dobj.name.toLower;
<a name="65"></a>        switch(gLiteral)
<a name="66"></a>        {       
<a name="67"></a>        case 'status':
<a name="68"></a>            DebugCtl.status();
<a name="69"></a>            break;
<a name="70"></a>        case 'off':
<a name="71"></a>        case 'stop':    
<a name="72"></a>            foreach(local opt in DebugCtl.all)
<a name="73"></a>                DebugCtl.enabled[opt] = nil;
<a name="74"></a>            DebugCtl.status();
<a name="75"></a>            break;
<a name="76"></a>        default:
<a name="77"></a>            if(DebugCtl.all.indexOf(gLiteral))
<a name="78"></a>            {
<a name="79"></a>                DebugCtl.enabled[gLiteral] = !DebugCtl.enabled[gLiteral];
<a name="80"></a>                DebugCtl.status();               
<a name="81"></a>            }
<a name="82"></a>            else                
<a name="83"></a>                "That is not a valid option. The valid DEBUG options are DEBUG
<a name="84"></a>                MESSAGES, DEBUG SPELLING, DEBUG ACTIONS, DEBUG DOERS,
<a name="85"></a>                DEBUG OFF or DEBUG STOP (to turn off all options) or
<a name="86"></a>                just DEBUG by itself to break into the debugger. ";
<a name="87"></a>            break;
<a name="88"></a>        }
<a name="89"></a>        
<a name="90"></a>    }
<a name="91"></a>;
<a name="92"></a>
<a name="93"></a>/* DEBUG without any options simply breaks into the debugger, as in adv3 */
<a name="94"></a>DefineSystemAction(DebugI)
<a name="95"></a>    execAction(cmd)
<a name="96"></a>    {
<a name="97"></a>        /* if the debugger is present, break into it */
<a name="98"></a>        if (t3DebugTrace(T3DebugCheck))
<a name="99"></a>            t3DebugTrace(T3DebugBreak);
<a name="100"></a>        else
<a name="101"></a>            DMsg(debugger not present, 'Debugger not present. ');
<a name="102"></a>    }
<a name="103"></a>;
<a name="104"></a>
<a name="105"></a>VerbRule(DebugI)
<a name="106"></a>    'debug' 
<a name="107"></a>    : VerbProduction
<a name="108"></a>    action = DebugI
<a name="109"></a>    verbPhrase = 'debug/debugging'
<a name="110"></a>    missingQ = 'which debug option do you want to set'
<a name="111"></a>;
<a name="112"></a>
<a name="113"></a>/* 
<a name="114"></a> *   The actionTab object holds a table providing the names (as strings)
<a name="115"></a> *   corresponding to the various Action objects, for use with the DEBUG ACTIONS
<a name="116"></a> *   option.
<a name="117"></a> */
<a name="118"></a>actionTab: PreinitObject
<a name="119"></a>    
<a name="120"></a>    /* 
<a name="121"></a>     *   To return the string val corresponding to the Action val, simply look
<a name="122"></a>     *   it up in out ctab table
<a name="123"></a>     */
<a name="124"></a>    symbolToVal(val)
<a name="125"></a>    {
<a name="126"></a>        return ctab[val];        
<a name="127"></a>    }
<a name="128"></a>    
<a name="129"></a>    /* A LookupTable of Actions and their corresponding string names */
<a name="130"></a>    ctab = [* -&gt; '???']
<a name="131"></a>        
<a name="132"></a>    execute()
<a name="133"></a>    {
<a name="134"></a>        /* 
<a name="135"></a>         *   Populate our ctab table by going through the global symbol table at
<a name="136"></a>         *   preinit and storing the value and associated name of every Action
<a name="137"></a>         *   object.
<a name="138"></a>         */
<a name="139"></a>        t3GetGlobalSymbols().forEachAssoc( new function(key, value)
<a name="140"></a>        {
<a name="141"></a>            if(dataType(value) == TypeObject &amp;&amp; value.ofKind(Action))
<a name="142"></a>                ctab[value] = key;
<a name="143"></a>        });
<a name="144"></a>    }
<a name="145"></a>;
<a name="146"></a>
<a name="147"></a>/* 
<a name="148"></a> *   The Purloin Action allows a game author to take any object in the game
<a name="149"></a> *   while testing
<a name="150"></a> */
<a name="151"></a>DefineTAction(Purloin)    
<a name="152"></a>    againRepeatsParse = true
<a name="153"></a>    
<a name="154"></a>    /* The PURLOIN action requires universal scope */
<a name="155"></a>    addExtraScopeItems(whichRole?)
<a name="156"></a>    {
<a name="157"></a>        makeScopeUniversal();
<a name="158"></a>    }
<a name="159"></a>    beforeAction() { }
<a name="160"></a>    afterAction() { }
<a name="161"></a>    turnSequence() { }
<a name="162"></a>    
<a name="163"></a>    /* The Purloin action should work even on a hidden item  */
<a name="164"></a>    unhides = true
<a name="165"></a>;    
<a name="166"></a>
<a name="167"></a>/* 
<a name="168"></a> *   The GONEAR action allows the game author to move the player character to
<a name="169"></a> *   anywhere on the map, while testing.
<a name="170"></a> */
<a name="171"></a>DefineTAction(GoNear)   
<a name="172"></a>    againRepeatsParse = true
<a name="173"></a>    
<a name="174"></a>    /* The GONEAR action requires universal scope */
<a name="175"></a>    addExtraScopeItems(whichRole?)
<a name="176"></a>    {
<a name="177"></a>        makeScopeUniversal();
<a name="178"></a>    }  
<a name="179"></a>    beforeAction() { }
<a name="180"></a>    afterAction() { }
<a name="181"></a>    turnSequence() { }
<a name="182"></a>    
<a name="183"></a>    /* The GoNear action should work even on a hidden item  */
<a name="184"></a>    unhides = true
<a name="185"></a>;
<a name="186"></a>
<a name="187"></a>/*  
<a name="188"></a> *   The FIAT LUX Action can be used to light up the player character (thus
<a name="189"></a> *   bringing light to a dark location). Repeating the FIAT LUX action removes
<a name="190"></a> *   the light from the player character
<a name="191"></a> */
<a name="192"></a>DefineIAction(FiatLux)
<a name="193"></a>    execAction(cmd)
<a name="194"></a>    {
<a name="195"></a>        gPlayerChar.isLit = !gPlayerChar.isLit;
<a name="196"></a>        DMsg(fiat lux, '{I} suddenly {1} glowing. ', gPlayerChar.isLit ? 'start'
<a name="197"></a>             :  'stop' );
<a name="198"></a>    }
<a name="199"></a>    
<a name="200"></a>    beforeAction() { }    
<a name="201"></a>    turnSequence() { }
<a name="202"></a>;
<a name="203"></a>
<a name="204"></a>/* The EVALUATE action allows any expression to be evaluated */
<a name="205"></a>DefineLiteralAction(Evaluate)
<a name="206"></a>    
<a name="207"></a>    /* 
<a name="208"></a>     *   Do we want to use Compiler.compile rather than Compiler.eval()? By default we do since this
<a name="209"></a>     *   circumvents a bug on FrobTADS for Limux users.
<a name="210"></a>     */
<a name="211"></a>    
<a name="212"></a>    useCompile = true
<a name="213"></a>    
<a name="214"></a>    exec(cmd)
<a name="215"></a>    {
<a name="216"></a>        try
<a name="217"></a>        {
<a name="218"></a>            /* 
<a name="219"></a>             *   Try using the Compiler object to evaluate the expression
<a name="220"></a>             *   contained in the name property of the direct object of this
<a name="221"></a>             *   command (i.e. the string literal it was executed upon).
<a name="222"></a>             */
<a name="223"></a>            local res;
<a name="224"></a>            local str = stripQuotesFrom(cmd.dobj.name);
<a name="225"></a>            
<a name="226"></a>            if(useCompile)
<a name="227"></a>            {
<a name="228"></a>                local func = Compiler.compile(str);
<a name="229"></a>                res = func();
<a name="230"></a>            }
<a name="231"></a>            else           
<a name="232"></a>               res = Compiler.eval(str);
<a name="233"></a>            
<a name="234"></a>            if(dataType(res) == TypeEnum)
<a name="235"></a>            {
<a name="236"></a>                local str = enumTabObj.enumTab[res];
<a name="237"></a>                if(str) res = str;
<a name="238"></a>            }
<a name="239"></a>            
<a name="240"></a>            /* Display a string version of the result */
<a name="241"></a>            say(toString(res));
<a name="242"></a>        }
<a name="243"></a>        /* 
<a name="244"></a>         *   If the attempt to evaluate the expression caused a compiler error,
<a name="245"></a>         *   display the exception message.
<a name="246"></a>         */
<a name="247"></a>        catch (CompilerException cex)
<a name="248"></a>        {           
<a name="249"></a>            cex.displayException();
<a name="250"></a>        }
<a name="251"></a>        
<a name="252"></a>        /* 
<a name="253"></a>         *   If the attempt to evaluate the expression caused any other kind of
<a name="254"></a>         *   error, display the exception message.
<a name="255"></a>         */
<a name="256"></a>        catch (Exception ex)
<a name="257"></a>        {
<a name="258"></a>            ex.displayException();
<a name="259"></a>        }
<a name="260"></a>        
<a name="261"></a>    }
<a name="262"></a>    includeInUndo = true
<a name="263"></a>    afterAction() {}
<a name="264"></a>    beforeAction() { }    
<a name="265"></a>    turnSequence() { }
<a name="266"></a>;
<a name="267"></a>
<a name="268"></a>/* An object to store class and object names */
<a name="269"></a>symTab: PreinitObject
<a name="270"></a>    symbolToVal(val)
<a name="271"></a>    {
<a name="272"></a>        return ctab[val];        
<a name="273"></a>    }
<a name="274"></a>    
<a name="275"></a>    ctab = [* -&gt; '???']
<a name="276"></a>    
<a name="277"></a>    /* 
<a name="278"></a>     *   Store a string equivalent of the name of every identifier defined in the
<a name="279"></a>     *   game (and the library)
<a name="280"></a>     */
<a name="281"></a>    execute()
<a name="282"></a>    {
<a name="283"></a>        t3GetGlobalSymbols().forEachAssoc( new function(key, value)
<a name="284"></a>        {
<a name="285"></a>//            if(dataType(value) == TypeObject &amp;&amp; value.isClass)
<a name="286"></a>//                ctab[value] = key;
<a name="287"></a>//            
<a name="288"></a>//            if(dataType(value) == TypeObject &amp;&amp; (value.ofKind(Region)))               
<a name="289"></a>//                ctab[value] = key;
<a name="290"></a>//            
<a name="291"></a>//            if(defined(Actor) &amp;&amp; dataType(value) == TypeObject &amp;&amp;
<a name="292"></a>//               (value.ofKind(ActorState) || value.ofKind(AgendaItem)))
<a name="293"></a>//                ctab[value] = key;
<a name="294"></a>            ctab[value] = key;
<a name="295"></a>        });
<a name="296"></a>    }
<a name="297"></a>;
<a name="298"></a>
<a name="299"></a>
<a name="300"></a>/* Take a string and return the object whose programmatic name it refers to */
<a name="301"></a>symToVal(val)
<a name="302"></a>{    
<a name="303"></a>    return t3GetGlobalSymbols()[val];      
<a name="304"></a>}
<a name="305"></a>    
<a name="306"></a>/* Take a value and return the string representation of its programmatic name */
<a name="307"></a>valToSym(val)
<a name="308"></a>{
<a name="309"></a>    local str;
<a name="310"></a>    switch(dataType(val))
<a name="311"></a>    {
<a name="312"></a>    case TypeSString:        
<a name="313"></a>        return val;
<a name="314"></a>    case TypeInt:
<a name="315"></a>        return toString(val);
<a name="316"></a>    case TypeObject:
<a name="317"></a>        str = symTab.ctab[val]; 
<a name="318"></a>        if(str == '???' &amp;&amp; val.propDefined(&amp;name)) str = val.name;
<a name="319"></a>        return str;
<a name="320"></a>        
<a name="321"></a>    case TypeEnum:
<a name="322"></a>        local enumStr = enumTabObj.enumTab[val];
<a name="323"></a>        if(enumStr) return enumStr;    
<a name="324"></a>        /* Fallthrough deliberate */
<a name="325"></a>    case TypeProp:  
<a name="326"></a>        return symTab.ctab[val]; 
<a name="327"></a>//        return str;   
<a name="328"></a>    case TypeNil:
<a name="329"></a>        return 'nil';
<a name="330"></a>    case TypeTrue:
<a name="331"></a>        return 'true';
<a name="332"></a>    case TypeList:
<a name="333"></a>        str = '[';
<a name="334"></a>        for(local cur in val, local i=1, local len=val.length;; i++)
<a name="335"></a>        {
<a name="336"></a>            str += valToSym(cur);
<a name="337"></a>            if(i &lt; len)
<a name="338"></a>                str += ', ';            
<a name="339"></a>        }
<a name="340"></a>        str += ']';
<a name="341"></a>        return str;
<a name="342"></a>        
<a name="343"></a>    }
<a name="344"></a>    
<a name="345"></a>    return '?';
<a name="346"></a>}
<a name="347"></a>
<a name="348"></a>
<a name="349"></a>/* 
<a name="350"></a> *   Provide TadsObject with an objToString() method so that the EVALUATE
<a name="351"></a> *   command can display some kind of name of the object via the toString()
<a name="352"></a> *   function
<a name="353"></a> */
<a name="354"></a>modify TadsObject
<a name="355"></a>    objToString()
<a name="356"></a>    {
<a name="357"></a>        /* If this object is a class, return the name of the class */
<a name="358"></a>        if(isClass)
<a name="359"></a>            return symTab.symbolToVal(self);
<a name="360"></a>        
<a name="361"></a>        local str = '';
<a name="362"></a>        
<a name="363"></a>        /* 
<a name="364"></a>         *   If the object has a name property, start the string with this
<a name="365"></a>         *   object's name
<a name="366"></a>         */
<a name="367"></a>        if(name != nil)
<a name="368"></a>            str = name + ' ';
<a name="369"></a>        /* 
<a name="370"></a>         *   Otherwise if we have an identifier for this object stored in our
<a name="371"></a>         *   symbol table, use that
<a name="372"></a>         */
<a name="373"></a>        else if(symTab.symbolToVal(self) != '???')
<a name="374"></a>            str = symTab.symbolToVal(self) + ' ';
<a name="375"></a>        
<a name="376"></a>        /*  Append this object's superclass list in parentheses*/
<a name="377"></a>        str  += '(' + getSuperclassList + ')';
<a name="378"></a>        
<a name="379"></a>        /*  Return the result */
<a name="380"></a>        return str;
<a name="381"></a>    }
<a name="382"></a>    
<a name="383"></a>;
<a name="384"></a>
<a name="385"></a>
<a name="386"></a>/* 
<a name="387"></a> *   Adaptation for use with adv3Lite of the tests extension based on work by
<a name="388"></a> *   Ben Cressy, Eric Eve, and N.R.Turner with substantial enhancements by 
<a name="389"></a> *   Mitch Mlinar
<a name="390"></a> */
<a name="391"></a>
<a name="392"></a>/*
<a name="393"></a> *   To use this facility, define Test objects like so:
<a name="394"></a> *
<a name="395"></a> *. foo: Test
<a name="396"></a> *.    testName = 'foo'
<a name="397"></a> *.    testList =
<a name="398"></a> *.    [
<a name="399"></a> *.        'x me',
<a name="400"></a> *.        'i'
<a name="401"></a> *.    ]
<a name="402"></a> *. ;
<a name="403"></a> *
<a name="404"></a> *. bar: Test
<a name="405"></a> *.     testName = 'bar'
<a name="406"></a> *.     testList =
<a name="407"></a> *.     [
<a name="408"></a> *.         'look',
<a name="409"></a> *.         'listen'
<a name="410"></a> *.     ]
<a name="411"></a> *. ;
<a name="412"></a> *
<a name="413"></a> *. allTests: Test
<a name="414"></a> *.     testName = 'all'
<a name="415"></a> *.     testList =
<a name="416"></a> *.     [
<a name="417"></a> *.         'test foo',
<a name="418"></a> *.         'test bar'
<a name="419"></a> *.     ]
<a name="420"></a> *   ;
<a name="421"></a> *
<a name="422"></a> *   Alternatively,  use the template structure to create your test objects more
<a name="423"></a> *   conveniently:
<a name="424"></a> *
<a name="425"></a> *.  someTest: Test 'foo' ['x me', 'i'];
<a name="426"></a> *
<a name="427"></a> *   Unless you're planning to refer to the Test object in some other part of
<a name="428"></a> *   your code, you can save a bit of typing by making it an anonymous object:
<a name="429"></a> *
<a name="430"></a> *. Test 'foo' ['x me', 'i'];
<a name="431"></a> *
<a name="432"></a> */
<a name="433"></a>
<a name="434"></a>
<a name="435"></a>/*
<a name="436"></a> *   Assertion-based testing
<a name="437"></a> *   assertPlayerInRoom room: Fails test when not in room; does nothing otherwise
<a name="438"></a> *   assertPlayerHasItem item(s): Fails test/script when not in possession
<a name="439"></a> *   assertPlayerLacksItem item(s): Fails test/script when in possession
<a name="440"></a> *   assertPlayerRoomHasItem item(s): Fails test/script when not in possession
<a name="441"></a> *   assertPlayerRoomLacksItem item(s): Fails test/script when in possession
<a name="442"></a> *   assertMsg text: Fails if text is not within prior text output messages; clears after
<a name="443"></a> *                   and, by default, before each non-assert message
<a name="444"></a> *   assertMsgClear: Clears assertMsg buffer
<a name="445"></a> *
<a name="446"></a> * 
<a name="447"></a> *   Usage:
<a name="448"></a> *
<a name="449"></a> *   test &lt;name&gt;
<a name="450"></a> *   testall [nostop]
<a name="451"></a> *   list tests [fully|sorted]
<a name="452"></a> *
<a name="453"></a> *
<a name="454"></a> *   Usage:
<a name="455"></a> *
<a name="456"></a> *   test &lt;name&gt;
<a name="457"></a> *   testall
<a name="458"></a> *   list tests [fully|sorted]
<a name="459"></a> *
<a name="460"></a> */
<a name="461"></a>
<a name="462"></a>/////////////////////////////////////
<a name="463"></a>// Mitch's assertion extensions
<a name="464"></a>///////////////////////////////////
<a name="465"></a>
<a name="466"></a>
<a name="467"></a>/* 
<a name="468"></a> *   The code below references an everything object that it didn't previously define. I assume the
<a name="469"></a> *   definition should he aa follows:
<a name="470"></a> */
<a name="471"></a>
<a name="472"></a>/*
<a name="473"></a> *   MM: Eric -- this everything object was part of the original Test file; and I did not
<a name="474"></a> *   change it as it seemed to work
<a name="475"></a> */
<a name="476"></a>
<a name="477"></a>everything: object
<a name="478"></a>    lst()
<a name="479"></a>    {
<a name="480"></a>        local obj = firstObj(Thing);
<a name="481"></a>        
<a name="482"></a>        /* Create a vector to store our results. */
<a name="483"></a>        local vec = new Vector;
<a name="484"></a>        
<a name="485"></a>        /* Go through every Thing in the game and add it to our vector. */
<a name="486"></a>        do
<a name="487"></a>        {
<a name="488"></a>            vec.append(obj);
<a name="489"></a>            obj = nextObj(obj, Thing);
<a name="490"></a>        } while (obj!= nil);
<a name="491"></a>        
<a name="492"></a>        lst = vec.toList();
<a name="493"></a>        return lst;
<a name="494"></a>    }
<a name="495"></a>    
<a name="496"></a>;
<a name="497"></a>
<a name="498"></a>DefineSystemAction(AssertPlayerInRoom)
<a name="499"></a>    
<a name="500"></a>    /* For this action to work all known rooms also need to be in scope */
<a name="501"></a>    addExtraScopeItems(whichRole?)
<a name="502"></a>    {
<a name="503"></a>        scopeList = scopeList.appendUnique(everything.lst().subset({x:
<a name="504"></a>            x.ofKind(Room)}));
<a name="505"></a>    }
<a name="506"></a>
<a name="507"></a>    execAction(cmd)
<a name="508"></a>    {
<a name="509"></a>        if (gActor.isPlayerChar &amp;&amp; gRoom != gDobj) {
<a name="510"></a>            allNewTests.fail('Expected player in room "&lt;&lt;gDobj&gt;&gt;" but was located in "&lt;&lt;gRoom&gt;&gt;"
<a name="511"></a>                instead');
<a name="512"></a>        }
<a name="513"></a>        else
<a name="514"></a>            allNewTests.succeed();
<a name="515"></a>    }  
<a name="516"></a>;
<a name="517"></a>
<a name="518"></a>VerbRule(AssertPlayerInRoom)
<a name="519"></a>	'assertPlayerInRoom' singleDobj
<a name="520"></a>	: VerbProduction
<a name="521"></a>	verbPhrase = 'assertPlayerInRoom (what)'
<a name="522"></a>    action = AssertPlayerInRoom
<a name="523"></a>    missingQ = 'what room is player supposed to be in'
<a name="524"></a>;
<a name="525"></a>
<a name="526"></a>///////////////////////////////////////////////
<a name="527"></a>
<a name="528"></a>DefineSystemAction(AssertPlayerHasItem)
<a name="529"></a>    
<a name="530"></a>    /* For this action to work all known rooms also need to be in scope */
<a name="531"></a>    addExtraScopeItems(whichRole?)
<a name="532"></a>    {
<a name="533"></a>        scopeList = scopeList.appendUnique(everything.lst());
<a name="534"></a>    }
<a name="535"></a>
<a name="536"></a>	execAction(cmd)
<a name="537"></a>	{       
<a name="538"></a>        if(gDobj.ofKind(Fixture) || gDobj.ofKind(Immovable) || gDobj.ofKind(Decoration)) {
<a name="539"></a>            allNewTests.fail('INVALID: Can never have item "&lt;&lt;gDobj&gt;&gt;"!&lt;.p&gt;');
<a name="540"></a>        }
<a name="541"></a>		else if (gActor.isPlayerChar &amp;&amp; !gDobj.isIn(gActor)) {
<a name="542"></a>            allNewTests.fail('Expected player to have item \"&lt;&lt;gDobj&gt;&gt;\" but does not!');
<a name="543"></a>		}
<a name="544"></a>        else
<a name="545"></a>            allNewTests.succeed();
<a name="546"></a>	}
<a name="547"></a>;
<a name="548"></a>
<a name="549"></a>VerbRule(AssertPlayerHasItem)
<a name="550"></a>	'assertPlayerHasItem' singleDobj
<a name="551"></a>	: VerbProduction
<a name="552"></a>	verbPhrase = 'assertPlayerHasItem (what)'
<a name="553"></a>    action = AssertPlayerHasItem
<a name="554"></a>    missingQ = 'what item is player supposed to have in possession'
<a name="555"></a>;
<a name="556"></a>
<a name="557"></a>///////////////////////////////////////////////
<a name="558"></a>
<a name="559"></a>DefineSystemAction(AssertPlayerLacksItem)
<a name="560"></a>    
<a name="561"></a>    /* For this action to work all known rooms also need to be in scope */
<a name="562"></a>    addExtraScopeItems(whichRole?)
<a name="563"></a>    {
<a name="564"></a>        scopeList = scopeList.appendUnique(everything.lst());
<a name="565"></a>    }
<a name="566"></a>
<a name="567"></a>	execAction(cmd)
<a name="568"></a>	{       
<a name="569"></a>        if(gDobj.ofKind(Fixture) || gDobj.ofKind(Immovable) || gDobj.ofKind(Decoration)) {
<a name="570"></a>            allNewTests.fail('INVALID: Can never have item "&lt;&lt;gDobj&gt;&gt;"!');
<a name="571"></a>        }
<a name="572"></a>		else if (gActor.isPlayerChar &amp;&amp; gDobj.isIn(gActor)) {
<a name="573"></a>            allNewTests.fail('Expected player to NOT have item \"&lt;&lt;gDobj&gt;&gt;\" but
<a name="574"></a>                does!');
<a name="575"></a>		}
<a name="576"></a>        else
<a name="577"></a>            allNewTests.succeed();
<a name="578"></a>	}
<a name="579"></a>;
<a name="580"></a>
<a name="581"></a>VerbRule(AssertPlayerLacksItem)
<a name="582"></a>	'assertPlayerLacksItem' singleDobj
<a name="583"></a>	: VerbProduction
<a name="584"></a>	verbPhrase = 'assertPlayerLacksItem (what)'
<a name="585"></a>    action = AssertPlayerLacksItem
<a name="586"></a>    missingQ = 'what item is player NOT supposed to have in possession'
<a name="587"></a>;
<a name="588"></a>
<a name="589"></a>///////////////////////////////////////////////
<a name="590"></a>
<a name="591"></a>DefineSystemAction(AssertPlayerRoomHasItem)
<a name="592"></a>    
<a name="593"></a>    /* For this action to work all known rooms also need to be in scope */
<a name="594"></a>    addExtraScopeItems(whichRole?)
<a name="595"></a>    {
<a name="596"></a>        scopeList = scopeList.appendUnique(everything.lst());
<a name="597"></a>    }
<a name="598"></a>
<a name="599"></a>	execAction(cmd)
<a name="600"></a>	{
<a name="601"></a>        if(gDobj.ofKind(Fixture) || gDobj.ofKind(Immovable) || gDobj.ofKind(Decoration)) {
<a name="602"></a>            allNewTests.fail('INVALID: Can never have item "&lt;&lt;gDobj&gt;&gt;"!&lt;.p&gt;');
<a name="603"></a>        }
<a name="604"></a>		else if (gActor.isPlayerChar &amp;&amp; !gDobj.isIn(gActor.location)) {
<a name="605"></a>            allNewTests.fail('Expected player\'s room to have item \"&lt;&lt;gDobj&gt;&gt;\" but does not!');
<a name="606"></a>		}
<a name="607"></a>        else
<a name="608"></a>            allNewTests.succeed();
<a name="609"></a>	}
<a name="610"></a>;
<a name="611"></a>
<a name="612"></a>VerbRule(AssertPlayerRoomHasItem)
<a name="613"></a>	'assertPlayerRoomHasItem' singleDobj
<a name="614"></a>	: VerbProduction
<a name="615"></a>	verbPhrase = 'assertPlayerRoomHasItem (what)'
<a name="616"></a>    action = AssertPlayerRoomHasItem
<a name="617"></a>    missingQ = 'what item is player\'s room supposed to contain'
<a name="618"></a>;
<a name="619"></a>
<a name="620"></a>///////////////////////////////////////////////
<a name="621"></a>
<a name="622"></a>DefineSystemAction(AssertPlayerRoomLacksItem)
<a name="623"></a>    
<a name="624"></a>    /* For this action to work all known rooms also need to be in scope */
<a name="625"></a>    addExtraScopeItems(whichRole?)
<a name="626"></a>    {
<a name="627"></a>        scopeList = scopeList.appendUnique(everything.lst());
<a name="628"></a>    }
<a name="629"></a>
<a name="630"></a>	execAction(cmd)
<a name="631"></a>	{       
<a name="632"></a>        if(gDobj.ofKind(Fixture) || gDobj.ofKind(Immovable) || gDobj.ofKind(Decoration)) {
<a name="633"></a>            allNewTests.fail('INVALID: Can never have item "&lt;&lt;gDobj&gt;&gt;"!');
<a name="634"></a>        }
<a name="635"></a>		else if (gActor.isPlayerChar &amp;&amp; gDobj.isIn(gActor.location)) {
<a name="636"></a>            allNewTests.fail('Expected player\'s room not to have item \"&lt;&lt;gDobj&gt;&gt;\" but
<a name="637"></a>                it does!');
<a name="638"></a>		}
<a name="639"></a>        else
<a name="640"></a>            allNewTests.succeed();
<a name="641"></a>	}
<a name="642"></a>;
<a name="643"></a>
<a name="644"></a>VerbRule(AssertPlayerRoomLacksItem)
<a name="645"></a>	'assertPlayerRoomLacksItem' singleDobj
<a name="646"></a>	: VerbProduction
<a name="647"></a>	verbPhrase = 'assertPlayerRoomLacksItem (what)'
<a name="648"></a>    action = AssertPlayerRoomLacksItem
<a name="649"></a>    missingQ = 'what item should not be in player\'s room'
<a name="650"></a>;
<a name="651"></a>
<a name="652"></a>///////////////////////////////////////////////
<a name="653"></a>
<a name="654"></a>DefineSystemAction(Assert)
<a name="655"></a>    exec(cmd)
<a name="656"></a>    {
<a name="657"></a>        /* Recreate the literal text */
<a name="658"></a>        local f = gCommandToks.cdr();
<a name="659"></a>        local expr = f.join('');
<a name="660"></a>        local msg = 'assert FAILED';
<a name="661"></a>        local res = nil;
<a name="662"></a>        expr = stripQuotesFrom(expr);
<a name="663"></a>//        "Expr:&lt;&lt;expr&gt;&gt;:\n";
<a name="664"></a>        try
<a name="665"></a>        {
<a name="666"></a>            /* 
<a name="667"></a>             *   Try using the Compiler object to evaluate the expression
<a name="668"></a>             *   contained in the name property of the direct object of this
<a name="669"></a>             *   command (i.e. the string literal it was executed upon).
<a name="670"></a>             */
<a name="671"></a>            
<a name="672"></a>            res = Compiler.eval(expr);
<a name="673"></a>        }
<a name="674"></a>        /* 
<a name="675"></a>         *   If the attempt to evaluate the expression caused a compiler error,
<a name="676"></a>         *   display the exception message.
<a name="677"></a>         */
<a name="678"></a>        catch (CompilerException cex)
<a name="679"></a>        {           
<a name="680"></a>            msg += ' with compiler exception';
<a name="681"></a>        }
<a name="682"></a>        
<a name="683"></a>        /* 
<a name="684"></a>         *   If the attempt to evaluate the expression caused any other kind of
<a name="685"></a>         *   error, display the exception message.
<a name="686"></a>         */
<a name="687"></a>        catch (Exception ex)
<a name="688"></a>        {
<a name="689"></a>            msg += ' with unknown exception';
<a name="690"></a>        }
<a name="691"></a>        
<a name="692"></a>        if(res == nil) {
<a name="693"></a>            msg += ': &lt;&lt;expr&gt;&gt;';
<a name="694"></a>            allNewTests.fail(msg);
<a name="695"></a>        } else {
<a name="696"></a>            // if do not clear this out, it processes the next token
<a name="697"></a>            cmd.nextTokens = [];
<a name="698"></a>            allNewTests.succeed();
<a name="699"></a>        }
<a name="700"></a>    }
<a name="701"></a>;
<a name="702"></a>
<a name="703"></a>
<a name="704"></a>VerbRule(Assert)
<a name="705"></a>    'assert' literalDobj
<a name="706"></a>    : VerbProduction
<a name="707"></a>    action = Assert
<a name="708"></a>    verbPhrase = 'assert (expression)'
<a name="709"></a>    missingQ = 'what expression should be true'
<a name="710"></a>;
<a name="711"></a>
<a name="712"></a>///////////////////////////////////////////////
<a name="713"></a>
<a name="714"></a>DefineSystemAction(AssertMsgClear)
<a name="715"></a>    exec(cmd)
<a name="716"></a>    {
<a name="717"></a>        "Done.\n";
<a name="718"></a>        allNewTests.lastMsg = '';
<a name="719"></a>    }
<a name="720"></a>;
<a name="721"></a>
<a name="722"></a>VerbRule(AssertMsgClear)
<a name="723"></a>    'assertMsgClear'
<a name="724"></a>    : VerbProduction
<a name="725"></a>    action = AssertMsgClear
<a name="726"></a>    verbPhrase = 'assertMsgClear'
<a name="727"></a>;
<a name="728"></a>
<a name="729"></a>///////////////////////////////////////////////
<a name="730"></a>
<a name="731"></a>DefineSystemAction(AssertMsg)
<a name="732"></a>    exec(cmd)
<a name="733"></a>    {
<a name="734"></a>        local f = gCommandToks.cdr();
<a name="735"></a>        local expr = f.join(' ').toLower();
<a name="736"></a>        local fnd = allNewTests.lastMsg.toLower();
<a name="737"></a>
<a name="738"></a>        if(fnd == nil) {
<a name="739"></a>            allNewTests.fail('No message to check for "&lt;&lt;expr&gt;&gt;"');
<a name="740"></a>        }
<a name="741"></a>        else if(!fnd.find(expr)) {
<a name="742"></a>            local msg = 'Message string mismatch:\n  found "&lt;&lt;fnd&gt;&gt;"\n';
<a name="743"></a>            msg += '  expected "&lt;&lt;expr&gt;&gt;"';
<a name="744"></a>            allNewTests.fail(msg);
<a name="745"></a>        }
<a name="746"></a>        else
<a name="747"></a>            allNewTests.succeed();
<a name="748"></a>
<a name="749"></a>        // message is CLEARED after testing so you don't stumble upon old messages
<a name="750"></a>        allNewTests.lastMsg = '';
<a name="751"></a>    }
<a name="752"></a>;
<a name="753"></a>
<a name="754"></a>VerbRule(AssertMsg)
<a name="755"></a>    'assertMsg' literalDobj
<a name="756"></a>    : VerbProduction
<a name="757"></a>    action = AssertMsg
<a name="758"></a>    verbPhrase = 'assertMsg (expression)'
<a name="759"></a>    missingQ = 'what expression should be true'
<a name="760"></a>;
<a name="761"></a>
<a name="762"></a>///////////////////////////////////////////////
<a name="763"></a>///////////////////////////////////////////////
<a name="764"></a>
<a name="765"></a>/* 
<a name="766"></a> * Based upon the Test object in the TADS library, this overhauls it to actually work
<a name="767"></a> * and provide needed functionality for actually ASSERTing if something is correct
<a name="768"></a> * Moreover, the Test did not work and had issues with "leftovers" where each subsequent
<a name="769"></a> * test depended upon the results of the previous test!
<a name="770"></a> * 
<a name="771"></a> *
<a name="772"></a> *.  Test 'foo' ['x me', 'i', 'wear uniform'] [uniform] @location;
<a name="773"></a> *
<a name="774"></a> *   Would cause the uniform to be moved into the player character's inventory
<a name="775"></a> *   and then the commands X ME and then I and WEAR UNIFORM to be executed in
<a name="776"></a> *   response to TEST FOO.  Both the location and the inventory entries are optional
<a name="777"></a> */
<a name="778"></a>
<a name="779"></a>class Test: object
<a name="780"></a>    /* The name of this test */
<a name="781"></a>    testName = 'nil'
<a name="782"></a>    
<a name="783"></a>    /* The list commands to be executed when running this test. */
<a name="784"></a>    testList = [ 'z' ]
<a name="785"></a>    
<a name="786"></a>    /*   
<a name="787"></a>     *   The objects to move into the player character's inventory before
<a name="788"></a>     *   running the test script.
<a name="789"></a>     */
<a name="790"></a>    testHolding = []    // objects to move
<a name="791"></a>    
<a name="792"></a>    /* 
<a name="793"></a>     *   The location to move the player character to before running the test
<a name="794"></a>     *   script
<a name="795"></a>     */
<a name="796"></a>    location = nil
<a name="797"></a>    
<a name="798"></a>    /*  
<a name="799"></a>     *   Flag: do we want to report on what items were added to inventory? By
<a name="800"></a>     *   default we do.
<a name="801"></a>     */
<a name="802"></a>    reportHolding = true
<a name="803"></a>	
<a name="804"></a>    /* 
<a name="805"></a>     *   Flag: Do we want to report any change of location by looking around in
<a name="806"></a>     *   the new one? By default we will.
<a name="807"></a>     */
<a name="808"></a>    reportMove = true
<a name="809"></a>    
<a name="810"></a>    /*
<a name="811"></a>     *   Restore game to where it was before this test.  
<a name="812"></a>     *   The default value is nil.
<a name="813"></a>     */   
<a name="814"></a>    restoreStartStateAfterTest = nil
<a name="815"></a>    
<a name="816"></a>    /*
<a name="817"></a>     *   If you need to restart the game BEFORE running the test
<a name="818"></a>     *   activity and values
<a name="819"></a>     */   
<a name="820"></a>    restartBeforeTest = nil
<a name="821"></a>    
<a name="822"></a>    /*
<a name="823"></a>     *   By default, we want to clear out the message buffer before each non-assert
<a name="824"></a>     *   command, but you can change that for each test
<a name="825"></a>     */   
<a name="826"></a>    clearAssertBufferBeforeCmd = true
<a name="827"></a>
<a name="828"></a>    /////////////////////
<a name="829"></a>    
<a name="830"></a>    /* Move everything in the testHolding list into the actor's inventory */
<a name="831"></a>    getHolding()
<a name="832"></a>    {
<a name="833"></a>        foreach (local x in testHolding) {
<a name="834"></a>            x.moveInto(gActor);
<a name="835"></a>            x.isHidden = nil;   // otherwise cannot see or interact with it
<a name="836"></a>
<a name="837"></a>        }
<a name="838"></a>        
<a name="839"></a>        /* 
<a name="840"></a>         *   If we want to report on the effect of moving additional items into
<a name="841"></a>         *   the player character's inventory, and if we specified any items to
<a name="842"></a>         *   move, report that the actor is now holding those items.
<a name="843"></a>         */
<a name="844"></a>        if(reportHolding &amp;&amp; testHolding.length &gt; 0)
<a name="845"></a>            DMsg(debug test now holding, '{I} {am} {now} holding {1}.\n',
<a name="846"></a>                 makeListStr(testHolding, &amp;theName));
<a name="847"></a>    }
<a name="848"></a>
<a name="849"></a>    /* 
<a name="850"></a>     *   Run this test by passing the commands into a script file to replay
<a name="851"></a>     */
<a name="852"></a>    run()
<a name="853"></a>    {        
<a name="854"></a>        "====================================\n";
<a name="855"></a>        "Test: \"&lt;&lt;testName&gt;&gt;\"\n";
<a name="856"></a>
<a name="857"></a>        if(restartBeforeTest) {
<a name="858"></a>            local hld = allNewTests.savedState();
<a name="859"></a>            if(allNewTests.restoregame(&amp;restartSaveFile) == nil) {
<a name="860"></a>                allNewTests.isTesting = nil;    // failed so quit the test
<a name="861"></a>                return;
<a name="862"></a>            }
<a name="863"></a>            allNewTests.restoreState(hld);
<a name="864"></a>        }
<a name="865"></a>
<a name="866"></a>        /* we save the entire game at this point by default to restore it */
<a name="867"></a>        if(restoreStartStateAfterTest)
<a name="868"></a>            allNewTests.savegame(&amp;revertSaveFile); // save the current state
<a name="869"></a>
<a name="870"></a>        /* 
<a name="871"></a>         *   If a location is specified, first move the actor into that
<a name="872"></a>         *   location.
<a name="873"></a>         */
<a name="874"></a>        if (location &amp;&amp; gPlayerChar.location != location)
<a name="875"></a>        {
<a name="876"></a>            gPlayerChar.moveInto(location);	
<a name="877"></a>            
<a name="878"></a>            /* If we want to report the move, show the new room description */
<a name="879"></a>            if(reportMove)
<a name="880"></a>                gPlayerChar.getOutermostRoom.lookAroundWithin();
<a name="881"></a>        }
<a name="882"></a>        
<a name="883"></a>        /*   Move any required objects into the actor's inventory */
<a name="884"></a>        getHolding();
<a name="885"></a>
<a name="886"></a>        /* Export a file to use */
<a name="887"></a>        local txt;
<a name="888"></a>        local temp = new TemporaryFile();
<a name="889"></a>        local f = File.openTextFile(temp, FileAccessWrite, 'ascii');
<a name="890"></a>
<a name="891"></a>        local testVec = new Vector(testList);
<a name="892"></a>
<a name="893"></a>        /*   Preparse and execute each command in the list */
<a name="894"></a>        local linecnt = 0;
<a name="895"></a>        testVec.forEach(new function(x)  {
<a name="896"></a>            local c = x.trim();
<a name="897"></a>            f.writeFile('&gt;&lt;&lt;c&gt;&gt;\n');
<a name="898"></a>            ++linecnt;
<a name="899"></a>        });
<a name="900"></a>        f.closeFile();
<a name="901"></a>        allNewTests.isTesting = true;
<a name="902"></a>        setScriptFile(temp,ScriptFileNonstop);
<a name="903"></a>        do
<a name="904"></a>        {
<a name="905"></a>            /* Display score notifications if the score module is included. */
<a name="906"></a>            if(defined(scoreNotifier) &amp;&amp; scoreNotifier.checkNotification())
<a name="907"></a>                ;
<a name="908"></a>            
<a name="909"></a>            /* run any PromptDaemons if the events module is included */
<a name="910"></a>            if(defined(eventManager) &amp;&amp; eventManager.executePrompt())
<a name="911"></a>                ;
<a name="912"></a>        
<a name="913"></a>            try
<a name="914"></a>            {
<a name="915"></a>                /* Output a paragraph break */
<a name="916"></a>                "&lt;.p&gt;";
<a name="917"></a>                
<a name="918"></a>                /* Read a new command from the keyboard. */
<a name="919"></a>                "&lt;.inputline&gt;";
<a name="920"></a>                DMsg(command prompt, '&gt;');
<a name="921"></a>                txt = inputManager.getInputLine();
<a name="922"></a>                "&lt;./inputline&gt;\n";   
<a name="923"></a>                
<a name="924"></a>                if(clearAssertBufferBeforeCmd &amp;&amp; !txt.startsWith('assert'))
<a name="925"></a>                    allNewTests.lastMsg = '';
<a name="926"></a>                
<a name="927"></a>                
<a name="928"></a>                /* Pass the command through all our StringPreParsers */
<a name="929"></a>                txt = StringPreParser.runAll(txt, Parser.rmcType());
<a name="930"></a>                
<a name="931"></a>                /* 
<a name="932"></a>                 *   If the txt is now nil, a StringPreParser has fully dealt with
<a name="933"></a>                 *   the command, so go back and prompt for another one.
<a name="934"></a>                 */        
<a name="935"></a>                if(txt == nil)
<a name="936"></a>                    continue;
<a name="937"></a>                
<a name="938"></a>                /* Parse and execute the command. */
<a name="939"></a>                Parser.parse(txt);
<a name="940"></a>            }
<a name="941"></a>            catch(TerminateCommandException tce)
<a name="942"></a>            {
<a name="943"></a>                
<a name="944"></a>            }
<a name="945"></a>            
<a name="946"></a>            /* Update the status line. */
<a name="947"></a>            statusLine.showStatusLine();
<a name="948"></a> 
<a name="949"></a>        } while (--linecnt &gt; 0 &amp;&amp; allNewTests.isTesting);
<a name="950"></a>
<a name="951"></a>        if(restoreStartStateAfterTest) {
<a name="952"></a>
<a name="953"></a>            local hld = allNewTests.savedState();
<a name="954"></a>            allNewTests.restoregame(&amp;revertSaveFile); // restore the saved state
<a name="955"></a>            allNewTests.restoreState(hld);
<a name="956"></a>        }
<a name="957"></a>        // this means an error happened so this script needs to go away
<a name="958"></a>        if(!allNewTests.isTesting)
<a name="959"></a>            setScriptFile(nil);
<a name="960"></a>        temp.deleteFile();
<a name="961"></a>    }
<a name="962"></a>    
<a name="963"></a>    /* 
<a name="964"></a>     *   The test all command will run tests in ascending order of their test order. By default we
<a name="965"></a>     *   use the sourceTextOrder.
<a name="966"></a>     */
<a name="967"></a>    testOrder = sourceTextOrder
<a name="968"></a>;
<a name="969"></a>    
<a name="970"></a>/*
<a name="971"></a> *   The 'list tests' and 'list tests fully' commands can be used to list your
<a name="972"></a> *   test scripts from within the running game.
<a name="973"></a> */   
<a name="974"></a>DefineSystemAction(GListTests)
<a name="975"></a>    execAction(cmd)
<a name="976"></a>    {
<a name="977"></a>        if(allNewTests.lst.length == 0)
<a name="978"></a>        {
<a name="979"></a>            DMsg(no test scripts, 'There are no test scripts defined in this
<a name="980"></a>                game. ');
<a name="981"></a>            exit;
<a name="982"></a>        }
<a name="983"></a>
<a name="984"></a>        local fully = cmd.verbProd.fully;
<a name="985"></a>        local sorted = cmd.verbProd.sorted;
<a name="986"></a>        
<a name="987"></a>        local testlist = allNewTests.lst;
<a name="988"></a>        if(sorted) {
<a name="989"></a>            testlist = testlist.sort(nil, { a, b: a.testName.compareTo(b.testName) });
<a name="990"></a>        }
<a name="991"></a>        
<a name="992"></a>        foreach(local testObj in testlist)
<a name="993"></a>        {
<a name="994"></a>            "&lt;&lt;testObj.testName&gt;&gt;: ";
<a name="995"></a>            if(fully)               
<a name="996"></a>            {
<a name="997"></a>                foreach(local txt in testObj.testList)
<a name="998"></a>                    "&lt;&lt;txt&gt;&gt;/";
<a name="999"></a>                "\n";
<a name="1000"></a>            } else {
<a name="1001"></a>                "restoreAfter=&lt;&lt;yesNo(testObj.restoreStartStateAfterTest)&gt;&gt;, ";
<a name="1002"></a>                "firstRestart=&lt;&lt;yesNo(testObj.restartBeforeTest)&gt;&gt;, ";
<a name="1003"></a>                "clearAssertBuff=&lt;&lt;yesNo(testObj.clearAssertBufferBeforeCmd)&gt;&gt;\n";
<a name="1004"></a>            }
<a name="1005"></a>        }
<a name="1006"></a>    }
<a name="1007"></a>    
<a name="1008"></a>    yesNo(bval) { return bval? 'yes' : 'no'; }
<a name="1009"></a>;
<a name="1010"></a>
<a name="1011"></a>VerbRule(GListTests)
<a name="1012"></a>    ('list' | 'l') 'tests' (| 'fully' -&gt; fully | 'sorted' -&gt; sorted)
<a name="1013"></a>    : VerbProduction
<a name="1014"></a>    action = GListTests
<a name="1015"></a>    verbPhrase = 'list/listing test scripts'
<a name="1016"></a>;
<a name="1017"></a>
<a name="1018"></a>/*
<a name="1019"></a> *   The 'test X' command can be used with any Test object defined in the source
<a name="1020"></a> *   code:
<a name="1021"></a> */
<a name="1022"></a>DefineLiteralAction(GTest)
<a name="1023"></a>    /* 
<a name="1024"></a>     *   We override exec() rather than exeAction() here, since we want to skip
<a name="1025"></a>     *   all the normal turn sequence routines such as before and after
<a name="1026"></a>     *   notifications and advancing the turn count.
<a name="1027"></a>     */
<a name="1028"></a>    exec(cmd)
<a name="1029"></a>    {
<a name="1030"></a>        local target = cmd.dobj.name.toLower();
<a name="1031"></a>        local script = allNewTests.valWhich({x: x.testName.toLower == target});
<a name="1032"></a>        if (script) {
<a name="1033"></a>            allNewTests.totasserts = 0;
<a name="1034"></a>            allNewTests.fasserts = 0;
<a name="1035"></a>            script.run();
<a name="1036"></a>        }
<a name="1037"></a>        else
<a name="1038"></a>            DMsg(test sequence not found, 'Test sequence not found. ');
<a name="1039"></a>    }
<a name="1040"></a>    
<a name="1041"></a>    /* Do nothing after the main action */
<a name="1042"></a>    afterAction() { }
<a name="1043"></a>      
<a name="1044"></a>    turnSequence() { }
<a name="1045"></a>;
<a name="1046"></a>
<a name="1047"></a>VerbRule(GTest)
<a name="1048"></a>    'test' literalDobj
<a name="1049"></a>    : VerbProduction
<a name="1050"></a>    action = GTest
<a name="1051"></a>    verbPhrase = 'test/testing (what)'
<a name="1052"></a>    missingQ = 'which sequence do you want to test'
<a name="1053"></a>;
<a name="1054"></a>
<a name="1055"></a>
<a name="1056"></a>////////////////////////////////////////////////
<a name="1057"></a>
<a name="1058"></a>DefineSystemAction(TestAll)
<a name="1059"></a>    execAction(cmd)
<a name="1060"></a>    {
<a name="1061"></a>        if(allNewTests.lst.length == 0)
<a name="1062"></a>        {
<a name="1063"></a>            DMsg(no test scripts, 'There are no test scripts defined in this
<a name="1064"></a>                game. ');
<a name="1065"></a>            exit;
<a name="1066"></a>        }
<a name="1067"></a>
<a name="1068"></a>        allNewTests.totasserts = 0;
<a name="1069"></a>        allNewTests.fasserts = 0;        
<a name="1070"></a>        
<a name="1071"></a>        local testenostop = cmd.verbProd.testnostop;
<a name="1072"></a>        local defstop = allNewTests.stopOnFail; // what it was
<a name="1073"></a>        if(testenostop)
<a name="1074"></a>            allNewTests.stopOnFail = nil;
<a name="1075"></a>        local cntr = 0;
<a name="1076"></a>
<a name="1077"></a>        foreach(local testObj in allNewTests.lst)
<a name="1078"></a>        {
<a name="1079"></a>            ++cntr;
<a name="1080"></a>            testObj.run();
<a name="1081"></a>            if(allNewTests.stopOnFail &amp;&amp; !allNewTests.isTesting)  // Houston, we have a problem
<a name="1082"></a>                break;
<a name="1083"></a>            allNewTests.isTesting = nil;
<a name="1084"></a>        }
<a name="1085"></a>        if(testenostop)
<a name="1086"></a>            allNewTests.stopOnFail = defstop;   // restore prior setting
<a name="1087"></a>
<a name="1088"></a>        "===========================\n";
<a name="1089"></a>        "===========================\n";
<a name="1090"></a>        "Total tests: \ \ \ \ \ &lt;&lt;cntr&gt;&gt;\n";
<a name="1091"></a>        "Total asserts: \ \ &lt;&lt;allNewTests.totasserts&gt;&gt;\n";
<a name="1092"></a>        "Failed asserts: &lt;&lt;allNewTests.fasserts&gt;&gt;\n";
<a name="1093"></a>        "===========================&lt;.p&gt;";
<a name="1094"></a>    }
<a name="1095"></a>;
<a name="1096"></a>
<a name="1097"></a>VerbRule(TestAll)
<a name="1098"></a>    'testall' (| 'nostop' -&gt; testnostop)
<a name="1099"></a>    : VerbProduction
<a name="1100"></a>    action = TestAll
<a name="1101"></a>    verbPhrase = 'testall test scripts'
<a name="1102"></a>;
<a name="1103"></a>
<a name="1104"></a>
<a name="1105"></a>////////////////////////////////////////////////
<a name="1106"></a>
<a name="1107"></a>/* 
<a name="1108"></a> *   The allTests object contains a list of Test objects for listing via the
<a name="1109"></a> *   LIST TESTS command, and for finding the test that corresponds to a
<a name="1110"></a> *   particular testName.
<a name="1111"></a> */
<a name="1112"></a>allNewTests: object
<a name="1113"></a>    
<a name="1114"></a>    // when set (the default), quit testing when failed assertion encountered
<a name="1115"></a>    stopOnFail = true
<a name="1116"></a>    
<a name="1117"></a>   lst()
<a name="1118"></a>   {
<a name="1119"></a>      if (lst_ == nil)
<a name="1120"></a>         initLst();
<a name="1121"></a>      return lst_;
<a name="1122"></a>   }
<a name="1123"></a>
<a name="1124"></a>    initLst()
<a name="1125"></a>    {
<a name="1126"></a>        lst_ = new Vector(100);
<a name="1127"></a>        local obj = firstObj(Test);
<a name="1128"></a>        while (obj != nil)
<a name="1129"></a>        {
<a name="1130"></a>            lst_.append(obj);
<a name="1131"></a>            obj = nextObj(obj, Test);
<a name="1132"></a>        }
<a name="1133"></a>        lst_ = lst_.toList().sort(SortAsc, {x, y: x.testOrder - y.testOrder});
<a name="1134"></a>    }
<a name="1135"></a>
<a name="1136"></a>   valWhich(cond)
<a name="1137"></a>   {
<a name="1138"></a>      return lst().valWhich(cond);
<a name="1139"></a>   }
<a name="1140"></a>    
<a name="1141"></a>    isTesting = nil     // indicator to tadsSay() about copying outcome here as well
<a name="1142"></a>    // last message(s) to copy here; reset before each non-test cmd or after assertMsg
<a name="1143"></a>    lastMsg = ''
<a name="1144"></a>    
<a name="1145"></a>    // counter of failed asserts and total asserts
<a name="1146"></a>    totasserts = 0
<a name="1147"></a>    fasserts = 0
<a name="1148"></a>
<a name="1149"></a>    setLastMsg(msg) {
<a name="1150"></a>        msg = msg.specialsToText().trim();
<a name="1151"></a>        msg = msg.findReplace('\n',' ',ReplaceAll);
<a name="1152"></a>        msg = msg.findReplace('\b',' ',ReplaceAll).trim();
<a name="1153"></a>        // solves situation of multiple-multiple spaces
<a name="1154"></a>        while(msg.find('  ') != nil)
<a name="1155"></a>            msg = msg.findReplace('  ',' ',ReplaceAll);
<a name="1156"></a>        lastMsg += ' &lt;&lt;msg&gt;&gt;';  // just keep concantenating with space between
<a name="1157"></a>    }
<a name="1158"></a>    
<a name="1159"></a>    fail(msg) {
<a name="1160"></a>        ++totasserts;
<a name="1161"></a>        ++fasserts;
<a name="1162"></a>        isTesting = nil;        // signals the end of THIS test
<a name="1163"></a>        "&lt;.p&gt;###  &lt;&lt;msg&gt;&gt;&lt;.p&gt;";
<a name="1164"></a>    }
<a name="1165"></a>    
<a name="1166"></a>    succeed(msg?) {
<a name="1167"></a>        if(msg == nil || msg == '')
<a name="1168"></a>            msg = 'Valid!';     // need to say something
<a name="1169"></a>        ++totasserts;
<a name="1170"></a>        "&lt;&lt;msg&gt;&gt;&lt;.p&gt;";
<a name="1171"></a>    }
<a name="1172"></a>
<a name="1173"></a>    // when undo() happens, it reverts all values to what they were prior to savepoint!
<a name="1174"></a>    savedState() { return [totasserts,fasserts,isTesting,restartSaveFile,revertSaveFile]; }
<a name="1175"></a>    restoreState(lst) {
<a name="1176"></a>        totasserts = lst[1];
<a name="1177"></a>        fasserts = lst[2];
<a name="1178"></a>        isTesting = lst[3];
<a name="1179"></a>        restartSaveFile = lst[4];
<a name="1180"></a>        revertSaveFile = lst[5];        
<a name="1181"></a>    }
<a name="1182"></a>
<a name="1183"></a>    restartSaveFile = nil       // this gets created at the start of the game
<a name="1184"></a>    revertSaveFile = nil        // and this gets created during testing
<a name="1185"></a>    
<a name="1186"></a>//    init() { savegame(&amp;restartSaveFile); }
<a name="1187"></a>    
<a name="1188"></a>    // exit with error if game cannot be saved
<a name="1189"></a>    savegame(fprop) {
<a name="1190"></a>        // only want to create temp file once per property per game
<a name="1191"></a>        local f = self.(fprop);
<a name="1192"></a>        
<a name="1193"></a>        if(f == nil)
<a name="1194"></a>            f = new TemporaryFile();
<a name="1195"></a>        try {
<a name="1196"></a>            saveGame(f);
<a name="1197"></a>        }
<a name="1198"></a>        catch (StorageServerError sse)
<a name="1199"></a>        {
<a name="1200"></a>            /* the save failed due to a storage server problem - explain */           
<a name="1201"></a>            DMsg(save failed on server, '&lt;.parser&gt;Failed, because of a problem
<a name="1202"></a>                accessing the storage server:
<a name="1203"></a>                &lt;&lt;makeSentence(sse.errMsg)&gt;&gt;&lt;./parser&gt;');
<a name="1204"></a>
<a name="1205"></a>            /* done */
<a name="1206"></a>            return;
<a name="1207"></a>        }
<a name="1208"></a>        catch (RuntimeError err)
<a name="1209"></a>        {
<a name="1210"></a>            /* the save failed - mention the problem */
<a name="1211"></a>            DMsg(save failed, '&lt;.parser&gt;Failed; your computer might be running
<a name="1212"></a>                low on disk space, or you might not have the necessary
<a name="1213"></a>                permissions to write this file.&lt;./parser&gt;');            
<a name="1214"></a>            
<a name="1215"></a>            /* done */
<a name="1216"></a>            return;
<a name="1217"></a>        }
<a name="1218"></a>        self.(fprop) = f;    // it worked
<a name="1219"></a>    }
<a name="1220"></a>   
<a name="1221"></a>    // return true if restored game ok, else nil
<a name="1222"></a>    restoregame(fprop) {
<a name="1223"></a>        if(self.(fprop) == nil) {
<a name="1224"></a>            "&lt;.p&gt;### No save file created!&lt;.p&gt;";
<a name="1225"></a>            return nil;
<a name="1226"></a>        }
<a name="1227"></a>        try
<a name="1228"></a>        {
<a name="1229"></a>            /* restore the file */
<a name="1230"></a>            restoreGame(self.(fprop));
<a name="1231"></a>        }
<a name="1232"></a>        catch (StorageServerError sse)
<a name="1233"></a>        {
<a name="1234"></a>            /* failed due to a storage server error - explain the problem */
<a name="1235"></a>            DMsg(restore failed on server,'&lt;.parser&gt;Failed, because of a problem
<a name="1236"></a>                accessing the storage server:
<a name="1237"></a>                &lt;&lt;makeSentence(sse.errMsg)&gt;&gt;&lt;./parser&gt;');            
<a name="1238"></a>
<a name="1239"></a>            /* indicate failure */
<a name="1240"></a>            return nil;
<a name="1241"></a>        }
<a name="1242"></a>        catch (RuntimeError err)
<a name="1243"></a>        {
<a name="1244"></a>            /* failed - check the error to see what went wrong */
<a name="1245"></a>            switch(err.errno_)
<a name="1246"></a>            {
<a name="1247"></a>            case 1201:
<a name="1248"></a>                /* not a saved state file */
<a name="1249"></a>                DMsg(restore invalid file, '&lt;.parser&gt;Failed: this is not a valid
<a name="1250"></a>                    saved position file.&lt;./parser&gt; ');                
<a name="1251"></a>                break;
<a name="1252"></a>                
<a name="1253"></a>            case 1202:
<a name="1254"></a>                /* saved by different game or different version */
<a name="1255"></a>                DMsg(restore invalid match, '&lt;.parser&gt;Failed: the file was not
<a name="1256"></a>                    saved by this story (or was saved by an incompatible version
<a name="1257"></a>                    of the story).&lt;./parser&gt; ');               
<a name="1258"></a>                break;
<a name="1259"></a>                
<a name="1260"></a>            case 1207:
<a name="1261"></a>                /* corrupted saved state file */
<a name="1262"></a>                DMsg(restore corrupted file, '&lt;.parser&gt;Failed: this saved state
<a name="1263"></a>                    file appears to be corrupted.  This can occur if the file
<a name="1264"></a>                    was modified by another program, or the file was copied
<a name="1265"></a>                    between computers in a non-binary transfer mode, or the
<a name="1266"></a>                    physical media storing the file were damaged.&lt;./parser&gt; ');                
<a name="1267"></a>                break;
<a name="1268"></a>                
<a name="1269"></a>            default:
<a name="1270"></a>                /* some other failure */
<a name="1271"></a>                DMsg(restore failed, '&lt;.parser&gt;Failed: the position could not be
<a name="1272"></a>                    restored.&lt;./parser&gt;');                
<a name="1273"></a>                break;
<a name="1274"></a>            }
<a name="1275"></a>
<a name="1276"></a>            /* indicate failure */
<a name="1277"></a>            return nil;
<a name="1278"></a>        }
<a name="1279"></a>               
<a name="1280"></a>        /* set the appropriate restore-action code */
<a name="1281"></a>        PostRestoreObject.restoreCode = 2;  // user restore
<a name="1282"></a>
<a name="1283"></a>        /* notify all PostRestoreObject instances */
<a name="1284"></a>        PostRestoreObject.classExec();
<a name="1285"></a>
<a name="1286"></a>        /* Ensure the current actor is defined. */
<a name="1287"></a>        gActor = gActor ?? gPlayerChar;
<a name="1288"></a>        
<a name="1289"></a>        return true;
<a name="1290"></a>    }
<a name="1291"></a>   
<a name="1292"></a>    lst_ = nil  // the tests that are found
<a name="1293"></a>;
<a name="1294"></a>
<a name="1295"></a>/* Modificatiion to allow assert to test for the presence of particular strings in game output. */
<a name="1296"></a>modify aioSay(txt)
<a name="1297"></a>{
<a name="1298"></a>    if(allNewTests.isTesting)
<a name="1299"></a>    {       
<a name="1300"></a>        allNewTests.setLastMsg(txt);        
<a name="1301"></a>    }
<a name="1302"></a>    
<a name="1303"></a>    replaced(txt);
<a name="1304"></a>}
<a name="1305"></a>
<a name="1306"></a>/* Create a save file at game startup to allow a Test to restore before running. */
<a name="1307"></a>testInit: InitObject
<a name="1308"></a>   testRestart = true
<a name="1309"></a>   execute()
<a name="1310"></a>   {
<a name="1311"></a>      if(testRestart)
<a name="1312"></a>          allNewTests.savegame(&amp;restartSaveFile);
<a name="1313"></a>   }
<a name="1314"></a>;
<a name="1315"></a>
<a name="1316"></a>
<a name="1317"></a>
<a name="1318"></a>#endif // __DEBUG
<a name="1319"></a>
<a name="1320"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 20/10/2025 from adv3Lite version 2.2.1.1</div>
</body>
</html>

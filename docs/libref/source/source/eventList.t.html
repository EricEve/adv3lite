<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>eventList.t</title></head><body>
<table class=ban><tr><td><h1>eventList.t</h1><td align=right><a href="../file/eventList.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   ************************************************************************
<a name="6"></a> *   eventList.t This module forms an optional part of the adv3Lite library.
<a name="7"></a> *   
<a name="8"></a> *
<a name="9"></a> *   (c) 2012-13 Eric Eve (but based largely on code borrowed from the adv3
<a name="10"></a> *   library Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="11"></a> *   Lightly adapted by Eric Eve for use in the advLite library
<a name="12"></a> *
<a name="13"></a> *   adv3Lite Library - EventLists
<a name="14"></a> *
<a name="15"></a> *   This module contains definitions of various types of EventLists. These are
<a name="16"></a> *   defined in a separate module so that games that don't require EventLists
<a name="17"></a> *   can exclude this module from the build. The Script class, from which all
<a name="18"></a> *   EventLists inherits is defined in misc.t to allow other modules to test for
<a name="19"></a> *   an object being ofKind(Script) even when this EventList module is not
<a name="20"></a> *   present.
<a name="21"></a> */
<a name="22"></a>
<a name="23"></a>
<a name="24"></a>/*
<a name="25"></a> *   Random-Firing script add-in.  This is a mix-in class that you can add
<a name="26"></a> *   to the superclass list of any Script subclass to make the script
<a name="27"></a> *   execute only a given percentage of the time it's invoked.  Each time
<a name="28"></a> *   doScript() is invoked on the script, we'll look at the probability
<a name="29"></a> *   settings (see the properties below) to determine whether we really
<a name="30"></a> *   want to execute the script this time; if so, we'll proceed with the
<a name="31"></a> *   scripted event, otherwise we'll just return immediately, doing
<a name="32"></a> *   nothing.
<a name="33"></a> *   
<a name="34"></a> *   Note that this must be used in the superclass list *before* the Script
<a name="35"></a> *   subclass:
<a name="36"></a> *   
<a name="37"></a> *   myScript: RandomFiringScript, EventList
<a name="38"></a> *.    // ...my definitions...
<a name="39"></a> *.  ;
<a name="40"></a> *   
<a name="41"></a> *   This class is especially useful for random atmospheric events, because
<a name="42"></a> *   it allows you to make the timing of scripted events random.  Rather
<a name="43"></a> *   than making a scripted event happen on every single turn, you can use
<a name="44"></a> *   this to make events happen only sporadically.  It can often feel too
<a name="45"></a> *   predictable and repetitious when a random background event happens on
<a name="46"></a> *   every single turn; firing events less frequently often makes them feel
<a name="47"></a> *   more realistic.  
<a name="48"></a> */
<a name="49"></a>class RandomFiringScript: object
<a name="50"></a>    /* 
<a name="51"></a>     *   Percentage of the time an event occurs.  By default, we execute an
<a name="52"></a>     *   event 100% of the time - meaning every time that doScript() is
<a name="53"></a>     *   invoked.  If you set this to a lower percentage, then each time
<a name="54"></a>     *   doScript() is invoked, we'll randomly decide whether or not to
<a name="55"></a>     *   execute an event based on this percentage.  For example, if you
<a name="56"></a>     *   want an event to execute on average about a third of the time, set
<a name="57"></a>     *   this to 33.
<a name="58"></a>     *   
<a name="59"></a>     *   Note that this is a probabilistic frequency.  Setting this to 33
<a name="60"></a>     *   does *not* mean that we'll execute exactly every third time.
<a name="61"></a>     *   Rather, it means that we'll randomly execute or not on each
<a name="62"></a>     *   invocation, and averaged over a large number of invocations, we'll
<a name="63"></a>     *   execute about a third of the time.  
<a name="64"></a>     */
<a name="65"></a>    eventPercent = 100
<a name="66"></a>
<a name="67"></a>    /* 
<a name="68"></a>     *   Random atmospheric events can get repetitive after a while, so we
<a name="69"></a>     *   provide an easy way to reduce the frequency of our events after a
<a name="70"></a>     *   while.  This way, we'll generate the events more frequently at
<a name="71"></a>     *   first, but once the player has seen them enough to get the idea,
<a name="72"></a>     *   we'll cut back.  Sometimes, the player will spend a lot of time in
<a name="73"></a>     *   one place trying to solve a puzzle, so the same set of random
<a name="74"></a>     *   events can get stale.  Set eventReduceAfter to the number of times
<a name="75"></a>     *   you want the events to be generated at full frequency; after we've
<a name="76"></a>     *   fired events that many times, we'll change eventPercent to
<a name="77"></a>     *   eventReduceTo.  If eventReduceAfter is nil, we won't ever change
<a name="78"></a>     *   eventPercent.  
<a name="79"></a>     */
<a name="80"></a>    eventReduceAfter = nil
<a name="81"></a>    eventReduceTo = nil
<a name="82"></a>
<a name="83"></a>    /*
<a name="84"></a>     *   When doScript() is invoked, check the event probabilities before
<a name="85"></a>     *   proceeding.  
<a name="86"></a>     */
<a name="87"></a>    doScript()
<a name="88"></a>    {
<a name="89"></a>        /* process the script step only if the event odds allow it */
<a name="90"></a>        if (checkEventOdds())
<a name="91"></a>            inherited();
<a name="92"></a>    }
<a name="93"></a>
<a name="94"></a>    /*
<a name="95"></a>     *   Check the event odds to see if we want to fire an event at all on
<a name="96"></a>     *   this invocation.  
<a name="97"></a>     */
<a name="98"></a>    checkEventOdds()
<a name="99"></a>    {
<a name="100"></a>        /* 
<a name="101"></a>         *   check the event odds to see if we fire an event this time; if
<a name="102"></a>         *   not, we're done with the script invocation 
<a name="103"></a>         */
<a name="104"></a>        if (rand(100) &gt;= eventPercent)
<a name="105"></a>            return nil;
<a name="106"></a>
<a name="107"></a>        /* 
<a name="108"></a>         *   we're firing an event this time, so count this against the
<a name="109"></a>         *   reduction limit, if there is one 
<a name="110"></a>         */
<a name="111"></a>        if (eventReduceAfter != nil)
<a name="112"></a>        {
<a name="113"></a>            /* decrement the limit counter */
<a name="114"></a>            --eventReduceAfter;
<a name="115"></a>            
<a name="116"></a>            /* if it has reached zero, apply the reduced frequency */
<a name="117"></a>            if (eventReduceAfter == 0)
<a name="118"></a>            {
<a name="119"></a>                /* apply the reduced frequency */
<a name="120"></a>                eventPercent = eventReduceTo;
<a name="121"></a>                
<a name="122"></a>                /* we no longer have a limit to look for */
<a name="123"></a>                eventReduceAfter = nil;
<a name="124"></a>            }
<a name="125"></a>        }
<a name="126"></a>
<a name="127"></a>        /* indicate that we do want to fire an event */
<a name="128"></a>        return true;
<a name="129"></a>    }
<a name="130"></a>;
<a name="131"></a>
<a name="132"></a>/* ------------------------------------------------------------------------ */
<a name="133"></a>/*
<a name="134"></a> *   An "event list."  This is a general-purpose type of script that lets
<a name="135"></a> *   you define the scripted events separately from the Script object.
<a name="136"></a> *   
<a name="137"></a> *   The script is driven by a list of values; each value represents one
<a name="138"></a> *   step of the script.  Each value can be a single-quoted string, in
<a name="139"></a> *   which case the string is simply displayed; a function pointer, in
<a name="140"></a> *   which case the function is invoked without arguments; another Script
<a name="141"></a> *   object, in which case the object's doScript() method is invoked; a
<a name="142"></a> *   property pointer, in which case the property of 'self' (the EventList
<a name="143"></a> *   object) is invoked with no arguments; or nil, in which case nothing
<a name="144"></a> *   happens.
<a name="145"></a> *   
<a name="146"></a> *   This base type of event list runs through the list once, in order, and
<a name="147"></a> *   then simply stops doing anything once we pass the last event.  
<a name="148"></a> */
<a name="149"></a>class EventList: Script
<a name="150"></a>    construct(lst) { eventList = lst; }
<a name="151"></a>
<a name="152"></a>    /* the list of events */
<a name="153"></a>    eventList = []
<a name="154"></a>
<a name="155"></a>    /* cached length of the event list */
<a name="156"></a>    eventListLen = (eventList.length())
<a name="157"></a>
<a name="158"></a>    /* advance to the next state */
<a name="159"></a>    advanceState()
<a name="160"></a>    {
<a name="161"></a>        /* increment our state index */
<a name="162"></a>        ++curScriptState;
<a name="163"></a>    }
<a name="164"></a>
<a name="165"></a>    /* by default, start at the first list element */
<a name="166"></a>    curScriptState = 1
<a name="167"></a>
<a name="168"></a>    /* process the next step of the script */
<a name="169"></a>    doScript()
<a name="170"></a>    {
<a name="171"></a>        /* get our current event state */
<a name="172"></a>        local idx = getScriptState();
<a name="173"></a>
<a name="174"></a>        /* get the list (evaluate it once to avoid repeated side effects) */
<a name="175"></a>        local lst = eventList;
<a name="176"></a>
<a name="177"></a>        /* cache the length */
<a name="178"></a>        eventListLen = lst.length();
<a name="179"></a>
<a name="180"></a>        /* if it's a valid index in our list, fire the event */
<a name="181"></a>        if (idx &gt;= 1 &amp;&amp; idx &lt;= eventListLen)
<a name="182"></a>        {
<a name="183"></a>            /* carry out the event */
<a name="184"></a>            doScriptEvent(lst[idx]);
<a name="185"></a>        }
<a name="186"></a>
<a name="187"></a>        /* perform any end-of-script processing */
<a name="188"></a>        scriptDone();
<a name="189"></a>    }
<a name="190"></a>
<a name="191"></a>    /* carry out one script event */
<a name="192"></a>    doScriptEvent(evt)
<a name="193"></a>    {
<a name="194"></a>        /* check what kind of event we have */
<a name="195"></a>        switch (dataTypeXlat(evt))
<a name="196"></a>        {
<a name="197"></a>        case TypeSString:
<a name="198"></a>            /* it's a string - display it */
<a name="199"></a>            say(evt);
<a name="200"></a>            break;
<a name="201"></a>            
<a name="202"></a>        case TypeObject:
<a name="203"></a>            /* it must be a Script object - invoke its doScript() method */
<a name="204"></a>            evt.doScript();
<a name="205"></a>            break;
<a name="206"></a>            
<a name="207"></a>        case TypeFuncPtr:
<a name="208"></a>            /* it's a function pointer - invoke it */
<a name="209"></a>            (evt)();
<a name="210"></a>            break;
<a name="211"></a>            
<a name="212"></a>        case TypeProp:
<a name="213"></a>            /* it's a property of self - invoke it */
<a name="214"></a>            self.(evt)();
<a name="215"></a>            break;
<a name="216"></a>            
<a name="217"></a>        default:
<a name="218"></a>            /* do nothing in other cases */
<a name="219"></a>            break;
<a name="220"></a>        }
<a name="221"></a>    }
<a name="222"></a>
<a name="223"></a>    /*
<a name="224"></a>     *   Perform any end-of-script processing.  By default, we advance the
<a name="225"></a>     *   script to the next state.
<a name="226"></a>     *   
<a name="227"></a>     *   Some scripts might want to override this.  For example, a script
<a name="228"></a>     *   could be driven entirely by some external timing; the state of a
<a name="229"></a>     *   script could vary once per turn, for example, or could change each
<a name="230"></a>     *   time an actor pushes a button.  In these cases, invoking the
<a name="231"></a>     *   script wouldn't affect the state of the event list, so the
<a name="232"></a>     *   subclass would override scriptDone() so that it does nothing at
<a name="233"></a>     *   all.  
<a name="234"></a>     */
<a name="235"></a>    scriptDone()
<a name="236"></a>    {
<a name="237"></a>        /* advance to the next state */
<a name="238"></a>        advanceState();
<a name="239"></a>    }
<a name="240"></a>;
<a name="241"></a>
<a name="242"></a>/*
<a name="243"></a> *   An "external" event list is one whose state is driven externally to
<a name="244"></a> *   the script.  Specifically, the state is *not* advanced by invoking the
<a name="245"></a> *   script; the state is advanced exclusively by some external process
<a name="246"></a> *   (for example, by a daemon that invokes the event list's advanceState()
<a name="247"></a> *   method).  
<a name="248"></a> */
<a name="249"></a>class ExternalEventList: EventList
<a name="250"></a>    scriptDone() { }
<a name="251"></a>;
<a name="252"></a>
<a name="253"></a>/*
<a name="254"></a> *   A cyclical event list - this runs through the event list in order,
<a name="255"></a> *   returning to the first element when we pass the last element.  
<a name="256"></a> */
<a name="257"></a>class CyclicEventList: EventList
<a name="258"></a>    advanceState()
<a name="259"></a>    {
<a name="260"></a>        /* go to the next state */
<a name="261"></a>        ++curScriptState;
<a name="262"></a>
<a name="263"></a>        /* if we've passed the end of the list, loop back to the start */
<a name="264"></a>        if (curScriptState &gt; eventListLen)
<a name="265"></a>            curScriptState = 1;
<a name="266"></a>    }
<a name="267"></a>;
<a name="268"></a>
<a name="269"></a>/*
<a name="270"></a> *   A stopping event list - this runs through the event list in order,
<a name="271"></a> *   then stops at the last item and repeats it each time the script is
<a name="272"></a> *   subsequently invoked. 
<a name="273"></a> *   
<a name="274"></a> *   This is often useful for things like ASK ABOUT topics, where we reveal
<a name="275"></a> *   more information when asked repeatedly about a topic, but eventually
<a name="276"></a> *   reach a point where we've said everything:
<a name="277"></a> *   
<a name="278"></a> *.  &gt;ask bob about black book
<a name="279"></a> *.  "What makes you think I know anything about it?" he says, his
<a name="280"></a> *   voice shaking.
<a name="281"></a> *   
<a name="282"></a> *   &gt;again
<a name="283"></a> *.  "No! You can't make me tell you!"
<a name="284"></a> *   
<a name="285"></a> *   &gt;again
<a name="286"></a> *.  "All right, I'll tell you what you want to know!  But I warn you,
<a name="287"></a> *   these are things mortal men were never meant to know.  Your life, your
<a name="288"></a> *   very soul will be in danger from the moment you hear these dark secrets!"
<a name="289"></a> *   
<a name="290"></a> *   &gt;again
<a name="291"></a> *.  [scene missing]
<a name="292"></a> *   
<a name="293"></a> *   &gt;again
<a name="294"></a> *.  "I've already told you all I know."
<a name="295"></a> *   
<a name="296"></a> *   &gt;again
<a name="297"></a> *.  "I've already told you all I know."
<a name="298"></a> */
<a name="299"></a>class StopEventList: EventList
<a name="300"></a>    advanceState()
<a name="301"></a>    {
<a name="302"></a>        /* if we haven't yet reached the last state, go to the next one */
<a name="303"></a>        if (curScriptState &lt; eventListLen)
<a name="304"></a>            ++curScriptState;
<a name="305"></a>    }
<a name="306"></a>;
<a name="307"></a>
<a name="308"></a>/*
<a name="309"></a> *   A synchronized event list.  This is an event list that takes its
<a name="310"></a> *   actions from a separate event list object.  We get our current state
<a name="311"></a> *   from the other list, and advancing our state advances the other list's
<a name="312"></a> *   state in lock step.  Set 'masterObject' to refer to the master list
<a name="313"></a> *   whose state we synchronize with.  
<a name="314"></a> *   
<a name="315"></a> *   This can be useful, for example, when we have messages that reflect
<a name="316"></a> *   two different points of view on the same events: the messages for each
<a name="317"></a> *   point of view can be kept in a separate list, but the one list can be
<a name="318"></a> *   a slave of the other to ensure that the two lists are based on a
<a name="319"></a> *   common state.  
<a name="320"></a> */
<a name="321"></a>class SyncEventList: EventList
<a name="322"></a>    /* my master event list object */
<a name="323"></a>    masterObject = nil
<a name="324"></a>
<a name="325"></a>    /* my state is simply the master list's state */
<a name="326"></a>    getScriptState() { return masterObject.getScriptState(); }
<a name="327"></a>
<a name="328"></a>    /* to advance my state, advance the master list's state */
<a name="329"></a>    advanceState() { masterObject.advanceState(); }
<a name="330"></a>
<a name="331"></a>    /* let the master list take care of finishing a script step */
<a name="332"></a>    scriptDone() { masterObject.scriptDone(); }
<a name="333"></a>;
<a name="334"></a>
<a name="335"></a>/*
<a name="336"></a> *   Randomized event list.  This is similar to a regular event list, but
<a name="337"></a> *   chooses an event at random each time it's invoked.
<a name="338"></a> */
<a name="339"></a>class RandomEventList: RandomFiringScript, EventList
<a name="340"></a>    /* process the next step of the script */
<a name="341"></a>    doScript()
<a name="342"></a>    {
<a name="343"></a>        /* check the odds to see if we want to fire an event at all */
<a name="344"></a>        if (!checkEventOdds())
<a name="345"></a>            return;
<a name="346"></a>        
<a name="347"></a>        /* get our next random number */
<a name="348"></a>        local idx = getNextRandom();
<a name="349"></a>
<a name="350"></a>        /* cache the list and its length, to avoid repeated side effects */
<a name="351"></a>        local lst = eventList;
<a name="352"></a>        eventListLen = lst.length();
<a name="353"></a>        
<a name="354"></a>        /* run the event, if the index is valid */
<a name="355"></a>        if (idx &gt;= 1 &amp;&amp; idx &lt;= eventListLen)
<a name="356"></a>            doScriptEvent(lst[idx]);
<a name="357"></a>    }
<a name="358"></a>    
<a name="359"></a>    /*
<a name="360"></a>     *   Get the next random state.  By default, we simply return a number
<a name="361"></a>     *   from 1 to the number of entries in our event list.  This is a
<a name="362"></a>     *   separate method to allow subclasses to customize the way the
<a name="363"></a>     *   random number is selected.  
<a name="364"></a>     */
<a name="365"></a>    getNextRandom()
<a name="366"></a>    {
<a name="367"></a>        /*   
<a name="368"></a>         *   Note that rand(n) returns a number from 0 to n-1 inclusive;
<a name="369"></a>         *   since list indices run from 1 to list.length, add one to the
<a name="370"></a>         *   result of rand(list.length) to get a value in the proper range
<a name="371"></a>         *   for a list index.  
<a name="372"></a>         */
<a name="373"></a>        return rand(eventListLen) + 1;
<a name="374"></a>    }
<a name="375"></a>;
<a name="376"></a>
<a name="377"></a>/*
<a name="378"></a> *   Shuffled event list.  This is similar to a random event list, except
<a name="379"></a> *   that we fire our events in a "shuffled" order rather than an
<a name="380"></a> *   independently random order.  "Shuffled order" means that we fire the
<a name="381"></a> *   events in random order, but we don't re-fire an event until we've run
<a name="382"></a> *   through all of the other events.  The effect is as though we were
<a name="383"></a> *   dealing from a deck of cards.
<a name="384"></a> *   
<a name="385"></a> *   For the first time through the main list, we normally shuffle the
<a name="386"></a> *   strings immediately at startup, but this is optional.  If shuffleFirst
<a name="387"></a> *   is set to nil, we will NOT shuffle the list the first time through -
<a name="388"></a> *   we'll run through it once in the given order, then shuffle for the
<a name="389"></a> *   next time through, then shuffle again for the next, and so on.  So, if
<a name="390"></a> *   you want a specific order for the first time through, just define the
<a name="391"></a> *   list in the desired order and set shuffleFirst to nil.
<a name="392"></a> *   
<a name="393"></a> *   You can optionally specify a separate list of one-time-only sequential
<a name="394"></a> *   strings in the property firstEvents.  We'll run through these strings
<a name="395"></a> *   once.  When we've exhausted them, we'll switch to the main eventList
<a name="396"></a> *   list, showing it one time through in its given order, then shuffling
<a name="397"></a> *   it and running through it again, and so on.  The firstEvents list is
<a name="398"></a> *   never shuffled - it's always shown in exactly the order given.  
<a name="399"></a> */
<a name="400"></a>class ShuffledEventList: RandomFiringScript, EventList
<a name="401"></a>    /* 
<a name="402"></a>     *   a list of events to go through sequentially, in the exact order
<a name="403"></a>     *   specified, before firing any events from the main list
<a name="404"></a>     */
<a name="405"></a>    firstEvents = []
<a name="406"></a>
<a name="407"></a>    /*
<a name="408"></a>     *   Flag: shuffle the eventList list before we show it for the first
<a name="409"></a>     *   time.  By default, this is set to true, so that the behavior is
<a name="410"></a>     *   random on each independent run of the game.  However, it might be
<a name="411"></a>     *   desirable in some cases to always use the original ordering of the
<a name="412"></a>     *   eventList list the first time through the list.  If this is set to
<a name="413"></a>     *   nil, we won't shuffle the list the first time through.  
<a name="414"></a>     */
<a name="415"></a>    shuffleFirst = true
<a name="416"></a>
<a name="417"></a>    /*
<a name="418"></a>     *   Flag: suppress repeats in the shuffle.  If this is true, it
<a name="419"></a>     *   prevents a given event from showing up twice in a row, which could
<a name="420"></a>     *   otherwise happen right after a shuffle.  This is ignored for lists
<a name="421"></a>     *   with one or two events: it's impossible to prevent repeats in a
<a name="422"></a>     *   one-element list, and doing so in a two-element list would produce
<a name="423"></a>     *   a predictable A-B-A-B... pattern.
<a name="424"></a>     *   
<a name="425"></a>     *   You might want to set this to nil for lists of three or four
<a name="426"></a>     *   elements, since such short lists can result in fairly
<a name="427"></a>     *   un-random-looking sequences when repeats are suppressed, because
<a name="428"></a>     *   the available number of permutations drops significantly.  
<a name="429"></a>     */
<a name="430"></a>    suppressRepeats = true
<a name="431"></a>
<a name="432"></a>    /* process the next step of the script */
<a name="433"></a>    doScript()
<a name="434"></a>    {
<a name="435"></a>        /* cache the lists to avoid repeated side effects */
<a name="436"></a>        local firstLst = firstEvents;
<a name="437"></a>        local firstLen = firstLst.length();
<a name="438"></a>        local lst = eventList;
<a name="439"></a>        eventListLen = lst.length();
<a name="440"></a>
<a name="441"></a>        /* process the script step only if the event odds allow it */
<a name="442"></a>        if (!checkEventOdds())
<a name="443"></a>            return;
<a name="444"></a>
<a name="445"></a>        /* 
<a name="446"></a>         *   States 1..N, where N is the number of elements in the
<a name="447"></a>         *   firstEvents list, simply show the firstEvents elements in
<a name="448"></a>         *   order.
<a name="449"></a>         *   
<a name="450"></a>         *   If we're set to shuffle the main eventList list initially, all
<a name="451"></a>         *   states above N simply show elements from the eventList list in
<a name="452"></a>         *   shuffled order.
<a name="453"></a>         *   
<a name="454"></a>         *   If we're NOT set to shuffle the main eventList list initially,
<a name="455"></a>         *   the following apply:
<a name="456"></a>         *   
<a name="457"></a>         *   States N+1..N+M, where M is the number of elements in the
<a name="458"></a>         *   eventList list, show the eventList elements in order.
<a name="459"></a>         *   
<a name="460"></a>         *   States above N+M show elements from the eventList list in
<a name="461"></a>         *   shuffled order.  
<a name="462"></a>         */
<a name="463"></a>        local evt;
<a name="464"></a>        if (curScriptState &lt;= firstLen)
<a name="465"></a>        {
<a name="466"></a>            /* simply fetch the next string from firstEvents */
<a name="467"></a>            evt = firstEvents[curScriptState++];
<a name="468"></a>        }
<a name="469"></a>        else if (!shuffleFirst &amp;&amp; curScriptState &lt;= firstLen + eventListLen)
<a name="470"></a>        {
<a name="471"></a>            /* fetch the next string from eventList */
<a name="472"></a>            evt = lst[curScriptState++ - firstLen];
<a name="473"></a>        }
<a name="474"></a>        else
<a name="475"></a>        {
<a name="476"></a>            /* we're showing shuffled strings from the eventList list */
<a name="477"></a>            evt = lst[getNextRandom()];
<a name="478"></a>        }
<a name="479"></a>
<a name="480"></a>        /* execute the event */
<a name="481"></a>        doScriptEvent(evt);
<a name="482"></a>    }
<a name="483"></a>
<a name="484"></a>
<a name="485"></a>    /*
<a name="486"></a>     *   Get the next random event.  We'll pick an event from our list of
<a name="487"></a>     *   events using a ShuffledIntegerList to ensure we pick each value
<a name="488"></a>     *   once before re-using any values.  
<a name="489"></a>     */
<a name="490"></a>    getNextRandom()
<a name="491"></a>    {
<a name="492"></a>        /* if we haven't created our shuffled list yet, do so now */
<a name="493"></a>        if (shuffledList_ == nil)
<a name="494"></a>        {
<a name="495"></a>            /* 
<a name="496"></a>             *   create a shuffled integer list - we'll use these shuffled
<a name="497"></a>             *   integers as indices into our event list 
<a name="498"></a>             */
<a name="499"></a>            shuffledList_ = new ShuffledIntegerList(1, eventListLen);
<a name="500"></a>
<a name="501"></a>            /* apply our suppressRepeats option to the shuffled list */
<a name="502"></a>            shuffledList_.suppressRepeats = suppressRepeats;
<a name="503"></a>        }
<a name="504"></a>
<a name="505"></a>        /* ask the shuffled list to pick an element */
<a name="506"></a>        return shuffledList_.getNextValue();
<a name="507"></a>    }
<a name="508"></a>
<a name="509"></a>    /* our ShuffledList - we'll initialize this on demand */
<a name="510"></a>    shuffledList_ = nil
<a name="511"></a>;
<a name="512"></a>
<a name="513"></a>/* ------------------------------------------------------------------------ */
<a name="514"></a>/*
<a name="515"></a> *   Shuffled List - this class keeps a list of values that can be returned
<a name="516"></a> *   in random order, but with the constraint that we never repeat a value
<a name="517"></a> *   until we've handed out every value.  Think of a shuffled deck of
<a name="518"></a> *   cards: the order of the cards handed out is random, but once a card is
<a name="519"></a> *   dealt, it can't be dealt again until we put everything back into the
<a name="520"></a> *   deck and reshuffle.  
<a name="521"></a> */
<a name="522"></a>class ShuffledList: object
<a name="523"></a>    /* 
<a name="524"></a>     *   the list of values we want to shuffle - initialize this in each
<a name="525"></a>     *   instance to the set of values we want to return in random order 
<a name="526"></a>     */
<a name="527"></a>    valueList = []
<a name="528"></a>
<a name="529"></a>    /*
<a name="530"></a>     *   Flag: suppress repeated values.  We mostly suppress repeats by our
<a name="531"></a>     *   very design, since we run through the entire list before repeating
<a name="532"></a>     *   anything in the list.  However, there's one situation (in a list
<a name="533"></a>     *   with more than one element) where a repeat can occur: immediately
<a name="534"></a>     *   after a shuffle, we could select the last element from the
<a name="535"></a>     *   previous shuffle as the first element of the new shuffle.  If this
<a name="536"></a>     *   flag is set, we'll suppress this type of repeat by choosing again
<a name="537"></a>     *   any time we're about to choose a repeat.
<a name="538"></a>     *   
<a name="539"></a>     *   Note that we ignore this for a list of one element, since it's
<a name="540"></a>     *   obviously impossible to avoid repeats in this case.  We also
<a name="541"></a>     *   ignore it for a two-element list, since this would produce the
<a name="542"></a>     *   predictable pattern A-B-A-B..., defeating the purpose of the
<a name="543"></a>     *   shuffle.  
<a name="544"></a>     */
<a name="545"></a>    suppressRepeats = nil
<a name="546"></a>
<a name="547"></a>    /* create from a given list */
<a name="548"></a>    construct(lst)
<a name="549"></a>    {
<a name="550"></a>        /* remember our list of values */
<a name="551"></a>        valueList = lst;
<a name="552"></a>    }
<a name="553"></a>
<a name="554"></a>    /* 
<a name="555"></a>     *   Get a random value.  This will return a randomly-selected element
<a name="556"></a>     *   from 'valueList', but we'll return every element of 'valueList'
<a name="557"></a>     *   once before repeating any element.
<a name="558"></a>     *   
<a name="559"></a>     *   If we've returned every value on the current round, we'll
<a name="560"></a>     *   automatically shuffle the values and start a new round.  
<a name="561"></a>     */
<a name="562"></a>    getNextValue()
<a name="563"></a>    {
<a name="564"></a>        local i;
<a name="565"></a>        local ret;
<a name="566"></a>        local justReshuffled = nil;
<a name="567"></a>
<a name="568"></a>        /* if we haven't initialized our vector, do so now */
<a name="569"></a>        if (valuesVec == nil)
<a name="570"></a>        {
<a name="571"></a>            /* create the vector */
<a name="572"></a>            valuesVec = new Vector(valueList.length(), valueList);
<a name="573"></a>
<a name="574"></a>            /* all values are initially available */
<a name="575"></a>            valuesAvail = valuesVec.length();
<a name="576"></a>        }
<a name="577"></a>
<a name="578"></a>        /* if we've exhausted our values on this round, start over */
<a name="579"></a>        if (valuesAvail == 0)
<a name="580"></a>        {
<a name="581"></a>            /* shuffle the elements */
<a name="582"></a>            reshuffle();
<a name="583"></a>
<a name="584"></a>            /* note that we just did a shuffle */
<a name="585"></a>            justReshuffled = true;
<a name="586"></a>        }
<a name="587"></a>
<a name="588"></a>        /* pick a random element from the 'available' partition */
<a name="589"></a>        i = rand(valuesAvail) + 1;
<a name="590"></a>
<a name="591"></a>        /*
<a name="592"></a>         *   If we just reshuffled, and we're configured to suppress a 
<a name="593"></a>         *   repeat immediately after a reshuffle, and we chose the first 
<a name="594"></a>         *   element of the vector, and we have at least three elements, 
<a name="595"></a>         *   choose a different element.  The first element in the vector is 
<a name="596"></a>         *   always the last element we return from each run-through, since 
<a name="597"></a>         *   the 'available' partition is at the start of the list and thus 
<a name="598"></a>         *   shrinks down until it contains only the first element. 
<a name="599"></a>         *
<a name="600"></a>         *   If we have one element, there's obviously no point in trying to 
<a name="601"></a>         *   suppress repeats.  If we have two elements, we *still* don't 
<a name="602"></a>         *   want to suppress repeats, because in this case we'd generate a 
<a name="603"></a>         *   predicatable A-B-A-B pattern (because we could never have two 
<a name="604"></a>         *   A's or two B's in a row).
<a name="605"></a>         */
<a name="606"></a>        if (justReshuffled &amp;&amp; suppressRepeats &amp;&amp; valuesAvail &gt; 2)
<a name="607"></a>        {
<a name="608"></a>            /* 
<a name="609"></a>             *   we don't want repeats, so choose anything besides the
<a name="610"></a>             *   first element; keep choosing until we get another element 
<a name="611"></a>             */
<a name="612"></a>            while (i == 1)
<a name="613"></a>                i = rand(valuesAvail) + 1;
<a name="614"></a>        }
<a name="615"></a>
<a name="616"></a>        /* remember the element we're returning */
<a name="617"></a>        ret = valuesVec[i];
<a name="618"></a>
<a name="619"></a>        /*
<a name="620"></a>         *   Move the value at the top of the 'available' partition down
<a name="621"></a>         *   into the hole we're creating at 'i', since we're about to
<a name="622"></a>         *   reduce the size of the 'available' partition to reflect the
<a name="623"></a>         *   use of one more value; that would leave the element at the top
<a name="624"></a>         *   of the partition homeless, so we need somewhere to put it.
<a name="625"></a>         *   Luckily, we also need to delete element 'i', since we're using
<a name="626"></a>         *   this element.  Solve both problems at once by moving element
<a name="627"></a>         *   we're rendering homeless into the hole we're creating.  
<a name="628"></a>         */
<a name="629"></a>        valuesVec[i] = valuesVec[valuesAvail];
<a name="630"></a>
<a name="631"></a>        /* move the value we're returning into the top slot */
<a name="632"></a>        valuesVec[valuesAvail] = ret;
<a name="633"></a>
<a name="634"></a>        /* reduce the 'available' partition by one */
<a name="635"></a>        --valuesAvail;
<a name="636"></a>
<a name="637"></a>        /* return the result */
<a name="638"></a>        return ret;
<a name="639"></a>    }
<a name="640"></a>
<a name="641"></a>    /*
<a name="642"></a>     *   Shuffle the values.  This puts all of the values back into the
<a name="643"></a>     *   deck (as it were) for a new round.  It's never required to call
<a name="644"></a>     *   this, because getNextValue() automatically shuffles the deck and
<a name="645"></a>     *   starts over each time it runs through the entire deck.  This is
<a name="646"></a>     *   provided in case the caller has a reason to want to put all the
<a name="647"></a>     *   values back into play immediately, before every value has been
<a name="648"></a>     *   dealt on the current round.  
<a name="649"></a>     */
<a name="650"></a>    reshuffle()
<a name="651"></a>    {
<a name="652"></a>        /* 
<a name="653"></a>         *   Simply reset the counter of available values.  Go with the
<a name="654"></a>         *   original source list's length, in case we haven't initialized
<a name="655"></a>         *   our internal vector yet. 
<a name="656"></a>         */
<a name="657"></a>        valuesAvail = valueList.length();
<a name="658"></a>    }
<a name="659"></a>
<a name="660"></a>    /*
<a name="661"></a>     *   Internal vector of available/used values.  Elements from 1 to
<a name="662"></a>     *   'valuesAvail', inclusive, are still available for use on this
<a name="663"></a>     *   round.  Elements above 'valuesAvail' have already been used.  
<a name="664"></a>     */
<a name="665"></a>    valuesVec = nil
<a name="666"></a>    
<a name="667"></a>    /* number of values still available on this round */ 
<a name="668"></a>    valuesAvail = 0
<a name="669"></a>;
<a name="670"></a>
<a name="671"></a>/*
<a name="672"></a> *   A Shuffled Integer List is a special kind of Shuffled List that
<a name="673"></a> *   returns integers in a given range.  Like an ordinary Shuffled List,
<a name="674"></a> *   we'll return integers in the given range in random order, but we'll
<a name="675"></a> *   only return each integer once during a given round; when we exhaust
<a name="676"></a> *   the supply, we'll reshuffle the set of integers and start over.  
<a name="677"></a> */
<a name="678"></a>class ShuffledIntegerList: ShuffledList
<a name="679"></a>    /* 
<a name="680"></a>     *   The minimum and maximum values for our range.  Instances should
<a name="681"></a>     *   define these to the range desired. 
<a name="682"></a>     */
<a name="683"></a>    rangeMin = 1
<a name="684"></a>    rangeMax = 10
<a name="685"></a>
<a name="686"></a>    /* initialize the value list on demand */
<a name="687"></a>    valueList = nil
<a name="688"></a>
<a name="689"></a>    /* construct with the given range */
<a name="690"></a>    construct(rmin, rmax)
<a name="691"></a>    {
<a name="692"></a>        rangeMin = rmin;
<a name="693"></a>        rangeMax = rmax;
<a name="694"></a>    }
<a name="695"></a>
<a name="696"></a>    /* get the next value */
<a name="697"></a>    getNextValue()
<a name="698"></a>    {
<a name="699"></a>        /* 
<a name="700"></a>         *   If we haven't set up our value list yet, do so now.  This is
<a name="701"></a>         *   simply a list of integers from rangeMin to rangeMax.  
<a name="702"></a>         */
<a name="703"></a>        if (valueList == nil)
<a name="704"></a>        {
<a name="705"></a>            local ele = rangeMin;
<a name="706"></a>            valueList = List.generate({i: ele++}, rangeMax - rangeMin + 1);
<a name="707"></a>        }
<a name="708"></a>
<a name="709"></a>        /* use the inherited handling to select from our value list */
<a name="710"></a>        return inherited();
<a name="711"></a>    }
<a name="712"></a>;
<a name="713"></a>
<a name="714"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/04/2024 from adv3Lite version 2.0</div>
</body>
</html>

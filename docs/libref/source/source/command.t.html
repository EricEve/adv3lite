<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>command.t</title></head><body>
<table class=ban><tr><td><h1>command.t</h1><td align=right><a href="../file/command.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/* ------------------------------------------------------------------------ */
<a name="5"></a>/*
<a name="6"></a> *   A Command describes the results of parsing one player predicate - that
<a name="7"></a> *   is, a single verb phrase, with all its parts.  This includes the
<a name="8"></a> *   action to be performed and the objects to perform it on.  It also
<a name="9"></a> *   includes information on the text of the player's input, and how it
<a name="10"></a> *   maps onto the grammar structures defined by the language module.
<a name="11"></a> *   
<a name="12"></a> *   The Command object is built in several steps, so its contents aren't
<a name="13"></a> *   complete until all of the steps are completed.  
<a name="14"></a> */
<a name="15"></a>class Command: object
<a name="16"></a>    /* 
<a name="17"></a>     *   Create the command object.  There are several ways to create a
<a name="18"></a>     *   command:
<a name="19"></a>     *   
<a name="20"></a>     *   new Command(parseTree) - create from a parsed command syntax tree.
<a name="21"></a>     *   
<a name="22"></a>     *   new Command(action, dobjProd...) - create from a given Action and
<a name="23"></a>     *   a set of parsed syntax trees for the noun phrases.  The first noun
<a name="24"></a>     *   phrase is the direct object, the second is the indirect object,
<a name="25"></a>     *   and the third is the accessory.
<a name="26"></a>     *   
<a name="27"></a>     *   new Command(action, dobjs...) - create from a given Action and a
<a name="28"></a>     *   set of objects or object lists for the noun slots.  The first
<a name="29"></a>     *   argument after the Action, dobjs, can be a single Mentionable
<a name="30"></a>     *   object to use as the resolved direct object, or a list or vector
<a name="31"></a>     *   of Mentionables to use as the multiple direct objects.  The next
<a name="32"></a>     *   argument is in the same format and is used for the indirect
<a name="33"></a>     *   object.  The third is the accessory.
<a name="34"></a>     *   
<a name="35"></a>     *   new Command(actor, action, dobjs...) - create from a given actor
<a name="36"></a>     *   (as a Mentionable object), an Action object, and the object list.
<a name="37"></a>     *   
<a name="38"></a>     *   new Command() - create a blank Command, for setting up externally
<a name="39"></a>     *   or in a subclass.  
<a name="40"></a>     */
<a name="41"></a>    construct([args])
<a name="42"></a>    {
<a name="43"></a>        /* presume the command will be implicitly addressed to the PC */
<a name="44"></a>        actor = gPlayerChar; //World.playerChar;
<a name="45"></a>
<a name="46"></a>        /* check the various argument list formats */
<a name="47"></a>        if (args.matchProto([Production]))
<a name="48"></a>        {
<a name="49"></a>            /* build the command from the parse tree */
<a name="50"></a>            args[1].build(self, nil);
<a name="51"></a>
<a name="52"></a>            /* save the parse tree */
<a name="53"></a>            parseTree = args[1];
<a name="54"></a>        }
<a name="55"></a>        else if (args.matchProto([Action, '...'])
<a name="56"></a>                 || args.matchProto([Mentionable, Action, '...']))
<a name="57"></a>        {
<a name="58"></a>            /* retrieve and skip the actor, if present */
<a name="59"></a>            local i = 1;
<a name="60"></a>            if (!args[i].ofKind(Action))
<a name="61"></a>                actor = args[i++];
<a name="62"></a>
<a name="63"></a>            /* retrieve the action */
<a name="64"></a>            action = args[i++];
<a name="65"></a>
<a name="66"></a>            /* the additional arguments are for the noun phrase slots */
<a name="67"></a>            local roles = NounRole.all, rlen = roles.length();
<a name="68"></a>            local alen = args.length();
<a name="69"></a>            for (local r = 1 ; r &lt;= rlen &amp;&amp; i &lt;= alen ; ++i, ++r)
<a name="70"></a>            {
<a name="71"></a>                /* get this noun phrase match tree or object list */
<a name="72"></a>                local np = args[i];
<a name="73"></a>
<a name="74"></a>                /*
<a name="75"></a>                 *   Check the type of this argument: if it's a Production,
<a name="76"></a>                 *   it's a parse tree to build into a NounPhrase list for
<a name="77"></a>                 *   the slot.  If it's a list/vector, it's a list of
<a name="78"></a>                 *   resolved objects for the slot. 
<a name="79"></a>                 */
<a name="80"></a>                if (np.ofKind(Production))
<a name="81"></a>                {
<a name="82"></a>                    /* parse tree - assign the role for this noun phrase */
<a name="83"></a>                    np.nounPhraseRole = roles[r];
<a name="84"></a>
<a name="85"></a>                    /* build it */
<a name="86"></a>                    np.build(self, addNounListItem(roles[r], np));
<a name="87"></a>                }
<a name="88"></a>                else if (np.ofKind(List))
<a name="89"></a>                {
<a name="90"></a>                    /* it's an object list - save a copy */
<a name="91"></a>                    self.(roles[r].objListProp) = np;
<a name="92"></a>                }
<a name="93"></a>                else if (np.ofKind(Vector))
<a name="94"></a>                {
<a name="95"></a>                    /* it's an object vector - save a list copy */
<a name="96"></a>                    self.(roles[r].objListProp) = np.toList();
<a name="97"></a>                }
<a name="98"></a>                else if (np.ofKind(Mentionable))
<a name="99"></a>                {
<a name="100"></a>                    /* single object - make it into a single-element list */
<a name="101"></a>                    self.(roles[r].objListProp) = [np];
<a name="102"></a>
<a name="103"></a>                    /* also set it as the current object */
<a name="104"></a>                    self.(roles[r].objProp) = np;
<a name="105"></a>
<a name="106"></a>                    /* synthesize an NPMatch object for it */
<a name="107"></a>                    local m = new NPMatch(nil, np, 0);
<a name="108"></a>                    m.flags = SelProg;
<a name="109"></a>                    self.(roles[r].objMatchProp) = m;
<a name="110"></a>                   
<a name="111"></a>                }
<a name="112"></a>                else
<a name="113"></a>                    throw new ArgumentMismatchError();
<a name="114"></a>            }
<a name="115"></a>        }
<a name="116"></a>        else if (args.matchProto([]))
<a name="117"></a>        {
<a name="118"></a>            /* no arguments - they just want a basic empty command */
<a name="119"></a>        }
<a name="120"></a>        else
<a name="121"></a>            throw new ArgumentMismatchError();
<a name="122"></a>
<a name="123"></a>        /* set up the reflexive antecedent table (if we didn't already) */
<a name="124"></a>        if (reflexiveAnte == nil)
<a name="125"></a>            reflexiveAnte = new LookupTable(16, 32);
<a name="126"></a>    }
<a name="127"></a>
<a name="128"></a>    /* clone - create a new Command based on this Command */
<a name="129"></a>    clone()
<a name="130"></a>    {
<a name="131"></a>        /* create a new object with my same property values */
<a name="132"></a>        local cl = createClone();
<a name="133"></a>
<a name="134"></a>        /* 
<a name="135"></a>         *   make a copy of the antecedent table, so that changes made in
<a name="136"></a>         *   the clone don't affect the original, and vice versa 
<a name="137"></a>         */
<a name="138"></a>        cl.reflexiveAnte = new LookupTable(16, 32);
<a name="139"></a>        reflexiveAnte.forEachAssoc({ key, val: cl.reflexiveAnte[key] = val });
<a name="140"></a>
<a name="141"></a>        /* likewise the object list vectors, if any */
<a name="142"></a>        foreach (local role in npList)
<a name="143"></a>        {
<a name="144"></a>            local v = cl.(role.objListProp);
<a name="145"></a>            if (v.ofKind(Vector))
<a name="146"></a>                cl.(role.objListProp) = new Vector(v.length(), v);
<a name="147"></a>        }
<a name="148"></a>
<a name="149"></a>        /* return the clone */
<a name="150"></a>        return cl;
<a name="151"></a>    }
<a name="152"></a>
<a name="153"></a>    /* clone a noun phrase that's part of this command */
<a name="154"></a>    cloneNP(np)
<a name="155"></a>    {
<a name="156"></a>        /* create a clone of the noun phrase */
<a name="157"></a>        local cl = np.clone();
<a name="158"></a>
<a name="159"></a>        /* find and replace the original copy with the clone */
<a name="160"></a>        foreach (local role in npList)
<a name="161"></a>        {
<a name="162"></a>            /* look for 'np' in this role's list of noun phrases */
<a name="163"></a>            local idx;
<a name="164"></a>            if ((idx = self.(role.npListProp).indexOf(np)) != nil)
<a name="165"></a>            {
<a name="166"></a>                /* found it - replace it with the clone, and we're done */
<a name="167"></a>                self.(role.npListProp)[idx] = cl;
<a name="168"></a>                break;
<a name="169"></a>            }
<a name="170"></a>        }
<a name="171"></a>
<a name="172"></a>        /* return the clone */
<a name="173"></a>        return cl;
<a name="174"></a>    }
<a name="175"></a>
<a name="176"></a>    /*
<a name="177"></a>     *   Execute the action.  This carries out the entire command
<a name="178"></a>     *   processing sequence for the action.  If the action involves a list
<a name="179"></a>     *   of objects (as in TAKE ALL or DROP BOOK AND CANDLE), we iterate
<a name="180"></a>     *   over the listed objects, executing the action on each object in
<a name="181"></a>     *   turn.  
<a name="182"></a>     */
<a name="183"></a>    exec()
<a name="184"></a>    {
<a name="185"></a>        try
<a name="186"></a>        {
<a name="187"></a>            action.reset();
<a name="188"></a>            gAction = action;
<a name="189"></a>            originalAction = action;
<a name="190"></a>            lastAction = nil;
<a name="191"></a>            gCommand = self;
<a name="192"></a>            actions = [];
<a name="193"></a>            
<a name="194"></a>            if(verbProd != nil)
<a name="195"></a>                local lastCommandStr = buildCommandString();
<a name="196"></a>                           
<a name="197"></a>            if(gameMain.autoSwitchAgain &amp;&amp; action != Again)           
<a name="198"></a>            {                
<a name="199"></a>                gameMain.againRepeatsParse = action.againRepeatsParse;
<a name="200"></a>            }
<a name="201"></a>            
<a name="202"></a>            if(action.isRepeatable)
<a name="203"></a>            {
<a name="204"></a>                libGlobal.lastCommand = self.createClone();
<a name="205"></a>                libGlobal.lastCommandForAgain = lastCommandStr;                    
<a name="206"></a>            }
<a name="207"></a>            
<a name="208"></a>            if(action.includeInUndo &amp;&amp; verbProd != nil)
<a name="209"></a>            {               
<a name="210"></a>                libGlobal.lastCommandForUndo = lastCommandStr;
<a name="211"></a>                savepoint();
<a name="212"></a>            }
<a name="213"></a>            
<a name="214"></a>            
<a name="215"></a>            
<a name="216"></a>            /* 
<a name="217"></a>             *   First, carry out the group action.  This gives the verb a
<a name="218"></a>             *   chance to perform the action collectively on all of the objects
<a name="219"></a>             *   at once.
<a name="220"></a>             */          
<a name="221"></a>            action.execGroup(self);
<a name="222"></a>            
<a name="223"></a>            
<a name="224"></a>            /* 
<a name="225"></a>             *   Get the list of predicate noun roles.  We only iterate over the
<a name="226"></a>             *   noun roles that are verb arguments.
<a name="227"></a>             */
<a name="228"></a>            local predRoles = npList.subset({ r: r.isPredicate });
<a name="229"></a>            
<a name="230"></a>            /* 
<a name="231"></a>             *   If we have any noun phrases, iterate over each combination of
<a name="232"></a>             *   objects.  Otherwise, this is an intransitive verb, so just
<a name="233"></a>             *   perform a single execution of the Action, with no objects.
<a name="234"></a>             */
<a name="235"></a>            if (predRoles.length() == 0)
<a name="236"></a>            {
<a name="237"></a>                /* it's intransitive - just execute once */
<a name="238"></a>                execIter([action]);
<a name="239"></a>            }
<a name="240"></a>            else
<a name="241"></a>            {
<a name="242"></a>                /* 
<a name="243"></a>                 *   It's transitive, so execute iteratively over the objects.
<a name="244"></a>                 *   First, generate the distinguished object names for each
<a name="245"></a>                 *   list.
<a name="246"></a>                 */
<a name="247"></a>                foreach (local role in predRoles)
<a name="248"></a>                {
<a name="249"></a>                    /* get the NPMatch list for this role */
<a name="250"></a>                    local matches = self.(role.objListProp);
<a name="251"></a>                    
<a name="252"></a>                    /* get the list of names for this role's list of objects */
<a name="253"></a>                    local names = Distinguisher.getNames(
<a name="254"></a>                        matches.mapAll({ m: m.obj }), nil);
<a name="255"></a>                    
<a name="256"></a>                    /* 
<a name="257"></a>                     *   Assign each NPMatch object its name from the name list.
<a name="258"></a>                     *   The name list is of the form [name, [objects]], so for
<a name="259"></a>                     *   each object, we need to find the element n such that
<a name="260"></a>                     *   n[2] (the object list) contains the object in question,
<a name="261"></a>                     *   then retrieve the name string from n[1].
<a name="262"></a>                     */
<a name="263"></a>                    matches.forEach(
<a name="264"></a>                        { m: m.name = names.valWhich(
<a name="265"></a>                            { n: n[2].indexOf(m.obj) != nil })[1] });
<a name="266"></a>                }
<a name="267"></a>                
<a name="268"></a>                /* 
<a name="269"></a>                 *   Sort the preRoles into canonical order (typically
<a name="270"></a>                 *   DirectObject, IndirectObject, AccessoryObject)
<a name="271"></a>                 */
<a name="272"></a>                predRoles = predRoles.sort(SortAsc, {a, b: a.order - b.order});
<a name="273"></a>                                /* 
<a name="274"></a>                 *   execute for each combination of objects, starting with the
<a name="275"></a>                 *   objects in the first role list
<a name="276"></a>                 */
<a name="277"></a>                execCombos(predRoles, 1, [action]);
<a name="278"></a>            }
<a name="279"></a>            
<a name="280"></a>            /* 
<a name="281"></a>             *   Let every action that has been involved in this Command
<a name="282"></a>             *   summarize or report on what it has just done.
<a name="283"></a>             */
<a name="284"></a>
<a name="285"></a>            
<a name="286"></a>            foreach(local a in actions)
<a name="287"></a>            {
<a name="288"></a>                action = a;
<a name="289"></a>                action.reportAction();
<a name="290"></a>            }
<a name="291"></a>            
<a name="292"></a>            /* 
<a name="293"></a>             *   Reset the action to the original one, if it has been executed,
<a name="294"></a>             *   or else to the first one actually executed.
<a name="295"></a>             */
<a name="296"></a>            
<a name="297"></a>            action = (actions.indexOf(originalAction) || actions.length == 0) 
<a name="298"></a>                ? originalAction : actions[1];
<a name="299"></a>            
<a name="300"></a>            /* List our own sequence of afterReports, if we have any. */
<a name="301"></a>            afterReport();
<a name="302"></a>            
<a name="303"></a>            /* Carry out the after action handling for the current action */
<a name="304"></a>            action.afterAction();
<a name="305"></a>                        
<a name="306"></a>            
<a name="307"></a>            /* 
<a name="308"></a>             *   Carry out the turn sequence handling (daemons and turn count
<a name="309"></a>             *   increment) for the current action.
<a name="310"></a>             */
<a name="311"></a>            action.turnSequence();
<a name="312"></a>            
<a name="313"></a>            
<a name="314"></a>            /*   Advance the game clock time for the current action. */
<a name="315"></a>            action.advanceTime();
<a name="316"></a>           
<a name="317"></a>        }
<a name="318"></a>        catch(AbortActionSignal aas)
<a name="319"></a>        {
<a name="320"></a>            /* 
<a name="321"></a>             *   An AbortActionSignal skips the rest of the command including
<a name="322"></a>             *   the post-action processing such as daemons and advancing the
<a name="323"></a>             *   turn counter; the idea is that an abort command (macro)
<a name="324"></a>             *   effectively cancels the entire command, or at least the rest of
<a name="325"></a>             *   the command from the point it's issued.
<a name="326"></a>             */
<a name="327"></a>        }
<a name="328"></a>    }
<a name="329"></a>    
<a name="330"></a>    /* 
<a name="331"></a>     *   Rebuild the original command string from the tokens. We call this out
<a name="332"></a>     *   as a separate method so language-specific code can override it.
<a name="333"></a>     */
<a name="334"></a>    buildCommandString()
<a name="335"></a>    {
<a name="336"></a>        return valToList(verbProd.tokenList).mapAll({x:        
<a name="337"></a>            getTokVal(x)}).join(' ');
<a name="338"></a>    }
<a name="339"></a>    
<a name="340"></a>    /*  A list of actions executed directly by this command or via a Doer */
<a name="341"></a>    actions = []
<a name="342"></a>
<a name="343"></a>    /*  
<a name="344"></a>     *   The originalAction this Command started out with, which may be changed
<a name="345"></a>     *   by a Doer (or some other mechanism)
<a name="346"></a>     */
<a name="347"></a>    originalAction = nil
<a name="348"></a>    
<a name="349"></a>     /*   
<a name="350"></a>     *   A list of strings containing reports to be displayed at the end of the
<a name="351"></a>     *   command execution cycle for this command.
<a name="352"></a>     */
<a name="353"></a>    
<a name="354"></a>    afterReports = []
<a name="355"></a>    
<a name="356"></a>    
<a name="357"></a>    
<a name="358"></a>    /* 
<a name="359"></a>     *   Run through our list of afterReports displaying each in turn. We do
<a name="360"></a>     *   this on the Command rather than on any of the Actions since actions may
<a name="361"></a>     *   invoke other actions (implicit, remapped, nested or replaced), while
<a name="362"></a>     *   the afterReports pertain to the command as a whole.
<a name="363"></a>     */
<a name="364"></a>    
<a name="365"></a>    afterReport()
<a name="366"></a>    {
<a name="367"></a>        foreach(local cur in afterReports)
<a name="368"></a>        {
<a name="369"></a>            "&lt;.p&gt;";
<a name="370"></a>            say(cur);
<a name="371"></a>        }
<a name="372"></a>    }
<a name="373"></a>    
<a name="374"></a>    
<a name="375"></a>    
<a name="376"></a>    /* 
<a name="377"></a>     *   A list of reports of previous implicit actions performed in the course
<a name="378"></a>     *   of executing this command which can be used if we need to collate a
<a name="379"></a>     *   report of a stack of implicit actions.
<a name="380"></a>     */
<a name="381"></a>  
<a name="382"></a>    
<a name="383"></a>    implicitActionReports = []
<a name="384"></a>
<a name="385"></a>    /*
<a name="386"></a>     *   Execute the command for each combination of objects for noun role index
<a name="387"></a>     *   'n' and above.  'lst' is a list containing a partial object combination
<a name="388"></a>     *   for roles at lower indices.  We iterate over each combination of the
<a name="389"></a>     *   remaining objects. predRoles is a list containing predicate roles (such
<a name="390"></a>     *   DirectObject, IndirectObject, AccessoryObject) relating to this action.
<a name="391"></a>     *   Callers are responsible for sorting predRoles into the correct order
<a name="392"></a>     *   before calling this method.
<a name="393"></a>     */
<a name="394"></a>    execCombos(predRoles, n, lst)
<a name="395"></a>    {
<a name="396"></a>        /* get this slot's role */
<a name="397"></a>        local role = predRoles[n];
<a name="398"></a>
<a name="399"></a>        /* iterate over the objects in the slot at this index */
<a name="400"></a>        foreach (local obj in self.(role.objListProp))
<a name="401"></a>        {
<a name="402"></a>            /* set the current object and selection flags for this role */
<a name="403"></a>            self.(role.objProp) = obj.obj;
<a name="404"></a>            self.(role.objMatchProp) = obj;
<a name="405"></a>             
<a name="406"></a>            /* 
<a name="407"></a>             *   create a new list that includes the new object at the
<a name="408"></a>             *   appropriate place.
<a name="409"></a>             */            
<a name="410"></a>            local nlst = lst;
<a name="411"></a>
<a name="412"></a>            /* add the object to the list */
<a name="413"></a>            nlst += obj.obj;
<a name="414"></a>            
<a name="415"></a>            /* 
<a name="416"></a>             *   if there are more noun roles, recursively iterate over
<a name="417"></a>             *   combinations of the remaining roles 
<a name="418"></a>             */
<a name="419"></a>            if (n &lt; predRoles.length())
<a name="420"></a>            {
<a name="421"></a>                /* we have more roles - iterate over them recursively */
<a name="422"></a>                execCombos(predRoles, n+1, nlst);
<a name="423"></a>            }
<a name="424"></a>            else
<a name="425"></a>            {
<a name="426"></a>                /* 
<a name="427"></a>                 *   this is the last role - we have a complete combination
<a name="428"></a>                 *   of current objects now, so execute the action with the
<a name="429"></a>                 *   current set 
<a name="430"></a>                 */
<a name="431"></a>                execIter(nlst);
<a name="432"></a>            }
<a name="433"></a>        }
<a name="434"></a>    }
<a name="435"></a>
<a name="436"></a>    /*
<a name="437"></a>     *   Execute one iteration of the command for a particular combination of objects.  'lst' is the
<a name="438"></a>     *   object combination about to be executed: the object combination to execute: this is an
<a name="439"></a>     *   [action, dobj, iobj, ...] list.
<a name="440"></a>     */
<a name="441"></a>    execIter(lst)
<a name="442"></a>    {
<a name="443"></a>       
<a name="444"></a>        try
<a name="445"></a>        {      
<a name="446"></a>            /* 
<a name="447"></a>             *   Give our actor's preAction method the chance to veto this action (or maybe do
<a name="448"></a>             *   something else) before it's passed to a Doer.
<a name="449"></a>             */
<a name="450"></a>            gActor.preAction(lst);
<a name="451"></a>            
<a name="452"></a>            /* carry out the default action processing */            
<a name="453"></a>            execDoer(lst);
<a name="454"></a>        }
<a name="455"></a>        catch (ExitSignal ex)
<a name="456"></a>        {
<a name="457"></a>        }
<a name="458"></a>        
<a name="459"></a>        finally
<a name="460"></a>        {
<a name="461"></a>            /* 
<a name="462"></a>             *   If the action isn't one this Command has executed before while
<a name="463"></a>             *   iterating over its list of objects, note that we've now
<a name="464"></a>             *   executed it
<a name="465"></a>             */
<a name="466"></a>            if(actions.indexOf(action) == nil)
<a name="467"></a>                actions += action;
<a name="468"></a>            
<a name="469"></a>            /*  Restore the original action */
<a name="470"></a>            action = originalAction;
<a name="471"></a>        }
<a name="472"></a>    }
<a name="473"></a>
<a name="474"></a>    /*
<a name="475"></a>     *   Execute the command via the Doers that match the command's action
<a name="476"></a>     *   and objects.  'lst' is the object combination to execute: [action,
<a name="477"></a>     *   dobj, iobj, ...].  
<a name="478"></a>     */
<a name="479"></a>    execDoer(lst)
<a name="480"></a>    {
<a name="481"></a>        /* 
<a name="482"></a>         *   In case the author tries to use gDobj and the like to match a
<a name="483"></a>         *   command, assign values to them
<a name="484"></a>         */
<a name="485"></a>        
<a name="486"></a>        if(dobj)
<a name="487"></a>            gDobj = dobj;
<a name="488"></a>        if(iobj)
<a name="489"></a>            gIobj = iobj;
<a name="490"></a>        if(acc)
<a name="491"></a>            gAobj = aobj;
<a name="492"></a>        
<a name="493"></a>        /* find the list of matching Doers */
<a name="494"></a>        local dlst = DoerCmd.findDoers(lst);
<a name="495"></a>      
<a name="496"></a>        IfDebug(doers, oSay('''[Executing Doer; cmd = '&lt;&lt;dlst[1].cmd&gt;&gt;']\n'''));       
<a name="497"></a>        dlst[1].exec(self);
<a name="498"></a>        
<a name="499"></a>    }
<a name="500"></a>    
<a name="501"></a>    /* Change the action to a new action with a new set of objects */
<a name="502"></a>    changeAction(newAct, newDo, newIo, newAo)
<a name="503"></a>    {
<a name="504"></a>        action = newAct;
<a name="505"></a>        
<a name="506"></a>        /* 
<a name="507"></a>         *   If we haven't used this action before while executing this command,
<a name="508"></a>         *   reset it.
<a name="509"></a>         */
<a name="510"></a>        if(actions.indexOf(action) == nil)
<a name="511"></a>            action.reset();
<a name="512"></a>        
<a name="513"></a>        dobj = newDo;
<a name="514"></a>        iobj = newIo;
<a name="515"></a>        acc = newAo;
<a name="516"></a>        action.curDobj = newDo;
<a name="517"></a>        action.curIobj = newIo;
<a name="518"></a>        action.curAobj = newAo;
<a name="519"></a>        gAction = action;
<a name="520"></a>        gAction.redirectParent = originalAction;
<a name="521"></a>    }
<a name="522"></a>  
<a name="523"></a>    /*
<a name="524"></a>     *   Invoke a callback for each object in the current command
<a name="525"></a>     *   iteration.  This invokes the callback on the direct object,
<a name="526"></a>     *   indirect object, accessory, and any other custom roles added by
<a name="527"></a>     *   the game.  
<a name="528"></a>     */
<a name="529"></a>    forEachObj(func)
<a name="530"></a>    {
<a name="531"></a>        
<a name="532"></a>        try
<a name="533"></a>        {
<a name="534"></a>            /* loop over the occupied roles */
<a name="535"></a>            foreach (local role in npListSorted)
<a name="536"></a>            {
<a name="537"></a>                /* if this role is occupied, invoke the callback */
<a name="538"></a>                local obj = self.(role.objProp);
<a name="539"></a>                if (obj != nil)
<a name="540"></a>                    func(role, obj);
<a name="541"></a>            }
<a name="542"></a>        }
<a name="543"></a>        catch (BreakLoopSignal sig)
<a name="544"></a>        {
<a name="545"></a>            /* we've broken out of the loop, so 'sig' is now handled */
<a name="546"></a>        }
<a name="547"></a>    }
<a name="548"></a>    
<a name="549"></a>
<a name="550"></a>    /*
<a name="551"></a>     *   Are terse messages OK for this command?  A terse message is a
<a name="552"></a>     *   simple acknowledgment of a standard command, such as "Taken",
<a name="553"></a>     *   "Dropped", "Done", etc.  The action is so ordinary that the result
<a name="554"></a>     *   of a successful attempt should be obvious to the player; so the
<a name="555"></a>     *   only reply needed is an acknowledgment, not an explanation.
<a name="556"></a>     *   
<a name="557"></a>     *   Terse replies only apply to simple actions, and only when the
<a name="558"></a>     *   actor is the player character, AND there's no disambiguation
<a name="559"></a>     *   involved.  If the actor isn't the PC, an acknowledgment isn't
<a name="560"></a>     *   sufficient; we should instead describe the NPC carrying out the
<a name="561"></a>     *   action, since it's something we observe, not something we do.  If
<a name="562"></a>     *   any objects were disambiguated, we also want to describe the
<a name="563"></a>     *   action fully, because the ambiguity calls for a description of
<a name="564"></a>     *   precisely which objects were chosen.  Disambiguation guesses are
<a name="565"></a>     *   sometimes wrong, so when they're involved, it's not safe to assume
<a name="566"></a>     *   that the player and parser must both be thinking the same thing.
<a name="567"></a>     *   Showing a full description of the action will make it obvious to
<a name="568"></a>     *   the player when we guessed wrong, because the description won't
<a name="569"></a>     *   accord with what they had in mind.  A terse acknowledgment would
<a name="570"></a>     *   hide this difference, allowing the player to wrongly assume that
<a name="571"></a>     *   the parser did what they thought it was going to do and
<a name="572"></a>     *   potentially leading to confusion down the road.  
<a name="573"></a>     */
<a name="574"></a>    terseOK()
<a name="575"></a>    {
<a name="576"></a>        /* use full messages for NPC-directed commands */
<a name="577"></a>        if (actor != gPlayerChar)
<a name="578"></a>            return nil;
<a name="579"></a>
<a name="580"></a>        /* 
<a name="581"></a>         *   use full message for commands where ALL was used, since
<a name="582"></a>         *   the player might not otherwise know what ALL referred to.
<a name="583"></a>         */
<a name="584"></a>        
<a name="585"></a>        if(matchedAll || matchedMulti)
<a name="586"></a>            return nil;
<a name="587"></a>        
<a name="588"></a>        /* check all noun roles for Disambig flags */
<a name="589"></a>        foreach (local role in npList)
<a name="590"></a>        {
<a name="591"></a>            /* 
<a name="592"></a>             *   if this is a predicate role, and there's an object in this
<a name="593"></a>             *   slot with the Disambig flag, don't allow terse messages 
<a name="594"></a>             */
<a name="595"></a>            if (role.isPredicate
<a name="596"></a>                &amp;&amp; self.(role.objProp) != nil
<a name="597"></a>                &amp;&amp; (self.(role.objMatchProp).flags &amp; SelDisambig) != 0)
<a name="598"></a>                return nil;
<a name="599"></a>        }
<a name="600"></a>
<a name="601"></a>        /* 
<a name="602"></a>         *   If we're reporting on fewer objects than the player requested then
<a name="603"></a>         *   we'd better be specific about which ones we mean.
<a name="604"></a>         */
<a name="605"></a>        
<a name="606"></a>        
<a name="607"></a>        if(dobjs.length &gt; action.reportList.length)
<a name="608"></a>            return nil;
<a name="609"></a>        
<a name="610"></a>        /* we have no objection to terse messages */
<a name="611"></a>        return true;
<a name="612"></a>    }
<a name="613"></a>
<a name="614"></a>    /* 
<a name="615"></a>     *   Add a noun production, building it out as though it had been part
<a name="616"></a>     *   of the original parse tree.  This can be used to add a noun phrase
<a name="617"></a>     *   after the initial parsing, such as when the player supplies a
<a name="618"></a>     *   missing object. 
<a name="619"></a>     */
<a name="620"></a>    addNounProd(role, prod)
<a name="621"></a>    {
<a name="622"></a>        /* create a noun list item for the production */
<a name="623"></a>        local np = addNounListItem(role, prod);
<a name="624"></a>        
<a name="625"></a>        if(npListSorted.length != npList.length)
<a name="626"></a>            npListSorted = npList;        
<a name="627"></a>        
<a name="628"></a>        
<a name="629"></a>        /* build the tree */
<a name="630"></a>        prod.nounPhraseRole = role;
<a name="631"></a>        prod.build(self, np);
<a name="632"></a>
<a name="633"></a>        /* let the verb production know about the change */
<a name="634"></a>        verbProd.answerMissing(self, np);
<a name="635"></a>    }
<a name="636"></a>
<a name="637"></a>    /* add a noun phrase to the given role (a NounRole) */
<a name="638"></a>    addNounListItem(role, prod)
<a name="639"></a>    {
<a name="640"></a>        /* create the new noun phrase object of the appropriate type */
<a name="641"></a>        local np = prod.npClass.createInstance(nil, prod);
<a name="642"></a>
<a name="643"></a>        /* remember the role in the noun phrase */
<a name="644"></a>        np.role = role;
<a name="645"></a>
<a name="646"></a>        /* add it to the given list */
<a name="647"></a>        self.(role.npListProp) += np;
<a name="648"></a>
<a name="649"></a>        /* 
<a name="650"></a>         *   If this role isn't already in our list or roles, and it has a
<a name="651"></a>         *   match property, add it.  Roles without match properties aren't
<a name="652"></a>         *   predicate noun roles, so they don't go in our predicate object
<a name="653"></a>         *   list.  
<a name="654"></a>         */
<a name="655"></a>        if (npList.indexOf(role) == nil)
<a name="656"></a>        {
<a name="657"></a>          
<a name="658"></a>            npList += role;
<a name="659"></a>            
<a name="660"></a>            /* 
<a name="661"></a>             *   if the action is a TIAction then make sure the Direct and
<a name="662"></a>             *   Indirect Objects are dealt with in the right order as specified
<a name="663"></a>             *   by the action's resolveIobjFirst property. We do this on a copy
<a name="664"></a>             *   of the list (npSorted) so we don't break anything that needs
<a name="665"></a>             *   the original order (such as matching a Doer).
<a name="666"></a>             */
<a name="667"></a>            
<a name="668"></a>            npListSorted = npList;
<a name="669"></a>            
<a name="670"></a>            if(action != nil &amp;&amp; action.ofKind(TIAction))
<a name="671"></a>            {
<a name="672"></a>                local doIdx = npListSorted.indexOf(DirectObject);
<a name="673"></a>                local ioIdx = npListSorted.indexOf(IndirectObject);
<a name="674"></a>                if(doIdx != nil &amp;&amp; ioIdx != nil)
<a name="675"></a>                {
<a name="676"></a>                    if((action.resolveIobjFirst &amp;&amp; ioIdx &gt; doIdx)
<a name="677"></a>                        ||  (!action.resolveIobjFirst &amp;&amp; doIdx &gt; ioIdx))
<a name="678"></a>                    {
<a name="679"></a>                        npListSorted[ioIdx] = DirectObject;
<a name="680"></a>                        npListSorted[doIdx] = IndirectObject;
<a name="681"></a>                    }
<a name="682"></a>                }
<a name="683"></a>            }
<a name="684"></a>        }
<a name="685"></a>
<a name="686"></a>        /* return the new noun phrase */
<a name="687"></a>        return np;
<a name="688"></a>    }
<a name="689"></a>
<a name="690"></a>    /* 
<a name="691"></a>     *   Start processing a new disambiguation reply.  This adds a reply to
<a name="692"></a>     *   a disambiguation question.  
<a name="693"></a>     */
<a name="694"></a>    startDisambigReply(parent, prod)
<a name="695"></a>    {
<a name="696"></a>        /* create the first NounPhrase for this reply */
<a name="697"></a>        local np = new NounPhrase(parent, prod);
<a name="698"></a>
<a name="699"></a>        /* add a new NounPhrase list to the reply list */
<a name="700"></a>        disambig = disambig.append([np]);
<a name="701"></a>
<a name="702"></a>        /* return the new noun phrase */
<a name="703"></a>        return np;
<a name="704"></a>    }
<a name="705"></a>
<a name="706"></a>    /* 
<a name="707"></a>     *   Add a disambiguation list item.  This adds a NounPhrase item to
<a name="708"></a>     *   the current reply list.
<a name="709"></a>     */
<a name="710"></a>    addDisambigNP(prod)
<a name="711"></a>    {
<a name="712"></a>        /* get the current reply list */
<a name="713"></a>        local idx = disambig.length(), lst = disambig[idx];
<a name="714"></a>
<a name="715"></a>        /* create the new noun phrase */
<a name="716"></a>        local np = new NounPhrase(lst[1].parent, prod);
<a name="717"></a>
<a name="718"></a>        /* add it to the current disambiguation reply list */
<a name="719"></a>        disambig[idx] = lst + np;
<a name="720"></a>
<a name="721"></a>        /* return it */
<a name="722"></a>        return np;
<a name="723"></a>    }
<a name="724"></a>
<a name="725"></a>    /*
<a name="726"></a>     *   Fetch a disambiguation reply.  If we have more replies available,
<a name="727"></a>     *   this returns the next reply's noun phrase list, otherwise nil.  
<a name="728"></a>     */
<a name="729"></a>    fetchDisambigReply()
<a name="730"></a>    {
<a name="731"></a>        return (disambigIdx &lt;= disambig.length()
<a name="732"></a>                ? disambig[disambigIdx++]
<a name="733"></a>                : nil);
<a name="734"></a>    }
<a name="735"></a>
<a name="736"></a>    /* mark a noun phrase role as empty */
<a name="737"></a>    emptyNounRole(role)
<a name="738"></a>    {
<a name="739"></a>        /* if this role isn't in our list yet, add it */
<a name="740"></a>        if (npList.indexOf(role) == nil)
<a name="741"></a>            npList += role;
<a name="742"></a>
<a name="743"></a>        /* count the missing phrase */
<a name="744"></a>        ++missingNouns;
<a name="745"></a>
<a name="746"></a>        /* clear out the role list */
<a name="747"></a>        self.(role.npListProp) = [];
<a name="748"></a>    }
<a name="749"></a>
<a name="750"></a>    /* resolve the noun phrases */
<a name="751"></a>    resolveNouns()
<a name="752"></a>    {
<a name="753"></a>        /* 
<a name="754"></a>         *   Note that we're the current command, in case anything wants to know
<a name="755"></a>         */
<a name="756"></a>        gCommand = self;
<a name="757"></a>        
<a name="758"></a>        /* we don't have an error for this resolution pass yet */
<a name="759"></a>        cmdErr = nil;
<a name="760"></a>
<a name="761"></a>        /* we haven't started pulling disambiguation replies yet */
<a name="762"></a>        disambigIdx = 1;
<a name="763"></a>        
<a name="764"></a>        /* Note the orginal lists of nps */
<a name="765"></a>        local npListOld = npList;
<a name="766"></a>        local npListSortedOld = npListSorted;
<a name="767"></a>            
<a name="768"></a>             
<a name="769"></a>        /* 
<a name="770"></a>         *   If the player has just supplied a missing object, we only want to
<a name="771"></a>         *   resolve the object for that role.
<a name="772"></a>         */
<a name="773"></a>        if(npToResolve != nil)
<a name="774"></a>        {
<a name="775"></a>            npList = [npToResolve];
<a name="776"></a>            npListSorted = [npToResolve];
<a name="777"></a>        }
<a name="778"></a>
<a name="779"></a>        /* 
<a name="780"></a>         *   Start by getting the basic vocabulary matches for each noun
<a name="781"></a>         *   phrase.  Run through each noun phrase list.  
<a name="782"></a>         */
<a name="783"></a>        forEachNP({ np: np.matchVocab(self) });
<a name="784"></a>
<a name="785"></a>        /* 
<a name="786"></a>         *   Before we do the object selection, build the tentative lists
<a name="787"></a>         *   of resolved objects.  This can be handy during disambiguation
<a name="788"></a>         *   to help decide the resolution of one slot based on the
<a name="789"></a>         *   possible values for other slots.  For example, for PUT COIN IN
<a name="790"></a>         *   JAR, it might help us choose a coin to know that the iobj is
<a name="791"></a>         *   JAR.  
<a name="792"></a>         */
<a name="793"></a>        buildObjLists();
<a name="794"></a>
<a name="795"></a>        /* determine the actor */
<a name="796"></a>        if (actorNPs != [])
<a name="797"></a>        {
<a name="798"></a>            /* 
<a name="799"></a>             *   We have an explicit addressee.  If we have more than one
<a name="800"></a>             *   object for the actor phrase, disambiguate to a single
<a name="801"></a>             *   object.  Disambiguate in the context of TALK TO.  
<a name="802"></a>             */
<a name="803"></a>            local anp = actorNPs[1];
<a name="804"></a>            if (anp.matches.length() &gt; 1)
<a name="805"></a>                anp.disambiguate(self, 1, TalkTo);
<a name="806"></a>            if (anp.matches.length() == 0)
<a name="807"></a>                throw new UnmatchedActorError(anp);
<a name="808"></a>
<a name="809"></a>            /* pull out the match as the actor object */
<a name="810"></a>            actor = anp.matches[1].obj;
<a name="811"></a>        }
<a name="812"></a>
<a name="813"></a>        /* 
<a name="814"></a>         *   select the objects from the available matches according to the
<a name="815"></a>         *   grammatical mode (definite, indefinite, plural) 
<a name="816"></a>         */
<a name="817"></a>        forEachNP({ np: np.selectObjects(self) });
<a name="818"></a>
<a name="819"></a>        /* 
<a name="820"></a>         *   Go back and re-resolve ALL lists.  For two-object commands,
<a name="821"></a>         *   resolving ALL in one slot sometimes depends on resolving the
<a name="822"></a>         *   object in the other slot first. 
<a name="823"></a>         */
<a name="824"></a>        forEachNP({ np: np.resolveAll(self) });
<a name="825"></a>
<a name="826"></a>        /*
<a name="827"></a>         *   Set up the second-person reflexive pronoun antecedent.  For a
<a name="828"></a>         *   command addressed in the imperative form to an NPC (e.g., BOB,
<a name="829"></a>         *   EXAMINE YOURSELF), YOU binds to the addressee.  For anything
<a name="830"></a>         *   else (e.g., EXAMINE YOURSELF, or TELL BOB TO EXAMINE
<a name="831"></a>         *   YOURSELF), YOU binds to the player character.  
<a name="832"></a>         */
<a name="833"></a>        if (reflexiveAnte != nil)
<a name="834"></a>        {
<a name="835"></a>            if (actorNPs != [] &amp;&amp; actorPerson == 2)
<a name="836"></a>            {
<a name="837"></a>                /* imperative addressed to an actor: YOU is the actor */
<a name="838"></a>                reflexiveAnte[You] = [actor];
<a name="839"></a>            }
<a name="840"></a>            else
<a name="841"></a>            {
<a name="842"></a>                /* for anything else, YOU is the PC */
<a name="843"></a>                reflexiveAnte[You] = [gPlayerChar]; //[World.playerChar];
<a name="844"></a>            }
<a name="845"></a>        }
<a name="846"></a>
<a name="847"></a>        /*
<a name="848"></a>         *   Resolve reflexive pronouns (e.g., ASK BOB ABOUT HIMSELF).  We
<a name="849"></a>         *   have to do this as a separate step because reflexives refer
<a name="850"></a>         *   back to other noun phrases in the same command.  We can't do
<a name="851"></a>         *   this until after we resolve everything else.  
<a name="852"></a>         */
<a name="853"></a>        forEachNP({ np: np.resolveReflexives(self) });
<a name="854"></a>
<a name="855"></a>        /* check for empty roles */
<a name="856"></a>        foreach (local role in npList)
<a name="857"></a>        {
<a name="858"></a>            if (self.(role.npListProp).length() == 0)
<a name="859"></a>                throw new EmptyNounError(self, role);
<a name="860"></a>        }
<a name="861"></a>
<a name="862"></a>        /* 
<a name="863"></a>         *   Clear out the old object lists, then build them anew.  The old
<a name="864"></a>         *   object lists were tentative, before disambiguation; we want to
<a name="865"></a>         *   replace them now with the final lists. 
<a name="866"></a>         */
<a name="867"></a>        buildObjLists();
<a name="868"></a>        
<a name="869"></a>        /* Restore the original lists of nps */
<a name="870"></a>        npList = npListOld;
<a name="871"></a>        npListSorted = npListSortedOld;
<a name="872"></a>    }
<a name="873"></a>
<a name="874"></a>    /* carry out a callback for each noun phrase in each list */
<a name="875"></a>    forEachNP(func)
<a name="876"></a>    {       
<a name="877"></a>        /* run through each noun phrase list in the command */
<a name="878"></a>        foreach (local role in npListSorted)
<a name="879"></a>        {
<a name="880"></a>            /* run through each NounPhrase in this slot's list */
<a name="881"></a>            foreach (local np in self.(role.npListProp))
<a name="882"></a>            {
<a name="883"></a>                /* invoke the callback on this item */
<a name="884"></a>                func(np);
<a name="885"></a>            }
<a name="886"></a>        }
<a name="887"></a>    }
<a name="888"></a>
<a name="889"></a>    /* 
<a name="890"></a>     *   If the parser has just asked the player to supply a missing object via
<a name="891"></a>     *   the askMissingObject() function, we don't want to resolve the nouns for
<a name="892"></a>     *   every object role, but only for the role with which askMissingObject()
<a name="893"></a>     *   is currently concerned; askMissingObject() stores that role here so
<a name="894"></a>     *   that our resolvedNouns() method knows to resolve only the noun for this
<a name="895"></a>     *   role rather than for all the roles in the command. If npToResolve is
<a name="896"></a>     *   nil (as it normally will be) then it will be ignored, and all noun
<a name="897"></a>     *   roles will be resolved.
<a name="898"></a>     */
<a name="899"></a>        
<a name="900"></a>    npToResolve = nil
<a name="901"></a>    
<a name="902"></a>    /* 
<a name="903"></a>     *   Build the object lists.  This runs through each NounPhrase in the
<a name="904"></a>     *   command to build its 'objs' list, then builds the corresponding
<a name="905"></a>     *   master list in the Command object.  
<a name="906"></a>     */
<a name="907"></a>    buildObjLists()
<a name="908"></a>    {
<a name="909"></a>        /* 
<a name="910"></a>         *   Note that we're the current command object, so that other object
<a name="911"></a>         *   methods can refer to our object lists.
<a name="912"></a>         */
<a name="913"></a>        gCommand = self;
<a name="914"></a>        
<a name="915"></a>        /* run through each active noun phrase list */
<a name="916"></a>        foreach (local role in npList)
<a name="917"></a>        {
<a name="918"></a>            /* set up a vector to hold this list's nouns */
<a name="919"></a>            self.(role.objListProp) = new Vector(10);
<a name="920"></a>
<a name="921"></a>            /* build the object list for each NounPhrase */
<a name="922"></a>            foreach (local np in self.(role.npListProp))
<a name="923"></a>            {
<a name="924"></a>                /* build the list */
<a name="925"></a>                np.buildObjList();
<a name="926"></a>
<a name="927"></a>                /* append it to the master match list for this slot */
<a name="928"></a>                self.(role.objListProp).appendAll(np.matches);
<a name="929"></a>            }
<a name="930"></a>        }
<a name="931"></a>    }
<a name="932"></a>
<a name="933"></a>    /*
<a name="934"></a>     *   Save a potential antecedent for a reflexive pronoun coming up
<a name="935"></a>     *   later in the command.  Each time we visit a noun phrase during the
<a name="936"></a>     *   reflexive pronoun phase, we'll note its resolved objects here.
<a name="937"></a>     *   Since we visit the noun phrases in their order of appearance in
<a name="938"></a>     *   the command, we'll naturally always have the latest one mentioned
<a name="939"></a>     *   when we come to a reflexive pronoun.  This gives us the correct
<a name="940"></a>     *   resolution, which is the nearest preceding noun.  Note that the
<a name="941"></a>     *   noun phrase shouldn't call this routine to note reflexive
<a name="942"></a>     *   pronouns, since they don't bind to earlier reflexive pronouns -
<a name="943"></a>     *   they only bind to regular noun phrases.  
<a name="944"></a>     */
<a name="945"></a>    saveReflexiveAnte(obj)
<a name="946"></a>    {
<a name="947"></a>        /* if we don't have a reflexive antecedent table, skip this */
<a name="948"></a>        if (reflexiveAnte == nil)
<a name="949"></a>            return;
<a name="950"></a>
<a name="951"></a>        /* if the object isn't already a list, wrap it in a list */
<a name="952"></a>        local lst = obj;
<a name="953"></a>        if (!lst.ofKind(Collection))
<a name="954"></a>            lst = [obj];
<a name="955"></a>
<a name="956"></a>        /* 
<a name="957"></a>         *   Run through the regular pronoun list, and save this object
<a name="958"></a>         *   with the pronouns that apply to this object.  Note that a
<a name="959"></a>         *   given object might match multiple pronouns, so we might save
<a name="960"></a>         *   the object for several different pronouns.  
<a name="961"></a>         */
<a name="962"></a>        foreach (local p in Pronoun.all)
<a name="963"></a>        {
<a name="964"></a>            if (p.matchObj(obj))
<a name="965"></a>                reflexiveAnte[p] = lst;
<a name="966"></a>        }
<a name="967"></a>    }
<a name="968"></a>
<a name="969"></a>    /*
<a name="970"></a>     *   Resolve a reflexive pronoun on behalf of one of the NounPhrases
<a name="971"></a>     *   within this command.  
<a name="972"></a>     */
<a name="973"></a>    resolveReflexive(pronoun)
<a name="974"></a>    {
<a name="975"></a>        /* if there's no table, there's no antecedent */
<a name="976"></a>        if (reflexiveAnte == nil)
<a name="977"></a>            return [];
<a name="978"></a>
<a name="979"></a>        /* get the meaning from the reflexive antecedent table */
<a name="980"></a>        local ante = reflexiveAnte[pronoun];
<a name="981"></a>
<a name="982"></a>        /* if there's no antecedent defined, return an empty list */
<a name="983"></a>        if (ante == nil)
<a name="984"></a>            ante = [];
<a name="985"></a>
<a name="986"></a>        /* return the result */
<a name="987"></a>        return ante;
<a name="988"></a>    }
<a name="989"></a>
<a name="990"></a>    /* table of reflexive pronoun antecedents */
<a name="991"></a>    reflexiveAnte = nil
<a name="992"></a>
<a name="993"></a>    /*
<a name="994"></a>     *   Class method: Sort a list of Command matches, in priority order.
<a name="995"></a>     *   The priority order is the order for processing predicate grammar
<a name="996"></a>     *   matches: start at the highest priority, and work through the list
<a name="997"></a>     *   until you find one where the noun phrases resolve to valid
<a name="998"></a>     *   game-world objects; that's the one to execute.  
<a name="999"></a>     */
<a name="1000"></a>    sortList(cmdLst)
<a name="1001"></a>    {
<a name="1002"></a>        
<a name="1003"></a>        /* First reduce the list to those with active predicates */
<a name="1004"></a>        cmdLst = cmdLst.subset({c: c.predActive});
<a name="1005"></a>        
<a name="1006"></a>        /* pre-calculate the priorities, to save work during the sort */
<a name="1007"></a>        foreach (local cmd in cmdLst)
<a name="1008"></a>            cmd.fixPriority();
<a name="1009"></a>        
<a name="1010"></a>        
<a name="1011"></a>
<a name="1012"></a>        /* sort in descending order of priority */
<a name="1013"></a>        return cmdLst.sort(SortDesc, {a, b: a.priority - b.priority});
<a name="1014"></a>    }
<a name="1015"></a>
<a name="1016"></a>    /*
<a name="1017"></a>     *   Calculate the parsing priority.
<a name="1018"></a>     *   
<a name="1019"></a>     *   When the parser looks for grammar rule matches to the input, it
<a name="1020"></a>     *   considers *all* of the possible matches.  Natural language is full
<a name="1021"></a>     *   of syntactic ambiguity, so a given input string can often be
<a name="1022"></a>     *   parsed into several different, but equally valid, syntax trees.
<a name="1023"></a>     *   It's often impossible to tell which parsing is correct based on
<a name="1024"></a>     *   syntax alone - you often have to look at the overall meaning of
<a name="1025"></a>     *   the sentence.  For example, GIVE BOOK TO BOB could be interpreted
<a name="1026"></a>     *   as having a direct object (BOOK) and an indirect object (BOB), or
<a name="1027"></a>     *   it could be seen as having only a direct object (BOOK TO BOB,
<a name="1028"></a>     *   treating the TO as a prepositional phrase modifying BOOK rather
<a name="1029"></a>     *   than as a part of the verb phrase structure).  The initial parsing
<a name="1030"></a>     *   phase only looks at the syntax, so it has to consider all of the
<a name="1031"></a>     *   valid phrase structures, even though a human speaker would
<a name="1032"></a>     *   immediately dismiss many of them as nonsensical.  Once we find all
<a name="1033"></a>     *   of the syntax matches, the parser puts them into priority order,
<a name="1034"></a>     *   and then goes down the list looking for the first one that makes
<a name="1035"></a>     *   sense semantically (which is defined roughly as having noun
<a name="1036"></a>     *   phrases that refer to actual objects).
<a name="1037"></a>     *   
<a name="1038"></a>     *   The priority, then, represents our guess at the likelihood that
<a name="1039"></a>     *   the grammar structure matches the user's intentions, based on the
<a name="1040"></a>     *   syntax.  Our fundamental assumption is that the command is valid:
<a name="1041"></a>     *   that is, it's well-formed grammatically, AND it expresses
<a name="1042"></a>     *   something that's possible, or at least logical to try, within the
<a name="1043"></a>     *   game-world context.  Given this, our strategy is to find a grammar
<a name="1044"></a>     *   structure that gives us a command that we can actually carry out.
<a name="1045"></a>     *   
<a name="1046"></a>     *   The priority is a composite value, made up of weighted component
<a name="1047"></a>     *   values.  We combine the components into a single scalar value
<a name="1048"></a>     *   simply by adding up the parts multiplied by their weights.  (Or,
<a name="1049"></a>     *   looked at another way, we combine the values using a high-radix
<a name="1050"></a>     *   numbering system.)  The components are, from most significant to
<a name="1051"></a>     *   least significant:
<a name="1052"></a>     *   
<a name="1053"></a>     *   - Grammatically correct commands sort ahead of commands with
<a name="1054"></a>     *   structural errors.
<a name="1055"></a>     *   
<a name="1056"></a>     *   - The predicate priority, from the VerbProduction.  (This tells us
<a name="1057"></a>     *   how "complete" the predicate structure is: a predicate with
<a name="1058"></a>     *   missing information has a lower priority.  This is in keeping with
<a name="1059"></a>     *   our assumption that the user's input is well-formed - we'll try
<a name="1060"></a>     *   the most complete structures first before falling back on the
<a name="1061"></a>     *   possibility that the user left out some information.)
<a name="1062"></a>     *   
<a name="1063"></a>     *   - Filled noun slots ahead of missing noun slots.  A missing noun
<a name="1064"></a>     *   slot occurs when the player leaves one of the noun roles empty
<a name="1065"></a>     *   (PUT BOX, TAKE).  We can fill in this information with automatic
<a name="1066"></a>     *   defaults, so it's not necessarily a reason to reject the parsing,
<a name="1067"></a>     *   but if there's another interpretation that has fully occupied noun
<a name="1068"></a>     *   slots, try the occupied one first.
<a name="1069"></a>     *   
<a name="1070"></a>     *   - More noun phrase slots first.  For example, sort a command with
<a name="1071"></a>     *   a direct and indirect object (two slots) ahead of one with only a
<a name="1072"></a>     *   direct object.  More slots means that we found more "structure" in
<a name="1073"></a>     *   the command; we can sometimes interpret the same command with less
<a name="1074"></a>     *   structure by subsuming more words into a long noun phrase.
<a name="1075"></a>     *   
<a name="1076"></a>     *   - Longest noun phrases, in aggregate, first.  This is in terms of
<a name="1077"></a>     *   tokens matched from the user input.  (We want to consider longer
<a name="1078"></a>     *   noun phrases first because it's more likely that they'll match
<a name="1079"></a>     *   exact objects, so there's less chance of ambiguity, *and* it's
<a name="1080"></a>     *   more likely that if we're wrong about the structure, we'll simply
<a name="1081"></a>     *   fail to find a matching object and move on to other parse trees.
<a name="1082"></a>     *   Longer noun phrases are less likely to yield spurious matches
<a name="1083"></a>     *   simply because they have more words that have to match.)
<a name="1084"></a>     *   
<a name="1085"></a>     *   - Grammatical noun phrases take priority over misc word phrases (a
<a name="1086"></a>     *   misc word phrase is text in a noun phrase slot that doesn't match
<a name="1087"></a>     *   any of the defined patterns in the grammar rules).
<a name="1088"></a>     *   
<a name="1089"></a>     *   - Longest command first, in terms of tokens matched from the user
<a name="1090"></a>     *   input.  (The more user input we use the better, since that gives
<a name="1091"></a>     *   us more confidence that we're correctly interpreting what the user
<a name="1092"></a>     *   said.  When we leave extra tokens for later, we can't be sure that
<a name="1093"></a>     *   we'll be able to make any sense of what's left over, whereas
<a name="1094"></a>     *   tokens in the current match are known to fit a grammar rule.)  
<a name="1095"></a>     */
<a name="1096"></a>    calcPriority()
<a name="1097"></a>    {
<a name="1098"></a>        return (badMulti == nil ? 250000000 : 0)
<a name="1099"></a>            + predPriority*2500000
<a name="1100"></a>            + 500000*(4 - min(missingNouns, 4))
<a name="1101"></a>            + 100000*min(numNounSlots(), 4)
<a name="1102"></a>            + 10000*(9 - min(miscWordLists.length(), 9))
<a name="1103"></a>            + 100*min(npTokenLen(), 99)
<a name="1104"></a>            + min(tokenLen, 99);
<a name="1105"></a>    }
<a name="1106"></a>
<a name="1107"></a>    /* 
<a name="1108"></a>     *   Set a fixed priority.  This makes the priority a fixed value
<a name="1109"></a>     *   rather than a calculated value.  We call this before sorting a
<a name="1110"></a>     *   list of commands, so that we don't have to recalculate the
<a name="1111"></a>     *   priority value repeatedly during the sort.  
<a name="1112"></a>     */
<a name="1113"></a>    fixPriority() { priority = self.calcPriority(); }
<a name="1114"></a>
<a name="1115"></a>    /* note a noun phrase with a miscellaneous word list */
<a name="1116"></a>    noteMiscWords(np)
<a name="1117"></a>    {
<a name="1118"></a>        /* if we haven't already noted this one, add it to our list */
<a name="1119"></a>        if (miscWordLists.indexOf(np) == nil)
<a name="1120"></a>            miscWordLists += np;
<a name="1121"></a>    }
<a name="1122"></a>
<a name="1123"></a>    /* the calculated priority */
<a name="1124"></a>    priority = 0
<a name="1125"></a>
<a name="1126"></a>    /*
<a name="1127"></a>     *   List of noun phrases containing misc word phrases.  The misc word
<a name="1128"></a>     *   phrase grammar rules will notify us when they're visited in the
<a name="1129"></a>     *   build process, and we'll note them here.  
<a name="1130"></a>     */
<a name="1131"></a>    miscWordLists = []
<a name="1132"></a>
<a name="1133"></a>    /*
<a name="1134"></a>     *   Do we have any missing or empty noun phrases in the match?  The
<a name="1135"></a>     *   verb and noun phrases will fill this in.  
<a name="1136"></a>     */
<a name="1137"></a>    missingNouns = 0
<a name="1138"></a>
<a name="1139"></a>    /* 
<a name="1140"></a>     *   The number of tokens from the command line that we matched for the
<a name="1141"></a>     *   command.  The CommandProduction object sets this for us as it
<a name="1142"></a>     *   builds the command from the parse tree.  We use this to determine
<a name="1143"></a>     *   the priority order of the syntax matches, when there are multiple
<a name="1144"></a>     *   matches: other things being equal, we'll take the longest match.
<a name="1145"></a>     *   Longer matches are better because they come closer to using
<a name="1146"></a>     *   everything the user typed, which is our eventual goal.
<a name="1147"></a>     *   
<a name="1148"></a>     *   This reflects the number of tokens used in the first predicate
<a name="1149"></a>     *   phrase; it omits any additional predicates or conjunctions.  We
<a name="1150"></a>     *   only count the first predicate because we always go back and
<a name="1151"></a>     *   re-parse any additional text on the line from scratch after
<a name="1152"></a>     *   executing the first predicate, in case the execution changes the
<a name="1153"></a>     *   game state in such a way that the parsing changes.  
<a name="1154"></a>     */
<a name="1155"></a>    tokenLen = 0
<a name="1156"></a>
<a name="1157"></a>    /* Calculate the sum of the token lengths of our noun phrases */
<a name="1158"></a>    npTokenLen()
<a name="1159"></a>    {
<a name="1160"></a>        /* sum the token counts of all of the noun phrases */
<a name="1161"></a>        local tot = 0;
<a name="1162"></a>        forEachNP({ np: tot += np.tokens.length() });
<a name="1163"></a>
<a name="1164"></a>        /* return the sum */
<a name="1165"></a>        return tot;
<a name="1166"></a>    }
<a name="1167"></a>
<a name="1168"></a>    /* Calculate the number of noun slots we have filled in */
<a name="1169"></a>    numNounSlots() { return npList.length(); }
<a name="1170"></a>
<a name="1171"></a>    /* the predicate priority (see VerbProduction.priority) */
<a name="1172"></a>    predPriority = 0
<a name="1173"></a>    
<a name="1174"></a>    /* is our predicate currently active (see VerbProduction.isActive) */
<a name="1175"></a>    predActive = true
<a name="1176"></a>
<a name="1177"></a>    /*
<a name="1178"></a>     *   The parse tree (the root of the grammar match), if applicable.
<a name="1179"></a>     *   Commands built from user input have a parse tree; those built
<a name="1180"></a>     *   internally don't.  Note that the parse tree doesn't necessarily
<a name="1181"></a>     *   include *all* of the user input, since we could have asked
<a name="1182"></a>     *   questions (disambiguation, missing noun phrases) before the
<a name="1183"></a>     *   command was completed.  The question replies will be represented
<a name="1184"></a>     *   in noun phrases or other data added to the command after the
<a name="1185"></a>     *   initial parse.  
<a name="1186"></a>     */
<a name="1187"></a>    parseTree = nil
<a name="1188"></a>
<a name="1189"></a>    /* the Action object giving the action to be performed */
<a name="1190"></a>    action = nil
<a name="1191"></a>
<a name="1192"></a>    /* the Previous action performed by this command */
<a name="1193"></a>    lastAction = nil
<a name="1194"></a>    
<a name="1195"></a>    /* the VerbProduction object for the command */
<a name="1196"></a>    verbProd = nil
<a name="1197"></a>
<a name="1198"></a>    /* the resolved actor; we determine this before disambiguation */
<a name="1199"></a>    actor = nil
<a name="1200"></a>
<a name="1201"></a>    /* the actor(s) to whom the command is addressed, as a NounPhrase list */
<a name="1202"></a>    actorNPs = []
<a name="1203"></a>
<a name="1204"></a>    /* the actor(s), as NPMatch objects */
<a name="1205"></a>    actors = []
<a name="1206"></a>
<a name="1207"></a>    /*
<a name="1208"></a>     *   The grammatical person in which we're addressing the actor.  This
<a name="1209"></a>     *   is 2 for a second-person address, 3 for third-person orders.
<a name="1210"></a>     *   (It's hard to think of a case for first-person orders, but 
<a name="1211"></a>     *   
<a name="1212"></a>     *   The conventional IF syntax for giving orders is ACTOR, DO
<a name="1213"></a>     *   SOMETHING, which addresses ACTOR in the second person (as YOU).
<a name="1214"></a>     *   This means that second-person pronouns 
<a name="1215"></a>     */
<a name="1216"></a>    actorPerson = 2
<a name="1217"></a>
<a name="1218"></a>    /* the direct object phrases, as a list of NounPhrase objects */
<a name="1219"></a>    dobjNPs = []
<a name="1220"></a>
<a name="1221"></a>    /* the list of resolved direct objects, as NPMatch objects */
<a name="1222"></a>    dobjs = []
<a name="1223"></a>
<a name="1224"></a>    /* the current direct object for the current action iteration */
<a name="1225"></a>    dobj = nil
<a name="1226"></a>
<a name="1227"></a>    /* the NPMatch object for the current iteration's direct object */
<a name="1228"></a>    dobjInfo = nil
<a name="1229"></a>
<a name="1230"></a>    /* the indirect object phrases, as a list of NounPhrase objects */
<a name="1231"></a>    iobjNPs = []
<a name="1232"></a>
<a name="1233"></a>    /* the list of resolved indirect objects, as NPMatch objects */
<a name="1234"></a>    iobjs = []
<a name="1235"></a>
<a name="1236"></a>    /* the indirect object for the current iteration */
<a name="1237"></a>    iobj = nil
<a name="1238"></a>
<a name="1239"></a>    /* the NPMatch object for the current indirect object */
<a name="1240"></a>    iobjInfo = nil
<a name="1241"></a>
<a name="1242"></a>    /* the accessory phrases, as a list of NounPhrase objects */
<a name="1243"></a>    accNPs = []
<a name="1244"></a>
<a name="1245"></a>    /* the list of resolved accessory objects, as NPMatch objects */
<a name="1246"></a>    accs = []
<a name="1247"></a>
<a name="1248"></a>    /* the accessory object for the current iteration */
<a name="1249"></a>    acc = nil
<a name="1250"></a>
<a name="1251"></a>    /* synonym for the accessory object */
<a name="1252"></a>    aobj = (acc)
<a name="1253"></a>    
<a name="1254"></a>    /* the NPMatch object for the current accessory */
<a name="1255"></a>    accInfo = nil
<a name="1256"></a>
<a name="1257"></a>    /*
<a name="1258"></a>     *   Disambiguation replies.  Each time the player answers a
<a name="1259"></a>     *   disambiguation question, we add the reply to this list.  We then
<a name="1260"></a>     *   go back and re-resolve the noun phrases, fetching replies from the
<a name="1261"></a>     *   list as we encounter the ambiguous objects again.
<a name="1262"></a>     *   
<a name="1263"></a>     *   Note that this is a list of list.  Each reply is a list of
<a name="1264"></a>     *   NounPhrase objects, and we might have a series of replies, so one
<a name="1265"></a>     *   list represents one reply.  
<a name="1266"></a>     */
<a name="1267"></a>    disambig = []
<a name="1268"></a>
<a name="1269"></a>    /* the next available disambiguation reply */
<a name="1270"></a>    disambigIdx = 1
<a name="1271"></a>
<a name="1272"></a>    /* 
<a name="1273"></a>     *   Is this command at the end of a sentence?  The grammar match sets
<a name="1274"></a>     *   this to true if the input syntax puts this predicate at the end of
<a name="1275"></a>     *   a sentence.  For example, in the English grammar, this is set if
<a name="1276"></a>     *   there's a period after this predicate.  This tells the parser that
<a name="1277"></a>     *   the next predicate in the same line is the start of a new
<a name="1278"></a>     *   sentence, so sentence-opening syntax is allowed.  
<a name="1279"></a>     */
<a name="1280"></a>    endOfSentence = nil
<a name="1281"></a>
<a name="1282"></a>    /*
<a name="1283"></a>     *   The noun phrase roles (as NounRole objects), in the order they
<a name="1284"></a>     *   actually appear in the user input.  We build this list as the
<a name="1285"></a>     *   VerbProduction adds our noun phrases.  The phrase order is
<a name="1286"></a>     *   important when there are reflexive pronouns, because a reflexive
<a name="1287"></a>     *   pronoun generally refers back to the nearest preceding phrase of
<a name="1288"></a>     *   the same number and gender.  
<a name="1289"></a>     */
<a name="1290"></a>    npList = []
<a name="1291"></a>    
<a name="1292"></a>    /*  
<a name="1293"></a>     *   A copy of the npList sorted to ensure that the direct and indirect
<a name="1294"></a>     *   objects of a TIAction are verified in the order specified on that
<a name="1295"></a>     *   action.
<a name="1296"></a>     */
<a name="1297"></a>    
<a name="1298"></a>    npListSorted = []
<a name="1299"></a>
<a name="1300"></a>    /* 
<a name="1301"></a>     *   Error flag: we have a noun list (grammatically) where a single
<a name="1302"></a>     *   noun is required.  When this occurs, this will be set to the role
<a name="1303"></a>     *   where the error was noted.  
<a name="1304"></a>     */
<a name="1305"></a>    badMulti = nil
<a name="1306"></a>
<a name="1307"></a>    /*
<a name="1308"></a>     *   The token list for the next predicate.  The first predicate
<a name="1309"></a>     *   production fills this in during the build process with the token
<a name="1310"></a>     *   list for the next predicate on the same command line, based on the
<a name="1311"></a>     *   location of the conjunction or punctuation that ends the first
<a name="1312"></a>     *   predicate.  This is just what's left of the token list after the
<a name="1313"></a>     *   tokens used for our own predicate and after any conjunctions or
<a name="1314"></a>     *   punctuation marks that separate our predicate from the next one.  
<a name="1315"></a>     */
<a name="1316"></a>    nextTokens = []
<a name="1317"></a>
<a name="1318"></a>    /* 
<a name="1319"></a>     *   The error we encountered building the command, if any.  This is
<a name="1320"></a>     *   usually a noun resolution error. 
<a name="1321"></a>     */
<a name="1322"></a>    cmdErr = nil
<a name="1323"></a>    
<a name="1324"></a>    /*   Does this command apply to objects matched to ALL? */
<a name="1325"></a>    
<a name="1326"></a>    
<a name="1327"></a>    matchedAll = nil
<a name="1328"></a>    
<a name="1329"></a>    /*   Does this command apply to objects matched to multiple objects? */
<a name="1330"></a>    matchedMulti = nil
<a name="1331"></a>    
<a name="1332"></a>    madeTopic = nil
<a name="1333"></a>    
<a name="1334"></a>    /* 
<a name="1335"></a>     *   Get the command phrase entered by the player, with the words used to
<a name="1336"></a>     *   match the direct, indirect and accessory objects replaced by (dobj),
<a name="1337"></a>     *   (iobj) and (acc) respectively; e.g. PUT RED BALL ON TABLE becomes 'put
<a name="1338"></a>     *   (dobj) on (iobj)'
<a name="1339"></a>     */
<a name="1340"></a>    getCommandPhrase()
<a name="1341"></a>    {
<a name="1342"></a>        /* 
<a name="1343"></a>         *   If for any reason we don't have a verbProd property, return an
<a name="1344"></a>         *   empty string (to avoid any run-time errors below).
<a name="1345"></a>         */
<a name="1346"></a>        if(verbProd == nil)
<a name="1347"></a>            return '';
<a name="1348"></a>        
<a name="1349"></a>        /*  Get the tokens making up the current command. */
<a name="1350"></a>        local toks = verbProd.tokenList.mapAll({t: getTokVal(t)});
<a name="1351"></a>        
<a name="1352"></a>        /*  Define a couple of local variables for use below */
<a name="1353"></a>        local idx1, idx2;
<a name="1354"></a>        
<a name="1355"></a>        /*  
<a name="1356"></a>         *   For each of the possible dobjMatch, iobjMatch and accMatch
<a name="1357"></a>         *   properties, replace the tokens used to match the dobj, iobj or
<a name="1358"></a>         *   accessory object with the placeholder '(dobj)', '(iobj)' or
<a name="1359"></a>         *   '(acc)'. To do that, replace the first token used to match the
<a name="1360"></a>         *   object with the placeholder, and then the other tokens that matched
<a name="1361"></a>         *   the object with '?-?'.
<a name="1362"></a>         */
<a name="1363"></a>        if(verbProd.dobjMatch)
<a name="1364"></a>        {
<a name="1365"></a>            idx1 = verbProd.dobjMatch.np_.firstTokenIndex;
<a name="1366"></a>            idx2 = verbProd.dobjMatch.np_.lastTokenIndex;
<a name="1367"></a>            toks[idx1] = '(dobj)';
<a name="1368"></a>            for(local i = idx1 + 1; i &lt;= idx2; i++)
<a name="1369"></a>                toks[i] = '?-?';
<a name="1370"></a>        }
<a name="1371"></a>        
<a name="1372"></a>        if(verbProd.iobjMatch)
<a name="1373"></a>        {
<a name="1374"></a>            idx1 = verbProd.iobjMatch.np_.firstTokenIndex;
<a name="1375"></a>            idx2 = verbProd.iobjMatch.np_.lastTokenIndex;
<a name="1376"></a>            toks[idx1] = '(iobj)';
<a name="1377"></a>            for(local i = idx1 + 1; i &lt;= idx2; i++)
<a name="1378"></a>                toks[i] = '?-?';
<a name="1379"></a>        }
<a name="1380"></a>        
<a name="1381"></a>        if(verbProd.accMatch)
<a name="1382"></a>        {
<a name="1383"></a>            idx1 = verbProd.accMatch.np_.firstTokenIndex;
<a name="1384"></a>            idx2 = verbProd.accMatch.np_.lastTokenIndex;
<a name="1385"></a>            toks[idx1] = '(acc)';
<a name="1386"></a>            for(local i = idx1 + 1; i &lt;= idx2; i++)
<a name="1387"></a>                toks[i] = '?-?';
<a name="1388"></a>        }
<a name="1389"></a>        
<a name="1390"></a>        /* Now remove all the '?-?' tokens */
<a name="1391"></a>        toks = toks.subset({t: t != '?-?'});
<a name="1392"></a>        
<a name="1393"></a>        /* Join the tokens together into a string and return it. */
<a name="1394"></a>        return toks.join(' ');
<a name="1395"></a>    }
<a name="1396"></a>;
<a name="1397"></a>
<a name="1398"></a>
<a name="1399"></a>
<a name="1400"></a>
<a name="1401"></a>/* ------------------------------------------------------------------------ */
<a name="1402"></a>/*
<a name="1403"></a> *   A FuncCommand is a special version of Command that carries out its
<a name="1404"></a> *   action via a custom callback function, rather than by executing a
<a name="1405"></a> *   regular Action.  This can be used to create a simple one-off custom
<a name="1406"></a> *   command without having to create a separate Action for it.  
<a name="1407"></a> */
<a name="1408"></a>class FuncCommand: Command
<a name="1409"></a>    /*
<a name="1410"></a>     *   Create: provide the grammar match object, if any, and the callback
<a name="1411"></a>     *   function to execute to carry out the command. 
<a name="1412"></a>     */
<a name="1413"></a>    construct(prod, func)
<a name="1414"></a>    {
<a name="1415"></a>        /* call the appropriate inherited constructor */
<a name="1416"></a>        if (prod != nil)
<a name="1417"></a>            inherited(prod);
<a name="1418"></a>        else
<a name="1419"></a>            inherited();
<a name="1420"></a>
<a name="1421"></a>        /* save the callback function */
<a name="1422"></a>        self.func = func;
<a name="1423"></a>    }
<a name="1424"></a>
<a name="1425"></a>    /* the callback function for carrying out our command action */
<a name="1426"></a>    func = nil
<a name="1427"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/04/2024 from adv3Lite version 2.0</div>
</body>
</html>

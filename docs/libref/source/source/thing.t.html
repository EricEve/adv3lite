<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>thing.t</title></head><body>
<table class=ban><tr><td><h1>thing.t</h1><td align=right><a href="../file/thing.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>property subLocation;
<a name="5"></a>property lookAroundShowExits;
<a name="6"></a>
<a name="7"></a>/*
<a name="8"></a> *   Mentionable is the base class for objects that the player can refer to
<a name="9"></a> *   in command input.  In order for the parser to recognize an object, the
<a name="10"></a> *   object must have vocabulary words in the dictionary.  This class's
<a name="11"></a> *   main function, then, is to set up the dictionary for an object, so
<a name="12"></a> *   that its words are recognizable to the parser.
<a name="13"></a> *   
<a name="14"></a> *   This class is based on LMentionable, which is defined in the language
<a name="15"></a> *   module.  LMentionable provides implementations for certain methods
<a name="16"></a> *   that we rely upon for functionality that varies by language.  
<a name="17"></a> */
<a name="18"></a>class Mentionable: LMentionable
<a name="19"></a>    /*
<a name="20"></a>     *   'vocab' is a string that we use to initialize the object's short
<a name="21"></a>     *   name, dictionary words, grammatical gender, and grammatical number
<a name="22"></a>     *   (singular/plural).  This is designed to make it as convenient as
<a name="23"></a>     *   possible to describe the object's name and grammatical behavior
<a name="24"></a>     *   for input and output purposes.
<a name="25"></a>     *   
<a name="26"></a>     *   The syntax is language-specific - see initVocab() for details.  
<a name="27"></a>     */
<a name="28"></a>    vocab = nil
<a name="29"></a>
<a name="30"></a>    /*
<a name="31"></a>     *   The object's short name, for display in lists and announcements.
<a name="32"></a>     *   By default, this is automatically derived from 'vocab', so you
<a name="33"></a>     *   usually don't have to set it directly.  If you define a non-nil
<a name="34"></a>     *   'name' value manually, though, it takes precedence (i.e., the
<a name="35"></a>     *   library won't replace it with the name implied by 'vocab').  
<a name="36"></a>     */
<a name="37"></a>    name = nil
<a name="38"></a>
<a name="39"></a>    /*
<a name="40"></a>     *   My room title.  This is displayed as the start of the room
<a name="41"></a>     *   headline, which is the first line of the room description when
<a name="42"></a>     *   'self' is the outermost visible container of the point-of-view
<a name="43"></a>     *   actor.  The headline is also conventionally shown on the status
<a name="44"></a>     *   line whenever the player is in the location.
<a name="45"></a>     *   
<a name="46"></a>     *   The room title essentially serves as a label for the room on the
<a name="47"></a>     *   player's mental and/or paper map of the game's geography.  It's
<a name="48"></a>     *   usually something short and pithy that sums up the room's essence,
<a name="49"></a>     *   function, or appearance, and is usually written in title case: Ice
<a name="50"></a>     *   Cave, Bank Lobby, Front of House, Transporter Room 3, etc.
<a name="51"></a>     *   
<a name="52"></a>     *   The room headline sometimes adds more status information to the
<a name="53"></a>     *   title, such as the point-of-view actor's direct container when the
<a name="54"></a>     *   actor is inside an intermediate container within the room, such as
<a name="55"></a>     *   a chair.  
<a name="56"></a>     */
<a name="57"></a>    roomTitle = nil
<a name="58"></a>
<a name="59"></a>    /*
<a name="60"></a>     *   The object's disambiguation name.  This is a more detailed version
<a name="61"></a>     *   of the name, for situations where the short name is ambiguous.
<a name="62"></a>     *   For example, the parser displays this name in "Which do you mean"
<a name="63"></a>     *   questions when it would help tell two of the listed objects apart.
<a name="64"></a>     *   
<a name="65"></a>     *   By default, this is the same as the short name.  It's uncommon to
<a name="66"></a>     *   override this, since short names are typically already detailed
<a name="67"></a>     *   enough for most purposes.  Every so often, though, you'll want to
<a name="68"></a>     *   keep the short name very terse, so you'll leave out some
<a name="69"></a>     *   distinguishing detail that it *could* have had.  In such cases,
<a name="70"></a>     *   you can add the distinguishing detail here, so that it's displayed
<a name="71"></a>     *   only when it's really needed.  
<a name="72"></a>     */
<a name="73"></a>    disambigName = (name)
<a name="74"></a>
<a name="75"></a>    /*
<a name="76"></a>     *   Disambiguation prompt grouping.  When the parser generates a
<a name="77"></a>     *   disambiguation question ("Which did you mean, the red book, or the blue
<a name="78"></a>     *   book?"), it'll group the objects in the list by common disambigGroup
<a name="79"></a>     *   values.  The group is just an arbitrary value that keeps like objects
<a name="80"></a>     *   together in the list.  You can use a string, a class, or whatever you
<a name="81"></a>     *   like for this, as long as grouped objects have the same value in
<a name="82"></a>     *   common. We give this property a default value of 0 so that the
<a name="83"></a>     *   disambigOrder will work by default without the need to specify a
<a name="84"></a>     *   disambigGroup.
<a name="85"></a>     */
<a name="86"></a>    disambigGroup = 0
<a name="87"></a>
<a name="88"></a>    /* 
<a name="89"></a>     *   Disambiguation prompt sorting.  This gives the display order of
<a name="90"></a>     *   this item within its disambiguation group, if it has one.  The
<a name="91"></a>     *   parser sorts objects within each group in ascending order of this
<a name="92"></a>     *   value when generating the object list for a disambiguation
<a name="93"></a>     *   question.  This is simply an integer; the default is 1 for every
<a name="94"></a>     *   object, which makes the ordering arbitrary.
<a name="95"></a>     *   
<a name="96"></a>     *   This property is useful for grouped objects with a natural
<a name="97"></a>     *   ordering, such as items with sequential labels of some sort
<a name="98"></a>     *   (numbers, letters, etc).  You can use this property to ensure that
<a name="99"></a>     *   lists of these items will be displayed in the natural order:
<a name="100"></a>     *   "button 1, button 2, or button 3?" or "the door on the left, the
<a name="101"></a>     *   door in the middle, or the door on the right?"  
<a name="102"></a>     */
<a name="103"></a>    disambigOrder = (listOrder)
<a name="104"></a>
<a name="105"></a>    /* 
<a name="106"></a>     *   Is this object's short name a proper name?  A proper name is the
<a name="107"></a>     *   name of a person, place, or other unique entity with its own name.
<a name="108"></a>     *   
<a name="109"></a>     *   This property controls how the library shows the object's name in
<a name="110"></a>     *   generated messages.  In English, for example, articles (a, the)
<a name="111"></a>     *   aren't used with a proper name.
<a name="112"></a>     *   
<a name="113"></a>     *   The English library tries to infer whether the object has a proper
<a name="114"></a>     *   name based on the 'vocab' string: if all the words in the short
<a name="115"></a>     *   name are capitalized, we'll consider it a proper name.  This rule
<a name="116"></a>     *   of thumb doesn't always apply, though, so you can override it:
<a name="117"></a>     *   simply set 'proper' explicitly in an individual object, and the
<a name="118"></a>     *   setting will take precedence over whatever the name's
<a name="119"></a>     *   capitalization would otherwise imply.  (Other languages might have
<a name="120"></a>     *   different rules for inferring 'proper', and some might not be able
<a name="121"></a>     *   to infer it at all.)  
<a name="122"></a>     */
<a name="123"></a>    proper = nil
<a name="124"></a>
<a name="125"></a>    /*
<a name="126"></a>     *   The object's name is "qualified" grammatically, meaning that it
<a name="127"></a>     *   can't be combined with articles (a, the) or possessives.  Proper
<a name="128"></a>     *   names are considered to be qualified, but it's possible for a name
<a name="129"></a>     *   to be qualified but not proper, such as a name that incorporates a
<a name="130"></a>     *   possessive.  
<a name="131"></a>     */
<a name="132"></a>    qualified = (proper)
<a name="133"></a>
<a name="134"></a>    /*
<a name="135"></a>     *   The grammatical person of narration relative to this object.  Use
<a name="136"></a>     *   1 for first person ("I am in a cave"), 2 for second person ("You
<a name="137"></a>     *   are in a cave"), and 3 for third person ("Bob is in a cave").
<a name="138"></a>     *   
<a name="139"></a>     *   Usually, every object in the game will be in the third person -
<a name="140"></a>     *   *except* the player character object, which is usually in the
<a name="141"></a>     *   second person.  The library doesn't care which person you use for
<a name="142"></a>     *   the player character, though - you're free to use first or third
<a name="143"></a>     *   person if you prefer.  First-person and third-person IF are
<a name="144"></a>     *   relatively uncommon, but not unheard of.
<a name="145"></a>     *   
<a name="146"></a>     *   This property is used for verb agreement when library messages are
<a name="147"></a>     *   generated.  This ensures that library messages adapt to the
<a name="148"></a>     *   correct narrative person of the story automatically.  To write a
<a name="149"></a>     *   first-person game, you don't have to replace all of the default
<a name="150"></a>     *   messages, but simply set person=1 in your PC object.
<a name="151"></a>     */
<a name="152"></a>    person = 3
<a name="153"></a>
<a name="154"></a>    /*
<a name="155"></a>     *   The object's grammatical gender(s).  This information is used to
<a name="156"></a>     *   determine which pronouns can match the object as an antecedent,
<a name="157"></a>     *   which pronouns should represent it in output, and (for some
<a name="158"></a>     *   languages) which articles and other gender-agreement words should
<a name="159"></a>     *   be used in conjunction with the object name in output.
<a name="160"></a>     *   
<a name="161"></a>     *   The default is neuter.  Use isHim and isHer to give an object
<a name="162"></a>     *   masculine and/or feminine gender.  Use isIt to explicitly give an
<a name="163"></a>     *   object neuter gender.  By default, we infer isIt from isHim and
<a name="164"></a>     *   isHer: we assume the object is neuter if it's not masculine or
<a name="165"></a>     *   feminine.
<a name="166"></a>     *   
<a name="167"></a>     *   Languages that have grammatical gender will almost certainly want
<a name="168"></a>     *   to parse articles in the 'vocab' property to make it more
<a name="169"></a>     *   convenient to encode each object's gender.  For example, a French
<a name="170"></a>     *   implementation could parse 'le' or 'la' at the start of a vocab
<a name="171"></a>     *   string and set isHim and isHer accordingly.
<a name="172"></a>     *   
<a name="173"></a>     *   The English library sets isHim and isHer if 'him' and 'her'
<a name="174"></a>     *   (respectively) are found in the object's pronoun list.  (This is
<a name="175"></a>     *   the most convenient way to represent gender via the vocab string
<a name="176"></a>     *   in English, since English doesn't have gendered articles.)
<a name="177"></a>     *   
<a name="178"></a>     *   Note that we define the genders as three separate properties, so
<a name="179"></a>     *   the genders are NOT mutually exclusive - an object can be a "him",
<a name="180"></a>     *   a "her", and an "it" at the same time.  This is because a single
<a name="181"></a>     *   object can have multiple grammatical genders in some languages.
<a name="182"></a>     *   In English, for example, an animal can be referred to as gendered
<a name="183"></a>     *   (matching its physical gender) or neuter; and a few inanimate
<a name="184"></a>     *   objects have a sort of optional, idiomatic gender, such as
<a name="185"></a>     *   referring to a ship or country as "her".  
<a name="186"></a>     *   
<a name="187"></a>     *   Some languages might need additional genders.  When needed,
<a name="188"></a>     *   LMentionable should simply define suitable additional properties.
<a name="189"></a>     *   
<a name="190"></a>     *   In most gendered languages, the grammatical gender is an attribute
<a name="191"></a>     *   of the noun, not of the object.  In particular, if an object has
<a name="192"></a>     *   two nouns in its vocabulary, the two nouns might be of different
<a name="193"></a>     *   genders.  The language module might therefore limit the use of
<a name="194"></a>     *   isIt et al to the gender of the object's name string as it appears
<a name="195"></a>     *   in output (e.g., for selecting an article when showing the name in
<a name="196"></a>     *   a list, or selecting a pronoun to represent the object), and use a
<a name="197"></a>     *   completely different scheme to tag the gender of individual
<a name="198"></a>     *   vocabulary words.  One approach would be to use separate mNoun and
<a name="199"></a>     *   fNoun token properties (and more if needed) to distinguish the
<a name="200"></a>     *   gender of individual nouns in the dictionary.  
<a name="201"></a>     */
<a name="202"></a>    isIt = (!(isHim || isHer))
<a name="203"></a>    isHim = nil
<a name="204"></a>    isHer = nil
<a name="205"></a>
<a name="206"></a>    /*
<a name="207"></a>     *   The object's name's grammatical number.  This specifies singular
<a name="208"></a>     *   or plural usage for the object's name when it appears in generated
<a name="209"></a>     *   messages.  By default, an object has singular usage, so it'll
<a name="210"></a>     *   appear as (for example) "an orange".  Some objects have names with
<a name="211"></a>     *   plural usage, either because they're words that always appear in
<a name="212"></a>     *   the plural (such as "scissors"), or because the game object
<a name="213"></a>     *   represents a group of items that are too numerous and unimportant
<a name="214"></a>     *   to the game to actually implement as separate Thing objects.  For
<a name="215"></a>     *   example, the books in a library might be implemented collectively
<a name="216"></a>     *   as a single "books" object.
<a name="217"></a>     *   
<a name="218"></a>     *   The English library sets this to true if 'them' is listed as a
<a name="219"></a>     *   pronoun for the object in the 'vocab' property.  
<a name="220"></a>     */
<a name="221"></a>    plural = nil
<a name="222"></a>    
<a name="223"></a>    /*   
<a name="224"></a>     *   Some objects, such as a pair of shoes or a flight of stairs could be
<a name="225"></a>     *   regarded as either singular or plural and referred to as either 'it' or
<a name="226"></a>     *   'them'. Set ambiguouslyPlural to true for such objects.
<a name="227"></a>     */
<a name="228"></a>    ambiguouslyPlural = nil
<a name="229"></a>
<a name="230"></a>    /*
<a name="231"></a>     *   The object's name is a mass noun.  A mass noun is a word that has
<a name="232"></a>     *   singular form but represents an indeterminate quantity or group of
<a name="233"></a>     *   something, such as "sand" or "furniture". 
<a name="234"></a>     *   
<a name="235"></a>     *   In English, mass nouns use "some" as the indefinite article rather
<a name="236"></a>     *   than "a" (some sand, not a sand).  Their plural usage tends to
<a name="237"></a>     *   differ from regular nouns, in that they already carry a sense of
<a name="238"></a>     *   plurality; if you have two distinct piles of sand, the two
<a name="239"></a>     *   together are usually still just "sand", not "two sands".
<a name="240"></a>     *   
<a name="241"></a>     *   When a mass noun is awkward as an object's name, you can often
<a name="242"></a>     *   make it into a regular noun by naming its overall form.  "Sand" is
<a name="243"></a>     *   a mass noun, but recasting it as "pile of sand" makes it an
<a name="244"></a>     *   ordinary noun.  (The generic way to do this for a homogeneous
<a name="245"></a>     *   substance is to add "quantity of".)  
<a name="246"></a>     */
<a name="247"></a>    massNoun = nil
<a name="248"></a>    
<a name="249"></a>    /*
<a name="250"></a>     *   My nominal contents is the special contents item we can use in
<a name="251"></a>     *   naming the object.  This is useful for containers whose identities
<a name="252"></a>     *   come primarily from their contents, such as a vessel for liquids
<a name="253"></a>     *   or a box of loose files.  Returns an object that qualifies the
<a name="254"></a>     *   name: a "water" object for BOX OF WATER, a "files" object for BOX
<a name="255"></a>     *   OF FILES.  Nil means that the object isn't named by its contents.
<a name="256"></a>     *   
<a name="257"></a>     *   Note that this is always a single object (or nil), not the whole
<a name="258"></a>     *   list of contents.  We can only be named by one content object.
<a name="259"></a>     *   (So you can't have a "box of books and papers" by having separate
<a name="260"></a>     *   nominal contents objects for the books and the papers; although
<a name="261"></a>     *   you could fake it by creating a "books and papers" object.)  
<a name="262"></a>     */
<a name="263"></a>    nominalContents = nil
<a name="264"></a>
<a name="265"></a>    /* 
<a name="266"></a>     *   Can I be distinguished in parser messages by my contents?  If so,
<a name="267"></a>     *   we can be distinguished (in parser messages) from similar objects
<a name="268"></a>     *   by our contents, or lack thereof: "bucket of water" vs "empty
<a name="269"></a>     *   bucket".  If this is true, our nominalContents property determines
<a name="270"></a>     *   the contents we display for this.  
<a name="271"></a>     */
<a name="272"></a>    distinguishByContents = nil
<a name="273"></a>
<a name="274"></a>    /*
<a name="275"></a>     *   Match the object to a noun phrase in the player's input.  If the given
<a name="276"></a>     *   token list is a valid name for this object, we return a combination of
<a name="277"></a>     *   MatchXxx flag values describing the match.  If the token list isn't a
<a name="278"></a>     *   valid name for this object, we return 0.
<a name="279"></a>     *
<a name="280"></a>     *   By default, we call simpleMatchName(), which matches the name if all of
<a name="281"></a>     *   the words in the token list are in the object's vocabulary list,
<a name="282"></a>     *   regardless of word order.
<a name="283"></a>     *
<a name="284"></a>     *   In most cases, an unordered word match works just fine.  The obvious
<a name="285"></a>     *   drawback with this approach is that it's far too generous at matching
<a name="286"></a>     *   nonsense phrases to object names - DUSTY OLD SPELL BOOK and BOOK DUSTY
<a name="287"></a>     *   SPELL OLD are treated the same.  In most cases, users won't enter
<a name="288"></a>     *   nonsense phrases like that anyway, so they'll probably never notice
<a name="289"></a>     *   that we accept them.  If they enter something like that intentionally,
<a name="290"></a>     *   we can plead Garbage In/Garbage Out: a user who willfully types a
<a name="291"></a>     *   nonsense command has only himself to blame for a nonsense reply.
<a name="292"></a>     *
<a name="293"></a>     *   Occasionally, though, there are reasons to be pickier.  When these come
<a name="294"></a>     *   up, you can override matchName() to be as picky as you like.
<a name="295"></a>     *
<a name="296"></a>     *   The most common situation where pickiness is called for is when two
<a name="297"></a>     *   objects happen to share some of the same vocabulary words, but certain
<a name="298"></a>     *   words orderings clearly refer to only one or the other. With the
<a name="299"></a>     *   unordered approach, this can be a nuisance for the player because it
<a name="300"></a>     *   can trigger disambiguation questions that seem unnecessary.  Overriding
<a name="301"></a>     *   matchName() to be picky about word order for those specific objects can
<a name="302"></a>     *   often fix this. In this implementation the matchPhrases property can be
<a name="303"></a>     *   used for this purpose.
<a name="304"></a>     *
<a name="305"></a>     *   Another example is ensuring the user knows the correct full name of an
<a name="306"></a>     *   object as part of a puzzle: you can override matchName() to make sure
<a name="307"></a>     *   the user doesn't accidentally stumble on the object by using one of its
<a name="308"></a>     *   vocabulary words to refer to something else nearby.  Another example is
<a name="309"></a>     *   matching words that aren't in the vocabulary list, such as a game
<a name="310"></a>     *   object that represents a group of apparent objects that have a whole
<a name="311"></a>     *   range of labels ("post office box 123", say).
<a name="312"></a>     */
<a name="313"></a>    matchName(tokens)
<a name="314"></a>    {        
<a name="315"></a>        return matchNameCommon(tokens, matchPhrases, matchPhrasesExclude);      
<a name="316"></a>    }
<a name="317"></a>    
<a name="318"></a>    /* 
<a name="319"></a>     *   Match a name against a list of tokens entered by the player. phrases is
<a name="320"></a>     *   the list of match phrases defined on the object (either for initial
<a name="321"></a>     *   matching or for disambiguation) and excludes should be true or nil
<a name="322"></a>     *   depending on whether failure to match phrases should exclude a match
<a name="323"></a>     *   overall.
<a name="324"></a>     */    
<a name="325"></a>    matchNameCommon(tokens, phrases, excludes)
<a name="326"></a>    {
<a name="327"></a>        /* 
<a name="328"></a>         *   If an item is hidden, the player character either shouldn't know of
<a name="329"></a>         *   its existence, or at least shouldn't be able to interact with it,
<a name="330"></a>         *   so it shouldn't match any vocab.
<a name="331"></a>         */
<a name="332"></a>        if(isHidden &amp;&amp; !gCommand.action.unhides)
<a name="333"></a>            return 0;
<a name="334"></a>        
<a name="335"></a>        /* 
<a name="336"></a>         *   First try the phrase-match matcher; if this fails return 0 to
<a name="337"></a>         *   indicate that we don't match. If it succeeds in matching a phrase
<a name="338"></a>         *   of more than one word, return MatchPhrase (we found a match).
<a name="339"></a>         */        
<a name="340"></a>        local phraseMatch = 0;
<a name="341"></a>        
<a name="342"></a>        /* 
<a name="343"></a>         *   We only need to test for phrase matching if there are any phrases
<a name="344"></a>         *   to match,
<a name="345"></a>         */
<a name="346"></a>        if(phrases != nil)
<a name="347"></a>        {    
<a name="348"></a>            /* See if our list of tokens matches any of our phrases. */           
<a name="349"></a>            phraseMatch = phraseMatchName(phrases, tokens);
<a name="350"></a>            
<a name="351"></a>            /* 
<a name="352"></a>             *   If there's a mismatch between our phrases and our tokens,
<a name="353"></a>             *   return 0 to indicate we don't have a match overall. A mismatch
<a name="354"></a>             *   only occurs if one or more of our tokens appears in one or more
<a name="355"></a>             *   of our phrases but there's no match between a phrase and the
<a name="356"></a>             *   succession of tokens.
<a name="357"></a>             */
<a name="358"></a>            if(phraseMatch is in (0, nil) &amp;&amp; excludes)    
<a name="359"></a>                return 0;
<a name="360"></a>            
<a name="361"></a>            /* 
<a name="362"></a>             *   A return type of true means there was no overlap between the
<a name="363"></a>             *   tokens and the matchPhrases, so the matchPhrases should have no
<a name="364"></a>             *   effect on the match.
<a name="365"></a>             */
<a name="366"></a>            if(dataType(phraseMatch) != TypeInt)
<a name="367"></a>                phraseMatch = 0;
<a name="368"></a>        }
<a name="369"></a>        
<a name="370"></a>        /* 
<a name="371"></a>         *   Now compute our simple match score (based on our individual tokens
<a name="372"></a>         *   without regard to their ordering or to their matching any phrases).
<a name="373"></a>         */
<a name="374"></a>        local simpleMatch = simpleMatchName(tokens);
<a name="375"></a>        
<a name="376"></a>        /* 
<a name="377"></a>         *   If the simpleMatchName routine fails to match anything, consider
<a name="378"></a>         *   the match a failure
<a name="379"></a>         */
<a name="380"></a>        if(simpleMatch == 0)
<a name="381"></a>            return 0;
<a name="382"></a>        
<a name="383"></a>        
<a name="384"></a>        /* 
<a name="385"></a>         *   Otherwise boost the simpleMatch score with the result of the phrase
<a name="386"></a>         *   match.
<a name="387"></a>         */
<a name="388"></a>        return phraseMatch | simpleMatch;
<a name="389"></a>    }
<a name="390"></a>    
<a name="391"></a>    
<a name="392"></a>
<a name="393"></a>    /*
<a name="394"></a>     *   Match the object to a noun phrase in *disambiguation* input.  This
<a name="395"></a>     *   checks words in the player's reply to a "Which one did you
<a name="396"></a>     *   mean...?" question from the parser.  When the player replies to
<a name="397"></a>     *   this kind of question, they usually don't respond with the full
<a name="398"></a>     *   name, but with just an adjective or two.
<a name="399"></a>     *   
<a name="400"></a>     *   Now, you might think we should handle these replies by just
<a name="401"></a>     *   appending them to the original noun phrase in the input.  But we
<a name="402"></a>     *   can't just do that: matchName() *could* care about the order of
<a name="403"></a>     *   the words in the noun phrase, so we can't just assume that we can
<a name="404"></a>     *   stick them in somewhere and still have a valid name for the
<a name="405"></a>     *   object.  So, instead of doing that, we call this routine with the
<a name="406"></a>     *   phrase from the player's answer to the "Which one" question.
<a name="407"></a>     *   Since this routine knows that the new words aren't part of the
<a name="408"></a>     *   original phrase, it can deal with them as it sees fit with respect
<a name="409"></a>     *   to word order.
<a name="410"></a>     *   
<a name="411"></a>     *   The default here, of course, is to do the same thing as the
<a name="412"></a>     *   default matchName(): we simply call simpleMatchName() to match the
<a name="413"></a>     *   input to the object vocabulary, ignoring word order.  This will
<a name="414"></a>     *   usually work even when matchName() is overridden to care about
<a name="415"></a>     *   word order, since the added words here are just serving to
<a name="416"></a>     *   distinguish one object from another.
<a name="417"></a>     */
<a name="418"></a>    matchNameDisambig(tokens)
<a name="419"></a>    {
<a name="420"></a>        
<a name="421"></a>        /* 
<a name="422"></a>         *   If disambigMatchPhrases is defined then we must match it
<a name="423"></a>         *   exclusively; i.e. a fail to match any relevant phrase must result
<a name="424"></a>         *   in a failure overall; otherwise we'll just keep getting the same
<a name="425"></a>         *   disambiguation question over and over.
<a name="426"></a>         */        
<a name="427"></a>        return matchNameCommon(tokens, disambigMatchPhrases, true);
<a name="428"></a>           
<a name="429"></a>    }
<a name="430"></a>   
<a name="431"></a>    /*
<a name="432"></a>     *   Simple implementation of matchName(), which simply checks to see
<a name="433"></a>     *   if all of the tokens are associated with the object.  The "simple"
<a name="434"></a>     *   aspect is that we don't pay any attention to the order of the
<a name="435"></a>     *   words - we simply check that they're all in the object's
<a name="436"></a>     *   vocabulary list, in any order.
<a name="437"></a>     */
<a name="438"></a>    simpleMatchName(tokens)
<a name="439"></a>    {
<a name="440"></a>        /* if the token list is empty, it's no match */
<a name="441"></a>        if (tokens.length() == 0)
<a name="442"></a>            return 0;
<a name="443"></a>        
<a name="444"></a>        /* we haven't found any strength demerits yet */
<a name="445"></a>        local strength = MatchNoTrunc | MatchNoApprox;
<a name="446"></a>
<a name="447"></a>        /* we haven't found any part-of-speech matches yet */
<a name="448"></a>        local partOfSpeech = 0;
<a name="449"></a>
<a name="450"></a>        /* remember the vocabulary word list and the string comparator */
<a name="451"></a>        local vw = vocabWords, cmp = Mentionable.dictComp;
<a name="452"></a>
<a name="453"></a>        /*
<a name="454"></a>         *   if we're distinguishable by contents, add either the
<a name="455"></a>         *   vocabulary for our contents object, if we have one, or the
<a name="456"></a>         *   special 'empty' vocabulary words 
<a name="457"></a>         */
<a name="458"></a>        if (distinguishByContents)
<a name="459"></a>        {
<a name="460"></a>            vw += nominalContents != nil
<a name="461"></a>                ? nominalContents.vocabWords : emptyVocabWords;
<a name="462"></a>        }
<a name="463"></a>
<a name="464"></a>        /* note the number of states we have */
<a name="465"></a>        local stateCnt = states.length();
<a name="466"></a>
<a name="467"></a>        /* scan the token list */
<a name="468"></a>        for (local i = 1, local len = tokens.length() ; i &lt;= len ; ++i)
<a name="469"></a>        {
<a name="470"></a>            /* get the word */
<a name="471"></a>            local tok = tokens[i];
<a name="472"></a>
<a name="473"></a>            /* match this word */
<a name="474"></a>            local match = matchToken(tok, vw, cmp);
<a name="475"></a>
<a name="476"></a>            /* 
<a name="477"></a>             *   if we didn't match it from our own vocabulary, try
<a name="478"></a>             *   matching it against any states we have 
<a name="479"></a>             */
<a name="480"></a>            if (match == 0)
<a name="481"></a>            {
<a name="482"></a>                /* try each state until we find a match or run out of states */
<a name="483"></a>                for (local j = 1 ; j &lt;= stateCnt ; ++j)
<a name="484"></a>                {
<a name="485"></a>                    /* try this state - stop searching if it matches */
<a name="486"></a>                    local state = states[j];
<a name="487"></a>                    if ((match = state.matchName(
<a name="488"></a>                        tok, self.(state.stateProp), cmp)) != 0)
<a name="489"></a>                        break;
<a name="490"></a>                }
<a name="491"></a>            }
<a name="492"></a>
<a name="493"></a>            /* 
<a name="494"></a>             *   if we didn't find a match for this token, the whole phrase
<a name="495"></a>             *   fails (even if we've already matched other tokens) 
<a name="496"></a>             */
<a name="497"></a>            if (match == 0)
<a name="498"></a>                return 0;
<a name="499"></a>
<a name="500"></a>            /* 
<a name="501"></a>             *   We found a match for this token, so combine it into the
<a name="502"></a>             *   running totals for the overall phrase.  The overall phrase
<a name="503"></a>             *   strength is the WEAKEST of the individual token strengths.
<a name="504"></a>             *   The overall phrase part-of-speech mix is the union of the
<a name="505"></a>             *   individual token part-of-speech matches. 
<a name="506"></a>             */
<a name="507"></a>            strength = min(strength, match &amp; MatchStrengthMask);
<a name="508"></a>            partOfSpeech |= match;
<a name="509"></a>        }
<a name="510"></a>
<a name="511"></a>        /* 
<a name="512"></a>         *   Omit prepositions from the results.  We don't want to reject
<a name="513"></a>         *   prepositions that are in our vocabulary, which is why we've
<a name="514"></a>         *   kept them in the results thus far, but we also don't want to
<a name="515"></a>         *   match the whole phrase on the strength of just a preposition -
<a name="516"></a>         *   "of" just isn't sufficiently specific to match "pile of
<a name="517"></a>         *   paper".  Also mask out the match-strength bits we've
<a name="518"></a>         *   accumulated, so that we can tell specifically which parts of
<a name="519"></a>         *   speech we've matched.  
<a name="520"></a>         */
<a name="521"></a>        partOfSpeech &amp;= MatchPartMask &amp; ~MatchPrep;
<a name="522"></a>
<a name="523"></a>        /* 
<a name="524"></a>         *   we need at least one actual part-of-speech match - if we
<a name="525"></a>         *   didn't find any, we must have had a string of nothing but
<a name="526"></a>         *   prepositions 
<a name="527"></a>         */
<a name="528"></a>        if (partOfSpeech == 0)
<a name="529"></a>            return 0;
<a name="530"></a>
<a name="531"></a>        /* return the overall results, combined into a single bit vector */
<a name="532"></a>        return strength | partOfSpeech;
<a name="533"></a>    }
<a name="534"></a>
<a name="535"></a>    
<a name="536"></a>    /* 
<a name="537"></a>     *   If we have any phraseMatches defined, check whether we fail to match
<a name="538"></a>     *   any of them. This will be the case if we find a phraseMatch containing
<a name="539"></a>     *   one of our tokens but not the rest in the right order.
<a name="540"></a>     */
<a name="541"></a>    phraseMatchName(phrases, tokens)
<a name="542"></a>    {
<a name="543"></a>        /* Start by assuming we won't find a mismatch */
<a name="544"></a>        local ok = true;
<a name="545"></a>        
<a name="546"></a>        /* Note the number of tokens to check */
<a name="547"></a>        local tokLen = tokens.length;
<a name="548"></a>        
<a name="549"></a>        /* Note the string comparator to use. */
<a name="550"></a>        local cmp = Mentionable.dictComp;
<a name="551"></a>        
<a name="552"></a>        /* 
<a name="553"></a>         *   Go through each phraseMatch in turn to see if the tokens either
<a name="554"></a>         *   fail to match it or succeed in matching it.
<a name="555"></a>         */
<a name="556"></a>        foreach(local pm in valToList(phrases))
<a name="557"></a>        {
<a name="558"></a>            /* Split the phraseMatch into a list of words */
<a name="559"></a>            local pmList = pm.split(' ');
<a name="560"></a>            
<a name="561"></a>            /* 
<a name="562"></a>             *   If the list of words from the phraseMatch contains no words in
<a name="563"></a>             *   common with the token list, there's nothing to test; but if it
<a name="564"></a>             *   does, we need to test it.
<a name="565"></a>             */
<a name="566"></a>            if(pmList.overlapsWith(tokens))
<a name="567"></a>            {
<a name="568"></a>                /* 
<a name="569"></a>                 *   See if we can find a list equivalent to the phraseMatch
<a name="570"></a>                 *   list as a sublist of the tokens list.
<a name="571"></a>                 */                
<a name="572"></a>                local pmLength = pmList.length();
<a name="573"></a>                for(local i in 1 .. tokLen - pmLength + 1)
<a name="574"></a>                {
<a name="575"></a>                    /* 
<a name="576"></a>                     *   If we can we've succeeded in finding a phrase match, so
<a name="577"></a>                     *   we can return true straight away.
<a name="578"></a>                     */
<a name="579"></a>                    if(tokens.sublist(i, pmLength).strComp(pmList, cmp))
<a name="580"></a>                    {
<a name="581"></a>                        return pmLength &gt; 1 ? MatchPhrase : MatchAdj;                            
<a name="582"></a>                    }                                            
<a name="583"></a>                }
<a name="584"></a>                /* 
<a name="585"></a>                 *   If we don't find a phrase match, note the failure, but
<a name="586"></a>                 *   there may be other phrases to try matching, so carry on
<a name="587"></a>                 *   looking.
<a name="588"></a>                 */
<a name="589"></a>                ok = 0;
<a name="590"></a>            }           
<a name="591"></a>        }
<a name="592"></a>        
<a name="593"></a>        /* Return the result */
<a name="594"></a>        return ok;
<a name="595"></a>    }
<a name="596"></a>    
<a name="597"></a>    
<a name="598"></a>    
<a name="599"></a>    /* 
<a name="600"></a>     *   A single-quoted string, or a list of single-quoted strings containing
<a name="601"></a>     *   exact phrases (i.e. sequences of words) that must be matched by the
<a name="602"></a>     *   player input if any of the words in the phrase matches appear in the
<a name="603"></a>     *   player input. Note that words defined here should also be defined in
<a name="604"></a>     *   the vocab property; the purpose of the matchPhrases property is to
<a name="605"></a>     *   limit matches. Note also that object will be matched if any of the
<a name="606"></a>     *   phrases in the list is matched.
<a name="607"></a>     */
<a name="608"></a>    matchPhrases = nil
<a name="609"></a>    
<a name="610"></a>    
<a name="611"></a>    /* 
<a name="612"></a>     *   Do we want to test for phrase matches when disambiguating? We'll assume
<a name="613"></a>     *   that by default we do since the same reasons for wanting the phrase
<a name="614"></a>     *   match are likely to apply when disambiguating, and that we'll use the
<a name="615"></a>     *   same set of phrases. This can be overridden to supply a different set
<a name="616"></a>     *   of phrases or none.
<a name="617"></a>     */
<a name="618"></a>    disambigMatchPhrases = matchPhrases
<a name="619"></a>        
<a name="620"></a>    
<a name="621"></a>    /*   
<a name="622"></a>     *   If failing to match any of the match phrases (when the player's input
<a name="623"></a>     *   includes at least one word used in any of them) excludes a match, then
<a name="624"></a>     *   return nil
<a name="625"></a>     */
<a name="626"></a>    matchPhrasesExclude = true
<a name="627"></a>   
<a name="628"></a>     
<a name="629"></a>    
<a name="630"></a>    /* 
<a name="631"></a>     *   On dynamically creating a new object, do the automatic vocabulary
<a name="632"></a>     *   and short name initialization.  
<a name="633"></a>     */
<a name="634"></a>    construct()
<a name="635"></a>    {
<a name="636"></a>        /* do the vocabulary initialization */
<a name="637"></a>        initVocab();
<a name="638"></a>
<a name="639"></a>        /* build the list of applicable states */
<a name="640"></a>        foreach (local s in State.all)
<a name="641"></a>        {
<a name="642"></a>            if (s.appliesTo(self))
<a name="643"></a>                states += s;
<a name="644"></a>        }
<a name="645"></a>    }
<a name="646"></a>
<a name="647"></a>    /*
<a name="648"></a>     *   Vocabulary word list.  This is a vector of VocabWord objects that
<a name="649"></a>     *   we build in initVocab(), giving the individual words that this
<a name="650"></a>     *   object uses for its noun phrase vocabulary.  
<a name="651"></a>     */
<a name="652"></a>    vocabWords = []
<a name="653"></a>
<a name="654"></a>    /* the State objects applying to this object */
<a name="655"></a>    states = []
<a name="656"></a>    
<a name="657"></a>    /*  
<a name="658"></a>     *   The filterResolveList method allows this object to remove itself or
<a name="659"></a>     *   other objects from the list of resolved objects.
<a name="660"></a>     *
<a name="661"></a>     *   np is the noun phrase, so np.matches gives the current list of matches,
<a name="662"></a>     *   and np.matches[i].obj gives the ith object match. To change the list of
<a name="663"></a>     *   matches, manipulate the np.matches list.
<a name="664"></a>     *
<a name="665"></a>     *   cmd is the command object, so that cmd.action gives the action about to
<a name="666"></a>     *   be executed.
<a name="667"></a>     *
<a name="668"></a>     *   mode is the match mode.
<a name="669"></a>     *
<a name="670"></a>     *   By default we do nothing here.
<a name="671"></a>     */
<a name="672"></a>    filterResolveList(np, cmd, mode) { }
<a name="673"></a>;
<a name="674"></a>
<a name="675"></a>/* ------------------------------------------------------------------------ */
<a name="676"></a>/*
<a name="677"></a> *   Match a token from the player's input against a given vocabulary list.
<a name="678"></a> *   Returns a set of MatchXxx flags for a match, or 0 if there's no match.
<a name="679"></a> *   
<a name="680"></a> *   'tok' is the token string to match.  'words' is the list of words to
<a name="681"></a> *   match, as VocabWords objects.  'cmp' is the StringComparator object
<a name="682"></a> *   that we use to compare the strings.  
<a name="683"></a> */
<a name="684"></a>matchToken(tok, words, cmp)
<a name="685"></a>{
<a name="686"></a>    /* we don't have a match for this token yet */
<a name="687"></a>    local strength = 0, partOfSpeech = 0;
<a name="688"></a>
<a name="689"></a>    /* try matching this token against our vocabulary list */
<a name="690"></a>    for (local len = words.length(), local i = 1 ; i &lt;= len ; ++i)
<a name="691"></a>    {
<a name="692"></a>        /* get this vocabulary word entry */
<a name="693"></a>        local entry = words[i];
<a name="694"></a>
<a name="695"></a>        /* check this token against the dictionary word */
<a name="696"></a>        local match = cmp.matchValues(tok, entry.wordStr);
<a name="697"></a>
<a name="698"></a>        /* if there's no match, keep looking */
<a name="699"></a>        if (match == 0)
<a name="700"></a>            continue;
<a name="701"></a>
<a name="702"></a>        /* 
<a name="703"></a>         *   Figure the result flags for this match.  Note that any
<a name="704"></a>         *   bits in the String Comparator match value above 0x80
<a name="705"></a>         *   are character approximation flags. 
<a name="706"></a>         */
<a name="707"></a>        local result =
<a name="708"></a>            (match &amp; StrCompTrunc ? 0 : MatchNoTrunc)
<a name="709"></a>            | (match &amp; ~0xFF ? 0 : MatchNoApprox);
<a name="710"></a>
<a name="711"></a>        /* 
<a name="712"></a>         *   Check the required match-strength flags to see if this
<a name="713"></a>         *   match is allowed.  If a MatchNoXxx flag is set in the
<a name="714"></a>         *   required flags in the dictionary entry, it means that
<a name="715"></a>         *   the match itself MUST have that flag.  So, if a flag
<a name="716"></a>         *   is set in the dictionary, and it's not set in the
<a name="717"></a>         *   result, reject this match.  
<a name="718"></a>         */
<a name="719"></a>        if (entry.strengthFlags &amp; ~result)
<a name="720"></a>            continue;
<a name="721"></a>
<a name="722"></a>        /*
<a name="723"></a>         *   Okay, it's a match.  There are three possibilities for how
<a name="724"></a>         *   it relates to other matches we've already found:
<a name="725"></a>         *   
<a name="726"></a>         *   - It's stronger, meaning that it's not truncated while the
<a name="727"></a>         *   earlier match was, or not approximated while the earlier
<a name="728"></a>         *   match was.  We only want to keep the strongest matche(es),
<a name="729"></a>         *   so if we have a prior match, forget it.
<a name="730"></a>         *   
<a name="731"></a>         *   - It's equally strong.  We might have found another
<a name="732"></a>         *   part-of-speech usage for the word at the same match
<a name="733"></a>         *   strength.  Combine the part-of-speech flags into the
<a name="734"></a>         *   running total.
<a name="735"></a>         *   
<a name="736"></a>         *   - It's weaker.  We only want to keep the best matches, so
<a name="737"></a>         *   reject this one.  
<a name="738"></a>         */
<a name="739"></a>        if (result &gt; strength)
<a name="740"></a>        {
<a name="741"></a>            /* it's stronger - replace any past match with this one */
<a name="742"></a>            strength = result;
<a name="743"></a>            partOfSpeech = entry.posFlags;
<a name="744"></a>        }
<a name="745"></a>        else if (result == strength)
<a name="746"></a>        {
<a name="747"></a>            /* equally strong - add this entry's part of speech */
<a name="748"></a>            partOfSpeech |= entry.posFlags;
<a name="749"></a>        }
<a name="750"></a>    }
<a name="751"></a>
<a name="752"></a>    /* return the combined MatchXxx flags */
<a name="753"></a>    return strength | partOfSpeech;
<a name="754"></a>}
<a name="755"></a>
<a name="756"></a>
<a name="757"></a>/* ------------------------------------------------------------------------ */
<a name="758"></a>/*
<a name="759"></a> *   A VocabWord is an entry in a Mentionable object's list of noun phrase
<a name="760"></a> *   words. 
<a name="761"></a> */
<a name="762"></a>class VocabWord: object
<a name="763"></a>    construct(w, f)
<a name="764"></a>    {
<a name="765"></a>        /* remember the word string */
<a name="766"></a>        wordStr = w;
<a name="767"></a>
<a name="768"></a>        /* separate out the part-of-speech and match-strength flags */
<a name="769"></a>        posFlags = f &amp; MatchPartMask;
<a name="770"></a>        strengthFlags = f &amp; MatchStrengthMask;
<a name="771"></a>    }
<a name="772"></a>
<a name="773"></a>    /* the word string (the text of this vocabulary word) */
<a name="774"></a>    wordStr = nil
<a name="775"></a>
<a name="776"></a>    /* the part-of-speech flags (MatchNoun, etc) */
<a name="777"></a>    posFlags = 0
<a name="778"></a>
<a name="779"></a>    /* the required match strength flags (MatchNoTrunc, MatchNoApprox) */
<a name="780"></a>    strengthFlags = 0
<a name="781"></a>;
<a name="782"></a>
<a name="783"></a>
<a name="784"></a>/* ------------------------------------------------------------------------ */
<a name="785"></a>/*
<a name="786"></a> *   A State represents a changeable condition of a Mentionable that can be
<a name="787"></a> *   used as part of the object's name in command input.  For example, a
<a name="788"></a> *   state could be used to represent whether a match is lit or unlit: the
<a name="789"></a> *   words 'lit' and 'unlit' could then be used to describe the object,
<a name="790"></a> *   according to its current condition.
<a name="791"></a> *   
<a name="792"></a> *   The actual current condition of a given object is given by a property
<a name="793"></a> *   of the Mentionable, which we define as part of the State object.  So
<a name="794"></a> *   testing whether an object is lit or unlit is just a matter of checking
<a name="795"></a> *   the corresponding property of the object.
<a name="796"></a> *   
<a name="797"></a> *   The parser considers an object to have the state, for parsing
<a name="798"></a> *   purposes, if the object defines any value for the state property.
<a name="799"></a> *   
<a name="800"></a> *   Most of the State object's definition is its vocabulary, which is
<a name="801"></a> *   obviously language-specific.  We therefore leave it to the language
<a name="802"></a> *   modules to define the individual State instances.  Games can also add
<a name="803"></a> *   new states as needed, of course.  
<a name="804"></a> */
<a name="805"></a>class State: LState
<a name="806"></a>    /*
<a name="807"></a>     *   The Mentionable property that indicates the current condition of
<a name="808"></a>     *   an object that has this State.  The range of values that this
<a name="809"></a>     *   property takes on in the Mentionable is up to the State to define.
<a name="810"></a>     *   For some states, this will be a simple boolean: Lit/Unlit,
<a name="811"></a>     *   Open/Closed, On/Off, etc.  For others, this might be an integer
<a name="812"></a>     *   range or a set of string values.
<a name="813"></a>     */
<a name="814"></a>    stateProp = nil
<a name="815"></a>
<a name="816"></a>    /*
<a name="817"></a>     *   Does this state apply to the given object?  By default, we
<a name="818"></a>     *   consider any object that defines the state property to exhibit the
<a name="819"></a>     *   state.  
<a name="820"></a>     */
<a name="821"></a>    appliesTo(obj) { return obj.propDefined(stateProp); }
<a name="822"></a>
<a name="823"></a>    /*
<a name="824"></a>     *   Match a token from the object name for the given state value.
<a name="825"></a>     *   Mentionable.matchName() calls this to see if a token applies
<a name="826"></a>     *   because of the object's current conditdion.  'tok' is the token
<a name="827"></a>     *   string; 'state' is the object's value for the state property; and
<a name="828"></a>     *   'cmp' is the string comparator to use for the string comparisons.
<a name="829"></a>     *   Returns a combination of MatchXxx flags, or zero if the token
<a name="830"></a>     *   doesn't match the current condition.
<a name="831"></a>     *   
<a name="832"></a>     *   For example, a Lit/Unlit state would return MatchAdj for 'lit' if
<a name="833"></a>     *   'state' is true, 0 otherwise.  
<a name="834"></a>     */
<a name="835"></a>    matchName(tok, state, cmp)
<a name="836"></a>    {
<a name="837"></a>        /* get the vocabulary for the state; if none, there's no match */
<a name="838"></a>        local v = getVocab(state);
<a name="839"></a>        if (v == nil)
<a name="840"></a>            return 0;
<a name="841"></a>
<a name="842"></a>        /* compare the token against the list for the current state */
<a name="843"></a>        return matchToken(tok, v, cmp);
<a name="844"></a>    }
<a name="845"></a>
<a name="846"></a>    /*
<a name="847"></a>     *   Get the vocabulary words that apply to the given state.  For
<a name="848"></a>     *   example, a Lit/Unlit object might return 'lit' if state is true
<a name="849"></a>     *   and 'unlit' if state is nil.  
<a name="850"></a>     */
<a name="851"></a>    getVocab(state)
<a name="852"></a>    {
<a name="853"></a>        /* return the list for this state */
<a name="854"></a>        return vocabTab[state];
<a name="855"></a>    }
<a name="856"></a>
<a name="857"></a>    /* state vocabulary lookup table (built automatically during preinit) */
<a name="858"></a>    vocabTab = nil
<a name="859"></a>
<a name="860"></a>    /*
<a name="861"></a>     *   State/adjective initializer list.
<a name="862"></a>     *   
<a name="863"></a>     *   States are generally represented in names by adjectives added to
<a name="864"></a>     *   the object name, both in displaying output and in parsing input.
<a name="865"></a>     *   For example, a Lit/Unlit state would add 'lit' in the lit state
<a name="866"></a>     *   and 'unlit' in the unlit state.  So we provide an easy way of
<a name="867"></a>     *   initializing a state object: just list the states and their
<a name="868"></a>     *   corresponding adjectives.
<a name="869"></a>     *   
<a name="870"></a>     *   Make one entry in this list for each possible state; the entry is
<a name="871"></a>     *   a list, [stateval, [adjectives]], where 'stateval' is the state
<a name="872"></a>     *   variable value, and [adjectives] is a list of strings giving the
<a name="873"></a>     *   corresponding adjectives.  The first adjective in the list is the
<a name="874"></a>     *   display adjective - this is the one that addToName() will use to
<a name="875"></a>     *   generate an object name for display.  The rest are used to parse
<a name="876"></a>     *   input; they'll all be matched to the state.  
<a name="877"></a>     */
<a name="878"></a>    adjectives = []
<a name="879"></a>
<a name="880"></a>    /* 
<a name="881"></a>     *   *Full* vocabulary initializer list.  If the 'adjectives' list
<a name="882"></a>     *   isn't sufficiently flexible for your needs, you can use this
<a name="883"></a>     *   initializer list instead.  This consists of a list of sublist
<a name="884"></a>     *   entries, [stateval, word, flags].  'stateval' is a state value,
<a name="885"></a>     *   'word' is a string giving a vocabulary word to match, and 'flags'
<a name="886"></a>     *   is a combination of MatchXxx flags for the word.
<a name="887"></a>     *   
<a name="888"></a>     *.     [[nil, 'unlit', MatchAdj],
<a name="889"></a>     *.      [true, 'lit', MatchAdj]]
<a name="890"></a>     */
<a name="891"></a>    vocabWords = []
<a name="892"></a>
<a name="893"></a>    /* class property: master list of all State objects */
<a name="894"></a>    all = []
<a name="895"></a>
<a name="896"></a>    /* construction */
<a name="897"></a>    construct()
<a name="898"></a>    {
<a name="899"></a>        /* create the vocabulary table */
<a name="900"></a>        local tab = vocabTab = new LookupTable(8, 16);
<a name="901"></a>
<a name="902"></a>        /* do the inherited work */
<a name="903"></a>        inherited();
<a name="904"></a>
<a name="905"></a>        /* load the vocabulary table from the adjectives list, if present */
<a name="906"></a>        foreach (local a in adjectives)
<a name="907"></a>        {
<a name="908"></a>            /* make sure there's a list for this state */
<a name="909"></a>            local st = a[1];
<a name="910"></a>            if (tab[st] == nil)
<a name="911"></a>                tab[st] = [];
<a name="912"></a>
<a name="913"></a>            /* add a VocabWord for each adjective for this state */
<a name="914"></a>            foreach (local adj in a[2])
<a name="915"></a>            {
<a name="916"></a>                initWord(adj);
<a name="917"></a>                tab[st] += new VocabWord(adj, MatchAdj);
<a name="918"></a>            }
<a name="919"></a>        }
<a name="920"></a>
<a name="921"></a>        /* load the vocabulary table from the vocabWords list, if present */
<a name="922"></a>        foreach (local w in vocabWords)
<a name="923"></a>        {
<a name="924"></a>            /* 
<a name="925"></a>             *   create an empty list for the state if this is the first
<a name="926"></a>             *   word we've seen for this state 
<a name="927"></a>             */
<a name="928"></a>            local st = w[1];
<a name="929"></a>            if (tab[st] == nil)
<a name="930"></a>                tab[st] = [];
<a name="931"></a>
<a name="932"></a>            /* add a VocabWord for this word to the state list */
<a name="933"></a>            initWord(w[2]);
<a name="934"></a>            tab[st] += new VocabWord(w[2], w[3]);
<a name="935"></a>        }
<a name="936"></a>    }
<a name="937"></a>
<a name="938"></a>    /* class initialization */
<a name="939"></a>    classInit()
<a name="940"></a>    {
<a name="941"></a>        /* build the master list of State objects */
<a name="942"></a>        forEachInstance(State, { s: State.all += s });
<a name="943"></a>    }
<a name="944"></a>;
<a name="945"></a>
<a name="946"></a>/*  
<a name="947"></a> *   A ReplaceRedirector is a Redirector that uses replaceAction (or its
<a name="948"></a> *   execNestedAction equivalent) to redirect one action to another.
<a name="949"></a> */
<a name="950"></a>class ReplaceRedirector: Redirector
<a name="951"></a>    
<a name="952"></a>    /* 
<a name="953"></a>     *   User code should normally call this method via doInstead rather than
<a name="954"></a>     *   directly. cmd is the current command object, altAction is the action we
<a name="955"></a>     *   want to perform instead of the current action, dobj and iobj are the
<a name="956"></a>     *   direct and indirect objects of the new action, and isReplacement
<a name="957"></a>     *   determines whether the new action replaces the original one (if true)
<a name="958"></a>     *   or merely takes place during the execution of the original one, which
<a name="959"></a>     *   then resumes when the new action is complete (if isReplacement is nil).
<a name="960"></a>     */    
<a name="961"></a>    redirect(cmd, altAction, dobj:?, iobj:?, aobj:?, isReplacement: = true)
<a name="962"></a>    {
<a name="963"></a>        if(iobj != nil &amp;&amp; dobj != nil &amp;&amp; aobj != nil)
<a name="964"></a>            execNestedAction(isReplacement, gActor, altAction, dobj, iobj, aobj); 
<a name="965"></a>        else if(iobj != nil &amp;&amp; dobj != nil)    
<a name="966"></a>            execNestedAction(isReplacement, gActor, altAction, dobj, iobj);
<a name="967"></a>        else if(dobj != nil)
<a name="968"></a>            execNestedAction(isReplacement, gActor, altAction, dobj);
<a name="969"></a>        else
<a name="970"></a>            execNestedAction(isReplacement, gActor, altAction);
<a name="971"></a>    }
<a name="972"></a>;
<a name="973"></a>
<a name="974"></a>/* 
<a name="975"></a> *   Thing is the base class for all game objects that represent physical
<a name="976"></a> *   objects which can be interacted with in the game world. All such physical
<a name="977"></a> *   objects are either Things or based on a subclass of Thing.
<a name="978"></a> */
<a name="979"></a>class Thing:  ReplaceRedirector, Mentionable
<a name="980"></a>   
<a name="981"></a>    
<a name="982"></a>    /* 
<a name="983"></a>     *   Most of the following properties and methods down to the next dashed
<a name="984"></a>     *   line are usually only relevant on Room, but they have been moved to
<a name="985"></a>     *   Thing in case the player char finds itself in a closed Booth.
<a name="986"></a>     */
<a name="987"></a>    
<a name="988"></a>    /*   
<a name="989"></a>     *   The title of this room to be displayed at the start of a room
<a name="990"></a>     *   description, or in the status line.
<a name="991"></a>     */
<a name="992"></a>    roomHeadline(pov)
<a name="993"></a>    {
<a name="994"></a>        /* 
<a name="995"></a>         *   start with the room title; if this room is illuminated use the
<a name="996"></a>         *   standard roomTitle, otherwise use our darkName. 
<a name="997"></a>         */
<a name="998"></a>        say(isIlluminated ? roomTitle : darkName);
<a name="999"></a>
<a name="1000"></a>        /* if the actor is in an intermediate container, add the container */
<a name="1001"></a>        if (pov.location not in (self, nil))
<a name="1002"></a>            pov.location.roomSubhead(pov);
<a name="1003"></a>    }
<a name="1004"></a>    
<a name="1005"></a>    /* 
<a name="1006"></a>     *   Can the player character recognize this room (enough to know its name
<a name="1007"></a>     *   and have a rough idea of its location) in the dark? (If so then looking
<a name="1008"></a>     *   around in this room in the dark makes it visited and familiar,
<a name="1009"></a>     *   otherwise it doesn't).
<a name="1010"></a>     */
<a name="1011"></a>    recognizableInDark = nil
<a name="1012"></a>    
<a name="1013"></a>    /* The name to display at the head of a room description */
<a name="1014"></a>    roomTitle = name
<a name="1015"></a>    
<a name="1016"></a>    /* The name to display at the head of a room description when it's dark */
<a name="1017"></a>    darkName =  BMsg(dark name, 'In the dark')
<a name="1018"></a>    
<a name="1019"></a>    /* The description of the room when it's dark */
<a name="1020"></a>    darkDesc() 
<a name="1021"></a>    { 
<a name="1022"></a>        DMsg(dark desc, 'It{dummy} {is} pitch black; {i} {can\'t} see a thing.
<a name="1023"></a>            '); 
<a name="1024"></a>    }
<a name="1025"></a>    
<a name="1026"></a>    /*
<a name="1027"></a>     *   The "inside" description.  This is displayed when an actor LOOKS AROUND
<a name="1028"></a>     *   from within this object.  Note that this applies not only to top-level
<a name="1029"></a>     *   rooms but also to things like chairs, platforms, and booths that can
<a name="1030"></a>     *   contain an actor.  By default, we simply show the ordinary EXAMINE
<a name="1031"></a>     *   description (or the darkDesc if there's no illumination).  Non-room
<a name="1032"></a>     *   containers such as chairs or booths should usually override this to
<a name="1033"></a>     *   provide the view from inside the object, which usually differs from the
<a name="1034"></a>     *   ordinary EXAMINE description.  For a top-level room, you don't usually
<a name="1035"></a>     *   override this, since the only description needed for a room is normally
<a name="1036"></a>     *   the LOOK AROUND perspective.
<a name="1037"></a>     */    
<a name="1038"></a>    interiorDesc = (desc)
<a name="1039"></a>
<a name="1040"></a>    /*  
<a name="1041"></a>     *   If we're a room, are we illuminated (is there enough light for an actor
<a name="1042"></a>     *   within us to see by)?
<a name="1043"></a>     */
<a name="1044"></a>    isIlluminated()
<a name="1045"></a>    {
<a name="1046"></a>        /* 
<a name="1047"></a>         *   If the room itself is lit, then it's self-illuminating and we don't
<a name="1048"></a>         *   need to check anything else.
<a name="1049"></a>         */        
<a name="1050"></a>        if(isLit)
<a name="1051"></a>            return true;
<a name="1052"></a>            
<a name="1053"></a>        /* 
<a name="1054"></a>         *   Otherwise we need to see if there's anything visible in the room's
<a name="1055"></a>         *   contents that's lit.
<a name="1056"></a>         */        
<a name="1057"></a>        return isThereALightSourceIn(contents);
<a name="1058"></a>    }
<a name="1059"></a>    
<a name="1060"></a>    /* 
<a name="1061"></a>     *   Determine (recursively) whether lst contains a light source; i.e.
<a name="1062"></a>     *   whether any of the items within list is lit or whether any of the
<a name="1063"></a>     *   visible contents of any of the items in lst it lit.
<a name="1064"></a>     */
<a name="1065"></a>    isThereALightSourceIn(lst)
<a name="1066"></a>    {
<a name="1067"></a>        foreach(local obj in lst)
<a name="1068"></a>        {
<a name="1069"></a>            /* If we find an object that's lit, return true. */
<a name="1070"></a>            if(obj.isLit)
<a name="1071"></a>                return true;
<a name="1072"></a>            
<a name="1073"></a>            /* 
<a name="1074"></a>             *   If we have any contents and our contents are visible from
<a name="1075"></a>             *   outside us, return true if there's a light source among our
<a name="1076"></a>             *   contents.
<a name="1077"></a>             */
<a name="1078"></a>            if(obj.contents.length &gt; 0 
<a name="1079"></a>               &amp;&amp; (obj.isOpen || obj.contType != In || obj.isTransparent)
<a name="1080"></a>               &amp;&amp; isThereALightSourceIn(obj.contents))
<a name="1081"></a>                return true;                      
<a name="1082"></a>            
<a name="1083"></a>        }
<a name="1084"></a>        
<a name="1085"></a>        /* If we get this far we haven't found a light source. */        
<a name="1086"></a>        return nil;
<a name="1087"></a>    }
<a name="1088"></a>    
<a name="1089"></a>    /* 
<a name="1090"></a>     *   The contents lister to use for listing this room's miscellaneous
<a name="1091"></a>     *   contents. By default we use the standard lookLister but this can be
<a name="1092"></a>     *   overridden to use a CustomRoomLister (say) to provide just about any
<a name="1093"></a>     *   wording we like.
<a name="1094"></a>     */
<a name="1095"></a>    roomContentsLister = lookLister
<a name="1096"></a>    
<a name="1097"></a>    /* 
<a name="1098"></a>     *   The contents lister to use for listing this room's miscellaneous
<a name="1099"></a>     *   subcontents. By default we use the standard lookContentsLister but this
<a name="1100"></a>     *   can be overridden.
<a name="1101"></a>     */
<a name="1102"></a>    roomSubContentsLister = lookContentsLister
<a name="1103"></a>    
<a name="1104"></a>    /* 
<a name="1105"></a>     *   Look around within this Thing (Room or Booth) to provide a full
<a name="1106"></a>     *   description of this location as seen from within, including our
<a name="1107"></a>     *   headline name, our internal description, and a listing of our visible
<a name="1108"></a>     *   contents.
<a name="1109"></a>     */
<a name="1110"></a>    lookAroundWithin()
<a name="1111"></a>    {
<a name="1112"></a>         /* Reset everything in the room to not mentioned. */
<a name="1113"></a>        unmention(contents);
<a name="1114"></a>        
<a name="1115"></a>        /* Reset everything in any remote rooms we're connected to */        
<a name="1116"></a>        unmentionRemoteContents();
<a name="1117"></a>        
<a name="1118"></a>        /* Begin by displaying our name */
<a name="1119"></a>        "&lt;.roomname&gt;&lt;&lt;roomHeadline(gPlayerChar)&gt;&gt;&lt;./roomname&gt;\n";
<a name="1120"></a>        
<a name="1121"></a>        /* If we're illuminate show our description and list our contents. */
<a name="1122"></a>        if(isIlluminated)
<a name="1123"></a>        {
<a name="1124"></a>            /* Display our interior description. */
<a name="1125"></a>            if(gameMain.verbose || !visited || gActionIs(Look))
<a name="1126"></a>                "&lt;.roomdesc&gt;&lt;&lt;interiorDesc&gt;&gt;&lt;./roomdesc&gt;&lt;.p&gt;";
<a name="1127"></a>            
<a name="1128"></a>            /* List our contents. */
<a name="1129"></a>            "&lt;.roomcontents&gt;";
<a name="1130"></a>            listContents();
<a name="1131"></a>            "&lt;./roomcontents&gt;";
<a name="1132"></a>            
<a name="1133"></a>            /* Note that we've been seen, examined and visited. */
<a name="1134"></a>            setSeen();
<a name="1135"></a>            visited = true;
<a name="1136"></a>            examined = true;
<a name="1137"></a>        }
<a name="1138"></a>        
<a name="1139"></a>        /* 
<a name="1140"></a>         *   Otherwise, if there's not enough light to see by, just show our
<a name="1141"></a>         *   dark description.
<a name="1142"></a>         */
<a name="1143"></a>        else
<a name="1144"></a>        {
<a name="1145"></a>            /* Display the darkDesc */
<a name="1146"></a>            "&lt;.roomdesc&gt;&lt;&lt;darkDesc&gt;&gt;&lt;./roomdesc&gt;";
<a name="1147"></a>            
<a name="1148"></a>            /* 
<a name="1149"></a>             *   If this location is recognizable to the player character in the
<a name="1150"></a>             *   dark despite the poor lighting (for example, the PC knows it's
<a name="1151"></a>             *   a cellar because s/he's just descended a flight of steps that
<a name="1152"></a>             *   clearly lead to a cellar), note that we've been visited and
<a name="1153"></a>             *   that we're now known about (the pc knows of our existence).
<a name="1154"></a>             */
<a name="1155"></a>            if(recognizableInDark)
<a name="1156"></a>            {
<a name="1157"></a>                visited = true;
<a name="1158"></a>                setKnown();
<a name="1159"></a>            }
<a name="1160"></a>        
<a name="1161"></a>        }
<a name="1162"></a>        "&lt;.p&gt;";
<a name="1163"></a>        
<a name="1164"></a>        /* If the game includes an exit lister, list our exits. */        
<a name="1165"></a>        if(gExitLister != nil)
<a name="1166"></a>            gExitLister.lookAroundShowExits(gActor, self, isIlluminated);
<a name="1167"></a>    }
<a name="1168"></a>    
<a name="1169"></a>    /* List the contents of this object using lister. */
<a name="1170"></a>    listContents(lister = &amp;roomContentsLister)
<a name="1171"></a>    {    
<a name="1172"></a>        
<a name="1173"></a>        /* Don't list the contents if we can't see in */
<a name="1174"></a>        if(!canSeeIn())
<a name="1175"></a>            return;
<a name="1176"></a>        
<a name="1177"></a>        /* 
<a name="1178"></a>         *   Set up a variable to contain the list of objects with specialDescs
<a name="1179"></a>         *   to be shown before the list of miscellaneous contents.
<a name="1180"></a>         */
<a name="1181"></a>        local firstSpecialList = [];
<a name="1182"></a>        
<a name="1183"></a>        /* Set up a variable to contain of list of miscellaneous contents. */
<a name="1184"></a>        local miscContentsList = [];
<a name="1185"></a>        
<a name="1186"></a>        /* 
<a name="1187"></a>         *   Set up a variable to contain the list of objects with specialDescs
<a name="1188"></a>         *   to be shown after the list of miscellaneous contents.
<a name="1189"></a>         */
<a name="1190"></a>        local secondSpecialList = [];
<a name="1191"></a>          
<a name="1192"></a>        /* 
<a name="1193"></a>         *   First mention the actor's immediate container, if it isn't the
<a name="1194"></a>         *   object we're looking around within. Then list the oontainer's
<a name="1195"></a>         *   contents immediately after.
<a name="1196"></a>         */        
<a name="1197"></a>        local loc = gActor.location;                
<a name="1198"></a>        
<a name="1199"></a>        /* 
<a name="1200"></a>         *   If we're not the pc's immediate container and we're looking around,
<a name="1201"></a>         *   start by describing the pc's immediate container and listing its
<a name="1202"></a>         *   contents.
<a name="1203"></a>         */
<a name="1204"></a>        if(loc != self &amp;&amp; lister == &amp;roomContentsLister)
<a name="1205"></a>        {
<a name="1206"></a>            /* 
<a name="1207"></a>             *   If there isn't a current action (e.g. because we're showing a
<a name="1208"></a>             *   room description before the first turn) create a Look Action to
<a name="1209"></a>             *   provide an action context for the gMessageParams() call that
<a name="1210"></a>             *   follows.
<a name="1211"></a>             */
<a name="1212"></a>            if(gAction == nil)
<a name="1213"></a>                gAction = Look.createInstance();
<a name="1214"></a>            
<a name="1215"></a>            /* Create a message parameter substitution. */
<a name="1216"></a>            gMessageParams(loc);
<a name="1217"></a>            
<a name="1218"></a>            /* Start by mentioning the PC's immediate container. */            
<a name="1219"></a>            DMsg(list immediate container, '{I} {am} {in loc}. &lt;.p&gt;');
<a name="1220"></a>            
<a name="1221"></a>            /* Note that the pc's immediate container has been mentioned. */
<a name="1222"></a>            loc.mentioned = true;
<a name="1223"></a>            
<a name="1224"></a>            /* 
<a name="1225"></a>             *   If the pc's immediate container is a subcomponent (of a complex
<a name="1226"></a>             *   container object), note that its lexical parent has been
<a name="1227"></a>             *   mentioned.
<a name="1228"></a>             */
<a name="1229"></a>            if(loc.ofKind(SubComponent) &amp;&amp; loc.lexicalParent != nil)
<a name="1230"></a>                loc.lexicalParent.mentioned = true;
<a name="1231"></a>                
<a name="1232"></a>            /* List the contents of the pc's immediate container. */
<a name="1233"></a>            listSubcontentsOf([loc]);
<a name="1234"></a>        }
<a name="1235"></a>        
<a name="1236"></a>        /* List every listable item in our contents. */
<a name="1237"></a>        foreach(local obj in contents)
<a name="1238"></a>        {            
<a name="1239"></a>            /* Don't include any hidden items in the listing */
<a name="1240"></a>            if(obj.isHidden)
<a name="1241"></a>                continue;
<a name="1242"></a>            
<a name="1243"></a>            /* 
<a name="1244"></a>             *   If the object has an initSpecialDesc or a specialDesc which is
<a name="1245"></a>             *   currently in use, add it to the appropriate list.
<a name="1246"></a>             */
<a name="1247"></a>            if((obj.propType(&amp;initSpecialDesc) != TypeNil &amp;&amp;
<a name="1248"></a>               obj.useInitSpecialDesc()) ||
<a name="1249"></a>               (obj.propType(&amp;specialDesc) != TypeNil &amp;&amp; obj.useSpecialDesc()))
<a name="1250"></a>            {
<a name="1251"></a>                /* 
<a name="1252"></a>                 *   If the specialDesc should be shown before the list of
<a name="1253"></a>                 *   miscellaneous items, add this object to the first list of
<a name="1254"></a>                 *   specials.
<a name="1255"></a>                 */
<a name="1256"></a>                if(obj.specialDescBeforeContents)
<a name="1257"></a>                    firstSpecialList += obj;
<a name="1258"></a>                
<a name="1259"></a>                /* Otherwise add it to the second list of specials. */
<a name="1260"></a>                else
<a name="1261"></a>                    secondSpecialList += obj;
<a name="1262"></a>            }
<a name="1263"></a>            /* 
<a name="1264"></a>             *   Otherwise add it to the list of miscellaneous items, provided
<a name="1265"></a>             *   it should be listed when looking around.
<a name="1266"></a>             */
<a name="1267"></a>            else if(obj.lookListed)
<a name="1268"></a>                miscContentsList += obj;
<a name="1269"></a>                      
<a name="1270"></a>            /* Note that the object has been seen by the pc. */
<a name="1271"></a>            obj.noteSeen();
<a name="1272"></a>        }
<a name="1273"></a>        
<a name="1274"></a>        /* Sort the first list of specials in order of their specialDescOrder */
<a name="1275"></a>        firstSpecialList = firstSpecialList.sort(nil, {a, b: a.specialDescOrder -
<a name="1276"></a>                                                 b.specialDescOrder});
<a name="1277"></a>                 
<a name="1278"></a>        /* Sort the second list of specials in order of their specialDescOrder */
<a name="1279"></a>        secondSpecialList = secondSpecialList.sort(nil, {a, b: a.specialDescOrder -
<a name="1280"></a>                                                 b.specialDescOrder});
<a name="1281"></a>
<a name="1282"></a>        /* 
<a name="1283"></a>         *   Show the specialDesc (or initSpecialDesc) of all the objects in the
<a name="1284"></a>         *   first specials list.
<a name="1285"></a>         */
<a name="1286"></a>        foreach(local obj in firstSpecialList)        
<a name="1287"></a>            obj.showSpecialDesc();                
<a name="1288"></a>        
<a name="1289"></a>        /* 
<a name="1290"></a>         *   If we're listing the contents of a room, then show the specialDescs
<a name="1291"></a>         *   of any items in the other rooms in our SenseRegions, where
<a name="1292"></a>         *   specialDescBeforeContents is true
<a name="1293"></a>         */        
<a name="1294"></a>        if(lister == &amp;roomContentsLister)
<a name="1295"></a>            showFirstConnectedSpecials(gPlayerChar);
<a name="1296"></a>        
<a name="1297"></a>        /* 
<a name="1298"></a>         *   Remove any items from the miscellaneous list that have already been
<a name="1299"></a>         *   mentioned.
<a name="1300"></a>         */
<a name="1301"></a>        miscContentsList = miscContentsList.subset({o: o.mentioned == nil});
<a name="1302"></a>                
<a name="1303"></a>        /* 
<a name="1304"></a>         *   Display the list of miscellaneous items using the lister passed as
<a name="1305"></a>         *   parameter to this method.         
<a name="1306"></a>         */
<a name="1307"></a>        self.(lister).show(miscContentsList, self);
<a name="1308"></a>               
<a name="1309"></a>        /*   List the contents of our contents. */
<a name="1310"></a>        listSubcontentsOf(contents, &amp;roomSubContentsLister);
<a name="1311"></a>        
<a name="1312"></a>         /* 
<a name="1313"></a>          *   If we're not putting paragraph breaks between each subcontents
<a name="1314"></a>          *   listing sentence, insert a paragraph break after the lot before we
<a name="1315"></a>          *   list anything else.
<a name="1316"></a>          *
<a name="1317"></a>          */
<a name="1318"></a>            if(!paraBrksBtwnSubcontents)
<a name="1319"></a>                "&lt;.p&gt;";
<a name="1320"></a>        
<a name="1321"></a>        /* 
<a name="1322"></a>         *   If we're listing the contents of a room, then show the
<a name="1323"></a>         *   miscellaneous contents of other rooms in our sense regions
<a name="1324"></a>         */
<a name="1325"></a>        if(lister == &amp;roomContentsLister)        
<a name="1326"></a>            showConnectedMiscContents(gPlayerChar);
<a name="1327"></a>                
<a name="1328"></a>        /* 
<a name="1329"></a>         *   Show the specialDesc (or initSpecialDesc) of every object in our
<a name="1330"></a>         *   second list of specials.
<a name="1331"></a>         */
<a name="1332"></a>        secondSpecialList = secondSpecialList.subset({o: o.mentioned == nil});
<a name="1333"></a>        
<a name="1334"></a>        foreach(local obj in secondSpecialList)
<a name="1335"></a>            obj.showSpecialDesc();
<a name="1336"></a>        
<a name="1337"></a>        
<a name="1338"></a>        /* 
<a name="1339"></a>         *   Show the specialDescs of any items in the other rooms in our
<a name="1340"></a>         *   SenseRegions, where specialDescBeforeContents is nil
<a name="1341"></a>         */
<a name="1342"></a>       if(lister == &amp;roomContentsLister)
<a name="1343"></a>           showSecondConnectedSpecials(gPlayerChar);
<a name="1344"></a>    }
<a name="1345"></a>    
<a name="1346"></a>    /* 
<a name="1347"></a>     *   List the contents of every item in contList, recursively listing the
<a name="1348"></a>     *   contents of contents all the way down the containment tree. The
<a name="1349"></a>     *   contList parameter can also be passed as a singleton object.
<a name="1350"></a>     */
<a name="1351"></a>    listSubcontentsOf(contList, lister = &amp;examineLister)
<a name="1352"></a>    {
<a name="1353"></a>       
<a name="1354"></a>        /* 
<a name="1355"></a>         *   If contList has been passed as a singleton value, convert it to a
<a name="1356"></a>         *   list, otherwise retain the list that's been passed.
<a name="1357"></a>         */
<a name="1358"></a>        contList = valToList(contList);
<a name="1359"></a>        
<a name="1360"></a>        /* 
<a name="1361"></a>         *   Ensure the contents of any associated remapXX items are included in
<a name="1362"></a>         *   the list of items whose contents are to be listed.
<a name="1363"></a>         */
<a name="1364"></a>        
<a name="1365"></a>        /* Initialize an empty list to collect the remapXXX items. */
<a name="1366"></a>        local lst = [];
<a name="1367"></a>        
<a name="1368"></a>        /* 
<a name="1369"></a>         *   Go through every item in the contList to see if it has any remapXXX
<a name="1370"></a>         *   objects attached. If so add the remapXXX object to our list.
<a name="1371"></a>         */
<a name="1372"></a>        foreach(local cur in contList)
<a name="1373"></a>        {
<a name="1374"></a>            foreach(local prop in remapProps)
<a name="1375"></a>            {
<a name="1376"></a>                local obj = cur.(prop);
<a name="1377"></a>                if(obj != nil)
<a name="1378"></a>                    lst += obj;
<a name="1379"></a>            }
<a name="1380"></a>        }
<a name="1381"></a>        
<a name="1382"></a>        /*  
<a name="1383"></a>         *   Append the list of remapXXX objects to the list of items whose
<a name="1384"></a>         *   contents are to be listed.
<a name="1385"></a>         */
<a name="1386"></a>        contList = contList.appendUnique(lst);
<a name="1387"></a>        
<a name="1388"></a>               
<a name="1389"></a> 
<a name="1390"></a>        /* 
<a name="1391"></a>         *   Sort the contList in listOrder. Although we're listing the contents
<a name="1392"></a>         *   of each item in the contList, it seems good to mention each item's
<a name="1393"></a>         *   contents in the listOrder order of the item. Amongst other things
<a name="1394"></a>         *   this helps give a consistent ordering for the listing of 
<a name="1395"></a>         *   SubComponents.
<a name="1396"></a>         */
<a name="1397"></a>        contList = contList.sort(nil, {a, b: a.listOrder - b.listOrder});
<a name="1398"></a>                     
<a name="1399"></a>        
<a name="1400"></a>        foreach(local obj in contList)
<a name="1401"></a>        {
<a name="1402"></a>            /* 
<a name="1403"></a>             *   We don't explicitly list things in actors' inventory, but we
<a name="1404"></a>             *   should note them as seen if the player can see them.
<a name="1405"></a>             */            
<a name="1406"></a>            if(obj.contType == Carrier &amp;&amp; markInventoryAsSeen)
<a name="1407"></a>                obj.allContents.subset({o: gPlayerChar.canSee(o) }).forEach( {o:
<a name="1408"></a>                    o.noteSeen() });           
<a name="1409"></a>            
<a name="1410"></a>            /* 
<a name="1411"></a>             *   Don't list the inventory of any actors, or of any items that
<a name="1412"></a>             *   don't want their contents listed, or any items we can't see in,
<a name="1413"></a>             *   or of any items that don't have any contents to list.
<a name="1414"></a>             */
<a name="1415"></a>            if(obj.contType == Carrier 
<a name="1416"></a>               || obj.(obj.(lister).contentsListedProp) == nil
<a name="1417"></a>               || obj.canSeeIn() == nil
<a name="1418"></a>               || obj.contents.length == 0)
<a name="1419"></a>                continue;
<a name="1420"></a>            
<a name="1421"></a>                      
<a name="1422"></a>            /* 
<a name="1423"></a>             *   Don't list any items that have already been mentioned or which
<a name="1424"></a>             *   are hidden.
<a name="1425"></a>             */ 
<a name="1426"></a>            local objList = obj.contents.subset({x: x.mentioned == nil 
<a name="1427"></a>                                                &amp;&amp; x.isHidden == nil
<a name="1428"></a>                                                &amp;&amp; x != gPlayerChar});
<a name="1429"></a>            
<a name="1430"></a>            
<a name="1431"></a>            /* 
<a name="1432"></a>             *   Extract the list of items that have active specialDescs or
<a name="1433"></a>             *   initSpecial Descs
<a name="1434"></a>             */
<a name="1435"></a>            local firstSpecialList = objList.subset(
<a name="1436"></a>                {o: (o.propType(&amp;specialDesc) != TypeNil &amp;&amp; o.useSpecialDesc())
<a name="1437"></a>                || (o.propType(&amp;initSpecialDesc) != TypeNil &amp;&amp;
<a name="1438"></a>                    o.useInitSpecialDesc() )
<a name="1439"></a>                }
<a name="1440"></a>                );
<a name="1441"></a>            
<a name="1442"></a>            
<a name="1443"></a>            /* 
<a name="1444"></a>             *   Remove items with specialDescs or initSpecialDescs from the
<a name="1445"></a>             *   list of miscellaneous items.
<a name="1446"></a>             */
<a name="1447"></a>            objList = objList - firstSpecialList;
<a name="1448"></a>            
<a name="1449"></a>            
<a name="1450"></a>            /*   
<a name="1451"></a>             *   From the list of items with specialDescs, extract those whose
<a name="1452"></a>             *   specialDescs should be listed after any miscellaneous items
<a name="1453"></a>             */
<a name="1454"></a>            local secondSpecialList = firstSpecialList.subset(
<a name="1455"></a>                { o: o.specialDescBeforeContents == nil });
<a name="1456"></a>            
<a name="1457"></a>            
<a name="1458"></a>            /* 
<a name="1459"></a>             *   Remove the items whose specialDescs should be listed after the
<a name="1460"></a>             *   miscellaneous items from the list of all items with
<a name="1461"></a>             *   specialDescs to give the list of items with specialDescs that
<a name="1462"></a>             *   should be listed before the miscellaneous items.
<a name="1463"></a>             */
<a name="1464"></a>            firstSpecialList = firstSpecialList - secondSpecialList;
<a name="1465"></a>            
<a name="1466"></a>            /*   
<a name="1467"></a>             *   Sort the list of items with specialDescs to be displayed before
<a name="1468"></a>             *   miscellaneous items by specialDescOrder
<a name="1469"></a>             */
<a name="1470"></a>            firstSpecialList = firstSpecialList.sort(nil, {a, b: a.specialDescOrder -
<a name="1471"></a>                b.specialDescOrder});
<a name="1472"></a>            
<a name="1473"></a>            /*   
<a name="1474"></a>             *   Sort the list of items with specialDescs to be displayed after
<a name="1475"></a>             *   miscellaneous items by specialDescOrder
<a name="1476"></a>             */
<a name="1477"></a>            secondSpecialList = secondSpecialList.sort(nil, {a, b: a.specialDescOrder -
<a name="1478"></a>                b.specialDescOrder});
<a name="1479"></a>            
<a name="1480"></a>            
<a name="1481"></a>            /*  
<a name="1482"></a>             *   Show the specialDescs of items whose specialDescs should be
<a name="1483"></a>             *   shown before the list of miscellaneous items.
<a name="1484"></a>             */
<a name="1485"></a>            firstSpecialList = firstSpecialList.subset({o: o.mentioned == nil});
<a name="1486"></a>            foreach(local cur in firstSpecialList)                    
<a name="1487"></a>                cur.showSpecialDesc(); 
<a name="1488"></a>            
<a name="1489"></a>            
<a name="1490"></a>            objList = objList.subset({o: o.mentioned == nil});
<a name="1491"></a>            /*   List the miscellaneous items */
<a name="1492"></a>            if(objList.length &gt; 0)   
<a name="1493"></a>            {
<a name="1494"></a>                obj.(lister).show(objList, obj, paraBrksBtwnSubcontents);                      
<a name="1495"></a>                objList.forEach({o: o.mentioned = true });
<a name="1496"></a>            }
<a name="1497"></a>            
<a name="1498"></a>            /* 
<a name="1499"></a>             *   If we're not putting paragraph breaks between each subcontents
<a name="1500"></a>             *   listing sentence, insert a space instead.
<a name="1501"></a>             */
<a name="1502"></a>            if(!paraBrksBtwnSubcontents &amp;&amp; secondSpecialList.indexWhich({o:o.isListed}))
<a name="1503"></a>                " ";
<a name="1504"></a>            
<a name="1505"></a>            
<a name="1506"></a>            /*  
<a name="1507"></a>             *   Show the specialDescs of items whose specialDescs should be
<a name="1508"></a>             *   shown after the list of miscellaneous items.
<a name="1509"></a>             */
<a name="1510"></a>            secondSpecialList = secondSpecialList.subset({o: o.mentioned == nil});
<a name="1511"></a>            foreach(local cur in secondSpecialList)        
<a name="1512"></a>                cur.showSpecialDesc(); 
<a name="1513"></a>            
<a name="1514"></a>            
<a name="1515"></a>            /* 
<a name="1516"></a>             *   Recursively list the contents of each item in this object's
<a name="1517"></a>             *   contents, if it has any; but don't list recursively for an
<a name="1518"></a>             *   object that's just been opened (for which the lister's
<a name="1519"></a>             *   listRecursively property should be nil) or for which there are
<a name="1520"></a>             *   no listable contents.
<a name="1521"></a>             */
<a name="1522"></a>            local lstr = obj.(lister);
<a name="1523"></a>            
<a name="1524"></a>            if(obj.contents.length &gt; 0 &amp;&amp; lstr.listRecursively
<a name="1525"></a>               &amp;&amp; obj.contents.countWhich({x: lstr.listed(x)}) &gt; 0)
<a name="1526"></a>                listSubcontentsOf(obj.contents, lister);                     
<a name="1527"></a>            
<a name="1528"></a>        }
<a name="1529"></a>        
<a name="1530"></a>         
<a name="1531"></a>    }
<a name="1532"></a>    
<a name="1533"></a>    
<a name="1534"></a>    
<a name="1535"></a>    /* 
<a name="1536"></a>     *   Do we want paragraph breaks between the listings of subcontents (i.e.
<a name="1537"></a>     *   the contents of this item's contents)? By default we take our value
<a name="1538"></a>     *   from the global setting on gameMain.
<a name="1539"></a>     */
<a name="1540"></a>    paraBrksBtwnSubcontents = (gameMain.paraBrksBtwnSubcontents)
<a name="1541"></a>    
<a name="1542"></a>    /* 
<a name="1543"></a>     *   Mark everything item in lst as not mentioned , and carry on down the
<a name="1544"></a>     *   containment tree marking the contents of every item in lst as not
<a name="1545"></a>     *   mentioned.
<a name="1546"></a>     */
<a name="1547"></a>    unmention(lst)
<a name="1548"></a>    {
<a name="1549"></a>        foreach(local obj in lst)
<a name="1550"></a>        {
<a name="1551"></a>            obj.mentioned = nil;
<a name="1552"></a>            
<a name="1553"></a>            /* If obj has any contents, unmention every item in is contents */
<a name="1554"></a>            if(obj.contents.length &gt; 0)
<a name="1555"></a>                unmention(obj.contents);
<a name="1556"></a>        }
<a name="1557"></a>    }
<a name="1558"></a>    
<a name="1559"></a>    /* 
<a name="1560"></a>     *   The next four methods are provided so that listContents() can call
<a name="1561"></a>     *   them, but they do nothing in the core library. They are overridden in
<a name="1562"></a>     *   senseRegion.t (for use if senseRegion.t is included in the build).
<a name="1563"></a>     */    
<a name="1564"></a>    unmentionRemoteContents() {}
<a name="1565"></a>    showFirstConnectedSpecials(pov) {}
<a name="1566"></a>    showConnectedMiscContents(pov) {}
<a name="1567"></a>    showSecondConnectedSpecials(pov) {}
<a name="1568"></a>    
<a name="1569"></a>    /*
<a name="1570"></a>     *   Display the "status line" name of the room.  This is normally a
<a name="1571"></a>     *   brief, single-line description.
<a name="1572"></a>     *   
<a name="1573"></a>     *   By long-standing convention, each location in a game usually has a
<a name="1574"></a>     *   distinctive name that's displayed here.  Players usually find
<a name="1575"></a>     *   these names helpful in forming a mental map of the game.
<a name="1576"></a>     *   
<a name="1577"></a>     *   By default, if we have an enclosing location, and the actor can
<a name="1578"></a>     *   see the enclosing location, we'll defer to the location.
<a name="1579"></a>     *   Otherwise, we'll display our roo interior name.  
<a name="1580"></a>     */
<a name="1581"></a>    statusName(actor)
<a name="1582"></a>    {
<a name="1583"></a>        /* 
<a name="1584"></a>         *   use the enclosing location's status name if there is an
<a name="1585"></a>         *   enclosing location and its visible; otherwise, show our
<a name="1586"></a>         *   interior room name 
<a name="1587"></a>         */
<a name="1588"></a>        if (location != nil &amp;&amp; Q.canSee(actor, location))
<a name="1589"></a>            location.statusName(actor);
<a name="1590"></a>        else
<a name="1591"></a>        {
<a name="1592"></a>            roomHeadline(actor);
<a name="1593"></a>        }
<a name="1594"></a>    }
<a name="1595"></a>    
<a name="1596"></a>    /* 
<a name="1597"></a>     *   Get the estimated height, in lines of text, of the exits display's
<a name="1598"></a>     *   contribution to the status line.  This is used to calculate the
<a name="1599"></a>     *   extra height we need in the status line, if any, to display the
<a name="1600"></a>     *   exit list.  If we're not configured to display exits in the status
<a name="1601"></a>     *   line, this should return zero. 
<a name="1602"></a>     */
<a name="1603"></a>    getStatuslineExitsHeight()
<a name="1604"></a>    {
<a name="1605"></a>        if (gExitLister != nil)
<a name="1606"></a>            return gExitLister.getStatuslineExitsHeight();
<a name="1607"></a>        else
<a name="1608"></a>            return 0;
<a name="1609"></a>    }
<a name="1610"></a>    
<a name="1611"></a>    /* Show our exits in the status line */
<a name="1612"></a>    showStatuslineExits()
<a name="1613"></a>    {
<a name="1614"></a>        location.showStatuslineExits();
<a name="1615"></a>    }
<a name="1616"></a>    
<a name="1617"></a>    /* 
<a name="1618"></a>     *   Would this location be lit for actor. By default it would if it's
<a name="1619"></a>     *   illuminated.
<a name="1620"></a>     */
<a name="1621"></a>    wouldBeLitFor(actor)   
<a name="1622"></a>    {
<a name="1623"></a>        return getOutermostRoom.isIlluminated;
<a name="1624"></a>    }
<a name="1625"></a>    
<a name="1626"></a>//------------------------------------------------------------------------------  
<a name="1627"></a>    /* 
<a name="1628"></a>     *   From here on we have properties and methods relating to Things in
<a name="1629"></a>     *   general rather than just Rooms and Booths.
<a name="1630"></a>     */
<a name="1631"></a>    
<a name="1632"></a>    /* 
<a name="1633"></a>     *   The description of this Thing that's displayed when it's examined.
<a name="1634"></a>     *   Normally this would be defined as a double-quoted string, but in more
<a name="1635"></a>     *   complicated cases you could also define it as a method that displays
<a name="1636"></a>     *   some text.
<a name="1637"></a>     */
<a name="1638"></a>    desc = ""     
<a name="1639"></a>    
<a name="1640"></a>    /* 
<a name="1641"></a>     *   The state-specific description of this object, which is appended to its
<a name="1642"></a>     *   desc when examined. This is defined as a single-quoted string to make
<a name="1643"></a>     *   it easy to change at run-time.
<a name="1644"></a>     */
<a name="1645"></a>    stateDesc = ''
<a name="1646"></a>    
<a name="1647"></a>    /* 
<a name="1648"></a>     *   Additional information to display after our desc in response to an
<a name="1649"></a>     *   EXAMINE command.
<a name="1650"></a>     */
<a name="1651"></a>    examineStatus()
<a name="1652"></a>    {        
<a name="1653"></a>        /* First display our stateDesc (our state-specific information) */
<a name="1654"></a>        display(&amp;stateDesc);
<a name="1655"></a>        
<a name="1656"></a>        /* 
<a name="1657"></a>         *   Then display our list of contents, unless we're a Carrier (an actor
<a name="1658"></a>         *   carrying our oontents) or our contentsListedInExamine is nil.
<a name="1659"></a>         */
<a name="1660"></a>        if(contType != Carrier &amp;&amp; contentsListedInExamine)
<a name="1661"></a>        {          
<a name="1662"></a>            /* 
<a name="1663"></a>             *   Start by marking our contents as not mentioned to ensure that
<a name="1664"></a>             *   they all get listed.
<a name="1665"></a>             */
<a name="1666"></a>            unmention(contents);
<a name="1667"></a>            
<a name="1668"></a>            /* Then list our contents using our examineLister. */
<a name="1669"></a>            listSubcontentsOf(self, &amp;examineLister);            
<a name="1670"></a>        }                   
<a name="1671"></a>    }
<a name="1672"></a>    
<a name="1673"></a>    /* The lister to use to list an item's contents when it's examined. */    
<a name="1674"></a>    examineLister = descContentsLister
<a name="1675"></a>    
<a name="1676"></a>    
<a name="1677"></a>    /* 
<a name="1678"></a>     *   Attempt to display prop appropriately according to it data type
<a name="1679"></a>     *   (single-quoted string, double-quoted string, integer or code). The prop
<a name="1680"></a>     *   parameter must be provided as a property pointer.
<a name="1681"></a>     */
<a name="1682"></a>    display(prop)
<a name="1683"></a>    {
<a name="1684"></a>        local str;
<a name="1685"></a>        switch(propType(prop))
<a name="1686"></a>        {
<a name="1687"></a>            /* 
<a name="1688"></a>             *   If prop is a single-quoted string or an integer, simply display
<a name="1689"></a>             *   it.
<a name="1690"></a>             */
<a name="1691"></a>        case TypeSString:
<a name="1692"></a>        case TypeInt:    
<a name="1693"></a>            say(self.(prop));
<a name="1694"></a>            break;
<a name="1695"></a>            
<a name="1696"></a>            /* If prop is a double-quoted string, display it by executing it. */
<a name="1697"></a>        case TypeDString:
<a name="1698"></a>            self.(prop);
<a name="1699"></a>            break;
<a name="1700"></a>            
<a name="1701"></a>            /* if prop is a method, execute it. */
<a name="1702"></a>        case TypeCode:
<a name="1703"></a>            /* 
<a name="1704"></a>             *   In case prop is a method that returns a single-quoted string,
<a name="1705"></a>             *   note the return value from executing prop.
<a name="1706"></a>             */
<a name="1707"></a>            str = self.(prop);
<a name="1708"></a>            
<a name="1709"></a>            /* If it's a string, display it. */
<a name="1710"></a>            if(dataType(str) == TypeSString &amp;&amp; str &gt; '')
<a name="1711"></a>                say(str);
<a name="1712"></a>            break;
<a name="1713"></a>        default:
<a name="1714"></a>            /* do nothing */
<a name="1715"></a>            break;
<a name="1716"></a>        }
<a name="1717"></a>    }
<a name="1718"></a>    
<a name="1719"></a>    /* 
<a name="1720"></a>     *   Attempt to display the message defined in the property prop, and return
<a name="1721"></a>     *   true if anything is displayed. Otherwise, if the altMsg parameter is
<a name="1722"></a>     *   supplied (either as a single-quoted string or as a property pointer)
<a name="1723"></a>     *   display it instead, and then in any case return nil to tell the caller
<a name="1724"></a>     *   that nothing was displayed by prop.
<a name="1725"></a>     *
<a name="1726"></a>     *   This method is primarily for use with properties such as smellDesc and
<a name="1727"></a>     *   listenDesc for which alternatives may need to be displayed if they
<a name="1728"></a>     *   don't display anything.
<a name="1729"></a>     */
<a name="1730"></a>    
<a name="1731"></a>    displayAlt(prop, altMsg?)
<a name="1732"></a>    {        
<a name="1733"></a>        /* 
<a name="1734"></a>         *   If attempting to display the prop property results in some output,
<a name="1735"></a>         *   return true to inform our caller of the fact.
<a name="1736"></a>         */
<a name="1737"></a>        if(gOutStream.watchForOutput({: display(prop) }))
<a name="1738"></a>            return true;
<a name="1739"></a>        
<a name="1740"></a>        
<a name="1741"></a>        /* 
<a name="1742"></a>         *   If we reach this point, prop failed to produce any output, so if
<a name="1743"></a>         *   altMsg has been provided as a single-quoted string, display it.
<a name="1744"></a>         */
<a name="1745"></a>        if(dataType(altMsg) == TypeSString)
<a name="1746"></a>            say(altMsg);
<a name="1747"></a>        
<a name="1748"></a>        /*  
<a name="1749"></a>         *   Otherwise, if altMsg has been provided as a property pointer,
<a name="1750"></a>         *   display it using the display() method.
<a name="1751"></a>         */        
<a name="1752"></a>        if(dataType(altMsg) == TypeProp)
<a name="1753"></a>            display(altMsg);
<a name="1754"></a>        
<a name="1755"></a>        /* 
<a name="1756"></a>         *   Tell our caller that there was no output from attempting to display
<a name="1757"></a>         *   prop.
<a name="1758"></a>         */
<a name="1759"></a>        return nil;
<a name="1760"></a>    }
<a name="1761"></a>    
<a name="1762"></a>    /* 
<a name="1763"></a>     *   Check if displaying prop could possibly produce any output. The only
<a name="1764"></a>     *   tests we apply here is that prop is not defined as nil.
<a name="1765"></a>     */
<a name="1766"></a>    checkDisplay(prop)    
<a name="1767"></a>    {          
<a name="1768"></a>        return propType(prop) != TypeNil;
<a name="1769"></a>    }
<a name="1770"></a>    
<a name="1771"></a>    
<a name="1772"></a>    
<a name="1773"></a>    /* 
<a name="1774"></a>     *   Has this item been mentioned yet in a room description. Note that this
<a name="1775"></a>     *   flag is used internally by the library; it shouldn't normally be
<a name="1776"></a>     *   necessary to manipulate it directly from game code.
<a name="1777"></a>     */
<a name="1778"></a>    mentioned = nil
<a name="1779"></a>    
<a name="1780"></a>   
<a name="1781"></a>    
<a name="1782"></a>    /* 
<a name="1783"></a>     *   Do we want this object to report whether it's open? By default we do if
<a name="1784"></a>     *   it's both openable and open.
<a name="1785"></a>     */
<a name="1786"></a>    openStatusReportable = (isOpenable &amp;&amp; isOpen)
<a name="1787"></a>    
<a name="1788"></a>        
<a name="1789"></a>    /* 
<a name="1790"></a>     *   If present, a description of this object shown in a separate paragraph
<a name="1791"></a>     *   in the listing of the contents of a Room. If specialDesc is defined
<a name="1792"></a>     *   then this paragraph will be displayed regardless of the value of
<a name="1793"></a>     *   isListed.
<a name="1794"></a>     */    
<a name="1795"></a>    specialDesc = nil
<a name="1796"></a>    
<a name="1797"></a>    /* 
<a name="1798"></a>     *   Should the specialDesc be used? Normally we use the specialDesc if we
<a name="1799"></a>     *   have one, but we may want to override this for particular cases. For
<a name="1800"></a>     *   example, if we want an item to have a paragraph to itself until it's
<a name="1801"></a>     *   moved we could define useSpecialDesc = (!moved) [making it equivalent
<a name="1802"></a>     *   to initSpecialDesc]. Note that the useSpecialDesc property only
<a name="1803"></a>     *   has any effect if specialDesc is not nil.
<a name="1804"></a>     */ 
<a name="1805"></a>    useSpecialDesc = true
<a name="1806"></a>    
<a name="1807"></a>    
<a name="1808"></a>    /* A specialDesc that's shown until this item has been moved */
<a name="1809"></a>    initSpecialDesc = nil
<a name="1810"></a>    
<a name="1811"></a>    
<a name="1812"></a>    /* 
<a name="1813"></a>     *   By default we use the initSpecialDesc until the object has been moved,
<a name="1814"></a>     *   but this can be overridden with some other condition.
<a name="1815"></a>     */
<a name="1816"></a>    useInitSpecialDesc = (!moved)
<a name="1817"></a>    
<a name="1818"></a>    /*  
<a name="1819"></a>     *   The specialDescOrder property controls where in a series of specialDesc
<a name="1820"></a>     *   paragraphs this item is mentioned: the higher the number, the later it
<a name="1821"></a>     *   will come relative to other items. Note that this does not override the
<a name="1822"></a>     *   specialDescBeforeContents setting.
<a name="1823"></a>     */
<a name="1824"></a>    specialDescOrder = 100
<a name="1825"></a>    
<a name="1826"></a>    /*   
<a name="1827"></a>     *   Is this item listed before or after the list of miscellaneous contents
<a name="1828"></a>     *   in the room. By default we'll show the specialDesc of items before
<a name="1829"></a>     *   miscellaneous items in a room description but afterwards otherwise:
<a name="1830"></a>     *   this places specialDescs in a more logical order in relation to the
<a name="1831"></a>     *   text of listers used to list the contents of obejcts other than rooms.
<a name="1832"></a>     */    
<a name="1833"></a>    specialDescBeforeContents = (location &amp;&amp; location.ofKind(Room))
<a name="1834"></a>    
<a name="1835"></a>    /* For possible future use; at the moment this doesn't do anything */
<a name="1836"></a>    specialDescListWith = nil
<a name="1837"></a>    
<a name="1838"></a>    
<a name="1839"></a>    /* Show our specialDesc or initSpecialDesc, as appropriate */
<a name="1840"></a>    showSpecialDesc()
<a name="1841"></a>    {
<a name="1842"></a>        /* 
<a name="1843"></a>         *   If we've already been mentioned in the room description, don't show
<a name="1844"></a>         *   us again. Otherwise note that we've now been mentioned.
<a name="1845"></a>         */
<a name="1846"></a>        if(mentioned)
<a name="1847"></a>            return;
<a name="1848"></a>        
<a name="1849"></a>        
<a name="1850"></a>        
<a name="1851"></a>        /* 
<a name="1852"></a>         *   If we have an initSpecialDesc and useInitSpecialDesc is true, show
<a name="1853"></a>         *   our initSpecialDesc, otherwise show our specialDesc.
<a name="1854"></a>         */
<a name="1855"></a>        if(propType(&amp;initSpecialDesc) != TypeNil &amp;&amp; useInitSpecialDesc)
<a name="1856"></a>        {
<a name="1857"></a>            initSpecialDesc;
<a name="1858"></a>            
<a name="1859"></a>            mentioned = true;
<a name="1860"></a>        }       
<a name="1861"></a>        else if(propType(&amp;specialDesc) != TypeNil)
<a name="1862"></a>        {        
<a name="1863"></a>            specialDesc;
<a name="1864"></a>            
<a name="1865"></a>            mentioned = true;
<a name="1866"></a>        }
<a name="1867"></a>           
<a name="1868"></a>        /*  Add a paragraph break. */
<a name="1869"></a>        if(mentioned)
<a name="1870"></a>            "&lt;.p&gt;";
<a name="1871"></a>        
<a name="1872"></a>        /* Note that we've been seen. */
<a name="1873"></a>        noteSeen();
<a name="1874"></a>    }
<a name="1875"></a>    
<a name="1876"></a>    
<a name="1877"></a>    
<a name="1878"></a>    /* 
<a name="1879"></a>     *   Flag to indicate whether this item is portable (nil) or fixed in place
<a name="1880"></a>     *   (true). If it's fixed in place it can't be picked up or moved around
<a name="1881"></a>     *   (by player commands).
<a name="1882"></a>     */    
<a name="1883"></a>    isFixed = (isDecoration)
<a name="1884"></a>    
<a name="1885"></a>    /* 
<a name="1886"></a>     *   Is this item listed in room descriptions and the like. We tend to list
<a name="1887"></a>     *   portable items but not those fixed in place, so we make this the
<a name="1888"></a>     *   default.
<a name="1889"></a>     */
<a name="1890"></a>    
<a name="1891"></a>    /*   
<a name="1892"></a>     *   A global isListed property that can be used to set the value of all the
<a name="1893"></a>     *   others. By default we're listed if we're not fixed in place.
<a name="1894"></a>     */
<a name="1895"></a>    isListed = (!isFixed)
<a name="1896"></a>    
<a name="1897"></a>    /*  
<a name="1898"></a>     *   Flag: is this item listed in a room description (when looking around).
<a name="1899"></a>     */
<a name="1900"></a>    lookListed = (isListed)
<a name="1901"></a>    
<a name="1902"></a>    /* Flag: is this item listed in an inventory listing. */
<a name="1903"></a>    inventoryListed = (isListed)
<a name="1904"></a>    
<a name="1905"></a>    /* Flag: is this item listed when its container is examined. */    
<a name="1906"></a>    examineListed = (isListed)
<a name="1907"></a>    
<a name="1908"></a>    /* 
<a name="1909"></a>     *   Flag: is this item listed when is container is searched (or looked in).
<a name="1910"></a>     */
<a name="1911"></a>    searchListed = (isListed)
<a name="1912"></a>    
<a name="1913"></a>    /*  
<a name="1914"></a>     *   Flag: should this item's contents be listed? This can be used to
<a name="1915"></a>     *   control both contentsListedInLook and contentsListedInExamine.
<a name="1916"></a>     */
<a name="1917"></a>    contentsListed = true
<a name="1918"></a>    
<a name="1919"></a>    /*  
<a name="1920"></a>     *   Flag: should this item's contents be listed as part of a room
<a name="1921"></a>     *   description (when looking around).
<a name="1922"></a>     */
<a name="1923"></a>    contentsListedInLook = (contentsListed)
<a name="1924"></a>    
<a name="1925"></a>    /*  
<a name="1926"></a>     *   Flag: should this item's contents be listed when its container is
<a name="1927"></a>     *   examined.
<a name="1928"></a>     */
<a name="1929"></a>    contentsListedInExamine = (contentsListed)
<a name="1930"></a>    
<a name="1931"></a>    /*  
<a name="1932"></a>     *   Flag, should this item's contents be listed when it is searched (by
<a name="1933"></a>     *   default this is simply true, since it would be odd to have a container
<a name="1934"></a>     *   that failed to reveal its contents when searched).
<a name="1935"></a>     */
<a name="1936"></a>    contentsListedInSearch = true
<a name="1937"></a>    
<a name="1938"></a>    /*
<a name="1939"></a>     *   Flag, if our contType is Carrier (i.e. we're an Actor), should our
<a name="1940"></a>     *   contents be marked as seen even though it hasn't been listed in a room
<a name="1941"></a>     *   description? By default this is set to true, on the basis that the
<a name="1942"></a>     *   inventory (and parts) of an actor would normally be in plain sight.
<a name="1943"></a>     */    
<a name="1944"></a>    markInventoryAsSeen = true
<a name="1945"></a>    
<a name="1946"></a>    /*
<a name="1947"></a>     *   The text we display in response to a READ command. This can be nil
<a name="1948"></a>     *   (if we're not readable), a single-quoted string, a double-quoted string
<a name="1949"></a>     *   or a routine to display a string.     */
<a name="1950"></a>    
<a name="1951"></a>    readDesc = nil
<a name="1952"></a>    
<a name="1953"></a>    /* The description displayed in response to a SMELL command */
<a name="1954"></a>    smellDesc = nil
<a name="1955"></a>    
<a name="1956"></a>    /* 
<a name="1957"></a>     *   Is the this object's smellDesc displayed in response to an intransitive
<a name="1958"></a>     *   SMELL command? (Only relevant if smellDesc is not nil)
<a name="1959"></a>     */
<a name="1960"></a>    isProminentSmell = true
<a name="1961"></a>    
<a name="1962"></a>    /*   The description displayed in response to a FEEL command */
<a name="1963"></a>    feelDesc = nil
<a name="1964"></a>    
<a name="1965"></a>    /*   The description displayed in response to a LISTEN command */
<a name="1966"></a>    listenDesc = nil
<a name="1967"></a>    
<a name="1968"></a>    /* 
<a name="1969"></a>     *   Is the this object's listenDesc displayed in response to an
<a name="1970"></a>     *   intransitive LISTEN command? (Only relevant if listenDesc is not nil)
<a name="1971"></a>     */
<a name="1972"></a>    isProminentNoise = true
<a name="1973"></a>    
<a name="1974"></a>    /*   The description displayed in response to a TASTE command */
<a name="1975"></a>    tasteDesc = nil
<a name="1976"></a>    
<a name="1977"></a>        
<a name="1978"></a>    
<a name="1979"></a>    /*  The subset of our contents that should be listed. */
<a name="1980"></a>    listableContents = (contents.subset({x: x.lookListed}))
<a name="1981"></a>    
<a name="1982"></a>    /* The subset of the contents of cont that should be listed. */
<a name="1983"></a>    listableContentsOf(cont)
<a name="1984"></a>    {
<a name="1985"></a>        local lst = [];
<a name="1986"></a>        foreach(local obj in cont.contents)
<a name="1987"></a>        {
<a name="1988"></a>            if(obj.isListed)
<a name="1989"></a>                lst += obj;
<a name="1990"></a>        }
<a name="1991"></a>        return lst;    
<a name="1992"></a>    }
<a name="1993"></a>    
<a name="1994"></a>    /* 
<a name="1995"></a>     *   Our globalParamName is an arbitrary string value that can be used to
<a name="1996"></a>     *   refer to this thing in a message substitution parameter; for code
<a name="1997"></a>     *   readability it may be a good idea to make this a string representation
<a name="1998"></a>     *   of our programmatic name (where we want to define it at all).
<a name="1999"></a>     */
<a name="2000"></a>    globalParamName = nil
<a name="2001"></a>    
<a name="2002"></a>   
<a name="2003"></a>    /* 
<a name="2004"></a>     *   Is this object lit, i.e. providing sufficient light to see not only
<a name="2005"></a>     *   this object but other objects in the vicinity by.
<a name="2006"></a>     */    
<a name="2007"></a>    isLit = nil
<a name="2008"></a>    
<a name="2009"></a>    /* Make this object lit or unlit */
<a name="2010"></a>    makeLit(stat) { isLit = stat; }
<a name="2011"></a>    
<a name="2012"></a>    /* 
<a name="2013"></a>     *   Is this object visible in the dark without (necessarily) providing
<a name="2014"></a>     *   enough light to see anything else by, e.g. the night sky.
<a name="2015"></a>     */
<a name="2016"></a>    visibleInDark = nil
<a name="2017"></a>    
<a name="2018"></a>    /*   
<a name="2019"></a>     *   An optional description to be displayed instead of our normal desc and
<a name="2020"></a>     *   any status information (such as our contents) if we're examined in a
<a name="2021"></a>     *   dark room and visibleInDark is true. Note that if visibleInDark is nil
<a name="2022"></a>     *   inDarkDesc will never be used.
<a name="2023"></a>     */
<a name="2024"></a>    inDarkDesc = nil
<a name="2025"></a>    
<a name="2026"></a>    /* 
<a name="2027"></a>     *   Is this object lightable (via a player command)? Note that setting this
<a name="2028"></a>     *   property to true also automatically makes the LitUnlit State applicable
<a name="2029"></a>     *   to this object, allowing it to be referred to as 'lit' or 'unlit' as
<a name="2030"></a>     *   appropriate.
<a name="2031"></a>     */
<a name="2032"></a>    isLightable = nil
<a name="2033"></a>    
<a name="2034"></a>    /*   
<a name="2035"></a>     *   The preposition that should be used to describe containment within this
<a name="2036"></a>     *   thing (e.g. 'in', 'on' , 'under' or 'behind'). By default we get this
<a name="2037"></a>     *   from our contType.
<a name="2038"></a>     */
<a name="2039"></a>    objInPrep = (contType.prep)
<a name="2040"></a>    
<a name="2041"></a>    /*   
<a name="2042"></a>     *   The preposition that should be used to describe movement to within this
<a name="2043"></a>     *   thing (e.g. 'into', 'onto' , 'under' or 'behind'). By default we get
<a name="2044"></a>     *   this from our contType.
<a name="2045"></a>     */
<a name="2046"></a>    objIntoPrep = (contType.intoPrep)
<a name="2047"></a>    
<a name="2048"></a>    /*   
<a name="2049"></a>     *   This object's bulk, in arbitrary units (game authors should devise
<a name="2050"></a>     *   their own bulk scale according to the needs of their game).
<a name="2051"></a>     */
<a name="2052"></a>    bulk = 0
<a name="2053"></a>    
<a name="2054"></a>    /*   
<a name="2055"></a>     *   The maximum bulk that can be contained in this Thing. We set a very
<a name="2056"></a>     *   large number by default.
<a name="2057"></a>     */
<a name="2058"></a>    bulkCapacity = 10000
<a name="2059"></a>    
<a name="2060"></a>    /*   
<a name="2061"></a>     *   The maximum bulk that a single item may have to be inserted into (onto,
<a name="2062"></a>     *   under, behind) this object; by default this is the same as the bulk
<a name="2063"></a>     *   capacity, but you could set a lower value, e.g. to model a bottle with
<a name="2064"></a>     *   a narrow neck.
<a name="2065"></a>     */
<a name="2066"></a>    maxSingleBulk = (bulkCapacity)
<a name="2067"></a>    
<a name="2068"></a>    
<a name="2069"></a>    /* 
<a name="2070"></a>     *   The maximum number of items we can hold, irrespective of their bulk (or weight). By default
<a name="2071"></a>     *   we make this a very large number so there's no effective limit; game code can set a lower
<a name="2072"></a>     *   limit on the player character and/or other actors.
<a name="2073"></a>     */
<a name="2074"></a>    maxItemsCarried = 100000
<a name="2075"></a>    
<a name="2076"></a>    /*   Calculate the total bulk of the items contained within this object. */
<a name="2077"></a>    getBulkWithin()
<a name="2078"></a>    {
<a name="2079"></a>        local totalBulk = 0;
<a name="2080"></a>        foreach(local cur in contents)
<a name="2081"></a>            totalBulk += cur.bulk;
<a name="2082"></a>        
<a name="2083"></a>        return totalBulk;
<a name="2084"></a>    }
<a name="2085"></a>    
<a name="2086"></a>    /*  
<a name="2087"></a>     *   Calculate the total bulk carried by an actor, which excludes the bulk
<a name="2088"></a>     *   of any items currently worn or anything fixed in place.
<a name="2089"></a>     */
<a name="2090"></a>    getCarriedBulk()
<a name="2091"></a>    {
<a name="2092"></a>        local totalBulk = 0;
<a name="2093"></a>        foreach(local cur in directlyHeld)
<a name="2094"></a>        {           
<a name="2095"></a>            totalBulk += cur.bulk;
<a name="2096"></a>        }
<a name="2097"></a>        
<a name="2098"></a>        return totalBulk;
<a name="2099"></a>    }
<a name="2100"></a>    
<a name="2101"></a>    /*  
<a name="2102"></a>     *   Check whether an item can be inserted into this object, or whether
<a name="2103"></a>     *   doing so would either exceed the total bulk capacity of the object or
<a name="2104"></a>     *   the maximum bulk allowed for a single item.
<a name="2105"></a>     */
<a name="2106"></a>    checkInsert(obj)
<a name="2107"></a>    {
<a name="2108"></a>        /* Create a message parameter substitution. */
<a name="2109"></a>        gMessageParams(obj);
<a name="2110"></a>        
<a name="2111"></a>        /* 
<a name="2112"></a>         *   If the bulk of obj is greater than the maxSingleBulk this Thing can
<a name="2113"></a>         *   take, or greater than its overall bulk capacity then display a
<a name="2114"></a>         *   message to say it's too big to fit inside ue.
<a name="2115"></a>         */
<a name="2116"></a>        if(obj.bulk &gt; maxSingleBulk || obj.bulk &gt; bulkCapacity)
<a name="2117"></a>            DMsg(too big, '{The subj obj} {is} too big to fit {1} {2}. ', 
<a name="2118"></a>                 objInPrep, theName);
<a name="2119"></a>            
<a name="2120"></a>        /* 
<a name="2121"></a>         *   Otherwise if the bulk of obj is greater than the remaining bulk
<a name="2122"></a>         *   capacity of this Thing allowing for what it already contains,
<a name="2123"></a>         *   display a message saying there's not enough room for obj.
<a name="2124"></a>         */
<a name="2125"></a>        else if(obj.bulk &gt; bulkCapacity - getBulkWithin())
<a name="2126"></a>            DMsg(no room, 'There {dummy} {is} not enough room {1} {2} for {the
<a name="2127"></a>                obj}. ', objInPrep, theName);            
<a name="2128"></a>    }
<a name="2129"></a>    
<a name="2130"></a>    
<a name="2131"></a>    /* The list of possible remap props */
<a name="2132"></a>    remapProps = [&amp;remapOn, &amp;remapIn, &amp;remapUnder, &amp;remapBehind]
<a name="2133"></a>    
<a name="2134"></a>    
<a name="2135"></a>    /* 
<a name="2136"></a>     *   If remapIn is not nil, a LOOK IN, PUT IN, OPEN, CLOSE, LOCK or UNLOCK
<a name="2137"></a>     *   command performed on this Thing will be redirected to the object
<a name="2138"></a>     *   specified on remapIn. In other words, remapIn specifies the object that
<a name="2139"></a>     *   acts as our proxy container.
<a name="2140"></a>     */
<a name="2141"></a>    remapIn = nil
<a name="2142"></a>    
<a name="2143"></a>    /* 
<a name="2144"></a>     *   If non-nil, remapOn speficies the object that acts as our proxy
<a name="2145"></a>     *   surface, in other words the object to which PUT ON will be redirected.
<a name="2146"></a>     */
<a name="2147"></a>    remapOn = nil
<a name="2148"></a>    
<a name="2149"></a>    /*  
<a name="2150"></a>     *   If non-nil, remapUnder specified the object that acts as our proxy
<a name="2151"></a>     *   underside, i.e. the object to which any PUT UNDER or LOOK UNDER action
<a name="2152"></a>     *   directed at us will be redirected.
<a name="2153"></a>     */
<a name="2154"></a>    remapUnder = nil
<a name="2155"></a>    
<a name="2156"></a>    /*  
<a name="2157"></a>     *   If non-nil, remapUnder specified the object that acts as our proxy
<a name="2158"></a>     *   rear, i.e. the object to which any PUT BEHIND or LOOK BEHIND action
<a name="2159"></a>     *   directed at us will be redirected.
<a name="2160"></a>     */
<a name="2161"></a>    remapBehind = nil
<a name="2162"></a>    
<a name="2163"></a>    
<a name="2164"></a>    /* 
<a name="2165"></a>     *   Our notional total contents is our normal contents plus anything
<a name="2166"></a>     *   contained in any of our remapXX objects representing our associated
<a name="2167"></a>     *   proxy container, surface, underside and rear, excluding anything in a
<a name="2168"></a>     *   closed opaque container (which would not be visible).
<a name="2169"></a>     */    
<a name="2170"></a>    notionalContents()
<a name="2171"></a>    {
<a name="2172"></a>        local nc = [];
<a name="2173"></a>        
<a name="2174"></a>        if(isTransparent || !enclosing)
<a name="2175"></a>            nc = contents;
<a name="2176"></a>        if(remapIn != nil &amp;&amp; (remapIn.isTransparent || !remapIn.enclosing))
<a name="2177"></a>            nc = nc + remapIn.contents;
<a name="2178"></a>        if(remapOn != nil)
<a name="2179"></a>            nc = nc + remapOn.contents;
<a name="2180"></a>        if(remapUnder != nil)
<a name="2181"></a>            nc = nc + remapUnder.contents;
<a name="2182"></a>        if(remapBehind != nil)
<a name="2183"></a>            nc = nc + remapBehind.contents;
<a name="2184"></a>        
<a name="2185"></a>        return nc;
<a name="2186"></a>    }
<a name="2187"></a>    
<a name="2188"></a>    /* 
<a name="2189"></a>     *   A list of objects that are treated as hidden under this one. A LOOK
<a name="2190"></a>     *   UNDER command will list them and move them into the enclosing room. It
<a name="2191"></a>     *   follows that objects placed in this property should not be given an
<a name="2192"></a>     *   initial location. This should deal with the most common reason for
<a name="2193"></a>     *   wanting items to be placed under things (i.e. to hide them). Note, the
<a name="2194"></a>     *   items in the hiddenUnder property should also be revealed when the
<a name="2195"></a>     *   player moves the hiding item.
<a name="2196"></a>     */    
<a name="2197"></a>    hiddenUnder = []
<a name="2198"></a>    
<a name="2199"></a>    /* 
<a name="2200"></a>     *   A list of objects that are treated as hidden behind this one. A LOOK
<a name="2201"></a>     *   BEHIND command will list them and move them into the enclosing room. It
<a name="2202"></a>     *   follows that objects placed in this property should not be given an
<a name="2203"></a>     *   initial location. This should deal with the most common reason for
<a name="2204"></a>     *   wanting items to be placed behind things (i.e. to hide them). Note, the
<a name="2205"></a>     *   items in the hiddenBehind property should also be revealed when the
<a name="2206"></a>     *   player moves the hiding item.
<a name="2207"></a>     */   
<a name="2208"></a>    hiddenBehind = []
<a name="2209"></a>    
<a name="2210"></a>    /* 
<a name="2211"></a>     *   A list of objects that are treated as hidden inside this one. A LOOK IN
<a name="2212"></a>     *   command will list them and move them into the enclosing room (or in
<a name="2213"></a>     *   this one if we're a container). It follows that objects placed in this
<a name="2214"></a>     *   property should not be given an initial location.
<a name="2215"></a>     */   
<a name="2216"></a>    hiddenIn = []
<a name="2217"></a>    
<a name="2218"></a>    
<a name="2219"></a>    /* 
<a name="2220"></a>     *   The maximum bulk that can be hidden under, behind or in this object,
<a name="2221"></a>     *   assuming that the player can put anything there at all. Note that this
<a name="2222"></a>     *   only affects what the player can place there with PUT IN, PUT UNDER and
<a name="2223"></a>     *   PUT BEHIND commands, not what can be defined there initially or moved
<a name="2224"></a>     *   there programmatically.
<a name="2225"></a>     */    
<a name="2226"></a>    maxBulkHiddenUnder = 100
<a name="2227"></a>    maxBulkHiddenBehind = 100
<a name="2228"></a>    maxBulkHiddenIn = 100
<a name="2229"></a>    
<a name="2230"></a>    /* The total bulk of items hidden in, under or behind this object */    
<a name="2231"></a>    getBulkHiddenUnder = (totalBulkIn(hiddenUnder))
<a name="2232"></a>    getBulkHiddenIn = (totalBulkIn(hiddenIn))
<a name="2233"></a>    getBulkHiddenBehind = (totalBulkIn(hiddenBehind))
<a name="2234"></a>    
<a name="2235"></a>    /* Calculate the total bulk of the items in lst */
<a name="2236"></a>    totalBulkIn(lst)
<a name="2237"></a>    {
<a name="2238"></a>        local totBulk = 0;
<a name="2239"></a>        for(local item in valToList(lst))
<a name="2240"></a>            totBulk += item.bulk;
<a name="2241"></a>        
<a name="2242"></a>        return totBulk;
<a name="2243"></a>    }
<a name="2244"></a>                          
<a name="2245"></a>    /* 
<a name="2246"></a>     *   Flag, do we want to treat this object as hidden from view (so that the
<a name="2247"></a>     *   player can't interact with it)?
<a name="2248"></a>     */
<a name="2249"></a>    isHidden = nil
<a name="2250"></a>    
<a name="2251"></a>    /* 
<a name="2252"></a>     *   Make a hidden item unhidden. If the method is called with the optional
<a name="2253"></a>     *   parameter and the parameter is nil, i.e. discover(nil), the method
<a name="2254"></a>     *   instead hides the object.
<a name="2255"></a>     */
<a name="2256"></a>    discover(stat = true)
<a name="2257"></a>    {
<a name="2258"></a>        isHidden = !stat;
<a name="2259"></a>        
<a name="2260"></a>        /* 
<a name="2261"></a>         *   If the player character can see me when I'm hidden, note that the
<a name="2262"></a>         *   player character has now seen me.
<a name="2263"></a>         */
<a name="2264"></a>        if(stat &amp;&amp; Q.canSee(gPlayerChar, self))
<a name="2265"></a>            noteSeen();
<a name="2266"></a>    }
<a name="2267"></a>       
<a name="2268"></a>    /* 
<a name="2269"></a>     *   The lockability property determines whether this object is lockable and
<a name="2270"></a>     *   if so how. The possible values are notLockable, lockableWithoutKey,
<a name="2271"></a>     *   lockableWithKey and indirectLockable.
<a name="2272"></a>     */    
<a name="2273"></a>    lockability = keyList == nil ? notLockable : lockableWithKey
<a name="2274"></a>    
<a name="2275"></a>    /* 
<a name="2276"></a>     *   Flag: is this object currently locked. By default we start out locked
<a name="2277"></a>     *   if we're lockable.
<a name="2278"></a>     */
<a name="2279"></a>    isLocked = lockability not in (nil, notLockable)
<a name="2280"></a>        
<a name="2281"></a>    /* 
<a name="2282"></a>     *   Make us locked or ublocked. We define this as a method so that
<a name="2283"></a>     *   subclasses such as Door can override to produce side effects (such as
<a name="2284"></a>     *   locking or unlocking the other side).
<a name="2285"></a>     */    
<a name="2286"></a>    makeLocked(stat)
<a name="2287"></a>    {
<a name="2288"></a>        isLocked = stat;
<a name="2289"></a>    }
<a name="2290"></a>    
<a name="2291"></a>    /* 
<a name="2292"></a>     *   Can this object be switched on and off? 
<a name="2293"></a>     */
<a name="2294"></a>    isSwitchable = nil
<a name="2295"></a>    
<a name="2296"></a>    /* is this item currently switched on? */
<a name="2297"></a>    isOn = nil
<a name="2298"></a>    
<a name="2299"></a>    /* switch this item on or off */
<a name="2300"></a>    makeOn(stat) { isOn = stat; }
<a name="2301"></a>    
<a name="2302"></a>    /* is this object something that can be worn */
<a name="2303"></a>    isWearable = nil
<a name="2304"></a>    
<a name="2305"></a>    /* 
<a name="2306"></a>     *   If this object is currently being worn by someone, the wornBy property
<a name="2307"></a>     *   contains the identity of the person wearing it.
<a name="2308"></a>     */
<a name="2309"></a>    wornBy = nil
<a name="2310"></a>    
<a name="2311"></a>    /* 
<a name="2312"></a>     *   Make this object worn or not worn. If this object is worn, note who     
<a name="2313"></a>     *   it's worn by. If stat is nil the object is no longer being worn.
<a name="2314"></a>     */    
<a name="2315"></a>    makeWorn(stat)  { wornBy = stat; }
<a name="2316"></a>    
<a name="2317"></a>    /* are we directly held by the given object? */
<a name="2318"></a>    isDirectlyHeldBy(obj) { return location == obj &amp;&amp; !isFixed &amp;&amp; wornBy == nil; }
<a name="2319"></a>
<a name="2320"></a>    /* 
<a name="2321"></a>     *   Get everything I'm directly holding, which is everything in my
<a name="2322"></a>     *   immediate contents which is neither fixed in place nor being worn.
<a name="2323"></a>     */
<a name="2324"></a>    directlyHeld = (contents.subset({ obj: !obj.isFixed &amp;&amp;
<a name="2325"></a>            obj.wornBy == nil }))
<a name="2326"></a>
<a name="2327"></a>    /* are we worn by the given object, directly or indirectly? */
<a name="2328"></a>    isWornBy(obj)
<a name="2329"></a>    {
<a name="2330"></a>        return (location == obj ? wornBy == obj :
<a name="2331"></a>                location != nil &amp;&amp; location.isWornBy(obj));
<a name="2332"></a>    }
<a name="2333"></a>
<a name="2334"></a>    /* are we directly worn by the given object? */
<a name="2335"></a>    isDirectlyWornBy(obj) { return location == obj &amp;&amp; wornBy == obj; }
<a name="2336"></a>
<a name="2337"></a>    /* get everything I'm directly wearing */
<a name="2338"></a>    directlyWorn = (contents.subset({ obj: obj.wornBy == self }))
<a name="2339"></a>    
<a name="2340"></a>    
<a name="2341"></a>    
<a name="2342"></a>    /* 
<a name="2343"></a>     *   Flag: can under objects be placed under us? By default they can if our
<a name="2344"></a>     *   contType is Under. If this is set to true and our contType is not
<a name="2345"></a>     *   Under, anything placed under us will be treated as hidden under.
<a name="2346"></a>     */
<a name="2347"></a>    canPutUnderMe = (contType == Under)
<a name="2348"></a>    
<a name="2349"></a>    /* 
<a name="2350"></a>     *   Flag: can under objects be placed behind us? By default they can if our
<a name="2351"></a>     *   contType is Behind. If this is set to true and our contType is not
<a name="2352"></a>     *   Behind, anything placed behind us will be treated as hidden behind.
<a name="2353"></a>     */
<a name="2354"></a>    canPutBehindMe = (contType == Behind)    
<a name="2355"></a>    
<a name="2356"></a>    /* 
<a name="2357"></a>     *   Flag: can under objects be placed inside us? By default they can if our
<a name="2358"></a>     *   contType is In. If this is set to true and our contType is not
<a name="2359"></a>     *   In, anything placed in us will be treated as hidden in.
<a name="2360"></a>     */
<a name="2361"></a>    canPutInMe = (contType == In)    
<a name="2362"></a>    
<a name="2363"></a>    
<a name="2364"></a>    /* 
<a name="2365"></a>     *   Can an actor enter (get in or on) this object. Note that for such an
<a name="2366"></a>     *   action to be allowing the contType must also match the proposed action.
<a name="2367"></a>     */    
<a name="2368"></a>    isBoardable = nil
<a name="2369"></a>    
<a name="2370"></a>    /* Flag: Can this thing be eaten */
<a name="2371"></a>    
<a name="2372"></a>    isEdible = nil  
<a name="2373"></a>   
<a name="2374"></a>    
<a name="2375"></a>    /*
<a name="2376"></a>     *   My nominal contents is the special contents item we can use in
<a name="2377"></a>     *   naming the object.  This is useful for containers whose identities
<a name="2378"></a>     *   come primarily from their contents, such as a vessel for liquids
<a name="2379"></a>     *   or a box of loose files.  Returns an object that qualifies the
<a name="2380"></a>     *   name: a "water" object for BOX OF WATER, a "files" object for BOX
<a name="2381"></a>     *   OF FILES.  Nil means that the object isn't named by its contents.
<a name="2382"></a>     *   
<a name="2383"></a>     *   Note that this is always a single object (or nil), not the whole
<a name="2384"></a>     *   list of contents.  We can only be named by one content object.
<a name="2385"></a>     *   (So you can't have a "box of books and papers" by having separate
<a name="2386"></a>     *   nominal contents objects for the books and the papers; although
<a name="2387"></a>     *   you could fake it by creating a "books and papers" object.)  
<a name="2388"></a>     */
<a name="2389"></a>    nominalContents = nil
<a name="2390"></a>
<a name="2391"></a>    /* 
<a name="2392"></a>     *   Can I be distinguished in parser messages by my contents?  If so,
<a name="2393"></a>     *   we can be distinguished (in parser messages) from similar objects
<a name="2394"></a>     *   by our contents, or lack thereof: "bucket of water" vs "empty
<a name="2395"></a>     *   bucket".  If this is true, our nominalContents property determines
<a name="2396"></a>     *   the contents we display for this.  
<a name="2397"></a>     */
<a name="2398"></a>    distinguishByContents = nil
<a name="2399"></a>
<a name="2400"></a>    
<a name="2401"></a>      /*
<a name="2402"></a>       *   This object's containment type - that is, the locType for direct
<a name="2403"></a>       *   children.  This is given as one of the spatial relation types (In,
<a name="2404"></a>       *   On, Under, Behind etc).      
<a name="2405"></a>       */
<a name="2406"></a>    contType = Outside
<a name="2407"></a>    
<a name="2408"></a>    
<a name="2409"></a>    /* The list of things directly contained by this object */
<a name="2410"></a>    contents = [ ]
<a name="2411"></a>    
<a name="2412"></a>    /* 
<a name="2413"></a>     *   The location of this object, i.e. this object's immediate container
<a name="2414"></a>     *   (which may be another Thing, a Room, or an Actor such as the player
<a name="2415"></a>     *   char). Note that while you should specify the initial location of an
<a name="2416"></a>     *   object via this property you should never directly alter this property
<a name="2417"></a>     *   in game code thereafter; to change the location on object during the
<a name="2418"></a>     *   the course of a game use the moveInto(loc) or actionMoveInto(loc)
<a name="2419"></a>     *   method.
<a name="2420"></a>     */
<a name="2421"></a>    location = nil
<a name="2422"></a>    
<a name="2423"></a>    /*  
<a name="2424"></a>     *   Add an item to this object's contents. Normally this method is used
<a name="2425"></a>     *   internally in the library than directly by game code. If the vec
<a name="2426"></a>     *   parameter is supplied, the object added to our contents is also added
<a name="2427"></a>     *   to vec; again this is intended primarily for internal use by the
<a name="2428"></a>     *   library.
<a name="2429"></a>     */
<a name="2430"></a>    addToContents(obj, vec?)
<a name="2431"></a>    {
<a name="2432"></a>        contents = contents.appendUnique([obj]);
<a name="2433"></a>        if(vec != nil)
<a name="2434"></a>            vec.appendUnique(self);
<a name="2435"></a>    }
<a name="2436"></a>    
<a name="2437"></a>    /*  
<a name="2438"></a>     *   Remove an item to this object's contents. Normally this method is used
<a name="2439"></a>     *   internally in the library than directly by game code. If the vec
<a name="2440"></a>     *   parameter is supplied, the object removed from our contents is also
<a name="2441"></a>     *   removed from vec; again this is intended primarily for internal use by
<a name="2442"></a>     *   the library.
<a name="2443"></a>     */
<a name="2444"></a>    removeFromContents(obj, vec?)
<a name="2445"></a>    {
<a name="2446"></a>        local idx = contents.indexOf(obj);
<a name="2447"></a>        if(idx != nil)
<a name="2448"></a>            contents = contents.removeElementAt(idx);
<a name="2449"></a>        
<a name="2450"></a>        if(vec != nil)
<a name="2451"></a>            vec.removeElement(self);
<a name="2452"></a>    }
<a name="2453"></a>
<a name="2454"></a>    /* 
<a name="2455"></a>     *   Basic moveInto for moving an object from one container to another by
<a name="2456"></a>     *   programmatic fiat.
<a name="2457"></a>     */    
<a name="2458"></a>    moveInto(newCont)
<a name="2459"></a>    {
<a name="2460"></a>        /* If we have a location, remove us from its list of contents. */
<a name="2461"></a>        if(location != nil)            
<a name="2462"></a>            location.removeFromContents(self);
<a name="2463"></a>        
<a name="2464"></a>        /* 
<a name="2465"></a>         *   If we have changed location, we are no longer being worn by our
<a name="2466"></a>         *   original location
<a name="2467"></a>         */
<a name="2468"></a>        if(newCont != location)
<a name="2469"></a>            wornBy = nil; 
<a name="2470"></a>        
<a name="2471"></a>        /* Set our new location. */
<a name="2472"></a>        location = newCont;
<a name="2473"></a>               
<a name="2474"></a>        /* 
<a name="2475"></a>         *   Provided our new location isn't nil, add us to our new location's
<a name="2476"></a>         *   list of contents.
<a name="2477"></a>         */
<a name="2478"></a>        if(location != nil)
<a name="2479"></a>            location.addToContents(self);        
<a name="2480"></a>    }
<a name="2481"></a>    
<a name="2482"></a>    /* Move into generated by a user action, which includes notifications */
<a name="2483"></a>    actionMoveInto(newCont)
<a name="2484"></a>    {
<a name="2485"></a>        /* 
<a name="2486"></a>         *   If we have a location, notify our existing location that we're
<a name="2487"></a>         *   about to be removed from it.
<a name="2488"></a>         */
<a name="2489"></a>        if(location != nil)
<a name="2490"></a>            location.notifyRemove(self);            
<a name="2491"></a>        
<a name="2492"></a>        /* 
<a name="2493"></a>         *   If the location we're about to be moved into is non-nil, notify our
<a name="2494"></a>         *   new location that we're about to be moved into it. Note that both
<a name="2495"></a>         *   this and the previous notification can veto the move with an exit
<a name="2496"></a>         *   command.
<a name="2497"></a>         */
<a name="2498"></a>        if(newCont != nil)
<a name="2499"></a>            newCont.notifyInsert(self); 
<a name="2500"></a>        
<a name="2501"></a>        /* Carry out the move. */
<a name="2502"></a>        moveInto(newCont);
<a name="2503"></a>        
<a name="2504"></a>        /* Note that we have been moved. */
<a name="2505"></a>        moved = true;
<a name="2506"></a>        
<a name="2507"></a>        /* If the player character can now see us, note that we've been seen */
<a name="2508"></a>        if(Q.canSee(gPlayerChar, self))
<a name="2509"></a>            noteSeen();
<a name="2510"></a>    }
<a name="2511"></a>    
<a name="2512"></a>    /* 
<a name="2513"></a>     *   Receive notification that obj is about to be removed from inside us; by default we do
<a name="2514"></a>     *   nothing. Do NOT use this method to prevent the removal of the object from us; use
<a name="2515"></a>     *   checkRemove(obj) instead.
<a name="2516"></a>     */
<a name="2517"></a>    notifyRemove(obj) { }
<a name="2518"></a>    
<a name="2519"></a>    /* 
<a name="2520"></a>     *   checkRemove is called from the check stage of an action (typically TAKE) that might remove
<a name="2521"></a>     *   obj from me. If it wants to object to the removal of the object, it should simply display a
<a name="2522"></a>     *   message explaining why. By default we call the same method our container to check whether
<a name="2523"></a>     *   anything in our containment hierarchy objects to the removal. If this method is overridden
<a name="2524"></a>     *   in game code it may only need to call inherited(obj) on any branch that doesn't itself
<a name="2525"></a>     *   object to the removal.
<a name="2526"></a>     */
<a name="2527"></a>    checkRemove(obj) 
<a name="2528"></a>    {  
<a name="2529"></a>        if(location)
<a name="2530"></a>            location.checkRemove(obj); 
<a name="2531"></a>    }
<a name="2532"></a>    
<a name="2533"></a>    /* 
<a name="2534"></a>     *   Receive notification that obj is about to be inserted into us; by
<a name="2535"></a>     *   default we do nothing.
<a name="2536"></a>     */
<a name="2537"></a>    notifyInsert(obj) { }
<a name="2538"></a>    
<a name="2539"></a>    
<a name="2540"></a>    /* 
<a name="2541"></a>     *   Move a MultiLoc (ml) into this additional Thing or Room, by adding it
<a name="2542"></a>     *   to this thing's contents list and adding the Thing to ml's
<a name="2543"></a>     *   locationList.
<a name="2544"></a>     */
<a name="2545"></a>    moveMLIntoAdd(ml)
<a name="2546"></a>    {
<a name="2547"></a>        if(contents.indexOf(ml) == nil)
<a name="2548"></a>            addToContents(ml);     
<a name="2549"></a>        
<a name="2550"></a>        
<a name="2551"></a>        if(ml.locationList.indexOf(self) == nil)
<a name="2552"></a>            ml.locationList += self;
<a name="2553"></a>    }
<a name="2554"></a>    
<a name="2555"></a>    /*  
<a name="2556"></a>     *   Move a MultiLoc (ml) out of this object, by removing it from our
<a name="2557"></a>     *   contents list and removing us from its locationList.
<a name="2558"></a>     */
<a name="2559"></a>    moveMLOutOf(ml)
<a name="2560"></a>    {
<a name="2561"></a>        removeFromContents(ml);  
<a name="2562"></a>        
<a name="2563"></a>        ml.locationList -= self;    
<a name="2564"></a>    }
<a name="2565"></a>    
<a name="2566"></a>    
<a name="2567"></a>    
<a name="2568"></a>    /* Is obj visible from us? */
<a name="2569"></a>    canSee(obj) { return Q.canSee(self, obj); }
<a name="2570"></a>    
<a name="2571"></a>    /* Is obj audible from us? */
<a name="2572"></a>    canHear(obj) { return Q.canHear(self, obj); }
<a name="2573"></a>    
<a name="2574"></a>    /* Is obj smellable from us? */
<a name="2575"></a>    canSmell(obj) { return Q.canSmell(self, obj); }
<a name="2576"></a>    
<a name="2577"></a>    /* Is obj reachable (by touch) from us? */
<a name="2578"></a>    canReach(obj) { return Q.canReach(self, obj); }
<a name="2579"></a>    
<a name="2580"></a>    
<a name="2581"></a>     /* 
<a name="2582"></a>     *   Are we a containment "child" of the given object with the given
<a name="2583"></a>     *   location type?  This returns true if our location is the given
<a name="2584"></a>     *   object and our locType is the given type, or our location is a
<a name="2585"></a>     *   containment child of the given object with the given type.
<a name="2586"></a>     *   
<a name="2587"></a>     *   'typ' is a LocType giving the relationship to test for, or nil.
<a name="2588"></a>     *   If it's nil, we'll return true if we have any containment
<a name="2589"></a>     *   relationship to 'obj'.  
<a name="2590"></a>     */
<a name="2591"></a>    isChild(obj, typ)    
<a name="2592"></a>    {
<a name="2593"></a>        /* 
<a name="2594"></a>         *   If the typ we're testing for is neither nil nor the containment
<a name="2595"></a>         *   type of obj, return nil.
<a name="2596"></a>         */
<a name="2597"></a>        if(typ not in (nil, obj.contType))
<a name="2598"></a>            return nil;
<a name="2599"></a>        
<a name="2600"></a>        /* Otherwise return whether or not we're in obj. */
<a name="2601"></a>        return isIn(obj);
<a name="2602"></a>    }
<a name="2603"></a>
<a name="2604"></a>    /* 
<a name="2605"></a>     *   Are we a direct containment child of the given object with the
<a name="2606"></a>     *   given containment type?  'typ' is a LocType giving the
<a name="2607"></a>     *   relationship to test for, or nil.  If it's nil, we'll return true
<a name="2608"></a>     *   if we have any direct containment relationship with 'obj'. 
<a name="2609"></a>     */
<a name="2610"></a>    isDirectChild(obj, typ)
<a name="2611"></a>    {
<a name="2612"></a>        /* 
<a name="2613"></a>         *   If the typ we're testing for is neither nil nor the containment
<a name="2614"></a>         *   type of obj, return nil.
<a name="2615"></a>         */
<a name="2616"></a>        if(typ not in (nil, obj.contType))
<a name="2617"></a>            return nil;
<a name="2618"></a>        
<a name="2619"></a>        /* Otherwise return whether or not we're directly in obj. */
<a name="2620"></a>        return isDirectlyIn(obj);
<a name="2621"></a>    }
<a name="2622"></a>    
<a name="2623"></a>    
<a name="2624"></a>    /*  Are we directly in cont? */
<a name="2625"></a>    isDirectlyIn(cont)
<a name="2626"></a>    {
<a name="2627"></a>        /* If cont is nil then we're in cont if our location is nil. */
<a name="2628"></a>        if(cont == nil)
<a name="2629"></a>            return location == nil;
<a name="2630"></a>        
<a name="2631"></a>        /* 
<a name="2632"></a>         *   Otherwise we're directly in cont either if our location is cont or
<a name="2633"></a>         *   if we're in cont's contents list (the latter test caters for
<a name="2634"></a>         *   MultiLocs).
<a name="2635"></a>         */
<a name="2636"></a>        return location == cont || valToList(cont.contents).indexOf(self) != nil;
<a name="2637"></a>    }
<a name="2638"></a>    
<a name="2639"></a>    /* Are we in cont? */
<a name="2640"></a>    isIn(cont)
<a name="2641"></a>    {
<a name="2642"></a>        /* If we're directly in cont, then we're certainly in cont. */
<a name="2643"></a>        if(isDirectlyIn(cont))
<a name="2644"></a>            return true;
<a name="2645"></a>        
<a name="2646"></a>        /* Otherwise if out location is nil, we're not in cont */
<a name="2647"></a>        if(location == nil)
<a name="2648"></a>            return nil;
<a name="2649"></a>        
<a name="2650"></a>        /* Otherwise we're in cont if our location is in cont. */
<a name="2651"></a>        return location.isIn(cont);
<a name="2652"></a>    }
<a name="2653"></a>    
<a name="2654"></a>    /* Are either oont or in cont ? */
<a name="2655"></a>    isOrIsIn(cont)
<a name="2656"></a>    {
<a name="2657"></a>        return self == cont || isIn(cont);
<a name="2658"></a>    }
<a name="2659"></a>    
<a name="2660"></a>     /*
<a name="2661"></a>     *   Get my list of enclosed direct contents.  This is the subset of my
<a name="2662"></a>     *   direct contents that have interior location types (In).  
<a name="2663"></a>     */
<a name="2664"></a>    intContents = ( contType == In ? contents : [] )
<a name="2665"></a>
<a name="2666"></a>    /*
<a name="2667"></a>     *   Get my list of unenclosed direct contents.  This is the subset of
<a name="2668"></a>     *   my direct contents that have exterior location types (On, Outside,
<a name="2669"></a>     *   Behind, Under). 
<a name="2670"></a>     */
<a name="2671"></a>    extContents = ( contType == In ? [] : contents)
<a name="2672"></a>
<a name="2673"></a>    /* 
<a name="2674"></a>     *   The isInitialPlayerChar property was formerly used as an alternative method of identifying
<a name="2675"></a>     *   the player character. This method of doing so is now deprecated, except for its use on the
<a name="2676"></a>     *   Player class. Instead you should now define the player character on
<a name="2677"></a>     *   gameMain.initialPlayerChar
<a name="2678"></a>     */    
<a name="2679"></a>    isInitialPlayerChar = nil
<a name="2680"></a>    
<a name="2681"></a>    /* Carry out the preinitialization of a Thing */
<a name="2682"></a>    preinitThing()
<a name="2683"></a>    {
<a name="2684"></a>        /*    
<a name="2685"></a>         *   If I am meant to be the initial player character and gameMain does
<a name="2686"></a>         *   not already define another one, register this object as the initial
<a name="2687"></a>         *   player character.
<a name="2688"></a>         */
<a name="2689"></a>        if(isInitialPlayerChar &amp;&amp; gameMain.propType(&amp;initialPlayerChar) != TypeObject)
<a name="2690"></a>        {
<a name="2691"></a>            /* Register me as the initial player character on gameMain */
<a name="2692"></a>            gameMain.initialPlayerChar = self;
<a name="2693"></a>            
<a name="2694"></a>            /* Register me as the current player character on libGlobal */
<a name="2695"></a>            gPlayerChar = gameMain.initialPlayerChar;
<a name="2696"></a>        }
<a name="2697"></a>        
<a name="2698"></a>        
<a name="2699"></a>        /* 
<a name="2700"></a>         *   If we have both a location and a subLocation (which should be a
<a name="2701"></a>         *   property pointer if it's not nil), change our location to the
<a name="2702"></a>         *   object defined on the subLocation property of our location; this is
<a name="2703"></a>         *   used to place objects in the SubComponents of their parent objects.
<a name="2704"></a>         */
<a name="2705"></a>        if(subLocation != nil &amp;&amp; location != nil)
<a name="2706"></a>            location = location.(subLocation);
<a name="2707"></a>        
<a name="2708"></a>        /*   If we have a location, add ourselves to its contents list. */
<a name="2709"></a>        if(location != nil)
<a name="2710"></a>            location.addToContents(self);
<a name="2711"></a>        
<a name="2712"></a>        /* if we have a global parameter name, add it to the global table */
<a name="2713"></a>        if (globalParamName != nil)
<a name="2714"></a>            libGlobal.nameTable_[globalParamName] = self;
<a name="2715"></a>        
<a name="2716"></a>        /* If our owner property isn't already a list, convert it to one. */
<a name="2717"></a>        owner = valToList(owner);
<a name="2718"></a>        
<a name="2719"></a>        /* If we have a keyList, add ourselves to every key in the list */
<a name="2720"></a>        if(keyList != nil)
<a name="2721"></a>        {
<a name="2722"></a>            foreach(local key in valToList(keyList))
<a name="2723"></a>            {
<a name="2724"></a>                if(key.ofKind(Key))
<a name="2725"></a>                {
<a name="2726"></a>                    key.actualLockList = key.actualLockList.appendUnique([self]);
<a name="2727"></a>                    key.plausibleLockList = key.plausibleLockList.appendUnique([self]);
<a name="2728"></a>                }
<a name="2729"></a>            }
<a name="2730"></a>            
<a name="2731"></a>            foreach(local key in valToList(knownKeyList))
<a name="2732"></a>            {
<a name="2733"></a>                if(key.ofKind(Key))
<a name="2734"></a>                {
<a name="2735"></a>                    key.knownLockList = key.knownLockList.appendUnique([self]);                    
<a name="2736"></a>                }
<a name="2737"></a>            }       
<a name="2738"></a>                    
<a name="2739"></a>        }
<a name="2740"></a>        
<a name="2741"></a>        /* 
<a name="2742"></a>         *   if we have any remapXXX properties, set those objects to the same
<a name="2743"></a>         *   listOrder as our own, since they're effectively representations of
<a name="2744"></a>         *   ourself.
<a name="2745"></a>         */
<a name="2746"></a>        
<a name="2747"></a>        for(local prop in remapProps)
<a name="2748"></a>        {
<a name="2749"></a>            local obj = self.(prop);
<a name="2750"></a>            if(obj)
<a name="2751"></a>                obj.listOrder = listOrder;
<a name="2752"></a>        }
<a name="2753"></a>        
<a name="2754"></a>        /* Set us as knowning about everything in our initiallyKnown lisr. */
<a name="2755"></a>        foreach(local item in valToList(initiallyKnowsAbout))
<a name="2756"></a>            setKnowsAbout(item);
<a name="2757"></a>        
<a name="2758"></a>
<a name="2759"></a>        /* 
<a name="2760"></a>         *   If we're compiling for debug, warn the user if s/he's used the
<a name="2761"></a>         *   canSitOn, canLieOn or canStand on properties in an inconsistent
<a name="2762"></a>         *   manner.
<a name="2763"></a>         */
<a name="2764"></a>#ifdef __DEBUG
<a name="2765"></a>        if(isBoardable == nil &amp;&amp; contType != On)
<a name="2766"></a>        {
<a name="2767"></a>            if(canSitOnMe)
<a name="2768"></a>                "WARNING! canSitOnMe is true on &lt;&lt;theName&gt;&gt; when &lt;&lt;theName&gt;&gt;
<a name="2769"></a>                cannot be boarded.\n";
<a name="2770"></a>            if(canStandOnMe)
<a name="2771"></a>                "WARNING! canStandOnMe is true on &lt;&lt;theName&gt;&gt; when &lt;&lt;theName&gt;&gt;
<a name="2772"></a>                cannot be boarded.\n";
<a name="2773"></a>            if(canLieOnMe)
<a name="2774"></a>                "WARNING! canLieOnMe is true on &lt;&lt;theName&gt;&gt; when &lt;&lt;theName&gt;&gt;
<a name="2775"></a>                cannot be boarded.\n";
<a name="2776"></a>            
<a name="2777"></a>            if(canSitOnMe || canStandOnMe || canLieOnMe)
<a name="2778"></a>                "You either need to make &lt;&lt;objToString()&gt;&gt; a Platform or remove
<a name="2779"></a>                your override on its canSit/Stand/LieOnMe properties\b";
<a name="2780"></a>        }
<a name="2781"></a>        
<a name="2782"></a>        
<a name="2783"></a>#endif
<a name="2784"></a>    }
<a name="2785"></a>    
<a name="2786"></a>    /* 
<a name="2787"></a>     *   Our outermost room, i.e. the top level Room in which we are indirectly
<a name="2788"></a>     *   or directly contained.
<a name="2789"></a>     */
<a name="2790"></a>    getOutermostRoom = (location == nil ? nil : location.getOutermostRoom)
<a name="2791"></a>    
<a name="2792"></a>    
<a name="2793"></a>    interiorParent()
<a name="2794"></a>    {
<a name="2795"></a>        /* if I don't have a location, there's no interior parent */
<a name="2796"></a>        if (location == nil)
<a name="2797"></a>            return nil;
<a name="2798"></a>
<a name="2799"></a>        /* if my immediate location is interior, it's the interior parent */
<a name="2800"></a>        if (location.contType == In || location.ofKind(Room))
<a name="2801"></a>            return location;
<a name="2802"></a>
<a name="2803"></a>        /* otherwise, it's my parent's interior parent */
<a name="2804"></a>        return location.interiorParent();
<a name="2805"></a>    }
<a name="2806"></a>    
<a name="2807"></a>    /* 
<a name="2808"></a>     *   Am I on the inside of the given object?  This returns true if our
<a name="2809"></a>     *   relationship to the given object is an interior location type. 
<a name="2810"></a>     */
<a name="2811"></a>    isInterior(obj)
<a name="2812"></a>    {
<a name="2813"></a>        if(location == nil)
<a name="2814"></a>            return nil;
<a name="2815"></a>        
<a name="2816"></a>        if(location == obj &amp;&amp; obj.contType == In)
<a name="2817"></a>            return true;
<a name="2818"></a>        
<a name="2819"></a>        if(location.ofKind(SubComponent) &amp;&amp; location.contType == In &amp;&amp;
<a name="2820"></a>           location.lexicalParent == obj)
<a name="2821"></a>            return true;
<a name="2822"></a>        
<a name="2823"></a>        return location.isInterior(obj);
<a name="2824"></a>    }
<a name="2825"></a>    
<a name="2826"></a>    /*
<a name="2827"></a>     *   Find the immediate child of 'self' that contains 'other'.  If
<a name="2828"></a>     *   'other' is directly in 'self', we return 'other'; otherwise, we
<a name="2829"></a>     *   return an object directly within 'self' that contains 'obj',
<a name="2830"></a>     *   directly or indirectly.  If 'other' is not within 'self', we
<a name="2831"></a>     *   return nil.  
<a name="2832"></a>     */
<a name="2833"></a>    directChildParent(other)
<a name="2834"></a>    {
<a name="2835"></a>        /* scan other's parent chain until we find a direct child of self */
<a name="2836"></a>        for (local o = other ; o != nil ; o = o.location)
<a name="2837"></a>        {
<a name="2838"></a>            if (o.location == self)
<a name="2839"></a>                return o;
<a name="2840"></a>        }
<a name="2841"></a>
<a name="2842"></a>        /* 'other' is not a child */
<a name="2843"></a>        return nil;
<a name="2844"></a>    }
<a name="2845"></a>    
<a name="2846"></a>      /*
<a name="2847"></a>     *   Get the containment relationship between 'child' and 'self'.  This
<a name="2848"></a>     *   returns the containment type of the immediate child of 'self' that
<a name="2849"></a>     *   contains 'child'.
<a name="2850"></a>     */
<a name="2851"></a>    childLocType(child)
<a name="2852"></a>    {
<a name="2853"></a>        /* get the direct child of self containing child */
<a name="2854"></a>        child = directChildParent(child);
<a name="2855"></a>
<a name="2856"></a>        /* 
<a name="2857"></a>         *   If we found the direct child container, the containment
<a name="2858"></a>         *   relationship is the one between 'self' and the direct child;
<a name="2859"></a>         *   otherwise there's no relationship.  
<a name="2860"></a>         */
<a name="2861"></a>        return (child != nil ? child.locType : nil);
<a name="2862"></a>    }
<a name="2863"></a>    
<a name="2864"></a>    /* 
<a name="2865"></a>     *   Find the nearest common containing parent of self and other. Unlike
<a name="2866"></a>     *   commonInteriorParent this doesn't take account of the type of
<a name="2867"></a>     *   containment (it can be In, On, Under, Behind or anything else) just so
<a name="2868"></a>     *   long as we find a common parent in the containment hierarchy.
<a name="2869"></a>     */    
<a name="2870"></a>    commonContainingParent(other)
<a name="2871"></a>    {
<a name="2872"></a>        /* start at each object's nearest direct parent */
<a name="2873"></a>        local l1 = location;
<a name="2874"></a>        local l2 = other.location;
<a name="2875"></a>        
<a name="2876"></a>         /* 
<a name="2877"></a>          *   if one or the other doesn't have a location, there's no common
<a name="2878"></a>          *   parent.
<a name="2879"></a>          */
<a name="2880"></a>        
<a name="2881"></a>        if(l1 == nil || l2 == nil)
<a name="2882"></a>            return nil;
<a name="2883"></a>        
<a name="2884"></a>         /* work up the containment tree one parent at a time */
<a name="2885"></a>        while (l1 != nil || l2 != nil)
<a name="2886"></a>        {
<a name="2887"></a>            /* if I'm inside the current other parent, that's the common one */
<a name="2888"></a>            if (l2 != nil &amp;&amp; isIn(l2))
<a name="2889"></a>                return l2;
<a name="2890"></a>
<a name="2891"></a>            /* if other is in my current parent, that's the nearest one */
<a name="2892"></a>            if (l1 != nil &amp;&amp; other.isIn(l1))
<a name="2893"></a>                return l1;
<a name="2894"></a>            
<a name="2895"></a>            /* move up one level */
<a name="2896"></a>            l1 = (l1 != nil ? l1.location : nil);
<a name="2897"></a>            l2 = (l2 != nil ? l2.location : nil);
<a name="2898"></a>        }
<a name="2899"></a>
<a name="2900"></a>        /* there's no common parent */
<a name="2901"></a>        return nil;
<a name="2902"></a>    }
<a name="2903"></a>    
<a name="2904"></a>    
<a name="2905"></a>   /*
<a name="2906"></a>     *   Find the nearest common interior parent of self and other.  This
<a name="2907"></a>     *   finds the nearest parent that both self and other are inside of.  
<a name="2908"></a>     */
<a name="2909"></a>    commonInteriorParent(other)
<a name="2910"></a>    {
<a name="2911"></a>        /* start at each object's nearest interior parent */
<a name="2912"></a>        local l1 = interiorParent();
<a name="2913"></a>        local l2 = other.interiorParent();
<a name="2914"></a>        
<a name="2915"></a>        /* 
<a name="2916"></a>         *   if one or the other doesn't have an interior parent, there's no
<a name="2917"></a>         *   common parent.
<a name="2918"></a>         */
<a name="2919"></a>        
<a name="2920"></a>        if(l1 == nil || l2 == nil)
<a name="2921"></a>            return nil;
<a name="2922"></a>        
<a name="2923"></a>        /* work up the containment tree one interior at a time */
<a name="2924"></a>        while (l1 != nil || l2 != nil)
<a name="2925"></a>        {
<a name="2926"></a>            /* if I'm inside the current other parent, that's the common one */
<a name="2927"></a>            if (l2 != nil &amp;&amp; isInterior(l2))
<a name="2928"></a>                return l2;
<a name="2929"></a>
<a name="2930"></a>            /* if other is in my current parent, that's the nearest one */
<a name="2931"></a>            if (l1 != nil &amp;&amp; other.isInterior(l1))
<a name="2932"></a>                return l1;
<a name="2933"></a>            
<a name="2934"></a>            /* move up one level */
<a name="2935"></a>            l1 = (l1 != nil ? l1.interiorParent() : nil);
<a name="2936"></a>            l2 = (l2 != nil ? l2.interiorParent() : nil);
<a name="2937"></a>        }
<a name="2938"></a>
<a name="2939"></a>        /* there's no common parent */
<a name="2940"></a>        return nil;
<a name="2941"></a>    }
<a name="2942"></a>    
<a name="2943"></a>    
<a name="2944"></a>    /*
<a name="2945"></a>     *   Get the interior containment path from 'self' to 'other'.  This
<a name="2946"></a>     *   returns a list containing three elements.  The first element is a
<a name="2947"></a>     *   sublist giving the interior containers you have to traverse
<a name="2948"></a>     *   outwards from self up to the common interior parent.  The second
<a name="2949"></a>     *   element is the common container; this will be nil if the two
<a name="2950"></a>     *   objects are in separate rooms.  The third element is a sublist
<a name="2951"></a>     *   giving the containers you have to traverse inwards from the common
<a name="2952"></a>     *   parent to other.  
<a name="2953"></a>     */
<a name="2954"></a>    containerPath(other)
<a name="2955"></a>    {
<a name="2956"></a>        /* set up vectors for the outward and inward paths */
<a name="2957"></a>        local outPath = new Vector(10), inPath = new Vector(10);
<a name="2958"></a>
<a name="2959"></a>        /* set up a variable for the common parent */
<a name="2960"></a>        local commonPar = nil;
<a name="2961"></a>
<a name="2962"></a>        /* trace the paths, accumulating the elements in the vectors */
<a name="2963"></a>        traceContainerPath(
<a name="2964"></a>            other,
<a name="2965"></a>            { c: outPath.append(c) },
<a name="2966"></a>            { c: commonPar = c },
<a name="2967"></a>            { c: inPath.append(c) });
<a name="2968"></a>
<a name="2969"></a>        /* return the lists */
<a name="2970"></a>        return [outPath.toList(), commonPar, inPath.toList()];
<a name="2971"></a>    }
<a name="2972"></a>    
<a name="2973"></a>    /*
<a name="2974"></a>     *   Trace the interior containment path from 'self' to 'other'.
<a name="2975"></a>     *   
<a name="2976"></a>     *   We'll start by working up the containment tree from 'self' to the
<a name="2977"></a>     *   nearest interior container we have in common with 'other' - that
<a name="2978"></a>     *   is, the nearest object that contains both 'self' and 'other' with
<a name="2979"></a>     *   an interior location type for each object.  For each container
<a name="2980"></a>     *   BELOW the common parent, we call outFunc(container).
<a name="2981"></a>     *   
<a name="2982"></a>     *   Next, we call parentFunc(container) on the common container.  If
<a name="2983"></a>     *   there is no common container, we call parentFunc(nil).
<a name="2984"></a>     *   
<a name="2985"></a>     *   Next, we work back down the containment tree from the common
<a name="2986"></a>     *   parent to 'other'.  For each container below the common parent, we
<a name="2987"></a>     *   call inFunc(container).
<a name="2988"></a>     */
<a name="2989"></a>    traceContainerPath(other, outFunc, parentFunc, inFunc)
<a name="2990"></a>    {
<a name="2991"></a>        /* find the nearest common enclosing container */
<a name="2992"></a>        local cpar = commonInteriorParent(other);
<a name="2993"></a>
<a name="2994"></a>        /* work up from self to the common parent */
<a name="2995"></a>        for (local c = interiorParent() ; c != cpar ; c = c.interiorParent())
<a name="2996"></a>            outFunc(c);
<a name="2997"></a>
<a name="2998"></a>        /* call the common parent callback */
<a name="2999"></a>        parentFunc(cpar);
<a name="3000"></a>
<a name="3001"></a>        /* 
<a name="3002"></a>         *   Work back down from the common parent to other.  The easy way
<a name="3003"></a>         *   to do this is to build a stack from other up to cpar, then
<a name="3004"></a>         *   work back through the stack.  
<a name="3005"></a>         */
<a name="3006"></a>        local stk = new Vector(10);
<a name="3007"></a>        for (local c = other.interiorParent() ; c != cpar ; 
<a name="3008"></a>             c = c.interiorParent())
<a name="3009"></a>            stk.push(c);
<a name="3010"></a>        
<a name="3011"></a>        /* work back through the stack */
<a name="3012"></a>        while (!stk.isEmpty())
<a name="3013"></a>            inFunc(stk.pop());
<a name="3014"></a>    }
<a name="3015"></a>    
<a name="3016"></a>    /*
<a name="3017"></a>     *   Search for a "blockage" along the container path between 'self'
<a name="3018"></a>     *   and 'other'.  'outProp' and 'inProp' are "can" properties
<a name="3019"></a>     *   (&amp;canSeeOut, &amp;canReachIn, etc) that test a container to see
<a name="3020"></a>     *   whether we can see/reach/hear/etc in or out of the container.
<a name="3021"></a>     *   
<a name="3022"></a>     *   We trace the containment path, using traceContainerPath().  For
<a name="3023"></a>     *   each outbound container on the path, we evaluate the container's
<a name="3024"></a>     *   outProp property: if this is nil, we add that container to the
<a name="3025"></a>     *   blockage list.  Next, if there's no common parent, we add the
<a name="3026"></a>     *   outermost room containing 'self' to the list.  Next, we trace the
<a name="3027"></a>     *   inbound path, evaluating each container's inProp property: if nil,
<a name="3028"></a>     *   we add that container to the blockage list.
<a name="3029"></a>     *   
<a name="3030"></a>     *   Finally, we return the blockage list.  This is a vector giving all
<a name="3031"></a>     *   of the blockages we found, in the order we encountered them.  
<a name="3032"></a>     */
<a name="3033"></a>    containerPathBlock(other, inProp, outProp)
<a name="3034"></a>    {
<a name="3035"></a>        /* set up a vector for the blockage list */
<a name="3036"></a>        local vec = new Vector(10);
<a name="3037"></a>
<a name="3038"></a>        /* trace the path, noting each blockage */
<a name="3039"></a>        traceContainerPath(
<a name="3040"></a>            other,
<a name="3041"></a>            new function(c) { if (!c.(inProp)) vec.append(c); },
<a name="3042"></a>            new function(c) { if (c == nil &amp;&amp; outermostParent) vec.append(outermostParent()); },
<a name="3043"></a>            new function(c) { if (!c.(outProp)) vec.append(c); });
<a name="3044"></a>
<a name="3045"></a>        /* return the path */
<a name="3046"></a>        return vec;
<a name="3047"></a>    }
<a name="3048"></a>
<a name="3049"></a>    /*
<a name="3050"></a>     *   Get the first blockage in a container path.  This calls
<a name="3051"></a>     *   containerPathBlock() and returns the first blockage in the list,
<a name="3052"></a>     *   or nil if there's no blockage.  
<a name="3053"></a>     */
<a name="3054"></a>    firstContainerPathBlock(other, inProp, outProp)
<a name="3055"></a>    {
<a name="3056"></a>        local v = containerPathBlock(other, inProp, outProp);
<a name="3057"></a>        return (v.length() != 0 ? v[1] : nil);
<a name="3058"></a>    }
<a name="3059"></a>
<a name="3060"></a>        
<a name="3061"></a>    outermostVisibleParent()
<a name="3062"></a>    {
<a name="3063"></a>        /* 
<a name="3064"></a>         *   our "eyes" are on our outside, so we can always see our own
<a name="3065"></a>         *   parent; find its outermost visible container 
<a name="3066"></a>         */
<a name="3067"></a>        local loc;
<a name="3068"></a>        for (loc = location ; loc != nil ; loc = loc.location)
<a name="3069"></a>        {
<a name="3070"></a>            /* if this is the outermost container, we're done */
<a name="3071"></a>            if (loc.location == nil)
<a name="3072"></a>                break;
<a name="3073"></a>
<a name="3074"></a>            /* if we can't see out to our next container, stop here */
<a name="3075"></a>            if (loc.contType == In &amp;&amp; !loc.canSeeOut)
<a name="3076"></a>                break;
<a name="3077"></a>        }
<a name="3078"></a>
<a name="3079"></a>        /* return what we found */
<a name="3080"></a>        return loc;
<a name="3081"></a>        
<a name="3082"></a>
<a name="3083"></a>    }
<a name="3084"></a>    
<a name="3085"></a>    /* 
<a name="3086"></a>     *   Our location type with respect to our immediate container; e.g. are we
<a name="3087"></a>     *   In, On, Under or Behind it?
<a name="3088"></a>     */
<a name="3089"></a>    locType()
<a name="3090"></a>    {
<a name="3091"></a>        /* If we don't have a location we can't have a locType */        
<a name="3092"></a>        if(location == nil)
<a name="3093"></a>            return nil;
<a name="3094"></a>        
<a name="3095"></a>        /* 
<a name="3096"></a>         *   If our location is a Carrier then our locType depends on other
<a name="3097"></a>         *   factors.
<a name="3098"></a>         */
<a name="3099"></a>        if(location.contType == Carrier)
<a name="3100"></a>        {
<a name="3101"></a>            /* If we're worn by our location then our locType is Worn. */
<a name="3102"></a>            if(wornBy == location)
<a name="3103"></a>                return Worn;
<a name="3104"></a>            
<a name="3105"></a>            /* 
<a name="3106"></a>             *   Otherwise, if we're fixed in place we're a component of our
<a name="3107"></a>             *   location (i.e. a part of the actor that's our location), so our
<a name="3108"></a>             *   locType is Outside (we're attached to but external to our
<a name="3109"></a>             *   location
<a name="3110"></a>             */
<a name="3111"></a>            if(isFixed)
<a name="3112"></a>                return Outside;
<a name="3113"></a>            
<a name="3114"></a>            /*  Otherwise, if we're a portable object, we're being carried. */
<a name="3115"></a>            return Held;
<a name="3116"></a>        }
<a name="3117"></a>        
<a name="3118"></a>        /* Otherwise our locType is simply our location's contType. */
<a name="3119"></a>        else return location.contType;      
<a name="3120"></a>    }
<a name="3121"></a>    
<a name="3122"></a>     /*
<a name="3123"></a>     *   Get my outermost parent.  This is simply our ancestor in the
<a name="3124"></a>     *   location tree that has no location itself. 
<a name="3125"></a>     */
<a name="3126"></a>    outermostParent()
<a name="3127"></a>    {
<a name="3128"></a>        return locationWhich({ p: p.location == nil });
<a name="3129"></a>    }
<a name="3130"></a>    
<a name="3131"></a>    /* are we on the exterior of the given object, directly or indirectly? */
<a name="3132"></a>    isOutside(obj)
<a name="3133"></a>    {
<a name="3134"></a>        return (location == obj ? locType == Outside :
<a name="3135"></a>                location != nil &amp;&amp; location.isOutside(obj));
<a name="3136"></a>    }
<a name="3137"></a>    
<a name="3138"></a>
<a name="3139"></a>    /* are we held by the given object, directly or indirectly? */
<a name="3140"></a>    isHeldBy(obj)
<a name="3141"></a>    {
<a name="3142"></a>        return (location == obj ? locType == Held :
<a name="3143"></a>                location != nil &amp;&amp; location.isHeldBy(obj));
<a name="3144"></a>    }
<a name="3145"></a>
<a name="3146"></a>
<a name="3147"></a>    /* 
<a name="3148"></a>     *   Flag; is this Thing a vehicle for an actor? If so then issuing a travel
<a name="3149"></a>     *   command while in this vehicle will call this vehicle to travel
<a name="3150"></a>     */
<a name="3151"></a>    isVehicle = nil
<a name="3152"></a>    
<a name="3153"></a>    /*
<a name="3154"></a>     *   The nested room subhead.  This shows a little addendum to the room
<a name="3155"></a>     *   headline when the point-of-view actor is inside an object within
<a name="3156"></a>     *   the main room, such as a chair or platform.  This usually shows
<a name="3157"></a>     *   something of the form "(in the chair)".  Note that only the
<a name="3158"></a>     *   *immediate* container is shown; if the actor is in a chair in a
<a name="3159"></a>     *   booth on a stage, we normally only mention the chair.
<a name="3160"></a>     *   
<a name="3161"></a>     *   We leave this to the language library to define, since the exact
<a name="3162"></a>     *   syntax varies by language.  
<a name="3163"></a>     */
<a name="3164"></a>    // roomSubhead(pov) { }
<a name="3165"></a>
<a name="3166"></a>   
<a name="3167"></a>    /*
<a name="3168"></a>     *   Listing order.  This is an integer giving the relative position of
<a name="3169"></a>     *   this item in a miscellaneous item list.  The list is sorted in
<a name="3170"></a>     *   ascending order of this value.  
<a name="3171"></a>     */
<a name="3172"></a>    listOrder = 100
<a name="3173"></a>
<a name="3174"></a>    /*
<a name="3175"></a>     *   List group.  At the moment this does nothing, but it has been retained
<a name="3176"></a>     *   from the Mercury library for possible future use.
<a name="3177"></a>     */
<a name="3178"></a>    listWith = nil
<a name="3179"></a>
<a name="3180"></a>    /*
<a name="3181"></a>     *   Group order.  This gives the relative order of this item within
<a name="3182"></a>     *   its list group.  
<a name="3183"></a>     */
<a name="3184"></a>    groupOrder = 100
<a name="3185"></a>
<a name="3186"></a>     /*   
<a name="3187"></a>      *   CollectiveGroup, or a list of CollectiveGroups, to which this item
<a name="3188"></a>      *   belongs.
<a name="3189"></a>      */
<a name="3190"></a>    collectiveGroups = nil
<a name="3191"></a>    
<a name="3192"></a>    /*
<a name="3193"></a>     *   The owner or owners of the object.  This is for resolving
<a name="3194"></a>     *   possessives in the player's input, such as BOB'S WALLET.  By
<a name="3195"></a>     *   default, an object has no explicit owner, so this is an empty
<a name="3196"></a>     *   list.
<a name="3197"></a>     *   
<a name="3198"></a>     *   This should only return the *explicit* owner(s), not an implied
<a name="3199"></a>     *   locational owner.  For example, if Bob is holding a key, it's
<a name="3200"></a>     *   implicitly BOB'S KEY.  However, the key may or may not still be
<a name="3201"></a>     *   Bob's after he drops it.  If the key is something that's
<a name="3202"></a>     *   understood to belong to Bob, whether it's currently in his
<a name="3203"></a>     *   physical possession or not, then this routine would return Bob;
<a name="3204"></a>     *   otherwise it would return nil.
<a name="3205"></a>     *   
<a name="3206"></a>     *   An object can have multiple explicit owners, in which case it'll
<a name="3207"></a>     *   be recognized with a possessive qualifier for any of the owners.
<a name="3208"></a>     *   The first owner in the list is the nominal owner, meaning its the
<a name="3209"></a>     *   one we'll use if we're called upon to display the object's name
<a name="3210"></a>     *   with a possessive phrase.  
<a name="3211"></a>     */
<a name="3212"></a>    owner = []
<a name="3213"></a>
<a name="3214"></a>    /*
<a name="3215"></a>     *   Are we the nominal owner of the objects we contain?  This controls
<a name="3216"></a>     *   whether or not we can be chosen as the nominal owner of a contained
<a name="3217"></a>     *   object for display purposes.  If a contained object has no explicit
<a name="3218"></a>     *   owner, it can still be implicitly owned by an actor carrying it, or by
<a name="3219"></a>     *   another suitable container.  (Note that this only applies as a default.
<a name="3220"></a>     *   When an item in our contents has an explicit owner, that will override
<a name="3221"></a>     *   the implied container ownership for that item.  So, for example, Bob
<a name="3222"></a>     *   can be carrying Bill's wallet wallet, and as long as the wallet has its
<a name="3223"></a>     *   explicit owner set, we'll still describe it as Bill's despite its
<a name="3224"></a>     *   location.)
<a name="3225"></a>     *
<a name="3226"></a>     *   By default, most objects are not nominal owners.  Actors generally
<a name="3227"></a>     *   should set this to true, so that (for example) anything Bob is carrying
<a name="3228"></a>     *   can be described as Bob's. Something with contType = Carrier is likely
<a name="3229"></a>     *   to be an actor and hence something that can own its contents.
<a name="3230"></a>     */
<a name="3231"></a>    ownsContents = (contType == Carrier)
<a name="3232"></a>
<a name="3233"></a>    /*
<a name="3234"></a>     *   Get my nominal owner.  If we have an explicit owner, we'll return
<a name="3235"></a>     *   the first explicit owner.  Otherwise, we'll look for a container
<a name="3236"></a>     *   that has ownsContents = true, and return the first such container.
<a name="3237"></a>     */
<a name="3238"></a>    nominalOwner()
<a name="3239"></a>    {
<a name="3240"></a>        /* if I have an explicit owner, return the first one */
<a name="3241"></a>        if (owner.length() &gt; 0)
<a name="3242"></a>            return owner[1];
<a name="3243"></a>
<a name="3244"></a>        /* look for a container with ownsContents = true */
<a name="3245"></a>        return locationWhich({loc: loc.ownsContents});
<a name="3246"></a>    }
<a name="3247"></a>
<a name="3248"></a>    /*
<a name="3249"></a>     *   Does the given object own me, explicitly or implicitly?  This
<a name="3250"></a>     *   returns true if 'obj' is in my 'owner' list, but it can also
<a name="3251"></a>     *   return true if there's merely an implied ownership relationship.
<a name="3252"></a>     *   Location can imply ownership: BOB'S KEY could refer to the key
<a name="3253"></a>     *   that Bob is holding, whether or not it would continue to be
<a name="3254"></a>     *   considered his key if he were to drop it.
<a name="3255"></a>     *   
<a name="3256"></a>     *   We return true if 'obj' is an explicit owner, OR self is contained
<a name="3257"></a>     *   within 'obj', OR self is contained within an object owned by
<a name="3258"></a>     *   'obj'.  (The latter case is for things like BOB'S TWENTY DOLLAR
<a name="3259"></a>     *   BILL, which is Bob's by virtue of being inside a wallet explicitly
<a name="3260"></a>     *   owned by Bob.)  
<a name="3261"></a>     */
<a name="3262"></a>    ownedBy(obj)
<a name="3263"></a>    {
<a name="3264"></a>        /* if obj is in my explicit owner, we're owned by obj */
<a name="3265"></a>        if (owner.indexOf(obj))
<a name="3266"></a>            return true;
<a name="3267"></a>
<a name="3268"></a>        /* if we're a child of obj, we're implicitly owned by obj */
<a name="3269"></a>        if (isChild(obj, nil))
<a name="3270"></a>            return true;
<a name="3271"></a>
<a name="3272"></a>        /* are we inside something owned by obj? */
<a name="3273"></a>        if (location != nil &amp;&amp; location.ownedBy(obj))
<a name="3274"></a>            return true;
<a name="3275"></a>
<a name="3276"></a>        /* we're not owned by obj */
<a name="3277"></a>        return nil;
<a name="3278"></a>    }
<a name="3279"></a>
<a name="3280"></a>    /* 
<a name="3281"></a>     *   Return a list of everything that's directly or indirectly contained
<a name="3282"></a>     *   within us.
<a name="3283"></a>     */
<a name="3284"></a>    allContents()
<a name="3285"></a>    {
<a name="3286"></a>        local vec = new Vector(20);
<a name="3287"></a>               
<a name="3288"></a>        addToAllContents(vec, contents);
<a name="3289"></a>        
<a name="3290"></a>        return vec.toList;
<a name="3291"></a>    }
<a name="3292"></a>    
<a name="3293"></a>    addToAllContents(vec, lst)
<a name="3294"></a>    {
<a name="3295"></a>        vec.appendUnique(lst);
<a name="3296"></a>        foreach(local cur in lst)
<a name="3297"></a>            addToAllContents(vec, cur.contents);
<a name="3298"></a>    }
<a name="3299"></a>    
<a name="3300"></a>
<a name="3301"></a>    /* get everything that's directly in me */
<a name="3302"></a>    directlyIn = (contents.subset({ obj: obj.locType == In }))
<a name="3303"></a>    
<a name="3304"></a>        
<a name="3305"></a>    /* 
<a name="3306"></a>     *   Run a check method passed as a property pointer in the prop parameter
<a name="3307"></a>     *   and return any string it tried to display
<a name="3308"></a>     */
<a name="3309"></a>    tryCheck(prop)
<a name="3310"></a>    {
<a name="3311"></a>        local ret;
<a name="3312"></a>        try
<a name="3313"></a>        {
<a name="3314"></a>            ret = gOutStream.captureOutput({: self.(prop) });      
<a name="3315"></a>        }
<a name="3316"></a>        catch (ExitSignal ex)
<a name="3317"></a>        {
<a name="3318"></a>            if(ret is in ('', nil))
<a name="3319"></a>                ret = gAction.failCheckMsg;
<a name="3320"></a>        }
<a name="3321"></a>        finally
<a name="3322"></a>        {
<a name="3323"></a>            return ret;
<a name="3324"></a>        }
<a name="3325"></a>    }
<a name="3326"></a>    
<a name="3327"></a>    locationWhich(func)
<a name="3328"></a>    {
<a name="3329"></a>        /* 
<a name="3330"></a>         *   scan up the location tree until we reach the top, or a
<a name="3331"></a>         *   location for which func(loc) returns true 
<a name="3332"></a>         */
<a name="3333"></a>        local loc;
<a name="3334"></a>        for (loc = location ; loc != nil &amp;&amp; !func(loc) ; loc = loc.location) ;
<a name="3335"></a>
<a name="3336"></a>        /* return what we found */
<a name="3337"></a>        return loc;
<a name="3338"></a>    }
<a name="3339"></a>    
<a name="3340"></a>    /*
<a name="3341"></a>     *   Are we transparent to light?  If this is true, then an observer
<a name="3342"></a>     *   outside this object can see through it to objects on its interior,
<a name="3343"></a>     *   and an observer inside can see through to objects on its exterior.
<a name="3344"></a>     *   
<a name="3345"></a>     *   This property controls transparency symmetrically (looking in from
<a name="3346"></a>     *   outside and looking out from within).  The library also lets you
<a name="3347"></a>     *   control transparency asymmetrically, using canSeeIn and canSeeOut.
<a name="3348"></a>     *   Those values are by default derived from this one, but you can
<a name="3349"></a>     *   override them separately to create something like a one-way
<a name="3350"></a>     *   mirror.  
<a name="3351"></a>     */
<a name="3352"></a>    isTransparent = nil
<a name="3353"></a>
<a name="3354"></a>    /*
<a name="3355"></a>     *   Do we fully enclose our interior contents (true), or only
<a name="3356"></a>     *   partially (nil)?  By default, we assume that our contents are
<a name="3357"></a>     *   fully enclosed.  This can be set to nil for objects that represent
<a name="3358"></a>     *   spaces that are open on one side, such as a nook in a rock or a
<a name="3359"></a>     *   create without a lid.
<a name="3360"></a>     *   
<a name="3361"></a>     *   For an object that's sometimes fully enclosing and sometimes not,
<a name="3362"></a>     *   such as a cabinet with a door that can be opened and closed, this
<a name="3363"></a>     *   should be overridden with a method that figures the current value
<a name="3364"></a>     *   based on the open/closed state.
<a name="3365"></a>     *   
<a name="3366"></a>     *   Note that this only applies to our *interior* contents, such as
<a name="3367"></a>     *   contents of location type In.  Contents that are atop the object
<a name="3368"></a>     *   or otherwise arranged around the exterior aren't affected by this.
<a name="3369"></a>     */
<a name="3370"></a>    enclosing = (contType == In &amp;&amp; isOpen == nil)
<a name="3371"></a>
<a name="3372"></a>    /*
<a name="3373"></a>     *   Can we see in from my exterior to my interior?  That is, can an
<a name="3374"></a>     *   observer outside of this object see things located within it?  By
<a name="3375"></a>     *   default, we can see in from outside if we're transparent or we're
<a name="3376"></a>     *   non-enclosing.  
<a name="3377"></a>     */
<a name="3378"></a>    canSeeIn = (isTransparent || !enclosing)
<a name="3379"></a>
<a name="3380"></a>    /*
<a name="3381"></a>     *   Can we see out from my interior to my exterior?  That is, can an
<a name="3382"></a>     *   observer inside this object see things located outside of it?  By
<a name="3383"></a>     *   default, we can see out from inside if we're transparent or we're
<a name="3384"></a>     *   non-enclosing.  
<a name="3385"></a>     */
<a name="3386"></a>    canSeeOut = (isTransparent || !enclosing)
<a name="3387"></a>
<a name="3388"></a>     /*
<a name="3389"></a>     *   Can we hear in from my exterior to my interior?  That is, can an
<a name="3390"></a>     *   observer on the outside of this container hear a sound source on
<a name="3391"></a>     *   the inside?
<a name="3392"></a>     *   
<a name="3393"></a>     *   By default, we can hear in for all containers, since most
<a name="3394"></a>     *   materials transmit at least some sound even if they're opaque to
<a name="3395"></a>     *   light.  For a soundproof material (a glass booth, say), you could
<a name="3396"></a>     *   override this to make it (!enclosing) instead.  
<a name="3397"></a>     */
<a name="3398"></a>    canHearIn = true
<a name="3399"></a>
<a name="3400"></a>    /*
<a name="3401"></a>     *   Can we hear out from my interior to my exterior?  That is, can an
<a name="3402"></a>     *   observer on the inside of this container hear a sound source on
<a name="3403"></a>     *   the outside?
<a name="3404"></a>     *   
<a name="3405"></a>     *   By default, we can hear out for all containers, since most
<a name="3406"></a>     *   materials transmit at least some sound even if they're opaque to
<a name="3407"></a>     *   light.  For a soundproof material (a glass both, say), you could
<a name="3408"></a>     *   override this to make it (!enclosing) instead.  
<a name="3409"></a>     */
<a name="3410"></a>    canHearOut = true
<a name="3411"></a>
<a name="3412"></a>    /*
<a name="3413"></a>     *   Can we smell in (from an observer on my exterior to an odor source
<a name="3414"></a>     *   on my interior)?  By default, we can smell in if we're
<a name="3415"></a>     *   non-enclosing, since most solid materials aren't very permeable to
<a name="3416"></a>     *   scents (at human sensitivities, at least).  
<a name="3417"></a>     */
<a name="3418"></a>    canSmellIn = (!enclosing)
<a name="3419"></a>
<a name="3420"></a>    /*
<a name="3421"></a>     *   Can we smell out (from an observer on my interior to an odor
<a name="3422"></a>     *   source on my exterior)?  By default, we can smell out if we're
<a name="3423"></a>     *   non-enclosing, since most solid materials aren't very permeable to
<a name="3424"></a>     *   scents (at human sensitivities, at least).  
<a name="3425"></a>     */
<a name="3426"></a>    canSmellOut = (!enclosing)
<a name="3427"></a>
<a name="3428"></a>    /*
<a name="3429"></a>     *   Can we reach out from my interior to my exterior?  That is, can an
<a name="3430"></a>     *   observer inside this object reach something outside of it?  By
<a name="3431"></a>     *   default, we can reach out if we're non-enclosing. 
<a name="3432"></a>     */
<a name="3433"></a>    canReachOut = (!enclosing)
<a name="3434"></a>
<a name="3435"></a>    /*
<a name="3436"></a>     *   Can we reach in from my exterior to my interior?  That is, can an
<a name="3437"></a>     *   observer outside this object reach something inside of it?  By
<a name="3438"></a>     *   default, we can reach in if we're non-enclosing. 
<a name="3439"></a>     */
<a name="3440"></a>    canReachIn = (!enclosing)
<a name="3441"></a>
<a name="3442"></a>    /*   
<a name="3443"></a>     *   Allow this object to add additional checks at the check and verify
<a name="3444"></a>     *   stages to stipulate whether it can reach obj (or obj can reach it). We
<a name="3445"></a>     *   might use this, for example, to put an object conditionally out of
<a name="3446"></a>     *   reach if it's on top of a high cupboard or it's too hot to touch.
<a name="3447"></a>     */
<a name="3448"></a>    
<a name="3449"></a>    
<a name="3450"></a>    /*  
<a name="3451"></a>     *   If the verifyReach() method is defined, it should use the
<a name="3452"></a>     *   illogical/inaccessible/implausible/logical/logicalRank verify macros
<a name="3453"></a>     *   like a verify method. Don't define this method if you don't want it to
<a name="3454"></a>     *   block reaching.
<a name="3455"></a>     */
<a name="3456"></a>//    verifyReach(obj) { }
<a name="3457"></a>    
<a name="3458"></a>    /* 
<a name="3459"></a>     *   Check whether the actor can reach (touch) this object. If this method
<a name="3460"></a>     *   displays anything (which should be the reason this object can't be
<a name="3461"></a>     *   touched) then the object can't be reached. Note that this only has any
<a name="3462"></a>     *   effect when the touchObj preCondition is defined.
<a name="3463"></a>     */
<a name="3464"></a>    checkReach(actor) {  }
<a name="3465"></a>   
<a name="3466"></a>    
<a name="3467"></a>    
<a name="3468"></a>    /*   
<a name="3469"></a>     *   Check whether an actor can reach inside this object (for reasons other
<a name="3470"></a>     *   that it enclosing its contents; e.g. because it's out of reach). If
<a name="3471"></a>     *   this method displays anything (which should be the reason the interior
<a name="3472"></a>     *   of this object can't be reached) then disallow reaching inside. Note
<a name="3473"></a>     *   that this only has any effect when the touchObj preCondition is defined
<a name="3474"></a>     *   on this object. By default we can reach inside if we can reach this
<a name="3475"></a>     *   object and not otherwise. If the optional target parameter is supplied,
<a name="3476"></a>     *   it's the object that actor is trying to reach.
<a name="3477"></a>     */
<a name="3478"></a>    checkReachIn(actor, target?)  
<a name="3479"></a>    {
<a name="3480"></a>        checkReach(actor);
<a name="3481"></a>    }
<a name="3482"></a>    
<a name="3483"></a>    
<a name="3484"></a>    /* 
<a name="3485"></a>     *   Check whether the actor can reach out of this object to touch obj, if
<a name="3486"></a>     *   obj is not in this object.
<a name="3487"></a>     */    
<a name="3488"></a>    allowReachOut(obj) { return true; }
<a name="3489"></a>    
<a name="3490"></a>     
<a name="3491"></a>    
<a name="3492"></a>    /*  
<a name="3493"></a>     *   If an actor within me cannot reach an object from me, should the actor
<a name="3494"></a>     *   automatically try to get out of me?
<a name="3495"></a>     */        
<a name="3496"></a>    autoGetOutToReach = true
<a name="3497"></a>    
<a name="3498"></a>    /* 
<a name="3499"></a>     *   Return a message explaining why an object outside me can't reach one
<a name="3500"></a>     *   inside (or vice versa); this will normally be triggered by an attempt
<a name="3501"></a>     *   to reach an object inside a closed transparent container. The method is
<a name="3502"></a>     *   defined here to make it easier to customize the message on the
<a name="3503"></a>     *   container that's doing the blocking.
<a name="3504"></a>     */
<a name="3505"></a>    reachBlockedMsg(target)
<a name="3506"></a>    {
<a name="3507"></a>        local obj = self;
<a name="3508"></a>        gMessageParams(obj, target);
<a name="3509"></a>        return  BMsg(cannot reach, '{I} {can\'t} reach {the target} through
<a name="3510"></a>            {the obj}. ');
<a name="3511"></a>    }
<a name="3512"></a>    
<a name="3513"></a>    /*  
<a name="3514"></a>     *   Return a message (single-quoted string) explaining why we can't be
<a name="3515"></a>     *   reached by the actor (typically because we're in a different room).
<a name="3516"></a>     */
<a name="3517"></a>    tooFarAwayMsg
<a name="3518"></a>    {
<a name="3519"></a>        local obj = self;
<a name="3520"></a>        gMessageParams(obj);
<a name="3521"></a>        return BMsg(too far away, '{The subj obj} {is} too far away. ');
<a name="3522"></a>    }
<a name="3523"></a>    
<a name="3524"></a>    /* 
<a name="3525"></a>     *   Return a message (single-quoted string) explaining why target can't be
<a name="3526"></a>     *   reached from inside this Thing (when this Thing is typically some kind
<a name="3527"></a>     *   of nested room such as a Booth or Platform).
<a name="3528"></a>     */
<a name="3529"></a>    cannotReachOutMsg(target)
<a name="3530"></a>    {
<a name="3531"></a>        local loc = self;
<a name="3532"></a>        gMessageParams(loc, target);
<a name="3533"></a>        return BMsg(cannot reach out, '{I} {can\'t} reach {the target} from
<a name="3534"></a>                    {the loc}. ');
<a name="3535"></a>    }
<a name="3536"></a>    
<a name="3537"></a>    
<a name="3538"></a>    /*
<a name="3539"></a>     *   Does this object shine light outwards?  This determines if the
<a name="3540"></a>     *   object is a light source to objects outside of it.  Light shines
<a name="3541"></a>     *   out from an object if the object itself is a light source, or one
<a name="3542"></a>     *   of its direct exterior contents shines out, or its contents are
<a name="3543"></a>     *   visible from the outside and one of its direct interior contents
<a name="3544"></a>     *   shines out.  
<a name="3545"></a>     */
<a name="3546"></a>    shinesOut()
<a name="3547"></a>    {
<a name="3548"></a>        /* if I'm a light source directly, we shine light outwards */
<a name="3549"></a>        if (isLit)
<a name="3550"></a>            return true;
<a name="3551"></a>
<a name="3552"></a>        /* check my exterior contents */
<a name="3553"></a>        if (contents.indexWhich(
<a name="3554"></a>            { c: c.locType.ofKind(ExtLocType) &amp;&amp; c.shinesOut() }) != nil)
<a name="3555"></a>            return true;
<a name="3556"></a>
<a name="3557"></a>        /* if we can see into this object from outside, check the contents */
<a name="3558"></a>        if (canSeeIn
<a name="3559"></a>            &amp;&amp; contents.indexWhich(
<a name="3560"></a>                { c: c.locType.ofKind(IntLocType) &amp;&amp; c.shinesOut() }) != nil)
<a name="3561"></a>            return true;
<a name="3562"></a>
<a name="3563"></a>        /* I don't provide light outwards */
<a name="3564"></a>        return nil;
<a name="3565"></a>    }
<a name="3566"></a>
<a name="3567"></a>    /*
<a name="3568"></a>     *   Is this object's interior lit?  
<a name="3569"></a>     *   an object if the object itself is a light source, or anything
<a name="3570"></a>     *   directly inside shines outwards, or we can see out from within and
<a name="3571"></a>     *   our location shines inwards.  
<a name="3572"></a>     */
<a name="3573"></a>    litWithin()
<a name="3574"></a>    {
<a name="3575"></a>        /* if I'm a light source directly, we shine inwards */
<a name="3576"></a>        if (isLit)
<a name="3577"></a>            return true;
<a name="3578"></a>
<a name="3579"></a>        /* if any interior contents shine outwards, we're lit within */
<a name="3580"></a>        if (contents.indexWhich(
<a name="3581"></a>            { c: c.locType.ofKind(IntLocType) &amp;&amp; c.shinesOut() }) != nil)
<a name="3582"></a>            return true;
<a name="3583"></a>
<a name="3584"></a>        /* 
<a name="3585"></a>         *   if we can see out from within, and my enclosing parent is lit
<a name="3586"></a>         *   within, I'm lit within 
<a name="3587"></a>         */
<a name="3588"></a>        if (canSeeOut)
<a name="3589"></a>        {
<a name="3590"></a>            local p = interiorParent();
<a name="3591"></a>            if (p != nil &amp;&amp; p.litWithin())
<a name="3592"></a>                return true;
<a name="3593"></a>        }
<a name="3594"></a>
<a name="3595"></a>        /* I don't provide light inwards */
<a name="3596"></a>        return nil;
<a name="3597"></a>    }
<a name="3598"></a>
<a name="3599"></a>    
<a name="3600"></a>    
<a name="3601"></a>    /*
<a name="3602"></a>     *   Has this object ever been moved by the player character?  This is
<a name="3603"></a>     *   set to true when the PC takes the object or puts it somewhere.  
<a name="3604"></a>     */
<a name="3605"></a>    moved = nil
<a name="3606"></a>
<a name="3607"></a>    /*
<a name="3608"></a>     *   Have we been examined?  This is set to true when the player
<a name="3609"></a>     *   character examines the object.  For a room, LOOK AROUND counts as
<a name="3610"></a>     *   examination, as does triggering a room description by traveling
<a name="3611"></a>     *   into the room.  
<a name="3612"></a>     */
<a name="3613"></a>    examined = nil
<a name="3614"></a>
<a name="3615"></a>  
<a name="3616"></a>    /*
<a name="3617"></a>     *   Have we been seen?  This is set to true the first time the object
<a name="3618"></a>     *   is described or listed in a room description or the description of
<a name="3619"></a>     *   another object (such as LOOK IN this object's container).  
<a name="3620"></a>     */
<a name="3621"></a>    seen = nil
<a name="3622"></a>
<a name="3623"></a>    /*
<a name="3624"></a>     *   The last location where the player character saw this object.
<a name="3625"></a>     *   Whenever the object is described or listed in the description of a
<a name="3626"></a>     *   room or another object, we set this to the object's location at
<a name="3627"></a>     *   that time.  
<a name="3628"></a>     */
<a name="3629"></a>    lastSeenAt = nil
<a name="3630"></a>
<a name="3631"></a>    /* Note that we've been seen and where we were last seen */    
<a name="3632"></a>    noteSeen()
<a name="3633"></a>    {
<a name="3634"></a>        gPlayerChar.setHasSeen(self);
<a name="3635"></a>        lastSeenAt = location;
<a name="3636"></a>    }       
<a name="3637"></a>    
<a name="3638"></a>    /*
<a name="3639"></a>     *   Whether the player character knows of the existence of this object, if
<a name="3640"></a>     *   if it hasn't been seen. Set to true for objects that the player
<a name="3641"></a>     *   character should be familiar with at the start of play, or make true
<a name="3642"></a>     *   when the PC learns of them.
<a name="3643"></a>     */    
<a name="3644"></a>    familiar = nil
<a name="3645"></a>    
<a name="3646"></a>    /* 
<a name="3647"></a>     *   Properties to set and test whether an object is known about or has been
<a name="3648"></a>     *   seen; we define these on Thing to allow the player char to be a Thing.
<a name="3649"></a>     *   In what follows 'this Thing' is the object on which the method is
<a name="3650"></a>     *   called (which would typically be an Actor, the player character, or
<a name="3651"></a>     *   some other object representing an NPC) and obj is the object that is
<a name="3652"></a>     *   potentially known about or seen.
<a name="3653"></a>     */
<a name="3654"></a>        
<a name="3655"></a>    /*  Mark this Thing as knowing about obj. */
<a name="3656"></a>    setKnowsAbout(obj, val?) 
<a name="3657"></a>    { 
<a name="3658"></a>        switch(dataType(obj))
<a name="3659"></a>        {
<a name="3660"></a>        case TypeObject:
<a name="3661"></a>            obj.(knownProp) = true; 
<a name="3662"></a>            break;
<a name="3663"></a>        case TypeSString:
<a name="3664"></a>            setInformed(obj, val);
<a name="3665"></a>            break;
<a name="3666"></a>        default:
<a name="3667"></a>            ;
<a name="3668"></a>        }
<a name="3669"></a>    }
<a name="3670"></a>    
<a name="3671"></a>    /*  Mark the player character as knowing about us (i.e. this Thing) */
<a name="3672"></a>    setKnown() { gPlayerChar.setKnowsAbout(self); }
<a name="3673"></a>    
<a name="3674"></a>    /*  Mark this Thing as having seen obj. */
<a name="3675"></a>    setHasSeen(obj) { obj.(seenProp) = true; }
<a name="3676"></a>    
<a name="3677"></a>    /*  Mark the player character as having seen this Thing. */
<a name="3678"></a>    setSeen() { gPlayerChar.setHasSeen(self); }
<a name="3679"></a>    
<a name="3680"></a>    /*  Test whether this Thing has seen obbj. */
<a name="3681"></a>    hasSeen(obj) { return obj.(seenProp); }
<a name="3682"></a>       
<a name="3683"></a>    /*  
<a name="3684"></a>     *   Test whether this Thing knows about obj, which it does either if it has seen this obj or
<a name="3685"></a>     *   its knownProp (by default, familiar) is true, or, if obj is passsed as a string tag, if we
<a name="3686"></a>     *   have been informed about it.
<a name="3687"></a>     */   
<a name="3688"></a>    knowsAbout(obj)
<a name="3689"></a>    {
<a name="3690"></a>        switch(dataType(obj))
<a name="3691"></a>        { 
<a name="3692"></a>        
<a name="3693"></a>        /* 
<a name="3694"></a>         *   If obj is an object, then return true either if we've seen this objector if we know
<a name="3695"></a>         *   about it as defined by our knownProp.
<a name="3696"></a>         */    
<a name="3697"></a>        case TypeObject:
<a name="3698"></a>            return hasSeen(obj) || obj.(knownProp);
<a name="3699"></a>            
<a name="3700"></a>            /* 
<a name="3701"></a>             *   If obj is a single-quoted string, assume it's a knowledge tag and test for our
<a name="3702"></a>             *   being informed abnout it.
<a name="3703"></a>             */
<a name="3704"></a>        case TypeSString:
<a name="3705"></a>            return informedAbout(obj);
<a name="3706"></a>            
<a name="3707"></a>        default:
<a name="3708"></a>            return nil;           
<a name="3709"></a>                
<a name="3710"></a>        }
<a name="3711"></a>    }    
<a name="3712"></a>   
<a name="3713"></a>    
<a name="3714"></a>    /* 
<a name="3715"></a>     *   Test whether this Thing is known to the player character.
<a name="3716"></a>     */
<a name="3717"></a>    known = (gPlayerChar.knowsAbout(self)) 
<a name="3718"></a>    
<a name="3719"></a>    
<a name="3720"></a>     /*  
<a name="3721"></a>      *   If we want to track whether characters other than than the player char
<a name="3722"></a>      *   know about or have seen this object, we can define knownProp and
<a name="3723"></a>      *   seenProp as the properties used by this Thing to track what it knows
<a name="3724"></a>      *   about and has seen.
<a name="3725"></a>      */
<a name="3726"></a>    knownProp = &amp;familiar
<a name="3727"></a>    seenProp = &amp;seen
<a name="3728"></a>    
<a name="3729"></a>    /* Our look up table for things we've been informed about */    
<a name="3730"></a>    informedNameTab = nil
<a name="3731"></a>    
<a name="3732"></a>    /* 
<a name="3733"></a>     *   Note that we've been informed of something, by adding it to our
<a name="3734"></a>     *   informedNameTab. Tag is an arbitrary single-quoted string value used to
<a name="3735"></a>     *   represent the information in question.
<a name="3736"></a>     */    
<a name="3737"></a>    setInformed(tag, val?)
<a name="3738"></a>    {
<a name="3739"></a>        if(informedNameTab == nil)
<a name="3740"></a>            informedNameTab = new LookupTable(32, 32);
<a name="3741"></a>               
<a name="3742"></a>        if(val == nil &amp;&amp; informedNameTab[tag] == nil)        
<a name="3743"></a>            informedNameTab[tag] = true;
<a name="3744"></a>        else
<a name="3745"></a>            informedNameTab[tag] = val ?? true;
<a name="3746"></a>    }
<a name="3747"></a>    
<a name="3748"></a>    /* Make this Actor or Consultable forget about tag altogether. */
<a name="3749"></a>    forget(tag)
<a name="3750"></a>    {
<a name="3751"></a>        if(informedNameTab)
<a name="3752"></a>            informedNameTab.removeElement(tag);
<a name="3753"></a>    }
<a name="3754"></a>    
<a name="3755"></a>    
<a name="3756"></a>    /* 
<a name="3757"></a>     *   Determine whether this Thing has been informed about tag. We return true if there is a
<a name="3758"></a>     *   corresponding non-nil entry in our informedNameTab, or else the value of the corresponding
<a name="3759"></a>     *   entry if ibGlobal.informedTrueOrFalseOnly is nil (the default).
<a name="3760"></a>     */
<a name="3761"></a>    informedAbout(tag) 
<a name="3762"></a>    {        
<a name="3763"></a>        return informedNameTab == nil ? nil 
<a name="3764"></a>            : (libGlobal.informedTrueOrFalseOnly ? (informedNameTab[tag] != nil)
<a name="3765"></a>               : informedNameTab[tag]);     
<a name="3766"></a>    }
<a name="3767"></a>    
<a name="3768"></a>    /* 
<a name="3769"></a>     *   The list of things we start the game knowing about. This list can contain a mix of game
<a name="3770"></a>     *   objects (Things and/or Topics) and fact tags. Note that it would be redundant to include
<a name="3771"></a>     *   Things and Topics already defined as familiar if this property is overridden on the initial
<a name="3772"></a>     *   player character object.
<a name="3773"></a>     */         
<a name="3774"></a>    initiallyKnowsAbout = nil
<a name="3775"></a>    
<a name="3776"></a>    /*   
<a name="3777"></a>     *   The currentInterlocutor is the Actor this object is currently in
<a name="3778"></a>     *   conversation with. This property is only relevant on gPlayerChar, but
<a name="3779"></a>     *   it is defined here rather than on Actor since the player char can be of
<a name="3780"></a>     *   kind Thing.
<a name="3781"></a>     */    
<a name="3782"></a>    currentInterlocutor = nil
<a name="3783"></a>    
<a name="3784"></a>    
<a name="3785"></a>     /* 
<a name="3786"></a>      *   Can this Thing (which might be the Player Char for instance) talk to
<a name="3787"></a>      *   other?
<a name="3788"></a>      */
<a name="3789"></a>    canTalkTo(other)
<a name="3790"></a>    {
<a name="3791"></a>        return Q.canTalkTo(self, other);
<a name="3792"></a>    }
<a name="3793"></a>   
<a name="3794"></a>      /* 
<a name="3795"></a>       *   The lister to use when listing this object's inventory. By default we use the standard
<a name="3796"></a>       *   inventory lister for the default WIDE inventory listing and the inventoryTallLister for
<a name="3797"></a>       *   the TALL inventory listing.
<a name="3798"></a>       */
<a name="3799"></a>    myInventoryLister = libGlobal.inventoryTall ? inventoryTallLister : inventoryLister
<a name="3800"></a>    
<a name="3801"></a>    /* The lister to use when listing what this object is wearing. */
<a name="3802"></a>    myWornLister = wornLister
<a name="3803"></a>    
<a name="3804"></a>    /*
<a name="3805"></a>     *   Score this object for disambiguation.  When a noun phrase is
<a name="3806"></a>     *   ambiguous (for example, the phrase matches multiple in-scope
<a name="3807"></a>     *   objects, and we have to choose just one), the parser calls this
<a name="3808"></a>     *   routine on each object it's considering as a match.
<a name="3809"></a>     *   
<a name="3810"></a>     *   Our job here is to read the player's mind.  The question before us
<a name="3811"></a>     *   is: did the player mean *this* object when typing this noun
<a name="3812"></a>     *   phrase?  Obviously we can't really know what's in the player's
<a name="3813"></a>     *   mind, but in many cases we can make an educated guess based on
<a name="3814"></a>     *   what ought to make the most sense in context.  The context in this
<a name="3815"></a>     *   case is the state of the simulated game world, as it's portrayed
<a name="3816"></a>     *   to the player.  That last bit is important: be cognizant of what
<a name="3817"></a>     *   the player is *meant* to know at this point.  DON'T base the score
<a name="3818"></a>     *   on information that the player isn't supposed to know, though:
<a name="3819"></a>     *   that could give away secrets that the player is meant to discover
<a name="3820"></a>     *   on her own.
<a name="3821"></a>     *   
<a name="3822"></a>     *   Before this routine is called, the Action has already assigned an
<a name="3823"></a>     *   initial score to each object, but this routine can override the
<a name="3824"></a>     *   initial score by assigning its own score value.  This routine is
<a name="3825"></a>     *   most useful in cases where a particular object has a special
<a name="3826"></a>     *   affinity for a verb, or for the verb in combination with
<a name="3827"></a>     *   particular other objects involved in the command.
<a name="3828"></a>     *   
<a name="3829"></a>     *   'cmd' is the Command object.  'role' is the noun phrase's role in
<a name="3830"></a>     *   the command (DirectObject, IndirectObject, etc).  'lst' is a list
<a name="3831"></a>     *   of NPMatch objects identifying the objects that matched the noun
<a name="3832"></a>     *   phrase.  'm' is the NPMatch object for self.
<a name="3833"></a>     *   
<a name="3834"></a>     *   To override or adjust the score, simply set m.score to the new
<a name="3835"></a>     *   value.  This routine is also free to override the scores of any
<a name="3836"></a>     *   other objects in the list, if needed.
<a name="3837"></a>     *   
<a name="3838"></a>     *   By default, we don't make any adjustment - we simply accept the
<a name="3839"></a>     *   initial score calculated by the Action, by leaving m.score
<a name="3840"></a>     *   unchanged.
<a name="3841"></a>     *   
<a name="3842"></a>     *   See Action.scoreObjects() for full details.  
<a name="3843"></a>     */
<a name="3844"></a>    scoreObject(cmd, role, lst, m) 
<a name="3845"></a>    {
<a name="3846"></a>        m.score += vocabLikelihood;
<a name="3847"></a>        
<a name="3848"></a>        /* 
<a name="3849"></a>         *   If we're the last object written on, boost our score if the player
<a name="3850"></a>         *   wants to write something again.
<a name="3851"></a>         */
<a name="3852"></a>        if(libGlobal.lastWrittenOnObj == self &amp;&amp; cmd.action == WriteOn &amp;&amp; role
<a name="3853"></a>           == IndirectObject)
<a name="3854"></a>            m.score += 20;
<a name="3855"></a>        
<a name="3856"></a>        /* 
<a name="3857"></a>         *   If we're the last object typed on, boost our score if the player
<a name="3858"></a>         *   wants to type something again.
<a name="3859"></a>         */
<a name="3860"></a>        if(libGlobal.lastTypedOnObj == self &amp;&amp; cmd.action == TypeOn &amp;&amp; role
<a name="3861"></a>           == IndirectObject)
<a name="3862"></a>            m.score += 20;
<a name="3863"></a>        
<a name="3864"></a>    }
<a name="3865"></a>
<a name="3866"></a>    /*  
<a name="3867"></a>     *   A property that can be used to boost this object being chosen by the
<a name="3868"></a>     *   parser, other things being equal; it can be used as a tie-breaker
<a name="3869"></a>     *   between two objects that otherwise have the same verification scores.
<a name="3870"></a>     *   Game code should normally use fairly small values for this property,
<a name="3871"></a>     *   say between -20 and +20, to prevent overriding the verification score.
<a name="3872"></a>     */
<a name="3873"></a>    vocabLikelihood = 0
<a name="3874"></a>          
<a name="3875"></a>    
<a name="3876"></a>    /*   
<a name="3877"></a>     *   A list of objects that are facets of this object, and so can be
<a name="3878"></a>     *   referred to with the same pronoun.
<a name="3879"></a>     */
<a name="3880"></a>    getFacets = []
<a name="3881"></a>    
<a name="3882"></a>    
<a name="3883"></a>    /* 
<a name="3884"></a>     *   Before travel notification. This is called just before traveler
<a name="3885"></a>     *   attempts to travel via connector. By default we do nothing
<a name="3886"></a>     */    
<a name="3887"></a>    beforeTravel(traveler, connector) {}
<a name="3888"></a>    
<a name="3889"></a>    
<a name="3890"></a>    /* 
<a name="3891"></a>     *   After travel notification. This is called just after traveler has
<a name="3892"></a>     *   traveled via connector. 
<a name="3893"></a>     */     
<a name="3894"></a>    afterTravel(traveler, connector) {}
<a name="3895"></a>    
<a name="3896"></a>    /*   
<a name="3897"></a>     *   Cause this Thing to travel via the connector conn. This method is
<a name="3898"></a>     *   supplied in case travelVia is called on a Thing which is not an Actor,
<a name="3899"></a>     *   although it's Actor that has the full implementation.
<a name="3900"></a>     */
<a name="3901"></a>    travelVia(conn, announceArrival = true)
<a name="3902"></a>    {
<a name="3903"></a>        /* 
<a name="3904"></a>         *   If we've been mixed in with a TravelConnector class, it's almost
<a name="3905"></a>         *   certainly the TravelConnector's version of travelVia() that we need
<a name="3906"></a>         *   to execute here.
<a name="3907"></a>         */        
<a name="3908"></a>        if(ofKind(TravelConnector))
<a name="3909"></a>            inherited TravelConnector(conn);
<a name="3910"></a>        
<a name="3911"></a>        else    
<a name="3912"></a>            /* Move this actor via conn. */
<a name="3913"></a>            conn.travelVia(self);
<a name="3914"></a>    }
<a name="3915"></a>    
<a name="3916"></a>    /* 
<a name="3917"></a>     *   Handle a command directed to this open (e.g. BALL, GET IN BOX). Since
<a name="3918"></a>     *   inanimate objects generally can't respond to commands we simply display
<a name="3919"></a>     *   a message announcing the futility of issuing one. This method is
<a name="3920"></a>     *   overridden on Actor to allow Actors to respond to commands via
<a name="3921"></a>     *   CommandTopics.
<a name="3922"></a>     */    
<a name="3923"></a>    handleCommand(action)
<a name="3924"></a>    {
<a name="3925"></a>        DMsg(cannot command thing, 'There{dummy}\'s no point trying to give
<a name="3926"></a>            orders to {1}. ', aName);
<a name="3927"></a>    }
<a name="3928"></a>    
<a name="3929"></a>    
<a name="3930"></a>    /* 
<a name="3931"></a>     *   The preAction handling on this Thing if it's the current actor. This is called just before
<a name="3932"></a>     *   the relevant Doer is executed to provide a convenient entrypoint to intervene in an action
<a name="3933"></a>     *   before it can do anything at all (typically when the actor is tied up, paralysed, or
<a name="3934"></a>     *   otherwise temporarily incapacitated, which might require the intervention of three or four
<a name="3935"></a>     *   simlar Doers to trap). the object combination to execute: this is an [action, dobj, iobj,
<a name="3936"></a>     *...] list.
<a name="3937"></a>     */
<a name="3938"></a>    
<a name="3939"></a>    preAction(lst)
<a name="3940"></a>    {
<a name="3941"></a>    }
<a name="3942"></a>    
<a name="3943"></a>    /* 
<a name="3944"></a>     *   The before action handling on this Thing if it's the current actor. We
<a name="3945"></a>     *   define it here rather than on Actor since the player character can be a
<a name="3946"></a>     *   Thing. By default we do nothing.
<a name="3947"></a>     */
<a name="3948"></a>    actorAction() { }
<a name="3949"></a>    
<a name="3950"></a>    /* 
<a name="3951"></a>     *   Before action notification on this Thing; this is triggered whenever an
<a name="3952"></a>     *   action is about to be performed when we're in scope (and could be used
<a name="3953"></a>     *   to veto the action with an exit macro). The action we'd test for here
<a name="3954"></a>     *   would normally be one that *doesn't* involve this Thing.
<a name="3955"></a>     */    
<a name="3956"></a>    beforeAction() { }
<a name="3957"></a>    
<a name="3958"></a>    /* 
<a name="3959"></a>     *   After action notification on this Thing; this is triggered whenever an
<a name="3960"></a>     *   action has just been performed when we're in scope. The action we'd
<a name="3961"></a>     *   test for here would normally be one that *doesn't* involve this Thing.
<a name="3962"></a>     */  
<a name="3963"></a>    afterAction() { }
<a name="3964"></a>    
<a name="3965"></a>    /* Is this object the player character? */
<a name="3966"></a>    isPlayerChar = (gPlayerChar == self)
<a name="3967"></a>    
<a name="3968"></a>    /* 
<a name="3969"></a>     *   To exclude this item from the list of objects to be acted upon when the
<a name="3970"></a>     *   player types a command with ALL for action, override this method to
<a name="3971"></a>     *   return true for the action or actions concerned. Note that this
<a name="3972"></a>     *   exclusion is applied after the action has constructed its own list of
<a name="3973"></a>     *   objects that ALL should apply to, and can only be used to make further
<a name="3974"></a>     *   exclusions.
<a name="3975"></a>     *
<a name="3976"></a>     *   It shouldn't be necessary to use this method very often, since the
<a name="3977"></a>     *   normal approach will be to override the getAll() method on the
<a name="3978"></a>     *   appropriate action. It may be useful to use this method to handle
<a name="3979"></a>     *   exceptional cases, however.
<a name="3980"></a>     */
<a name="3981"></a>    hideFromAll(action) { return nil; }
<a name="3982"></a>    
<a name="3983"></a>    /*   
<a name="3984"></a>     *   This method is primarily intended for use with the symconn extension, where it is
<a name="3985"></a>     *   redefined, but other code may find a use for it.
<a name="3986"></a>     */
<a name="3987"></a>    byRoom(arg) { return ''; }
<a name="3988"></a>    
<a name="3989"></a>    /* 
<a name="3990"></a>     *   The ThoughtManager object associated with this Thing (if this Thing does any thinking);
<a name="3991"></a>     *   this is only relevant if thoughts.t is present and this Thing becomea a player character.
<a name="3992"></a>     */
<a name="3993"></a>    myThoughtManager = nil
<a name="3994"></a>    
<a name="3995"></a>    /*
<a name="3996"></a>     *   ******************************************************************
<a name="3997"></a>     *   ACTION HANDLING
<a name="3998"></a>     *
<a name="3999"></a>     *   Here follows code relating to the handling of specific actions
<a name="4000"></a>     */
<a name="4001"></a>    
<a name="4002"></a>     /* 
<a name="4003"></a>      *   If I declare this object to be a decoration (i.e. isDecoration = true)
<a name="4004"></a>      *   then its default behaviour will be to display its notImportantMsg for
<a name="4005"></a>      *   every action except Examine or GoTo. We can extend the actions it will
<a name="4006"></a>      *   respond to by adding them to the list in the decorationActions
<a name="4007"></a>      *   property.
<a name="4008"></a>      */    
<a name="4009"></a>    isDecoration = nil
<a name="4010"></a>    
<a name="4011"></a>    /*   
<a name="4012"></a>     *   The list of actions this object will respond to specifically if
<a name="4013"></a>     *   isDecoration is true. All other actions will be handled by
<a name="4014"></a>     *   dobjFor(Default) and/or iobjFor(Default). Game code can override this
<a name="4015"></a>     *   list (usually to expand it) for decorations that are required to handle
<a name="4016"></a>     *   additional actions.
<a name="4017"></a>     *
<a name="4018"></a>     *   If we're compiling for debugging, it will be useful to allow the GONEAR
<a name="4019"></a>     *   command with Decorations for testing purposes, but this can't be
<a name="4020"></a>     *   included in a release build without causing a compilation error, so we
<a name="4021"></a>     *   define the decorationActions property with different lists of actions
<a name="4022"></a>     *   depending on whether we're compiling for debugging or release.
<a name="4023"></a>     */    
<a name="4024"></a>#ifdef __DEBUG
<a name="4025"></a>    decorationActions = [Examine, GoTo, GoNear]
<a name="4026"></a>#else
<a name="4027"></a>    decorationActions = [Examine, GoTo]
<a name="4028"></a>#endif
<a name="4029"></a>    /*   
<a name="4030"></a>     *   Our handling of any action of which we're the direct or indirect action
<a name="4031"></a>     *   that's not in our list of decorationActions when our isDecoration
<a name="4032"></a>     *   property is true. By default we just stop the action at the verify
<a name="4033"></a>     *   stage and display our notImportantMsg.
<a name="4034"></a>     */    
<a name="4035"></a>    dobjFor(Default)
<a name="4036"></a>    {
<a name="4037"></a>        verify
<a name="4038"></a>        {
<a name="4039"></a>            illogical(notImportantMsg);
<a name="4040"></a>        }
<a name="4041"></a>    }
<a name="4042"></a>    
<a name="4043"></a>    iobjFor(Default)
<a name="4044"></a>    {
<a name="4045"></a>        verify()
<a name="4046"></a>        {
<a name="4047"></a>            illogical(notImportantMsg);
<a name="4048"></a>        }
<a name="4049"></a>    }
<a name="4050"></a>    
<a name="4051"></a>    notImportantMsg = BMsg(not important, '{The subj cobj} {is} not important.
<a name="4052"></a>         ')
<a name="4053"></a>    
<a name="4054"></a>    
<a name="4055"></a>    /* 
<a name="4056"></a>     *   Next deal with what happens if this object is being tested as a
<a name="4057"></a>     *   potential actor
<a name="4058"></a>     */    
<a name="4059"></a>    verifyActor()
<a name="4060"></a>    {
<a name="4061"></a>       /* 
<a name="4062"></a>        *   If our contType isn't Carrier we're unlikely to be an actor, so
<a name="4063"></a>        *   we're a poor choice of object if the parser has to select an actor,
<a name="4064"></a>        *   typically when the player has entered a command targeted at an NPC.
<a name="4065"></a>        */
<a name="4066"></a>        if(contType != Carrier)
<a name="4067"></a>            logicalRank(70);
<a name="4068"></a>    }
<a name="4069"></a>    
<a name="4070"></a>    remapActor = nil
<a name="4071"></a>    
<a name="4072"></a>    preCondActor = [objAudible]
<a name="4073"></a>    
<a name="4074"></a>    
<a name="4075"></a>    /* Now the handling for specific actions */
<a name="4076"></a>    
<a name="4077"></a>    dobjFor(Examine)
<a name="4078"></a>    {
<a name="4079"></a>        preCond = [objVisible]
<a name="4080"></a>        
<a name="4081"></a>        verify() 
<a name="4082"></a>        { 
<a name="4083"></a>            if(isDecoration)
<a name="4084"></a>                logicalRank(70);
<a name="4085"></a>            else
<a name="4086"></a>                logical; 
<a name="4087"></a>        }
<a name="4088"></a>        
<a name="4089"></a>        check() { }
<a name="4090"></a>        
<a name="4091"></a>        action()
<a name="4092"></a>        {            
<a name="4093"></a>            local descDisplayed = nil;
<a name="4094"></a>            
<a name="4095"></a>            /* 
<a name="4096"></a>             *   If we have a non-nil darkDesc property and we're in a dark
<a name="4097"></a>             *   room, display our darkDesc and stop there. Note this will only
<a name="4098"></a>             *   ever happen if we're visibleInDark.
<a name="4099"></a>             */
<a name="4100"></a>            if(propType(&amp;inDarkDesc) != TypeNil 
<a name="4101"></a>               &amp;&amp; !getOutermostRoom.isIlluminated())
<a name="4102"></a>            {
<a name="4103"></a>                /* Display our darkDesc */
<a name="4104"></a>                display(&amp;inDarkDesc);
<a name="4105"></a>                
<a name="4106"></a>                /* 
<a name="4107"></a>                 *   Stop there, because in a dark room we can only be seen
<a name="4108"></a>                 *   partially, and so we don't add any status information or
<a name="4109"></a>                 *   record that we've been (properly) examined.
<a name="4110"></a>                 */
<a name="4111"></a>                return;
<a name="4112"></a>            }
<a name="4113"></a>            
<a name="4114"></a>            /* 
<a name="4115"></a>             *   Display our description. Normally the desc property will be
<a name="4116"></a>             *   specified as a double-quoted string or a routine that displays
<a name="4117"></a>             *   a string, but by using the display() message we ensure that it
<a name="4118"></a>             *   will still be shown even if desc has been defined a
<a name="4119"></a>             *   single-quoted string.
<a name="4120"></a>             */
<a name="4121"></a>            if(gOutStream.watchForOutput({:display(&amp;desc) }))
<a name="4122"></a>               descDisplayed = true;
<a name="4123"></a>            
<a name="4124"></a>            /*   
<a name="4125"></a>             *   Display any additional information, such as our stateDesc (if
<a name="4126"></a>             *   we have one) and our contents (if we have any).
<a name="4127"></a>             */
<a name="4128"></a>            if(gOutStream.watchForOutput({:examineStatus()} ))
<a name="4129"></a>                descDisplayed = true;
<a name="4130"></a>               
<a name="4131"></a>            /*   
<a name="4132"></a>             *   If nothing has been displayed yet, show the default message
<a name="4133"></a>             *   saying we nothing special about this object.
<a name="4134"></a>             */
<a name="4135"></a>            if(!descDisplayed)
<a name="4136"></a>                DMsg(nothing special,  '{I} {see} nothing special about 
<a name="4137"></a>                {the 1}. ', self); 
<a name="4138"></a>               
<a name="4139"></a>            
<a name="4140"></a>            /*   Note that we've now been examined. */
<a name="4141"></a>            examined = true;
<a name="4142"></a>            
<a name="4143"></a>            /*   
<a name="4144"></a>             *   Note that the player character has seen us. 99 times out a
<a name="4145"></a>             *   hundred this probably won't be necessary, but it may catch the
<a name="4146"></a>             *   odd case where something is examined that hasn't yet been set
<a name="4147"></a>             *   as seen.
<a name="4148"></a>             */
<a name="4149"></a>            if(gActor == gPlayerChar)
<a name="4150"></a>                noteSeen();
<a name="4151"></a>            
<a name="4152"></a>            
<a name="4153"></a>            "\n";
<a name="4154"></a>        }
<a name="4155"></a>    }
<a name="4156"></a>    
<a name="4157"></a>    /* The message to display when it's too dark to see anything */
<a name="4158"></a>    tooDarkToSeeMsg = BMsg(too dark to see, 'It{dummy}{\'s} too dark to see
<a name="4159"></a>        anything. ')
<a name="4160"></a>    
<a name="4161"></a>    /* 
<a name="4162"></a>     *   By default everything is smellable, but you can override this to nil if
<a name="4163"></a>     *   something isn't
<a name="4164"></a>     */
<a name="4165"></a>    isSmellable = true
<a name="4166"></a>       
<a name="4167"></a>    
<a name="4168"></a>    cannotSmellMsg = BMsg(cannot smell, '{I} {can\'t} smell {the dobj}. ')
<a name="4169"></a>    
<a name="4170"></a>    dobjFor(SmellSomething)
<a name="4171"></a>    {
<a name="4172"></a>        preCond = [objSmellable]
<a name="4173"></a>        
<a name="4174"></a>        verify()
<a name="4175"></a>        {
<a name="4176"></a>            if(!isSmellable)
<a name="4177"></a>                illogical(cannotSmellMsg);
<a name="4178"></a>        }
<a name="4179"></a>        
<a name="4180"></a>        action()
<a name="4181"></a>        {
<a name="4182"></a>            displayAlt(&amp;smellDesc, &amp;smellNothingMsg);            
<a name="4183"></a>        }
<a name="4184"></a>    }
<a name="4185"></a>    
<a name="4186"></a>    smellNothingMsg = BMsg(smell nothing, '{I} {smell} nothing out of the
<a name="4187"></a>                    ordinary.&lt;.p&gt;')
<a name="4188"></a>    
<a name="4189"></a>    dobjFor(ListenTo)
<a name="4190"></a>    {
<a name="4191"></a>        
<a name="4192"></a>        preCond = [objAudible]
<a name="4193"></a>        
<a name="4194"></a>        action()
<a name="4195"></a>        {
<a name="4196"></a>            displayAlt(&amp;listenDesc, &amp;hearNothingMsg);           
<a name="4197"></a>        }
<a name="4198"></a>    }
<a name="4199"></a>    
<a name="4200"></a>    hearNothingMsg = BMsg(hear nothing listen to, '{I} hear{s/d} nothing out of
<a name="4201"></a>        the ordinary.&lt;.p&gt;')
<a name="4202"></a>    
<a name="4203"></a>    /* 
<a name="4204"></a>     *   By default everything is tasteable, but there might well be things the
<a name="4205"></a>     *   that it would not be appropriate to taste.
<a name="4206"></a>     */
<a name="4207"></a>    isTasteable = true
<a name="4208"></a>    
<a name="4209"></a>    
<a name="4210"></a>    cannotTasteMsg = BMsg(cannot taste, '{The subj dobj} {is} not suitable for
<a name="4211"></a>        tasting. ')
<a name="4212"></a>    
<a name="4213"></a>    dobjFor(Taste)
<a name="4214"></a>    {
<a name="4215"></a>        preCond = [touchObj]
<a name="4216"></a>        
<a name="4217"></a>        verify()
<a name="4218"></a>        {
<a name="4219"></a>            if(!isTasteable)
<a name="4220"></a>                illogical(cannotTasteMsg);
<a name="4221"></a>        }
<a name="4222"></a>        
<a name="4223"></a>        action()
<a name="4224"></a>        {
<a name="4225"></a>            if(propType(&amp;tasteDesc) == TypeNil)           
<a name="4226"></a>                DMsg(taste nothing, '{I} taste{s/d} nothing unexpected.&lt;.p&gt;');
<a name="4227"></a>            else
<a name="4228"></a>                display(&amp;tasteDesc);      
<a name="4229"></a>        }
<a name="4230"></a>    }
<a name="4231"></a>    
<a name="4232"></a>    
<a name="4233"></a>    /* 
<a name="4234"></a>     *   By default we can try feeling most things, but there may be some things
<a name="4235"></a>     *   it would be inappropriate to try feeling (like a blazing fire or Aunt
<a name="4236"></a>     *   Mable) or somethings that cannot be felt (like a ray of light).
<a name="4237"></a>     */
<a name="4238"></a>    isFeelable = true
<a name="4239"></a>    
<a name="4240"></a>    cannotFeelMsg = BMsg(cannot feel, 'It{\'s} hardly a good idea to try feeling
<a name="4241"></a>        {the dobj}. ')
<a name="4242"></a>    
<a name="4243"></a>    /* 
<a name="4244"></a>     *   This property can be defined to display a message at the check stage
<a name="4245"></a>     *   (and so stop the FEEL action there). Normally checkFeelMsg would be
<a name="4246"></a>     *   defined as a double-quoted string, but it can also be defined as a
<a name="4247"></a>     *   double-quoted string or a method that displays some text.
<a name="4248"></a>     */
<a name="4249"></a>    checkFeelMsg = nil
<a name="4250"></a>    
<a name="4251"></a>    dobjFor(Feel)    
<a name="4252"></a>    {
<a name="4253"></a>        preCond = [touchObj]
<a name="4254"></a>        
<a name="4255"></a>        verify()
<a name="4256"></a>        {
<a name="4257"></a>            if(!isFeelable)
<a name="4258"></a>                illogical(cannotFeelMsg);
<a name="4259"></a>        }
<a name="4260"></a>        
<a name="4261"></a>        check()
<a name="4262"></a>        {
<a name="4263"></a>            if(dataType(&amp;checkFeelMsg) != TypeNil)
<a name="4264"></a>                display(&amp;checkFeelMsg);
<a name="4265"></a>        
<a name="4266"></a>        }
<a name="4267"></a>        
<a name="4268"></a>        action()
<a name="4269"></a>        {
<a name="4270"></a>            if(propType(&amp;feelDesc) == TypeNil)            
<a name="4271"></a>                DMsg(feel nothing, '{I} {feel} nothing unexpected.&lt;.p&gt;');
<a name="4272"></a>            else
<a name="4273"></a>                display(&amp;feelDesc);
<a name="4274"></a>        }
<a name="4275"></a>    }
<a name="4276"></a>    
<a name="4277"></a>    /* By default a Thing is takeable if it's not fixed in place */
<a name="4278"></a>    isTakeable = (!isFixed)
<a name="4279"></a>    
<a name="4280"></a>    dobjFor(Take)    
<a name="4281"></a>    {
<a name="4282"></a>        preCond = [touchObj]
<a name="4283"></a>        
<a name="4284"></a>        verify()
<a name="4285"></a>        {
<a name="4286"></a>            if(!isTakeable)
<a name="4287"></a>                illogical(cannotTakeMsg);
<a name="4288"></a>            
<a name="4289"></a>            if(isDirectlyIn(gActor))
<a name="4290"></a>                illogicalNow(alreadyHeldMsg);
<a name="4291"></a>            
<a name="4292"></a>            if(gActor.isIn(self))
<a name="4293"></a>                illogicalNow(cannotTakeMyContainerMsg);
<a name="4294"></a>            
<a name="4295"></a>            if(gActor == self)
<a name="4296"></a>                illogicalSelf(cannotTakeSelfMsg);
<a name="4297"></a>            
<a name="4298"></a>            logical;
<a name="4299"></a>        }
<a name="4300"></a>        
<a name="4301"></a>        check() 
<a name="4302"></a>        {
<a name="4303"></a>            
<a name="4304"></a>            /* First check that my container doesn't object to my being removed from it. */
<a name="4305"></a>            if(location)
<a name="4306"></a>                location.checkRemove(self);
<a name="4307"></a>            
<a name="4308"></a>            /* 
<a name="4309"></a>             *   Check that the actor has room to hold the item s/he's about to
<a name="4310"></a>             *   pick up.
<a name="4311"></a>             */
<a name="4312"></a>            checkRoomToHold();
<a name="4313"></a>        }
<a name="4314"></a>        
<a name="4315"></a>        action()
<a name="4316"></a>        {
<a name="4317"></a>            /* 
<a name="4318"></a>             *   If we have any contents hidden behind us or under us, reveal it
<a name="4319"></a>             *   now
<a name="4320"></a>             */
<a name="4321"></a>            revealOnMove();     
<a name="4322"></a>            
<a name="4323"></a>            /* 
<a name="4324"></a>             *   move us into the actor who is taking us, triggering the
<a name="4325"></a>             *   appropriate notifications.
<a name="4326"></a>             */
<a name="4327"></a>            actionMoveInto(gActor);
<a name="4328"></a>        }
<a name="4329"></a>        
<a name="4330"></a>        /* 
<a name="4331"></a>         *   Report that we've been taken. Note that if the action causes
<a name="4332"></a>         *   several items to be taken, this method will only be called on the
<a name="4333"></a>         *   final item, and will need to report on all the items taken.
<a name="4334"></a>         */
<a name="4335"></a>        report()
<a name="4336"></a>        {            
<a name="4337"></a>            DMsg(report take, 'Taken. | {I} {take} {1}. ', gActionListStr);
<a name="4338"></a>        }
<a name="4339"></a>    }
<a name="4340"></a>       
<a name="4341"></a>    cannotTakeMsg = BMsg(cannot take, '{The subj cobj} {is} fixed in place.
<a name="4342"></a>        ')
<a name="4343"></a>    
<a name="4344"></a>    alreadyHeldMsg = BMsg(already holding, '{I}{\'m} already holding {the dobj}.
<a name="4345"></a>        ')
<a name="4346"></a>    
<a name="4347"></a>    cannotTakeMyContainerMsg = BMsg(cannot take my container, '{I} {can\'t}
<a name="4348"></a>        take {the dobj} while {i}{\'m} {1} {him dobj}. ', objInPrep)
<a name="4349"></a>    
<a name="4350"></a>    cannotTakeSelfMsg = BMsg(cannot take self, '{I} {can} hardly take {myself}. ')
<a name="4351"></a>    
<a name="4352"></a>    /* 
<a name="4353"></a>     *   Flag, should any items behind me be left behind when I'm moved; by
<a name="4354"></a>     *   default, they should.
<a name="4355"></a>     */
<a name="4356"></a>    dropItemsBehind = true
<a name="4357"></a>    
<a name="4358"></a>    /* 
<a name="4359"></a>     *   Flag, should any items behind me be left behind when I'm moved; by
<a name="4360"></a>     *   default, they should.
<a name="4361"></a>     */
<a name="4362"></a>    dropItemsUnder = true
<a name="4363"></a>    
<a name="4364"></a>    
<a name="4365"></a>    /* 
<a name="4366"></a>     *   List and move into an appropriate location any item that was hidden
<a name="4367"></a>     *   behind or under us. We place this in a separate method so it can be
<a name="4368"></a>     *   conveniently called by other actions that move an object, or overridden
<a name="4369"></a>     *   by particular objects that want a different handling.
<a name="4370"></a>     *
<a name="4371"></a>     *   Note that we don't provide any handling for the hiddenIn property here,
<a name="4372"></a>     *   on the assumption that items hidden in something may well stay there
<a name="4373"></a>     *   when it's moved; but this method can always be overridden to provide
<a name="4374"></a>     *   custom behaviour.
<a name="4375"></a>     */    
<a name="4376"></a>    revealOnMove()
<a name="4377"></a>    {
<a name="4378"></a>        local moveReport = '';
<a name="4379"></a>        local underLoc = location;
<a name="4380"></a>        local behindLoc = location;
<a name="4381"></a>        
<a name="4382"></a>        /* 
<a name="4383"></a>         *   If I don't want to leave items under me behind when I'm moved, and
<a name="4384"></a>         *   I am or have an underside, change the location to move items hidden
<a name="4385"></a>         *   under me to accordingly.
<a name="4386"></a>         */
<a name="4387"></a>        if(contType == Under &amp;&amp; dropItemsUnder == nil)
<a name="4388"></a>            underLoc = self;
<a name="4389"></a>        else if(remapUnder != nil &amp;&amp; dropItemsUnder == nil)
<a name="4390"></a>            underLoc = remapUnder;
<a name="4391"></a>        
<a name="4392"></a>         /* 
<a name="4393"></a>          *   If I don't want to leave items behind me behind when I'm moved,
<a name="4394"></a>          *   and I am or have a RearContainer, change the location to move
<a name="4395"></a>          *   items hidden under me to accordingly.
<a name="4396"></a>          */
<a name="4397"></a>        if(contType == Behind &amp;&amp; dropItemsBehind == nil)
<a name="4398"></a>            behindLoc = self;
<a name="4399"></a>        else if(remapBehind != nil &amp;&amp; dropItemsBehind == nil)
<a name="4400"></a>            behindLoc = remapBehind;
<a name="4401"></a>        
<a name="4402"></a>        
<a name="4403"></a>        /* 
<a name="4404"></a>         *   If anything is hidden under us, add a report saying that it's just
<a name="4405"></a>         *   been revealed moved and then move the previously hidden items to
<a name="4406"></a>         *   our location.
<a name="4407"></a>         */
<a name="4408"></a>        if(hiddenUnder.length &gt; 0)
<a name="4409"></a>        {
<a name="4410"></a>            moveReport += 
<a name="4411"></a>                BMsg(reveal move under,'Moving {1} {dummy} reveal{s/ed} {2}
<a name="4412"></a>                    previously hidden under {3}. ',
<a name="4413"></a>                     theName, makeListStr(hiddenUnder), himName);
<a name="4414"></a>                     
<a name="4415"></a>            moveHidden(&amp;hiddenUnder, underLoc);
<a name="4416"></a>            
<a name="4417"></a>        }
<a name="4418"></a>        
<a name="4419"></a>        
<a name="4420"></a>        /* 
<a name="4421"></a>         *   If anything is hidden behind us, add a report saying that's just
<a name="4422"></a>         *   been revealed and then move the previously hidden items to our
<a name="4423"></a>         *   location.
<a name="4424"></a>         */
<a name="4425"></a>        if(hiddenBehind.length &gt; 0)
<a name="4426"></a>        {
<a name="4427"></a>            moveReport += 
<a name="4428"></a>                BMsg(reveal move behind,'Moving {1} {dummy} reveal{s/ed} {2}
<a name="4429"></a>                    previously hidden behind {3}. ',
<a name="4430"></a>                     theName, makeListStr(hiddenBehind), himName);
<a name="4431"></a>                        
<a name="4432"></a>            moveHidden(&amp;hiddenBehind, behindLoc);            
<a name="4433"></a>        }
<a name="4434"></a>        
<a name="4435"></a>        /* 
<a name="4436"></a>         *   Construct a list of anything left behind from under or behind us
<a name="4437"></a>         *   when we're moved.
<a name="4438"></a>         */
<a name="4439"></a>        local lst = [];
<a name="4440"></a>        
<a name="4441"></a>        if(dropItemsUnder)
<a name="4442"></a>        {
<a name="4443"></a>            if(contType == Under)
<a name="4444"></a>                lst = contents;
<a name="4445"></a>            else if(remapUnder)
<a name="4446"></a>                lst = remapUnder.contents;                    
<a name="4447"></a>        }
<a name="4448"></a>               
<a name="4449"></a>        if(dropItemsBehind)
<a name="4450"></a>        {
<a name="4451"></a>            if(contType == Behind)
<a name="4452"></a>                lst += contents;
<a name="4453"></a>            else if(remapBehind)
<a name="4454"></a>                lst += remapBehind.contents;           
<a name="4455"></a>        }
<a name="4456"></a>        
<a name="4457"></a>        lst = lst.subset({o: !o.isFixed});
<a name="4458"></a>        
<a name="4459"></a>        if(lst.length &gt; 0)
<a name="4460"></a>        {
<a name="4461"></a>            foreach(local cur in lst)
<a name="4462"></a>                cur.moveInto(location);                
<a name="4463"></a>         
<a name="4464"></a>            moveReport +=
<a name="4465"></a>                BMsg(report left behind, '&lt;&lt;if moveReport == ''&gt;&gt;Moving {1}
<a name="4466"></a>                    &lt;&lt;else&gt;&gt;It also &lt;&lt;end&gt;&gt; {dummy} {leaves} {2} behind. ',
<a name="4467"></a>                     theName, makeListStr(lst));
<a name="4468"></a>        }
<a name="4469"></a>        
<a name="4470"></a>        
<a name="4471"></a>        /* 
<a name="4472"></a>         *   If anything has been reported as being revealed, report the
<a name="4473"></a>         *   discovery after reporting the action that caused it.
<a name="4474"></a>         */
<a name="4475"></a>        if(moveReport != '' )
<a name="4476"></a>            reportAfter(moveReport);
<a name="4477"></a>    }
<a name="4478"></a>    
<a name="4479"></a>    /* 
<a name="4480"></a>     *   Service method: move everything in the prop property to loc and mark it
<a name="4481"></a>     *   as seen.
<a name="4482"></a>     */    
<a name="4483"></a>    moveHidden(prop, loc)
<a name="4484"></a>    {
<a name="4485"></a>        foreach(local cur in self.(prop))
<a name="4486"></a>        {
<a name="4487"></a>            cur.moveInto(loc);
<a name="4488"></a>            cur.noteSeen();
<a name="4489"></a>        }
<a name="4490"></a>        self.(prop) = [];
<a name="4491"></a>                
<a name="4492"></a>    }
<a name="4493"></a>    
<a name="4494"></a>    /* 
<a name="4495"></a>     *   Check that the actor has enough spare bulkCapacity and enough items carried capacity to add
<a name="4496"></a>     *   this item to his/her inventory. Since by default everything has a bulk of zero and a very
<a name="4497"></a>     *   large bulkCapacity, by default there will be no effective restriction on what an actor (and
<a name="4498"></a>     *   in particular the player char) can carry, but game authors may often wish to give portable
<a name="4499"></a>     *   items bulk in the interests of realism and may wish to impose an inventory limit by bulk by
<a name="4500"></a>     *   reducing the bulkCapacity of the player char.
<a name="4501"></a>     */    
<a name="4502"></a>    checkRoomToHold()
<a name="4503"></a>    {
<a name="4504"></a>        /* 
<a name="4505"></a>         *   First check whether this item is individually too big for the actor to carry.
<a name="4506"></a>         */
<a name="4507"></a>        if(bulk &gt; gActor.maxSingleBulk)
<a name="4508"></a>            DMsg(too big to carry, '{The subj dobj} {is} too big for {me} to
<a name="4509"></a>                carry. ');
<a name="4510"></a>        
<a name="4511"></a>        /* 
<a name="4512"></a>         *   If the BagOfHolding class is defined and the actor doesn't have enough spare bulk
<a name="4513"></a>         *   capacity or maxItemCarried capacity, see if the BagOfHolding class can deal with it by
<a name="4514"></a>         *   moving something to a BagOfHolding.
<a name="4515"></a>         */
<a name="4516"></a>        if(defined(BagOfHolding) 
<a name="4517"></a>           &amp;&amp; (bulk &gt; gActor.bulkCapacity - gActor.getCarriedBulk ||
<a name="4518"></a>               gActor.directlyHeld.length &gt; gActor.maxItemsCarried - 1)
<a name="4519"></a>           &amp;&amp; BagOfHolding.tryHolding(self));
<a name="4520"></a>        
<a name="4521"></a>        
<a name="4522"></a>        /* 
<a name="4523"></a>         *   otherwise check that the actor has sufficient spare carrying capacity.
<a name="4524"></a>         */
<a name="4525"></a>        else if(bulk &gt; gActor.bulkCapacity - gActor.getCarriedBulk ||
<a name="4526"></a>                gActor.directlyHeld.length &gt; gActor.maxItemsCarried - 1)
<a name="4527"></a>            DMsg(cannot carry any more, '{I} {can\'t} carry any more than
<a name="4528"></a>                {i}{\'m} already carrying. ');
<a name="4529"></a>    }
<a name="4530"></a>    
<a name="4531"></a>    /* By default we can drop anything that's held */
<a name="4532"></a>    isDroppable = true
<a name="4533"></a>    
<a name="4534"></a>    /* The message to display if something can't be dropped. */
<a name="4535"></a>    cannotDropMsg = BMsg(cannot drop, '{The subj dobj} {can\'t} be dropped. ')
<a name="4536"></a>    
<a name="4537"></a>    /* The location in which something dropped in me should land. */
<a name="4538"></a>    dropLocation = self
<a name="4539"></a>    
<a name="4540"></a>    /* 
<a name="4541"></a>     *   Flag: can our contents be dropped when we're in the actor's inventory (if they can, an
<a name="4542"></a>     *   implicit TaksFrom us will be performed to enable the Drop). By default they can't.
<a name="4543"></a>     */
<a name="4544"></a>    canDropContents = nil
<a name="4545"></a>    
<a name="4546"></a>    dobjFor(Drop)
<a name="4547"></a>    {
<a name="4548"></a>        preCond = [touchObj, objNotWorn, objCarried]
<a name="4549"></a>        
<a name="4550"></a>        verify()
<a name="4551"></a>        {
<a name="4552"></a>            
<a name="4553"></a>            /* 
<a name="4554"></a>             *   This object cannot be dropped if game code deems it to be undroppable for reasons
<a name="4555"></a>             *   beyond throse enforced in the objCarried PreCondition.
<a name="4556"></a>             */            
<a name="4557"></a>            if(!isDroppable)
<a name="4558"></a>                illogical(cannotDropMsg);           
<a name="4559"></a>        }
<a name="4560"></a>                
<a name="4561"></a>        
<a name="4562"></a>        action()
<a name="4563"></a>        {           
<a name="4564"></a>            actionMoveInto(gActor.location.dropLocation);
<a name="4565"></a>        }
<a name="4566"></a>        
<a name="4567"></a>        report()
<a name="4568"></a>        {
<a name="4569"></a>            DMsg(report drop, 'Dropped. |{I} drop{s/?ed} {1}. ', gActionListStr);            
<a name="4570"></a>        }
<a name="4571"></a>    }
<a name="4572"></a>    
<a name="4573"></a>    notHoldingMsg = BMsg(not holding, '{I} {amn\'t} holding {the dobj}. ')
<a name="4574"></a>    partOfYouMsg = BMsg(part of me, '{The subj dobj} {is} part of {me}. ')
<a name="4575"></a>    
<a name="4576"></a>    /* By default an object is readable if it defines a non-nil readDesc */
<a name="4577"></a>    isReadable = (propType(&amp;readDesc) != TypeNil)
<a name="4578"></a>    
<a name="4579"></a>    dobjFor(Read)
<a name="4580"></a>    {
<a name="4581"></a>        preCond = [objVisible]
<a name="4582"></a>        
<a name="4583"></a>        verify()
<a name="4584"></a>        {
<a name="4585"></a>            if(!isReadable)
<a name="4586"></a>                illogical(cannotReadMsg);
<a name="4587"></a>        }
<a name="4588"></a>        
<a name="4589"></a>        action()
<a name="4590"></a>        {
<a name="4591"></a>            if(propType(&amp;readDesc) == TypeNil)
<a name="4592"></a>                say(cannotReadMsg);
<a name="4593"></a>            else
<a name="4594"></a>                display(&amp;readDesc);         
<a name="4595"></a>        }
<a name="4596"></a>    }
<a name="4597"></a>    
<a name="4598"></a>    cannotReadMsg = BMsg(cannot read, 'There {dummy} {is} nothing to read on
<a name="4599"></a>        {the dobj}. ')
<a name="4600"></a>    
<a name="4601"></a>
<a name="4602"></a>    /* 
<a name="4603"></a>     *   Flag: can this object be followed? Most inanimate objects cannot, so
<a name="4604"></a>     *   the default value is nil.
<a name="4605"></a>     */
<a name="4606"></a>    isFollowable = nil
<a name="4607"></a>    
<a name="4608"></a>    dobjFor(Follow)
<a name="4609"></a>    {
<a name="4610"></a>        preCond = [objVisible]
<a name="4611"></a>        
<a name="4612"></a>        verify()
<a name="4613"></a>        {
<a name="4614"></a>            if(!isFollowable)
<a name="4615"></a>                illogical(cannotFollowMsg);
<a name="4616"></a>            
<a name="4617"></a>            if(self == gActor)
<a name="4618"></a>                illogicalSelf(cannotFollowSelfMsg);
<a name="4619"></a>        }
<a name="4620"></a>    }
<a name="4621"></a>    
<a name="4622"></a>    
<a name="4623"></a>    cannotFollowMsg = BMsg(cannot follow, '{The subj dobj} {isn\'t} going
<a name="4624"></a>        anywhere. ')
<a name="4625"></a>    
<a name="4626"></a>    cannotFollowSelfMsg = BMsg(cannot follow self, '{I} {can\'t} follow
<a name="4627"></a>        {myself}. ')
<a name="4628"></a>
<a name="4629"></a>    
<a name="4630"></a>   
<a name="4631"></a>    /* 
<a name="4632"></a>     *   Although in theory we can attack almost anything, in practice there's
<a name="4633"></a>     *   seldom reason to do so.
<a name="4634"></a>     */
<a name="4635"></a>    isAttackable = nil
<a name="4636"></a>    
<a name="4637"></a>    dobjFor(Attack)
<a name="4638"></a>    {
<a name="4639"></a>        preCond = [touchObj]
<a name="4640"></a>        
<a name="4641"></a>        verify()
<a name="4642"></a>        {
<a name="4643"></a>            if(!isAttackable)
<a name="4644"></a>                illogical(cannotAttackMsg);
<a name="4645"></a>        }
<a name="4646"></a>        
<a name="4647"></a>        check()
<a name="4648"></a>        {
<a name="4649"></a>            if(dataType(&amp;checkAttackMsg) != TypeNil)
<a name="4650"></a>                display(&amp;checkAttackMsg);
<a name="4651"></a>        }
<a name="4652"></a>        
<a name="4653"></a>        /* 
<a name="4654"></a>         *   In case isAttackable is changed to true but no other handling is
<a name="4655"></a>         *   added, we need to provide some kind of default report.
<a name="4656"></a>         */
<a name="4657"></a>        report()
<a name="4658"></a>        {
<a name="4659"></a>            say(futileToAttackMsg); 
<a name="4660"></a>        }
<a name="4661"></a>    }
<a name="4662"></a>   
<a name="4663"></a>    /* 
<a name="4664"></a>     *   If we want Attack to fail at the check stage we can supply a message
<a name="4665"></a>     *   explaining why.
<a name="4666"></a>     */ 
<a name="4667"></a>    checkAttackMsg = nil
<a name="4668"></a>    
<a name="4669"></a>    cannotAttackMsg = BMsg(cannot attack, 'It{dummy}{\'s} best to avoid
<a name="4670"></a>        pointless violence. ')
<a name="4671"></a>    
<a name="4672"></a>    dobjFor(AttackWith)
<a name="4673"></a>    {
<a name="4674"></a>        preCond = [touchObj]
<a name="4675"></a>        
<a name="4676"></a>        verify()
<a name="4677"></a>        {
<a name="4678"></a>            if(!isAttackable)
<a name="4679"></a>                illogical(cannotAttackMsg);
<a name="4680"></a>        }
<a name="4681"></a>        
<a name="4682"></a>        
<a name="4683"></a>        /* 
<a name="4684"></a>         *   In case isAttackable is changed to true but no other handling is
<a name="4685"></a>         *   added, we need to provide some kind of default report.
<a name="4686"></a>         */
<a name="4687"></a>        report()
<a name="4688"></a>        {
<a name="4689"></a>            say(futileToAttackMsg); 
<a name="4690"></a>        }       
<a name="4691"></a>    }
<a name="4692"></a>    
<a name="4693"></a>    futileToAttackMsg = BMsg(futile attack, 'Attacking {1} prove{s/d} futile. ', 
<a name="4694"></a>                             gActionListStr)
<a name="4695"></a>    
<a name="4696"></a>    iobjFor(AttackWith)
<a name="4697"></a>    {
<a name="4698"></a>        preCond = [objHeld]
<a name="4699"></a>        verify() 
<a name="4700"></a>        { 
<a name="4701"></a>            if(!canAttackWithMe)
<a name="4702"></a>               illogical(cannotAttackWithMsg); 
<a name="4703"></a>            
<a name="4704"></a>            if(gVerifyDobj == self)
<a name="4705"></a>                illogicalSelf(cannotAttackWithSelfMsg);
<a name="4706"></a>        }
<a name="4707"></a>    }
<a name="4708"></a>    
<a name="4709"></a>    
<a name="4710"></a>    /* By default we can't use most things as weapons */    
<a name="4711"></a>    canAttackWithMe = nil
<a name="4712"></a>    
<a name="4713"></a>    cannotAttackWithSelfMsg = BMsg(cannot attack with self, '{I} {can\'t}
<a name="4714"></a>        attack anything with itself. ')
<a name="4715"></a>    
<a name="4716"></a>    cannotAttackWithMsg = BMsg(cannot attack with, '{I} {can\'t} attack
<a name="4717"></a>        anything with {that iobj}. ')
<a name="4718"></a>    
<a name="4719"></a>    dobjFor(Strike) asDobjFor(Attack)
<a name="4720"></a>    
<a name="4721"></a>    /* 
<a name="4722"></a>     *   By default treat everything as breakable, but there are somethings that
<a name="4723"></a>     *   clearly aren't like sunbeams, sounds and mountains.
<a name="4724"></a>     */
<a name="4725"></a>    isBreakable = true
<a name="4726"></a>    
<a name="4727"></a>    /*   Probably most things shouldn't be broken though. */
<a name="4728"></a>    shouldBeBroken = nil
<a name="4729"></a>    
<a name="4730"></a>    dobjFor(Break)
<a name="4731"></a>    {
<a name="4732"></a>        preCond = [touchObj]
<a name="4733"></a>        
<a name="4734"></a>        verify()
<a name="4735"></a>        {
<a name="4736"></a>            if(!isBreakable)
<a name="4737"></a>                illogical(cannotBreakMsg);
<a name="4738"></a>            else if(!shouldBeBroken)
<a name="4739"></a>                implausible(shouldNotBreakMsg);            
<a name="4740"></a>        }       
<a name="4741"></a>    }
<a name="4742"></a>    
<a name="4743"></a>    cannotBreakMsg = BMsg(cannot break, '{The subj dobj} {is} not the sort of
<a name="4744"></a>        thing (i) {can} break. ')
<a name="4745"></a>    
<a name="4746"></a>    shouldNotBreakMsg = BMsg(dont break, '{I} {see} no point in breaking {that
<a name="4747"></a>        dobj}. ')
<a name="4748"></a>    
<a name="4749"></a>    /* By default something is throwable unless it's fixed in place. */
<a name="4750"></a>    isThrowable = (!isFixed)
<a name="4751"></a>    
<a name="4752"></a>    dobjFor(ThrowDir)
<a name="4753"></a>    {
<a name="4754"></a>        preCond = [objHeld ,objNotWorn]
<a name="4755"></a>        
<a name="4756"></a>        verify()
<a name="4757"></a>        {
<a name="4758"></a>            if(!isThrowable)
<a name="4759"></a>                illogical(cannotThrowMsg);
<a name="4760"></a>               
<a name="4761"></a>        }
<a name="4762"></a>             
<a name="4763"></a>        /* 
<a name="4764"></a>         *   The default result of throwing something in a compass direction is
<a name="4765"></a>         *   that it lands in the dropLocation of its outermost room.
<a name="4766"></a>         */
<a name="4767"></a>        action() { actionMoveInto(getOutermostRoom.dropLocation); }
<a name="4768"></a>        
<a name="4769"></a>        report()
<a name="4770"></a>        {
<a name="4771"></a>            local obj = gActionListObj;
<a name="4772"></a>            
<a name="4773"></a>            gMessageParams(obj);
<a name="4774"></a>            
<a name="4775"></a>            DMsg(throw dir, '{I} {throw} {the obj} {1} and {he obj}
<a name="4776"></a>                land{s/ed} on the ground. ', gAction.direction.name );
<a name="4777"></a>        }
<a name="4778"></a>    }
<a name="4779"></a>    
<a name="4780"></a>    cannotThrowMsg = BMsg(cannot throw, '{I} {can\'t} throw {the dobj} anywhere.
<a name="4781"></a>        ')
<a name="4782"></a>    
<a name="4783"></a>    
<a name="4784"></a>    /* 
<a name="4785"></a>     *   Is this object openable. If this property is set to true then this
<a name="4786"></a>     *   object can be open and closed via the OPEN and CLOSE commands. Note
<a name="4787"></a>     *   that setting this property to true also automatically makes the
<a name="4788"></a>     *   OpenClosed State apply to this object, so that it can be referred to as
<a name="4789"></a>     *   'open' or 'closed' accordingly.
<a name="4790"></a>     */
<a name="4791"></a>    isOpenable = nil
<a name="4792"></a>    
<a name="4793"></a>    /* 
<a name="4794"></a>     *   Is this object open. By default we'll make Things open so that their
<a name="4795"></a>     *   interiors (if they have any) are accessible, unless they're openable,
<a name="4796"></a>     *   in which case we'll assume they start out closed.
<a name="4797"></a>     */
<a name="4798"></a>    isOpen = (!isOpenable)
<a name="4799"></a>    
<a name="4800"></a>    /* 
<a name="4801"></a>     *   Make us open or closed. We define this as a method so that subclasses
<a name="4802"></a>     *   such as Door can override to produce side effects (such as opening or
<a name="4803"></a>     *   closing the other side).
<a name="4804"></a>     */    
<a name="4805"></a>    makeOpen(stat)
<a name="4806"></a>    {
<a name="4807"></a>        isOpen = stat;
<a name="4808"></a>        if(stat)
<a name="4809"></a>            opened = true;
<a name="4810"></a>    }
<a name="4811"></a>    
<a name="4812"></a>    /* 
<a name="4813"></a>     *   Flag, has this object ever been opened. Note that this is nil for an
<a name="4814"></a>     *   object that starts out open but has never been closed and opened again.
<a name="4815"></a>     */
<a name="4816"></a>    opened = nil
<a name="4817"></a>    
<a name="4818"></a>    /* 
<a name="4819"></a>     *   Flag, do we want to attempt to unlock this item it it's locked when we
<a name="4820"></a>     *   try to open it?
<a name="4821"></a>     */
<a name="4822"></a>    autoUnlock = nil
<a name="4823"></a>    
<a name="4824"></a>    
<a name="4825"></a>    dobjFor(Open)
<a name="4826"></a>    {
<a name="4827"></a>        
<a name="4828"></a>        preCond = autoUnlock ? [touchObj, objUnlocked] : [touchObj]
<a name="4829"></a>        
<a name="4830"></a>        /* 
<a name="4831"></a>         *   If this object is not itself openable, but its remapIn property
<a name="4832"></a>         *   points to an associated object that is, remap this action to use
<a name="4833"></a>         *   the remapIn object instead of us.
<a name="4834"></a>         */
<a name="4835"></a>        remap()
<a name="4836"></a>        {
<a name="4837"></a>            if(!isOpenable &amp;&amp; remapIn != nil &amp;&amp; remapIn.isOpenable)
<a name="4838"></a>                return remapIn;
<a name="4839"></a>            else
<a name="4840"></a>                return self;
<a name="4841"></a>        }
<a name="4842"></a>        
<a name="4843"></a>        verify()
<a name="4844"></a>        {
<a name="4845"></a>            if(isOpenable == nil)
<a name="4846"></a>                illogical(cannotOpenMsg);
<a name="4847"></a>            
<a name="4848"></a>            if(isOpen)
<a name="4849"></a>                illogicalNow(alreadyOpenMsg);
<a name="4850"></a>            
<a name="4851"></a>            logical;                          
<a name="4852"></a>        }
<a name="4853"></a>        
<a name="4854"></a>        /* 
<a name="4855"></a>         *   An object can't be open if it's locked. We test this at check
<a name="4856"></a>         *   rather than verify since it may not be obvious that an object's
<a name="4857"></a>         *   locked until someone tries to open it.
<a name="4858"></a>         */
<a name="4859"></a>        check()
<a name="4860"></a>        {
<a name="4861"></a>            if(isLocked)
<a name="4862"></a>                say(lockedMsg);
<a name="4863"></a>        }
<a name="4864"></a>        
<a name="4865"></a>        action()
<a name="4866"></a>        {
<a name="4867"></a>            makeOpen(true);
<a name="4868"></a>            
<a name="4869"></a>            /* 
<a name="4870"></a>             *   If opening us is not being performed as an implicit action,
<a name="4871"></a>             *   list the contents that are revealed as a result of our being
<a name="4872"></a>             *   opened.
<a name="4873"></a>             */
<a name="4874"></a>            if(!gAction.isImplicit)
<a name="4875"></a>            {              
<a name="4876"></a>                unmention(contents);
<a name="4877"></a>                listSubcontentsOf(self, &amp;myOpeningContentsLister);
<a name="4878"></a>            }           
<a name="4879"></a>        }
<a name="4880"></a>        
<a name="4881"></a>        report()
<a name="4882"></a>        {
<a name="4883"></a>            DMsg(okay open, okayOpenMsg, gActionListStr);
<a name="4884"></a>        }
<a name="4885"></a>    }
<a name="4886"></a>    
<a name="4887"></a>    /* 
<a name="4888"></a>     *   The lister to use when listing my contents when I'm opened. By default
<a name="4889"></a>     *   we use the openingContentsLister.
<a name="4890"></a>     */
<a name="4891"></a>    myOpeningContentsLister = openingContentsLister
<a name="4892"></a>
<a name="4893"></a>    okayOpenMsg = 'Opened.|{I} open{s/ed} {1}. '
<a name="4894"></a>    
<a name="4895"></a>    cannotOpenMsg = BMsg(cannot open, '{The subj dobj} {is} not something {i}
<a name="4896"></a>        {can} open. ')
<a name="4897"></a>    alreadyOpenMsg = BMsg(already open, '{The subj dobj} {is} already open. ')
<a name="4898"></a>    lockedMsg = BMsg(locked, '{The subj dobj} {is} locked. ')
<a name="4899"></a> 
<a name="4900"></a>    
<a name="4901"></a>    /* By default something is closeable if it's openable */         
<a name="4902"></a>    isCloseable = (isOpenable)
<a name="4903"></a>    
<a name="4904"></a>    dobjFor(Close)
<a name="4905"></a>    {
<a name="4906"></a>        preCond = [touchObj]
<a name="4907"></a>        
<a name="4908"></a>        remap()
<a name="4909"></a>        {
<a name="4910"></a>            if(!isCloseable &amp;&amp; remapIn != nil &amp;&amp; remapIn.isCloseable)
<a name="4911"></a>                return remapIn;
<a name="4912"></a>            else
<a name="4913"></a>                return self;
<a name="4914"></a>        }
<a name="4915"></a>        
<a name="4916"></a>        
<a name="4917"></a>        verify()
<a name="4918"></a>        {
<a name="4919"></a>            if(!isCloseable)
<a name="4920"></a>                illogical(cannotCloseMsg);
<a name="4921"></a>            if(!isOpen)
<a name="4922"></a>                illogicalNow(alreadyClosedMsg);
<a name="4923"></a>            logical;
<a name="4924"></a>        }
<a name="4925"></a>           
<a name="4926"></a>        
<a name="4927"></a>        action()
<a name="4928"></a>        {            
<a name="4929"></a>            makeOpen(nil);
<a name="4930"></a>        }
<a name="4931"></a>        
<a name="4932"></a>        report()
<a name="4933"></a>        {
<a name="4934"></a>            DMsg(report close, 'Done. |{I} close{s/d} {1}. ',  gActionListStr);
<a name="4935"></a>        }
<a name="4936"></a>    }
<a name="4937"></a>    
<a name="4938"></a>    cannotCloseMsg = BMsg(not closeable, '{The subj dobj} {is} not something
<a name="4939"></a>        that {can} be closed. ')
<a name="4940"></a>    alreadyClosedMsg = BMsg(already closed,'{The subj dobj} {isn\'t} open. ')
<a name="4941"></a>    
<a name="4942"></a>       
<a name="4943"></a>    
<a name="4944"></a>    /* 
<a name="4945"></a>     *   By default we make everything turnable, but lots of things clearly
<a name="4946"></a>     *   won't be.
<a name="4947"></a>     */
<a name="4948"></a>    isTurnable = true
<a name="4949"></a>    
<a name="4950"></a>    
<a name="4951"></a>    dobjFor(Turn)
<a name="4952"></a>    {
<a name="4953"></a>        
<a name="4954"></a>        preCond = [touchObj]
<a name="4955"></a>        
<a name="4956"></a>        verify()
<a name="4957"></a>        {
<a name="4958"></a>            if(!isTurnable)
<a name="4959"></a>                illogical(cannotTurnMsg);
<a name="4960"></a>            else if(isDirectlyIn(gActor))
<a name="4961"></a>                logical;
<a name="4962"></a>            else
<a name="4963"></a>                logicalRank(80);
<a name="4964"></a>        }
<a name="4965"></a>        
<a name="4966"></a>        report()
<a name="4967"></a>        {
<a name="4968"></a>            say(turnNoEffectMsg);
<a name="4969"></a>        }
<a name="4970"></a>        
<a name="4971"></a>    }
<a name="4972"></a>    
<a name="4973"></a>    cannotTurnMsg = BMsg(cannot turn, '{The subj dobj} {can\'t} be turned. ')
<a name="4974"></a>    
<a name="4975"></a>    turnNoEffectMsg = BMsg(turn useless, 'Turning {1} {dummy} achieve{s/d}
<a name="4976"></a>        nothing. ', gActionListStr)
<a name="4977"></a>    
<a name="4978"></a>    dobjFor(TurnWith)
<a name="4979"></a>    {
<a name="4980"></a>        preCond = [touchObj]
<a name="4981"></a>        
<a name="4982"></a>        verify()
<a name="4983"></a>        {
<a name="4984"></a>            if(!isTurnable)
<a name="4985"></a>                illogical(cannotTurnMsg);
<a name="4986"></a>            else if(isDirectlyIn(gActor))
<a name="4987"></a>                logical;
<a name="4988"></a>            else
<a name="4989"></a>                logicalRank(80);
<a name="4990"></a>        }
<a name="4991"></a>        
<a name="4992"></a>        report()
<a name="4993"></a>        {
<a name="4994"></a>            say(turnNoEffectMsg);
<a name="4995"></a>        }
<a name="4996"></a>        
<a name="4997"></a>    }
<a name="4998"></a>    
<a name="4999"></a>    /* By default things can't be used to turn other things with */
<a name="5000"></a>    canTurnWithMe = nil
<a name="5001"></a>    
<a name="5002"></a>    iobjFor(TurnWith)
<a name="5003"></a>    {
<a name="5004"></a>        preCond = [objHeld]
<a name="5005"></a>        verify() 
<a name="5006"></a>        {           
<a name="5007"></a>            if(!canTurnWithMe)
<a name="5008"></a>                illogical(cannotTurnWithMsg); 
<a name="5009"></a>            
<a name="5010"></a>            if(gVerifyDobj == self)
<a name="5011"></a>                illogical(cannotTurnWithSelfMsg); 
<a name="5012"></a>        }
<a name="5013"></a>    }
<a name="5014"></a>        
<a name="5015"></a>    
<a name="5016"></a>    cannotTurnWithMsg = BMsg(cannot turn with, '{I} {can\'t} turn anything with
<a name="5017"></a>        {that iobj}. ')
<a name="5018"></a>    
<a name="5019"></a>    cannotTurnWithSelfMsg = BMsg(turn self, '{I} {cannot} turn anything with
<a name="5020"></a>        itself. ')
<a name="5021"></a>    
<a name="5022"></a>    /* By default things can't be cut */
<a name="5023"></a>    isCuttable = nil
<a name="5024"></a>    
<a name="5025"></a>    dobjFor(Cut)
<a name="5026"></a>    {
<a name="5027"></a>        preCond = [touchObj]
<a name="5028"></a>        verify() 
<a name="5029"></a>        { 
<a name="5030"></a>            if(!isCuttable)
<a name="5031"></a>               illogical(cannotCutMsg); 
<a name="5032"></a>        }
<a name="5033"></a>        
<a name="5034"></a>        action() { askForIobj(CutWith); }
<a name="5035"></a>    }
<a name="5036"></a>    
<a name="5037"></a>    dobjFor(CutWith)
<a name="5038"></a>    {
<a name="5039"></a>        preCond = [touchObj]
<a name="5040"></a>        verify() 
<a name="5041"></a>        { 
<a name="5042"></a>            if(!isCuttable)
<a name="5043"></a>               illogical(cannotCutMsg); 
<a name="5044"></a>        }
<a name="5045"></a>    }
<a name="5046"></a>    
<a name="5047"></a>    /* Most things can't be used to cut other things with */
<a name="5048"></a>    canCutWithMe = nil
<a name="5049"></a>    
<a name="5050"></a>    iobjFor(CutWith)
<a name="5051"></a>    {
<a name="5052"></a>        preCond = [objHeld]
<a name="5053"></a>        
<a name="5054"></a>        verify()
<a name="5055"></a>        {                       
<a name="5056"></a>            if(!canCutWithMe)
<a name="5057"></a>                illogical(cannotCutWithMsg);
<a name="5058"></a>            
<a name="5059"></a>            if(self == gVerifyDobj)
<a name="5060"></a>                illogicalSelf(cannotCutWithSelfMsg);
<a name="5061"></a>        }
<a name="5062"></a>    }
<a name="5063"></a>    
<a name="5064"></a>    cannotCutMsg = BMsg(cannot cut, '{I} {can\'t} cut {the dobj}. ')
<a name="5065"></a>    cannotCutWithMsg = BMsg(cannot cut with, '{I} {can\'t} cut anything with
<a name="5066"></a>        {that iobj}. ')
<a name="5067"></a>    cannotCutWithSelfMsg = BMsg(cannot cut with self, '{I} {cannot} cut anything
<a name="5068"></a>        with itself. ')
<a name="5069"></a>                     
<a name="5070"></a>    
<a name="5071"></a>    /* 
<a name="5072"></a>     *   If the actor finds something in a hiddenPrep list and there's nowhere
<a name="5073"></a>     *   obvious for it go, should he take it? By default the actor should take
<a name="5074"></a>     *   it if the object he's found it in/under/behind is fixed in place.
<a name="5075"></a>     */
<a name="5076"></a>    autoTakeOnFindHidden = (isFixed)
<a name="5077"></a>    
<a name="5078"></a>    /*   
<a name="5079"></a>     *   Where should an item that's been hidden in/under/behind something be
<a name="5080"></a>     *   moved to when its found? If it's taken, move into the actor; otherwise
<a name="5081"></a>     *   move it to the location of the object it's just been found
<a name="5082"></a>     *   in/under/behind.
<a name="5083"></a>     */
<a name="5084"></a>    findHiddenDest = (autoTakeOnFindHidden ? gActor : location)
<a name="5085"></a>      
<a name="5086"></a>    dobjFor(LookIn)
<a name="5087"></a>    {
<a name="5088"></a>        preCond = [objVisible, containerOpen]
<a name="5089"></a>        
<a name="5090"></a>        remap = remapIn
<a name="5091"></a>                
<a name="5092"></a>        verify()
<a name="5093"></a>        {
<a name="5094"></a>            if(contType == In || remapIn != nil)
<a name="5095"></a>                logicalRank(120);
<a name="5096"></a>                        
<a name="5097"></a>            logical;
<a name="5098"></a>        }
<a name="5099"></a>        
<a name="5100"></a>        action()
<a name="5101"></a>        {       
<a name="5102"></a>           /* 
<a name="5103"></a>            *   If we're actually a container-type object, i.e. if our contType
<a name="5104"></a>            *   is In, try to determine what's inside us and display a list of
<a name="5105"></a>            *   it; if there's nothing inside us just display a message to that
<a name="5106"></a>            *   effect.
<a name="5107"></a>            */
<a name="5108"></a>            if(contType == In)
<a name="5109"></a>            {            
<a name="5110"></a>                /* 
<a name="5111"></a>                 *   If there's anything hidden inside us move it into us before
<a name="5112"></a>                 *   doing anything else
<a name="5113"></a>                 */
<a name="5114"></a>                if(hiddenIn.length &gt; 0)                
<a name="5115"></a>                    moveHidden(&amp;hiddenIn, self);                    
<a name="5116"></a>                
<a name="5117"></a>                
<a name="5118"></a>                /* If there's nothing inside us, simply display our lookInMsg */
<a name="5119"></a>                if(contents.length == 0)
<a name="5120"></a>                    display(&amp;lookInMsg);                    
<a name="5121"></a>                
<a name="5122"></a>                /* Otherwise display a list of our contents */
<a name="5123"></a>                else
<a name="5124"></a>                {
<a name="5125"></a>                    /* Start by marking our contents as not mentioned. */
<a name="5126"></a>                    unmention(contents);
<a name="5127"></a>                    
<a name="5128"></a>                    /* 
<a name="5129"></a>                     *   It's possible that we have contents but nothing in our
<a name="5130"></a>                     *   contents is listable, so instead of just displaying a
<a name="5131"></a>                     *   list of contents we also watch to see if anything is
<a name="5132"></a>                     *   displayed; if nothing was we display our lookInMsg
<a name="5133"></a>                     *   instead.
<a name="5134"></a>                     */
<a name="5135"></a>                    if(gOutStream.watchForOutput(
<a name="5136"></a>                        {: listSubcontentsOf(self, &amp;myLookInLister) }) == nil)
<a name="5137"></a>                      display(&amp;lookInMsg);       
<a name="5138"></a>
<a name="5139"></a>                }
<a name="5140"></a>            }
<a name="5141"></a>            
<a name="5142"></a>            /* 
<a name="5143"></a>             *   Otherwise, if we're not a container-type object (our contType
<a name="5144"></a>             *   is not In), if there's anything in our hiddenIn list move it
<a name="5145"></a>             *   into scope and display a list of it.
<a name="5146"></a>             */
<a name="5147"></a>            else if(hiddenIn.length &gt; 0)            
<a name="5148"></a>                findHidden(&amp;hiddenIn, In);                               
<a name="5149"></a>                        
<a name="5150"></a>            
<a name="5151"></a>            /*  Otherwise just display our lookInMsg */
<a name="5152"></a>            else
<a name="5153"></a>                display(&amp;lookInMsg);
<a name="5154"></a>        }
<a name="5155"></a>        
<a name="5156"></a>    }
<a name="5157"></a>    
<a name="5158"></a>    /* 
<a name="5159"></a>     *   The lister to use when listing the objects inside me in response to a
<a name="5160"></a>     *   LOOK IN command. By default we use the lookInLister.
<a name="5161"></a>     */
<a name="5162"></a>    myLookInLister = lookInLister
<a name="5163"></a>    
<a name="5164"></a>    
<a name="5165"></a>    /* 
<a name="5166"></a>     *   By default our lookInMsg just says the actor finds nothing of interest
<a name="5167"></a>     *   in us; this could be overridden for an objecy with a more interesting
<a name="5168"></a>     *   interior.
<a name="5169"></a>     */
<a name="5170"></a>    lookInMsg = BMsg(look in, '{I} {see} nothing interesting in {the
<a name="5171"></a>        dobj}. ')
<a name="5172"></a>    
<a name="5173"></a>    
<a name="5174"></a>    /* 
<a name="5175"></a>     *   If there's something hidden in the dobj but nowhere obvious to move it
<a name="5176"></a>     *   to then by default we move everything from the hiddenIn list to the
<a name="5177"></a>     *   actor's inventory and announce that the actor has taken it. We call
<a name="5178"></a>     *   this out as a separate method to make it easy to override if desired.
<a name="5179"></a>     */    
<a name="5180"></a>    findHidden(prop, prep)
<a name="5181"></a>    {
<a name="5182"></a>        /* Report what we find */
<a name="5183"></a>        sayFindHidden(prop, prep);
<a name="5184"></a>        
<a name="5185"></a>        /* Move the hidden items to the appropriate location. */
<a name="5186"></a>        moveHidden(prop, findHiddenDest);        
<a name="5187"></a>    }
<a name="5188"></a>    
<a name="5189"></a>    /*  
<a name="5190"></a>     *   Report what was found hidded in/under/behind us. We make this a
<a name="5191"></a>     *   separate method so that it can be easily customized on individual
<a name="5192"></a>     *   objects.
<a name="5193"></a>     */
<a name="5194"></a>    sayFindHidden(prop, prep)
<a name="5195"></a>    {
<a name="5196"></a>         DMsg(find hidden, '\^{1} {the dobj} {i} {find} {2}&lt;&lt;if findHiddenDest ==
<a name="5197"></a>              gActor&gt;&gt;, which {i} {take}&lt;&lt;end&gt;&gt;. ',
<a name="5198"></a>             prep.prep, makeListStr(self.(prop)));
<a name="5199"></a>    }
<a name="5200"></a>    
<a name="5201"></a>    /* 
<a name="5202"></a>     *   We can look under most things, but there are some things (houses, the
<a name="5203"></a>     *   ground, sunlight) it might not make much sense to try looking under.
<a name="5204"></a>     */
<a name="5205"></a>    canLookUnderMe = true  
<a name="5206"></a>    
<a name="5207"></a>    
<a name="5208"></a>    dobjFor(LookUnder)
<a name="5209"></a>    {
<a name="5210"></a>        preCond = [objVisible, touchObj]
<a name="5211"></a>        
<a name="5212"></a>        remap = remapUnder        
<a name="5213"></a>        
<a name="5214"></a>        verify()
<a name="5215"></a>        {
<a name="5216"></a>            if(!canLookUnderMe)
<a name="5217"></a>                illogical(cannotLookUnderMsg);       
<a name="5218"></a>        }
<a name="5219"></a>        
<a name="5220"></a>        
<a name="5221"></a>        action()
<a name="5222"></a>        {            
<a name="5223"></a>            /* 
<a name="5224"></a>             *   If we're actually an underside-type object, i.e. if our
<a name="5225"></a>             *   contType is Under, try to determine what's under us and display
<a name="5226"></a>             *   a list of it; if there's nothing under us just display a
<a name="5227"></a>             *   message to that effect.
<a name="5228"></a>             */                       
<a name="5229"></a>            if(contType == Under)
<a name="5230"></a>            {
<a name="5231"></a>                
<a name="5232"></a>                /* 
<a name="5233"></a>                 *   If there's anything hidden under us move it into us before
<a name="5234"></a>                 *   doing anything else
<a name="5235"></a>                 */
<a name="5236"></a>                if(hiddenUnder.length &gt; 0)                
<a name="5237"></a>                    moveHidden(&amp;hiddenUnder, self);                    
<a name="5238"></a>                
<a name="5239"></a>                /* If there's nothing under us, simply display our lookUnerMsg */
<a name="5240"></a>                if(contents.length == 0)
<a name="5241"></a>                    display(&amp;lookUnderMsg);  
<a name="5242"></a>                
<a name="5243"></a>                /* Otherwise display a list of our contents */
<a name="5244"></a>                else
<a name="5245"></a>                {
<a name="5246"></a>                    /* Start by marking our contents as not mentioned. */
<a name="5247"></a>                    unmention(contents);
<a name="5248"></a>                    
<a name="5249"></a>                    /* 
<a name="5250"></a>                     *   It's possible that we have contents but nothing in our
<a name="5251"></a>                     *   contents is listable, so instead of just displaying a
<a name="5252"></a>                     *   list of contents we also watch to see if anything is
<a name="5253"></a>                     *   displayed; if nothing was we display our lookUnderMsg
<a name="5254"></a>                     *   instead.
<a name="5255"></a>                     */
<a name="5256"></a>                    if(gOutStream.watchForOutput(
<a name="5257"></a>                        {: listSubcontentsOf(self, &amp;myLookUnderLister) }) == nil)
<a name="5258"></a>                        display(&amp;lookUnderMsg);  
<a name="5259"></a>                    
<a name="5260"></a>                }
<a name="5261"></a>            }
<a name="5262"></a>            
<a name="5263"></a>            /* 
<a name="5264"></a>             *   Otherwise, if we're not an underside-type object (our contType
<a name="5265"></a>             *   is not Under), if there's anything in our hiddenUnder list move
<a name="5266"></a>             *   it into scope and display a list of it.
<a name="5267"></a>             */
<a name="5268"></a>            else if(hiddenUnder.length &gt; 0)            
<a name="5269"></a>                findHidden(&amp;hiddenUnder, Under);      
<a name="5270"></a>            
<a name="5271"></a>            /*  Otherwise just display our lookUnderMsg */
<a name="5272"></a>            else
<a name="5273"></a>                display(&amp;lookUnderMsg);           
<a name="5274"></a>            
<a name="5275"></a>        }
<a name="5276"></a>    }
<a name="5277"></a>    
<a name="5278"></a>    /* 
<a name="5279"></a>     *   The lister to use when listing the objects under me in response to a
<a name="5280"></a>     *   LOOK UNDER command. By default we use the lookInLister.
<a name="5281"></a>     */
<a name="5282"></a>    myLookUnderLister = lookInLister
<a name="5283"></a>    
<a name="5284"></a>    cannotLookUnderMsg = BMsg(cannot look under, '{I} {can\'t} look under {that
<a name="5285"></a>        dobj}. ')
<a name="5286"></a>    
<a name="5287"></a>    lookUnderMsg = BMsg(look under, '{I} {find} nothing of interest under
<a name="5288"></a>        {the dobj}. ')
<a name="5289"></a>    
<a name="5290"></a>     
<a name="5291"></a>    
<a name="5292"></a>    /* 
<a name="5293"></a>     *   By default we make it possible to look behind things, but there could
<a name="5294"></a>     *   be many things it makes no sense to try to look behind.
<a name="5295"></a>     */    
<a name="5296"></a>    canLookBehindMe = true    
<a name="5297"></a>    
<a name="5298"></a>    dobjFor(LookBehind)
<a name="5299"></a>    {
<a name="5300"></a>        preCond = [objVisible, touchObj]
<a name="5301"></a>        
<a name="5302"></a>        remap = remapBehind        
<a name="5303"></a>        
<a name="5304"></a>        verify()
<a name="5305"></a>        {
<a name="5306"></a>            if(!canLookBehindMe)
<a name="5307"></a>                illogical(cannotLookBehindMsg);
<a name="5308"></a>        }
<a name="5309"></a>        
<a name="5310"></a>        
<a name="5311"></a>        action()
<a name="5312"></a>        {            
<a name="5313"></a>            /* 
<a name="5314"></a>             *   If we're actually a rear-type object, i.e. if our contType is
<a name="5315"></a>             *   Behind, try to determine what's behind us and display a list of
<a name="5316"></a>             *   it; if there's nothing behind us just display a message to that
<a name="5317"></a>             *   effect.
<a name="5318"></a>             */
<a name="5319"></a>            if(contType == Behind)
<a name="5320"></a>            {
<a name="5321"></a>                
<a name="5322"></a>                /* 
<a name="5323"></a>                 *   If there's anything hidden behind us move it into us before
<a name="5324"></a>                 *   doing anything else
<a name="5325"></a>                 */
<a name="5326"></a>                if(hiddenBehind.length &gt; 0)                
<a name="5327"></a>                    moveHidden(&amp;hiddenBehind, self);                    
<a name="5328"></a>                
<a name="5329"></a>                /* 
<a name="5330"></a>                 *   If there's nothing behind us, simply display our
<a name="5331"></a>                 *   lookBehindMsg
<a name="5332"></a>                 */
<a name="5333"></a>                if(contents.length == 0)
<a name="5334"></a>                    display(&amp;lookBehindMsg);  
<a name="5335"></a>                
<a name="5336"></a>                /* Otherwise display a list of our contents */
<a name="5337"></a>                else
<a name="5338"></a>                {
<a name="5339"></a>                    /* Start by marking our contents as not mentioned. */
<a name="5340"></a>                    unmention(contents);
<a name="5341"></a>                    
<a name="5342"></a>                    /* 
<a name="5343"></a>                     *   It's possible that we have contents but nothing in our
<a name="5344"></a>                     *   contents is listable, so instead of just displaying a
<a name="5345"></a>                     *   list of contents we also watch to see if anything is
<a name="5346"></a>                     *   displayed; if nothing was we display our lookBehindMsg
<a name="5347"></a>                     *   instead.
<a name="5348"></a>                     */
<a name="5349"></a>                    if(gOutStream.watchForOutput(
<a name="5350"></a>                        {: listSubcontentsOf(self, &amp;myLookBehindLister) }) == nil)                        
<a name="5351"></a>                        display(&amp;lookBehindMsg); 
<a name="5352"></a>
<a name="5353"></a>                }
<a name="5354"></a>            }
<a name="5355"></a>            
<a name="5356"></a>            /* 
<a name="5357"></a>             *   Otherwise, if we're not a rear-type object (our contType is not
<a name="5358"></a>             *   Behind), if there's anything in our hiddenBehind list move it
<a name="5359"></a>             *   into scope and display a list of it.
<a name="5360"></a>             */
<a name="5361"></a>            else if(hiddenBehind.length &gt; 0)            
<a name="5362"></a>                findHidden(&amp;hiddenBehind, Behind);     
<a name="5363"></a>            
<a name="5364"></a>            /*  Otherwise just display our lookBehindMsg */
<a name="5365"></a>            else
<a name="5366"></a>                display(&amp;lookBehindMsg);           
<a name="5367"></a>            
<a name="5368"></a>            
<a name="5369"></a>        }
<a name="5370"></a>    }
<a name="5371"></a>    
<a name="5372"></a>    
<a name="5373"></a>    /* 
<a name="5374"></a>     *   The lister to use when listing the objects behind me in response to a
<a name="5375"></a>     *   LOOK BEHIND command. By default we use the lookInLister.
<a name="5376"></a>     */
<a name="5377"></a>    myLookBehindLister = lookInLister
<a name="5378"></a>    
<a name="5379"></a>    
<a name="5380"></a>    cannotLookBehindMsg = BMsg(cannot look behind, '{I} {can\'t} look behind
<a name="5381"></a>        {that dobj}. ')
<a name="5382"></a>    
<a name="5383"></a>    lookBehindMsg = BMsg(look behind, '{I} {find} nothing behind {the
<a name="5384"></a>        dobj}. ')
<a name="5385"></a>    
<a name="5386"></a>           
<a name="5387"></a>    
<a name="5388"></a>    /* 
<a name="5389"></a>     *   By default we make it possible to look through things, but there may
<a name="5390"></a>     *   well be things you obviously couldn't look through.
<a name="5391"></a>     */
<a name="5392"></a>    canLookThroughMe = true
<a name="5393"></a>    
<a name="5394"></a>    dobjFor(LookThrough)
<a name="5395"></a>    {
<a name="5396"></a>        preCond = [objVisible]
<a name="5397"></a>        
<a name="5398"></a>        verify()
<a name="5399"></a>        {
<a name="5400"></a>            if(!canLookThroughMe)
<a name="5401"></a>                illogical(cannotLookThroughMsg);            
<a name="5402"></a>        }
<a name="5403"></a>        
<a name="5404"></a>        action() { display(&amp;lookThroughMsg); }
<a name="5405"></a>    }
<a name="5406"></a>    
<a name="5407"></a>    cannotLookThroughMsg = BMsg(cannot look through, '{I} {can\'t} look through
<a name="5408"></a>        {that dobj}. ')
<a name="5409"></a>    
<a name="5410"></a>    lookThroughMsg = BMsg(look through, '{I} {see} nothing through {the
<a name="5411"></a>        dobj}. ')
<a name="5412"></a>    
<a name="5413"></a>    
<a name="5414"></a>    /* Most things cannot be gone through */
<a name="5415"></a>    canGoThroughMe = nil
<a name="5416"></a>    
<a name="5417"></a>    dobjFor(GoThrough)
<a name="5418"></a>    {
<a name="5419"></a>        preCond = [touchObj]
<a name="5420"></a>        verify() 
<a name="5421"></a>        { 
<a name="5422"></a>            if(!canGoThroughMe)
<a name="5423"></a>                illogical(cannotGoThroughMsg); 
<a name="5424"></a>        }
<a name="5425"></a>    }
<a name="5426"></a>    
<a name="5427"></a>    cannotGoThroughMsg = BMsg(cannot go through,'{I} {can\'t} go through {that
<a name="5428"></a>        dobj}. ')
<a name="5429"></a>    
<a name="5430"></a>    
<a name="5431"></a>    /* Most things cannot be gone along */
<a name="5432"></a>    canGoAlongMe = nil
<a name="5433"></a>    
<a name="5434"></a>    dobjFor(GoAlong)
<a name="5435"></a>    {
<a name="5436"></a>        preCond = [touchObj]
<a name="5437"></a>        verify() 
<a name="5438"></a>        { 
<a name="5439"></a>            if(!canGoAlongMe)
<a name="5440"></a>                illogical(cannotGoAlongMsg); 
<a name="5441"></a>        }
<a name="5442"></a>    }
<a name="5443"></a>    
<a name="5444"></a>    cannotGoAlongMsg = BMsg(cannot go through,'{I} {can\'t} go along {that
<a name="5445"></a>        dobj}. ')
<a name="5446"></a>    
<a name="5447"></a>    
<a name="5448"></a>    /* We can at least try to push most things. */
<a name="5449"></a>    isPushable = true
<a name="5450"></a>    
<a name="5451"></a>    dobjFor(Push)
<a name="5452"></a>    {
<a name="5453"></a>        preCond = [touchObj]
<a name="5454"></a>        verify()
<a name="5455"></a>        {
<a name="5456"></a>            if(!isPushable)
<a name="5457"></a>                illogical(cannotPushMsg);
<a name="5458"></a>        }
<a name="5459"></a>        
<a name="5460"></a>        report() { say(pushNoEffectMsg); }
<a name="5461"></a>    }
<a name="5462"></a>        
<a name="5463"></a>    cannotPushMsg = BMsg(cannot push, 'There{\'s} no point trying to push
<a name="5464"></a>        {that dobj}. ')
<a name="5465"></a>    
<a name="5466"></a>    pushNoEffectMsg = BMsg(push no effect, 'Pushing {1} {dummy} {has} no
<a name="5467"></a>        effect. ', gActionListStr)
<a name="5468"></a>    
<a name="5469"></a>    /* We can at least try to pull most things. */
<a name="5470"></a>    isPullable = true
<a name="5471"></a>    
<a name="5472"></a>    dobjFor(Pull)
<a name="5473"></a>    {
<a name="5474"></a>        preCond = [touchObj]
<a name="5475"></a>        
<a name="5476"></a>        verify()
<a name="5477"></a>        {
<a name="5478"></a>            if(!isPullable)
<a name="5479"></a>                illogical(cannotPullMsg);
<a name="5480"></a>        }
<a name="5481"></a>        
<a name="5482"></a>        report() { say(pullNoEffectMsg); }
<a name="5483"></a>    }
<a name="5484"></a>    
<a name="5485"></a>    cannotPullMsg = BMsg(cannot pull, 'There{\'s} no point trying to pull
<a name="5486"></a>        {that dobj}. ')
<a name="5487"></a>    
<a name="5488"></a>    pullNoEffectMsg = BMsg(pull no effect, 'Pulling {1} {dummy} {has} no
<a name="5489"></a>        effect. ', gActionListStr)
<a name="5490"></a>    
<a name="5491"></a>    /* 
<a name="5492"></a>     *   The most usual reason why we can't put something somewhere is that we
<a name="5493"></a>     *   can't pick it up in the first place, so by default we'll just copy
<a name="5494"></a>     *   cannotPutMsg from cannotTakeMsg.
<a name="5495"></a>     */
<a name="5496"></a>    cannotPutMsg = cannotTakeMsg
<a name="5497"></a>    
<a name="5498"></a>       
<a name="5499"></a>    dobjFor(PutOn)
<a name="5500"></a>    {
<a name="5501"></a>        preCond = [objHeld, objNotWorn]
<a name="5502"></a>        
<a name="5503"></a>        verify()
<a name="5504"></a>        {
<a name="5505"></a>            if(gVerifyIobj == self)
<a name="5506"></a>                illogicalSelf(cannotPutInSelfMsg);  
<a name="5507"></a>            
<a name="5508"></a>            if(isFixed)
<a name="5509"></a>                illogical(cannotPutMsg);
<a name="5510"></a>            
<a name="5511"></a>            if(isDirectlyIn(gVerifyIobj))
<a name="5512"></a>                illogicalNow(alreadyInMsg);
<a name="5513"></a>            
<a name="5514"></a>            if(gVerifyIobj.isIn(self))
<a name="5515"></a>                illogicalNow(circularlyInMsg);     
<a name="5516"></a>            
<a name="5517"></a>           
<a name="5518"></a>            
<a name="5519"></a>            logical;
<a name="5520"></a>        }
<a name="5521"></a>        
<a name="5522"></a>        
<a name="5523"></a>        action()
<a name="5524"></a>        {          
<a name="5525"></a>            /* Handled on iobj */                                    
<a name="5526"></a>        }
<a name="5527"></a>        
<a name="5528"></a>        report()
<a name="5529"></a>        {
<a name="5530"></a>            DMsg(report put on, '{I} {put} {1} on {the iobj}. ', gActionListStr);            
<a name="5531"></a>        }
<a name="5532"></a>    }
<a name="5533"></a>    
<a name="5534"></a>    alreadyInMsg = BMsg(already in, '{The subj dobj} {is} already {1}. ', gVerifyIobj.objInName)
<a name="5535"></a>    
<a name="5536"></a>    circularlyInMsg = BMsg(circularly in, '{I} {can\'t} put {the dobj} {1}
<a name="5537"></a>        while {the subj iobj} {is} {in dobj}. ', gVerifyIobj.objInName)
<a name="5538"></a>        
<a name="5539"></a>    cannotPutInSelfMsg = BMsg(cannot put in self, '{I} {can\'t} put {the dobj}
<a name="5540"></a>        {1} {itself dobj}. ', gIobj.objInPrep)
<a name="5541"></a>    
<a name="5542"></a>    iobjFor(PutOn)
<a name="5543"></a>    {
<a name="5544"></a>        
<a name="5545"></a>        preCond = [touchObj]
<a name="5546"></a>        
<a name="5547"></a>        remap = remapOn         
<a name="5548"></a>        
<a name="5549"></a>        verify()
<a name="5550"></a>        {
<a name="5551"></a>            if(contType != On)
<a name="5552"></a>                illogical(cannotPutOnMsg);
<a name="5553"></a>            
<a name="5554"></a>            logical;
<a name="5555"></a>        }
<a name="5556"></a>        
<a name="5557"></a>        check()
<a name="5558"></a>        {
<a name="5559"></a>            checkInsert(gDobj);
<a name="5560"></a>        }
<a name="5561"></a>        
<a name="5562"></a>        action()
<a name="5563"></a>        {
<a name="5564"></a>            gDobj.actionMoveInto(self);
<a name="5565"></a>        }      
<a name="5566"></a>    
<a name="5567"></a>    }
<a name="5568"></a>    
<a name="5569"></a>    cannotPutOnMsg = BMsg(cannot put on,'{I} {can\'t} put anything on {the
<a name="5570"></a>        iobj}. '   )
<a name="5571"></a>    
<a name="5572"></a>    dobjFor(PutIn)
<a name="5573"></a>    {
<a name="5574"></a>        preCond = [objHeld, objNotWorn]
<a name="5575"></a>        
<a name="5576"></a>        verify()
<a name="5577"></a>        {
<a name="5578"></a>            if(gVerifyIobj == self)
<a name="5579"></a>                illogicalSelf(cannotPutInSelfMsg);   
<a name="5580"></a>            
<a name="5581"></a>            if(isDirectlyIn(gVerifyIobj))
<a name="5582"></a>                illogicalNow(alreadyInMsg);
<a name="5583"></a>            
<a name="5584"></a>            if(isFixed)
<a name="5585"></a>                illogical(cannotPutMsg);
<a name="5586"></a>            
<a name="5587"></a>            if(gVerifyIobj.isIn(self))
<a name="5588"></a>                illogicalNow(circularlyInMsg);    
<a name="5589"></a>                        
<a name="5590"></a>            
<a name="5591"></a>            logical;
<a name="5592"></a>        }
<a name="5593"></a>        
<a name="5594"></a>              
<a name="5595"></a>        action()
<a name="5596"></a>        {                     
<a name="5597"></a>            /* handled on iobj */                          
<a name="5598"></a>        }
<a name="5599"></a>        
<a name="5600"></a>        report()
<a name="5601"></a>        {
<a name="5602"></a>            DMsg(report put in, '{I} {put} {1} in {the iobj}. ', gActionListStr);            
<a name="5603"></a>        }
<a name="5604"></a>    }
<a name="5605"></a>    
<a name="5606"></a>    
<a name="5607"></a>        
<a name="5608"></a>    iobjFor(PutIn)
<a name="5609"></a>    {
<a name="5610"></a>        preCond = [containerOpen, touchObj]
<a name="5611"></a>        
<a name="5612"></a>        remap = remapIn        
<a name="5613"></a>        
<a name="5614"></a>        verify()
<a name="5615"></a>        {
<a name="5616"></a>            if(!canPutInMe)
<a name="5617"></a>                illogical(cannotPutInMsg);
<a name="5618"></a>            
<a name="5619"></a>            logical;
<a name="5620"></a>        }
<a name="5621"></a>        
<a name="5622"></a>        check()
<a name="5623"></a>        {
<a name="5624"></a>            /* 
<a name="5625"></a>             *   If we're actually a container-like object (our contType is In),
<a name="5626"></a>             *   check whether there's enough room inside us to contain the
<a name="5627"></a>             *   direct object.
<a name="5628"></a>             */
<a name="5629"></a>            if(contType == In)
<a name="5630"></a>               checkInsert(gDobj);
<a name="5631"></a>            
<a name="5632"></a>            /*  
<a name="5633"></a>             *   Otherwise check whether adding the direct object to our
<a name="5634"></a>             *   hiddenIn list would exceed the amount of bulk allowed there.
<a name="5635"></a>             */
<a name="5636"></a>            else if(gDobj.bulk &gt; maxBulkHiddenIn - getBulkHiddenIn)
<a name="5637"></a>                DMsg(no room in, 'There {dummy}{isn\'t} enough room for {the
<a name="5638"></a>                    dobj} in {the iobj}. ');            
<a name="5639"></a>        }
<a name="5640"></a>        
<a name="5641"></a>        action()
<a name="5642"></a>        {
<a name="5643"></a>            /* 
<a name="5644"></a>             *   If we're actually a container-like object (i.e. if our contType
<a name="5645"></a>             *   is In) then something put in us can be moved inside us.
<a name="5646"></a>             *   Otherwise, all we can do with something put in us is to add it
<a name="5647"></a>             *   to our hiddenIn list and move it off-stage.
<a name="5648"></a>             */            
<a name="5649"></a>            if(contType == In)
<a name="5650"></a>                gDobj.actionMoveInto(self);
<a name="5651"></a>            else
<a name="5652"></a>            {
<a name="5653"></a>                hiddenIn += gDobj;
<a name="5654"></a>                gDobj.actionMoveInto(nil);
<a name="5655"></a>            }  
<a name="5656"></a>        }      
<a name="5657"></a>    
<a name="5658"></a>    }
<a name="5659"></a>    
<a name="5660"></a>    cannotPutInMsg = BMsg(cannot put in, '{I} {can\'t} put anything in {the
<a name="5661"></a>        iobj}. ')
<a name="5662"></a>    
<a name="5663"></a>    dobjFor(PutUnder)
<a name="5664"></a>    {
<a name="5665"></a>        preCond = [objHeld, objNotWorn]
<a name="5666"></a>        
<a name="5667"></a>                
<a name="5668"></a>        verify()
<a name="5669"></a>        {
<a name="5670"></a>            if(gVerifyIobj == gIobj)
<a name="5671"></a>                illogicalSelf(cannotPutInSelfMsg);     
<a name="5672"></a>            
<a name="5673"></a>            if(isFixed)
<a name="5674"></a>                illogical(cannotPutMsg);
<a name="5675"></a>            
<a name="5676"></a>            if(isDirectlyIn(gVerifyIobj))
<a name="5677"></a>                illogicalNow(alreadyInMsg);
<a name="5678"></a>            
<a name="5679"></a>            if(gVerifyIobj.isIn(self))
<a name="5680"></a>                illogicalNow(circularlyInMsg);           
<a name="5681"></a>            
<a name="5682"></a>                         
<a name="5683"></a>            logical;           
<a name="5684"></a>        }
<a name="5685"></a>        
<a name="5686"></a>        action()
<a name="5687"></a>        {
<a name="5688"></a>            /* Handled by iobj */
<a name="5689"></a>        }
<a name="5690"></a>        
<a name="5691"></a>        report()
<a name="5692"></a>        {
<a name="5693"></a>            DMsg(report put under, '{I} {put} {1} under {the iobj}. ', 
<a name="5694"></a>                 gActionListStr);
<a name="5695"></a>        }
<a name="5696"></a>        
<a name="5697"></a>            
<a name="5698"></a>    }
<a name="5699"></a>    
<a name="5700"></a>    iobjFor(PutUnder)
<a name="5701"></a>    {
<a name="5702"></a>        preCond = [touchObj]
<a name="5703"></a>        
<a name="5704"></a>        remap = remapUnder
<a name="5705"></a>        
<a name="5706"></a>        verify()
<a name="5707"></a>        {
<a name="5708"></a>            if(!canPutUnderMe)
<a name="5709"></a>                illogical(cannotPutUnderMsg);
<a name="5710"></a>            else
<a name="5711"></a>                logical;
<a name="5712"></a>        }
<a name="5713"></a>        
<a name="5714"></a>        check() 
<a name="5715"></a>        { 
<a name="5716"></a>            /* 
<a name="5717"></a>             *   If we're actually an underside-like object (our contType is
<a name="5718"></a>             *   Under), check whether there's enough room under us to contain
<a name="5719"></a>             *   the direct object.
<a name="5720"></a>             */
<a name="5721"></a>            if(contType == Under)
<a name="5722"></a>               checkInsert(gDobj); 
<a name="5723"></a>            
<a name="5724"></a>            /*  
<a name="5725"></a>             *   Otherwise check whether adding the direct object to our
<a name="5726"></a>             *   hiddenUnder list would exceed the amount of bulk allowed there.
<a name="5727"></a>             */
<a name="5728"></a>            else if(gDobj.bulk &gt; maxBulkHiddenUnder - getBulkHiddenUnder)
<a name="5729"></a>                DMsg(no room under, 'There {dummy}{isn\'t} enough room for {the
<a name="5730"></a>                    dobj} under {the iobj}. ');    
<a name="5731"></a>        }
<a name="5732"></a>        
<a name="5733"></a>        action()
<a name="5734"></a>        {
<a name="5735"></a>            /* 
<a name="5736"></a>             *   If we're actually an underside-like object (i.e. if our
<a name="5737"></a>             *   contType is Under) then something put under us can be moved
<a name="5738"></a>             *   inside us. Otherwise, all we can do with something put under us
<a name="5739"></a>             *   is to add it to our hiddenUnder list and move it off-stage.
<a name="5740"></a>             */
<a name="5741"></a>            if(contType == Under)
<a name="5742"></a>                gDobj.actionMoveInto(self);
<a name="5743"></a>            else
<a name="5744"></a>            {
<a name="5745"></a>                hiddenUnder += gDobj;
<a name="5746"></a>                gDobj.actionMoveInto(nil);
<a name="5747"></a>            }
<a name="5748"></a>        }
<a name="5749"></a>        
<a name="5750"></a>        
<a name="5751"></a>    }
<a name="5752"></a>    
<a name="5753"></a>    cannotPutUnderMsg = BMsg(cannot put under, '{I} {cannot} put anything under
<a name="5754"></a>        {the iobj}. ' )
<a name="5755"></a>        
<a name="5756"></a>    dobjFor(PutBehind)
<a name="5757"></a>    {
<a name="5758"></a>        preCond = [objHeld, objNotWorn]
<a name="5759"></a>        
<a name="5760"></a>        verify()
<a name="5761"></a>        {
<a name="5762"></a>            if(gVerifyIobj == self)
<a name="5763"></a>                illogicalSelf(cannotPutInSelfMsg);     
<a name="5764"></a>            
<a name="5765"></a>            if(isFixed)
<a name="5766"></a>                illogical(cannotPutMsg);
<a name="5767"></a>            
<a name="5768"></a>            if(isDirectlyIn(gVerifyIobj))
<a name="5769"></a>                illogicalNow(alreadyInMsg);
<a name="5770"></a>            
<a name="5771"></a>            if(gVerifyIobj.isIn(self))
<a name="5772"></a>                illogicalNow(circularlyInMsg);           
<a name="5773"></a>            
<a name="5774"></a>                         
<a name="5775"></a>            logical;           
<a name="5776"></a>        }
<a name="5777"></a>        
<a name="5778"></a>        action()
<a name="5779"></a>        {
<a name="5780"></a>            /* Handled by iobj */
<a name="5781"></a>        }
<a name="5782"></a>        
<a name="5783"></a>        report()
<a name="5784"></a>        {
<a name="5785"></a>            DMsg(report put behind, '{I} {put} {1} behind {the iobj}. ', 
<a name="5786"></a>                 gActionListStr);
<a name="5787"></a>        }
<a name="5788"></a>        
<a name="5789"></a>            
<a name="5790"></a>    }
<a name="5791"></a>    
<a name="5792"></a>    iobjFor(PutBehind)
<a name="5793"></a>    {
<a name="5794"></a>        preCond = [touchObj]
<a name="5795"></a>        
<a name="5796"></a>        remap = remapBehind
<a name="5797"></a>        
<a name="5798"></a>        verify()
<a name="5799"></a>        {
<a name="5800"></a>            if(!canPutBehindMe)
<a name="5801"></a>                illogical(cannotPutBehindMsg);
<a name="5802"></a>            else
<a name="5803"></a>                logical;
<a name="5804"></a>        }
<a name="5805"></a>        
<a name="5806"></a>        check() 
<a name="5807"></a>        { 
<a name="5808"></a>            /* 
<a name="5809"></a>             *   If we're actually a rear-like object (our contType is Behind),
<a name="5810"></a>             *   check whether there's enough room behind us to contain the
<a name="5811"></a>             *   direct object.
<a name="5812"></a>             */
<a name="5813"></a>            if(contType == Behind)
<a name="5814"></a>                checkInsert(gDobj);
<a name="5815"></a>            
<a name="5816"></a>            /*  
<a name="5817"></a>             *   Otherwise check whether adding the direct object to our
<a name="5818"></a>             *   hiddenBehind list would exceed the amount of bulk allowed
<a name="5819"></a>             *   there.
<a name="5820"></a>             */
<a name="5821"></a>             else if(gDobj.bulk &gt; maxBulkHiddenBehind - getBulkHiddenBehind)
<a name="5822"></a>                DMsg(no room behind, 'There {dummy}{isn\'t} enough room for {the
<a name="5823"></a>                    dobj} behind {the iobj}. ');    
<a name="5824"></a>        }
<a name="5825"></a>        
<a name="5826"></a>        action()
<a name="5827"></a>        {
<a name="5828"></a>            /* 
<a name="5829"></a>             *   If we're actually a rear-like object (i.e. if our contType is
<a name="5830"></a>             *   Behind) then something put behind us can be moved inside us.
<a name="5831"></a>             *   Otherwise, all we can do with something put behind us is to add
<a name="5832"></a>             *   it to our hiddenBehind list and move it off-stage.
<a name="5833"></a>             */
<a name="5834"></a>            if(contType == Behind)
<a name="5835"></a>                gDobj.actionMoveInto(self);
<a name="5836"></a>            else
<a name="5837"></a>            {
<a name="5838"></a>                hiddenBehind += gDobj;
<a name="5839"></a>                gDobj.actionMoveInto(nil);
<a name="5840"></a>            }
<a name="5841"></a>        }
<a name="5842"></a>        
<a name="5843"></a>        
<a name="5844"></a>    }   
<a name="5845"></a>    
<a name="5846"></a>    cannotPutBehindMsg = BMsg(cannot put behind, '{I} {cannot} put anything
<a name="5847"></a>        behind {the iobj}. ')
<a name="5848"></a>    
<a name="5849"></a>    /* 
<a name="5850"></a>     *   A list of Keys that can be used to lock or unlock this Thing. Any Keys
<a name="5851"></a>     *   in this list will cause this Thing to be added to the plausible and
<a name="5852"></a>     *   actual lock lists of that Key at PreInit. This provides an alternative
<a name="5853"></a>     *   way of specifying the relation between locks and keys.
<a name="5854"></a>     */        
<a name="5855"></a>    keyList = nil
<a name="5856"></a>       
<a name="5857"></a>    /*   
<a name="5858"></a>     *   A list of Keys that the player character starts out knowing at the
<a name="5859"></a>     *   start of the game can lock our unlock this Thing.
<a name="5860"></a>     */
<a name="5861"></a>    knownKeyList = nil
<a name="5862"></a>    
<a name="5863"></a>    /* 
<a name="5864"></a>     *   Note: we don't use isLockable, because this is not a binary property;
<a name="5865"></a>     *   there are different kings of lockability and defining an isLockable
<a name="5866"></a>     *   property in addition would only confuse things and might break the
<a name="5867"></a>     *   logic.
<a name="5868"></a>     */    
<a name="5869"></a>    dobjFor(UnlockWith)
<a name="5870"></a>    {
<a name="5871"></a>        
<a name="5872"></a>        preCond = [touchObj]
<a name="5873"></a>        
<a name="5874"></a>        /* 
<a name="5875"></a>         *   Remap the unlock action to our remapIn object if we're not lockable
<a name="5876"></a>         *   but we have a lockable remapIn object (i.e. an associated
<a name="5877"></a>         *   container).
<a name="5878"></a>         */
<a name="5879"></a>        remap()
<a name="5880"></a>        {
<a name="5881"></a>            if(lockability == notLockable &amp;&amp; remapIn != nil &amp;&amp;
<a name="5882"></a>               remapIn.lockability != notLockable)
<a name="5883"></a>                return remapIn;
<a name="5884"></a>            else
<a name="5885"></a>                return self;
<a name="5886"></a>        }
<a name="5887"></a>        
<a name="5888"></a>        verify()
<a name="5889"></a>        {
<a name="5890"></a>            /* 
<a name="5891"></a>             *   If we're not lockable at all, we're a very poor choice of
<a name="5892"></a>             *   direct object for an UnlockWith action.
<a name="5893"></a>             */
<a name="5894"></a>            if(lockability == notLockable || lockability == nil)
<a name="5895"></a>                illogical(notLockableMsg);
<a name="5896"></a>            
<a name="5897"></a>            /*  
<a name="5898"></a>             *   If we're lockable, but not with a key (either because we don't
<a name="5899"></a>             *   need one at all or because we use some other form of locking
<a name="5900"></a>             *   mechanism) then we're still a bad choice of object for an
<a name="5901"></a>             *   UnlockWith action, but not so bad as if we weren't lockable at
<a name="5902"></a>             *   all.
<a name="5903"></a>             */
<a name="5904"></a>            if(lockability == lockableWithoutKey)
<a name="5905"></a>                implausible(keyNotNeededMsg);
<a name="5906"></a>            
<a name="5907"></a>            if(lockability == indirectLockable)
<a name="5908"></a>                implausible(indirectLockableMsg);
<a name="5909"></a>            
<a name="5910"></a>            /*  
<a name="5911"></a>             *   If we are lockable with key, then were a good choice of object
<a name="5912"></a>             *   for an UnlockWith action provided we're currently locked.
<a name="5913"></a>             */
<a name="5914"></a>            if(lockability == lockableWithKey)
<a name="5915"></a>            {
<a name="5916"></a>                if(isLocked)
<a name="5917"></a>                    logical;
<a name="5918"></a>                else
<a name="5919"></a>                    illogicalNow(notLockedMsg);
<a name="5920"></a>            }
<a name="5921"></a>        }
<a name="5922"></a>    }
<a name="5923"></a>    
<a name="5924"></a>    notLockableMsg = BMsg(not lockable, '{The subj dobj} {isn\'t} lockable. ')
<a name="5925"></a>    keyNotNeededMsg = BMsg(key not needed,'{I} {don\'t need[ed]} a key to lock
<a name="5926"></a>        and unlock {the dobj}. ')
<a name="5927"></a>    indirectLockableMsg = BMsg(indirect lockable,'{The dobj} appear{s/ed} to use
<a name="5928"></a>        some other kind of locking mechanism. ')
<a name="5929"></a>    notLockedMsg = BMsg(not locked, '{The subj dobj} {isn\'t} locked. ')
<a name="5930"></a>    
<a name="5931"></a>    /* 
<a name="5932"></a>     *   Most things can't be used to unlock with. In practice there's probably
<a name="5933"></a>     *   little point in overriding this property since if you do want to use
<a name="5934"></a>     *   something to unlock other things with, you'd use the Key class.
<a name="5935"></a>     */
<a name="5936"></a>    canUnlockWithMe = nil 
<a name="5937"></a>    
<a name="5938"></a>    iobjFor(UnlockWith)
<a name="5939"></a>    {
<a name="5940"></a>        preCond = [touchObj]
<a name="5941"></a>        
<a name="5942"></a>        verify()
<a name="5943"></a>        {
<a name="5944"></a>            if(!canUnlockWithMe)
<a name="5945"></a>               illogical(cannotUnlockWithMsg);
<a name="5946"></a>            
<a name="5947"></a>            if(gVerifyDobj == self)
<a name="5948"></a>                illogicalSelf(cannotUnlockWithSelfMsg);
<a name="5949"></a>        }      
<a name="5950"></a>    }
<a name="5951"></a>    
<a name="5952"></a>    cannotUnlockWithMsg = BMsg(cannot unlock with, '{I} {can\'t} unlock
<a name="5953"></a>        anything with {that iobj}. ' )
<a name="5954"></a>    
<a name="5955"></a>    cannotUnlockWithSelfMsg = BMsg(cannot unlock with self, '{I} {can\'t} unlock
<a name="5956"></a>        anything with itself. ' )
<a name="5957"></a>    
<a name="5958"></a>    dobjFor(LockWith)
<a name="5959"></a>    {
<a name="5960"></a>        preCond  = [objClosed, touchObj]
<a name="5961"></a>        
<a name="5962"></a>         /* 
<a name="5963"></a>          *   Remap the lock action to our remapIn object if we're not lockable
<a name="5964"></a>          *   but we have a lockable remapIn object (i.e. an associated
<a name="5965"></a>          *   container).
<a name="5966"></a>          */
<a name="5967"></a>        remap()
<a name="5968"></a>        {
<a name="5969"></a>            if(lockability == notLockable &amp;&amp; remapIn != nil &amp;&amp;
<a name="5970"></a>               remapIn.lockability != notLockable)
<a name="5971"></a>                return remapIn;
<a name="5972"></a>            else
<a name="5973"></a>                return self;
<a name="5974"></a>        }
<a name="5975"></a>        
<a name="5976"></a>        verify()
<a name="5977"></a>        {
<a name="5978"></a>            if(lockability == notLockable || lockability == nil)
<a name="5979"></a>                illogical(notLockableMsg);
<a name="5980"></a>            
<a name="5981"></a>            if(lockability == lockableWithoutKey)
<a name="5982"></a>                implausible(keyNotNeededMsg);
<a name="5983"></a>            
<a name="5984"></a>            if(lockability == indirectLockable)
<a name="5985"></a>                implausible(indirectLockableMsg);
<a name="5986"></a>            
<a name="5987"></a>            if(lockability == lockableWithKey)
<a name="5988"></a>            {
<a name="5989"></a>                if(isLocked)
<a name="5990"></a>                   illogicalNow(alreadyLockedMsg);
<a name="5991"></a>                else                    
<a name="5992"></a>                    logical;
<a name="5993"></a>            }
<a name="5994"></a>        }
<a name="5995"></a>        
<a name="5996"></a>    }
<a name="5997"></a>    
<a name="5998"></a>    alreadyLockedMsg = BMsg(already locked, '{The subj dobj} {is} already
<a name="5999"></a>        locked. ')
<a name="6000"></a>    
<a name="6001"></a>    
<a name="6002"></a>    /* 
<a name="6003"></a>     *   Usually, if something can be used to unlock things it can also be used
<a name="6004"></a>     *   to lock them
<a name="6005"></a>     */
<a name="6006"></a>    canLockWithMe = (canUnlockWithMe)
<a name="6007"></a>    
<a name="6008"></a>    iobjFor(LockWith)
<a name="6009"></a>    {
<a name="6010"></a>        preCond = [touchObj]
<a name="6011"></a>        
<a name="6012"></a>        verify()
<a name="6013"></a>        {
<a name="6014"></a>            if(!canLockWithMe)
<a name="6015"></a>               illogical(cannotLockWithMsg);
<a name="6016"></a>            
<a name="6017"></a>            if(gVerifyDobj == self)
<a name="6018"></a>                illogicalSelf(cannotLockWithSelfMsg);
<a name="6019"></a>        }      
<a name="6020"></a>    }
<a name="6021"></a>    
<a name="6022"></a>    cannotLockWithMsg = BMsg(cannot lock with, '{I} {can\'t} lock anything with
<a name="6023"></a>        {that iobj}. ' )
<a name="6024"></a>    
<a name="6025"></a>    cannotLockWithSelfMsg = BMsg(cannot lock with self, '{I} {can\'t} lock
<a name="6026"></a>        anything with itself. ' )
<a name="6027"></a>    
<a name="6028"></a>    
<a name="6029"></a>    dobjFor(Unlock)
<a name="6030"></a>    {
<a name="6031"></a>        preCond = [touchObj]
<a name="6032"></a>        
<a name="6033"></a>        /* 
<a name="6034"></a>         *   Remap the unlock action to our remapIn object if we're not lockable
<a name="6035"></a>         *   but we have a lockable remapIn object (i.e. an associated
<a name="6036"></a>         *   container).
<a name="6037"></a>         */
<a name="6038"></a>        remap()
<a name="6039"></a>        {
<a name="6040"></a>            if(lockability == notLockable &amp;&amp; remapIn != nil &amp;&amp;
<a name="6041"></a>               remapIn.lockability != notLockable)
<a name="6042"></a>                return remapIn;
<a name="6043"></a>            else
<a name="6044"></a>                return self;
<a name="6045"></a>        }
<a name="6046"></a>        
<a name="6047"></a>        verify()
<a name="6048"></a>        {
<a name="6049"></a>            if(lockability == notLockable || lockability == nil)
<a name="6050"></a>                illogical(notLockableMsg);
<a name="6051"></a>            
<a name="6052"></a>            if(lockability == indirectLockable)
<a name="6053"></a>                implausible(indirectLockableMsg);
<a name="6054"></a>            
<a name="6055"></a>            if(!isLocked)            
<a name="6056"></a>                illogicalNow(notLockedMsg);           
<a name="6057"></a>        }
<a name="6058"></a>        
<a name="6059"></a>        check()
<a name="6060"></a>        {
<a name="6061"></a>            /* 
<a name="6062"></a>             *   if we need a key to be unlocked with, check whether the player
<a name="6063"></a>             *   is holding a suitable one.
<a name="6064"></a>             */
<a name="6065"></a>            if(lockability == lockableWithKey)            
<a name="6066"></a>                findPlausibleKey();                
<a name="6067"></a>            
<a name="6068"></a>               
<a name="6069"></a>        }
<a name="6070"></a>        
<a name="6071"></a>        action()
<a name="6072"></a>        {
<a name="6073"></a>            /* 
<a name="6074"></a>             *   The useKey_ property will have been set by the
<a name="6075"></a>             *   findPlausibleKey() method at the check stage. If it's non-nil
<a name="6076"></a>             *   it's the key we're going to use to try to unlock this object
<a name="6077"></a>             *   with, so we display a parenthetical note to the player that
<a name="6078"></a>             *   we're using this key. (Note: the action would have failed at
<a name="6079"></a>             *   the check stage if useKey_ wasn't the right key for the job).
<a name="6080"></a>             */
<a name="6081"></a>            if(useKey_ != nil)
<a name="6082"></a>                extraReport(withKeyMsg);
<a name="6083"></a>            
<a name="6084"></a>            /* 
<a name="6085"></a>             *   Otherwise, if we need a key to unlock this object with, ask the
<a name="6086"></a>             *   player to specify it and then execute an UnlockWith action
<a name="6087"></a>             *   using that key.
<a name="6088"></a>             */ 
<a name="6089"></a>            else if(lockability == lockableWithKey)
<a name="6090"></a>                askForIobj(UnlockWith);
<a name="6091"></a>            
<a name="6092"></a>            /*  Make us unlocked. */
<a name="6093"></a>            makeLocked(nil);               
<a name="6094"></a>        }
<a name="6095"></a>        
<a name="6096"></a>        report()
<a name="6097"></a>        {
<a name="6098"></a>            DMsg(report unlock, okayUnlockMsg, gActionListStr);
<a name="6099"></a>        }
<a name="6100"></a>        
<a name="6101"></a>    }
<a name="6102"></a>    
<a name="6103"></a>    okayUnlockMsg = 'Unlocked.|{I} unlock{s/ed} {1}. '
<a name="6104"></a>    
<a name="6105"></a>    dobjFor(Lock)
<a name="6106"></a>    {
<a name="6107"></a>        preCond = [objClosed, touchObj]
<a name="6108"></a>        
<a name="6109"></a>         /* 
<a name="6110"></a>          *   Remap the lock action to our remapIn object if we're not lockable
<a name="6111"></a>          *   but we have a lockable remapIn object (i.e. an associated
<a name="6112"></a>          *   container).
<a name="6113"></a>          */
<a name="6114"></a>        remap()
<a name="6115"></a>        {
<a name="6116"></a>            if(lockability == notLockable &amp;&amp; remapIn != nil &amp;&amp;
<a name="6117"></a>               remapIn.lockability != notLockable)
<a name="6118"></a>                return remapIn;
<a name="6119"></a>            else
<a name="6120"></a>                return self;
<a name="6121"></a>        }
<a name="6122"></a>        
<a name="6123"></a>        verify()
<a name="6124"></a>        {
<a name="6125"></a>            if(lockability == notLockable || lockability == nil)
<a name="6126"></a>                illogical(notLockableMsg);
<a name="6127"></a>            
<a name="6128"></a>            if(lockability == indirectLockable)
<a name="6129"></a>                implausible(indirectLockableMsg);            
<a name="6130"></a>            
<a name="6131"></a>            if(isLocked)
<a name="6132"></a>                illogicalNow(alreadyLockedMsg);            
<a name="6133"></a>            
<a name="6134"></a>        }
<a name="6135"></a>        
<a name="6136"></a>        check()
<a name="6137"></a>        {
<a name="6138"></a>            /* 
<a name="6139"></a>             *   if we need a key to be locked with, check whether the player
<a name="6140"></a>             *   is holding a suitable one.
<a name="6141"></a>             */
<a name="6142"></a>            if(lockability == lockableWithKey)            
<a name="6143"></a>                findPlausibleKey();                
<a name="6144"></a>            
<a name="6145"></a>               
<a name="6146"></a>        }
<a name="6147"></a>        
<a name="6148"></a>        action()
<a name="6149"></a>        {
<a name="6150"></a>            /* 
<a name="6151"></a>             *   The useKey_ property will have been set by the
<a name="6152"></a>             *   findPlausibleKey() method at the check stage. If it's non-nil
<a name="6153"></a>             *   it's the key we're going to use to try to lock this object
<a name="6154"></a>             *   with, so we display a parenthetical note to the player that
<a name="6155"></a>             *   we're using this key. (Note: the action would have failed at
<a name="6156"></a>             *   the check stage if useKey_ wasn't the right key for the job).
<a name="6157"></a>             */
<a name="6158"></a>            if(useKey_ != nil)
<a name="6159"></a>                extraReport(withKeyMsg);
<a name="6160"></a>                
<a name="6161"></a>            /* 
<a name="6162"></a>             *   Otherwise, if we need a key to unlock this object with, ask the
<a name="6163"></a>             *   player to specify it and then execute a LockWith action
<a name="6164"></a>             *   using that key.
<a name="6165"></a>             */    
<a name="6166"></a>            else if(lockability == lockableWithKey)
<a name="6167"></a>                askForIobj(LockWith);
<a name="6168"></a>         
<a name="6169"></a>            /*  Make us locked. */
<a name="6170"></a>            makeLocked(true);              
<a name="6171"></a>        }
<a name="6172"></a>        
<a name="6173"></a>        report()
<a name="6174"></a>        {
<a name="6175"></a>            DMsg(report lock, okayLockMsg, gActionListStr);
<a name="6176"></a>        }
<a name="6177"></a>    }
<a name="6178"></a>    
<a name="6179"></a>    
<a name="6180"></a>    
<a name="6181"></a>    
<a name="6182"></a>    okayLockMsg = 'Locked.|{I} {lock} {1}. '
<a name="6183"></a>    
<a name="6184"></a>    withKeyMsg = BMsg(with key, '(with {1})\n', useKey_.theName)
<a name="6185"></a>    
<a name="6186"></a>    /* 
<a name="6187"></a>     *   Find a key among the actor's possessions that might plausibly lock or
<a name="6188"></a>     *   unlock us. If the silent parameter is true, then don't report a failed
<a name="6189"></a>     *   attempt.
<a name="6190"></a>     */
<a name="6191"></a>    findPlausibleKey(silent = nil)
<a name="6192"></a>    {
<a name="6193"></a>      
<a name="6194"></a>        useKey_ = nil;   
<a name="6195"></a>        local lockObj = self;
<a name="6196"></a>        
<a name="6197"></a>        /* 
<a name="6198"></a>         *   First see if the actor is holding a key that is known to work on
<a name="6199"></a>         *   this object. If so, use it.
<a name="6200"></a>         */
<a name="6201"></a>        foreach(local obj in gActor.contents)
<a name="6202"></a>        {
<a name="6203"></a>            if(obj.ofKind(Key) 
<a name="6204"></a>               &amp;&amp; obj.knownLockList.indexOf(self) !=  nil)
<a name="6205"></a>            {
<a name="6206"></a>                useKey_ = obj;
<a name="6207"></a>                return;
<a name="6208"></a>            }
<a name="6209"></a>        }
<a name="6210"></a>        
<a name="6211"></a>        
<a name="6212"></a>        /*  
<a name="6213"></a>         *   Then see if the actor is holding a key that might plausibly work on
<a name="6214"></a>         *   this object; if so, try that.
<a name="6215"></a>         */
<a name="6216"></a>        foreach(local obj in gActor.contents)
<a name="6217"></a>        {
<a name="6218"></a>            if(obj.ofKind(Key) 
<a name="6219"></a>               &amp;&amp; obj.plausibleLockList.indexOf(self) !=  nil)
<a name="6220"></a>            {
<a name="6221"></a>                useKey_ = obj;
<a name="6222"></a>                break;
<a name="6223"></a>            }
<a name="6224"></a>        }
<a name="6225"></a>        
<a name="6226"></a>        /*  
<a name="6227"></a>         *   If we haven't found a suitable key yet, check to see if the actor
<a name="6228"></a>         *   is holding one that might fit our lexicalParent, if we have a
<a name="6229"></a>         *   lexicalParent whose interior we're representing.
<a name="6230"></a>         */
<a name="6231"></a>        if(useKey_ == nil)
<a name="6232"></a>        {
<a name="6233"></a>            if(lexicalParent != nil &amp;&amp; lexicalParent.remapIn == self)
<a name="6234"></a>            {
<a name="6235"></a>                lexicalParent.findPlausibleKey();
<a name="6236"></a>                useKey_ = lexicalParent.useKey_;
<a name="6237"></a>                lockObj = lexicalParent;
<a name="6238"></a>            }
<a name="6239"></a>        }
<a name="6240"></a>        
<a name="6241"></a>        /*  
<a name="6242"></a>         *   If we've found a possible key but it doesn't actually work on this
<a name="6243"></a>         *   object, report that we're trying this key but it doesn't work.
<a name="6244"></a>         */
<a name="6245"></a>        if(useKey_ &amp;&amp; useKey_.actualLockList.indexOf(lockObj) == nil &amp;&amp; !silent)
<a name="6246"></a>        {
<a name="6247"></a>            say(withKeyMsg);
<a name="6248"></a>            say(keyDoesntWorkMsg);            
<a name="6249"></a>        }
<a name="6250"></a>        
<a name="6251"></a>    }
<a name="6252"></a>  
<a name="6253"></a>    
<a name="6254"></a>    keyDoesntWorkMsg = BMsg(key doesnt work, 'Unfortunately {1} {dummy}
<a name="6255"></a>        {doesn\'t work[ed]} on {the dobj}. ', useKey_.theName)
<a name="6256"></a>    
<a name="6257"></a>    useKey_ = nil
<a name="6258"></a>    
<a name="6259"></a>    
<a name="6260"></a>    
<a name="6261"></a>    dobjFor(SwitchOn)
<a name="6262"></a>    {
<a name="6263"></a>        
<a name="6264"></a>        preCond = [touchObj]
<a name="6265"></a>        
<a name="6266"></a>        verify()
<a name="6267"></a>        {
<a name="6268"></a>            if(!isSwitchable)
<a name="6269"></a>                illogical(notSwitchableMsg);
<a name="6270"></a>            else if(isOn)
<a name="6271"></a>                illogicalNow(alreadyOnMsg);
<a name="6272"></a>        }
<a name="6273"></a>        
<a name="6274"></a>        action()
<a name="6275"></a>        {
<a name="6276"></a>            makeOn(true);
<a name="6277"></a>        }
<a name="6278"></a>        
<a name="6279"></a>        report()
<a name="6280"></a>        {
<a name="6281"></a>            DMsg(report turn on, 'Done.|{I} turn{s/ed} on {the dobj}. ');
<a name="6282"></a>        } 
<a name="6283"></a>    }
<a name="6284"></a>    
<a name="6285"></a>    notSwitchableMsg = BMsg(not switchable, '{The subj dobj} {can\'t} be
<a name="6286"></a>        switched on and off. ')
<a name="6287"></a>    alreadyOnMsg = BMsg(already switched on, '{The subj dobj} {is} already
<a name="6288"></a>        switched on. ')
<a name="6289"></a>    
<a name="6290"></a>    dobjFor(SwitchOff)
<a name="6291"></a>    {
<a name="6292"></a>        preCond = [touchObj]
<a name="6293"></a>        
<a name="6294"></a>        verify()
<a name="6295"></a>        {
<a name="6296"></a>            if(!isSwitchable)
<a name="6297"></a>                illogical(notSwitchableMsg);
<a name="6298"></a>            else if(!isOn)
<a name="6299"></a>                illogicalNow(alreadyOffMsg);
<a name="6300"></a>        }
<a name="6301"></a>        
<a name="6302"></a>        action()
<a name="6303"></a>        {
<a name="6304"></a>            makeOn(nil);
<a name="6305"></a>        }
<a name="6306"></a>        
<a name="6307"></a>        report()
<a name="6308"></a>        {
<a name="6309"></a>            DMsg(report turn off, 'Done.|{I} turn{s/ed} off {the dobj}. ');
<a name="6310"></a>        } 
<a name="6311"></a>    }
<a name="6312"></a>    
<a name="6313"></a>   alreadyOffMsg = BMsg(not switched on, '{The subj dobj} {isn\'t} switched on.
<a name="6314"></a>       ')
<a name="6315"></a>    
<a name="6316"></a>    
<a name="6317"></a>    dobjFor(SwitchVague)
<a name="6318"></a>    {
<a name="6319"></a>        verify()
<a name="6320"></a>        {
<a name="6321"></a>            if(!isSwitchable)
<a name="6322"></a>                illogical(notSwitchableMsg);
<a name="6323"></a>        }
<a name="6324"></a>        
<a name="6325"></a>        action()
<a name="6326"></a>        {
<a name="6327"></a>            makeOn(!isOn);
<a name="6328"></a>        }
<a name="6329"></a>        
<a name="6330"></a>        report()
<a name="6331"></a>        {
<a name="6332"></a>            DMsg(report switch, 'Okay, {i} turn{s/ed} {1} {2}. ', isOn ? 
<a name="6333"></a>                 'on' : 'off', gActionListStr);
<a name="6334"></a>        }
<a name="6335"></a>    }
<a name="6336"></a>    
<a name="6337"></a>    /* 
<a name="6338"></a>     *   Since FLIP X is often synonymous with SWITCH X , by default we make
<a name="6339"></a>     *   something flippable if it's switchable.
<a name="6340"></a>     */
<a name="6341"></a>    isFlippable = (isSwitchable)
<a name="6342"></a>    
<a name="6343"></a>    dobjFor(Flip)
<a name="6344"></a>    {
<a name="6345"></a>        verify() 
<a name="6346"></a>        { 
<a name="6347"></a>            if(!isFlippable)
<a name="6348"></a>               illogical(cannotFlipMsg); 
<a name="6349"></a>        }
<a name="6350"></a>    }
<a name="6351"></a>    
<a name="6352"></a>    cannotFlipMsg = BMsg(cannot flip, '{I} {can\'t} usefully flip {the dobj}. ')
<a name="6353"></a>    
<a name="6354"></a>    
<a name="6355"></a>    /* By default we assume most things aren't burnable */
<a name="6356"></a>    isBurnable = nil
<a name="6357"></a>    
<a name="6358"></a>    dobjFor(Burn)
<a name="6359"></a>    {
<a name="6360"></a>        preCond = [touchObj]
<a name="6361"></a>        verify() 
<a name="6362"></a>        {
<a name="6363"></a>            if(!isBurnable)
<a name="6364"></a>               illogical(cannotBurnMsg); 
<a name="6365"></a>        }
<a name="6366"></a>    }
<a name="6367"></a>        
<a name="6368"></a>    dobjFor(BurnWith)
<a name="6369"></a>    {
<a name="6370"></a>        preCond = [touchObj]        
<a name="6371"></a>        verify() 
<a name="6372"></a>        {
<a name="6373"></a>            if(!isBurnable)
<a name="6374"></a>               illogical(cannotBurnMsg); 
<a name="6375"></a>        }
<a name="6376"></a>    }
<a name="6377"></a>    
<a name="6378"></a>    /* 
<a name="6379"></a>     *   By default we assume most things can't be used to burn other things
<a name="6380"></a>     *   with.
<a name="6381"></a>     */
<a name="6382"></a>    canBurnWithMe = nil
<a name="6383"></a>    
<a name="6384"></a>    iobjFor(BurnWith)
<a name="6385"></a>    {
<a name="6386"></a>        preCond = [objHeld]
<a name="6387"></a>        verify() 
<a name="6388"></a>        { 
<a name="6389"></a>            if(!canBurnWithMe)
<a name="6390"></a>                illogical(cannotBurnWithMsg); 
<a name="6391"></a>        }
<a name="6392"></a>    }
<a name="6393"></a>    
<a name="6394"></a>    cannotBurnMsg = BMsg(cannot burn, '{I} {cannot} burn {the dobj}. ')
<a name="6395"></a>    cannotBurnWithMsg = BMsg(cannot burn with, '{I} {can\'t} burn {the dobj}
<a name="6396"></a>        with {that iobj}. ')
<a name="6397"></a>    
<a name="6398"></a>    dobjFor(Wear)
<a name="6399"></a>    {
<a name="6400"></a>        preCond = [objHeld]
<a name="6401"></a>        
<a name="6402"></a>        verify()
<a name="6403"></a>        {
<a name="6404"></a>            if(!isWearable)
<a name="6405"></a>                illogical(cannotWearMsg);
<a name="6406"></a>            
<a name="6407"></a>            if(wornBy == gActor)
<a name="6408"></a>                illogicalNow(alreadyWornMsg);
<a name="6409"></a>        }
<a name="6410"></a>        
<a name="6411"></a>        action()  {  makeWorn(gActor);  }
<a name="6412"></a>        
<a name="6413"></a>        report()
<a name="6414"></a>        {
<a name="6415"></a>            DMsg(okay wear, 'Okay, {i}{\'m} now wearing {1}. ',
<a name="6416"></a>                 gActionListStr);
<a name="6417"></a>        }
<a name="6418"></a>    }
<a name="6419"></a>    
<a name="6420"></a>    cannotWearMsg = BMsg(cannot wear, '{The subj dobj} {can\'t} be worn. ')
<a name="6421"></a>    alreadyWornMsg = BMsg(already worn, '{I}{\'m} already wearing {the dobj}. ')
<a name="6422"></a>    
<a name="6423"></a>    
<a name="6424"></a>    /* By default we assume that something's doffable if it's wearable */
<a name="6425"></a>    isDoffable = (isWearable)
<a name="6426"></a>    
<a name="6427"></a>    dobjFor(Doff)
<a name="6428"></a>    {
<a name="6429"></a>        
<a name="6430"></a>        verify()
<a name="6431"></a>        {
<a name="6432"></a>            if(wornBy != gActor)
<a name="6433"></a>                illogicalNow(notWornMsg);
<a name="6434"></a>                        
<a name="6435"></a>            if(!isDoffable)
<a name="6436"></a>                illogical(cannotDoffMsg);
<a name="6437"></a>        }
<a name="6438"></a>        
<a name="6439"></a>        check()
<a name="6440"></a>        {
<a name="6441"></a>            checkRoomToHold();
<a name="6442"></a>        }
<a name="6443"></a>        
<a name="6444"></a>        action()  {   makeWorn(nil);  }
<a name="6445"></a>        
<a name="6446"></a>        report()
<a name="6447"></a>        {
<a name="6448"></a>            DMsg(okay doff, 'Okay, {I}{\'m} no longer wearing {1}. ', 
<a name="6449"></a>                 gActionListStr);
<a name="6450"></a>            
<a name="6451"></a>        }
<a name="6452"></a>    }
<a name="6453"></a>    
<a name="6454"></a>  
<a name="6455"></a>    cannotDoffMsg = (cannotWearMsg)
<a name="6456"></a>    
<a name="6457"></a>    notWornMsg = BMsg(not worn, '{I}{\'m} not wearing {the dobj}. ')
<a name="6458"></a>    
<a name="6459"></a>    /* Most things can't be climbed */
<a name="6460"></a>    isClimbable = nil
<a name="6461"></a>    
<a name="6462"></a>    dobjFor(Climb)
<a name="6463"></a>    {
<a name="6464"></a>        preCond = [touchObj]
<a name="6465"></a>        verify() 
<a name="6466"></a>        { 
<a name="6467"></a>            if(!isClimbable)
<a name="6468"></a>               illogical(cannotClimbMsg); 
<a name="6469"></a>        }
<a name="6470"></a>    }
<a name="6471"></a>    
<a name="6472"></a>    canClimbUpMe = (isClimbable)
<a name="6473"></a>    
<a name="6474"></a>    dobjFor(ClimbUp)
<a name="6475"></a>    {
<a name="6476"></a>        preCond = [touchObj]
<a name="6477"></a>        verify() 
<a name="6478"></a>        { 
<a name="6479"></a>            if(!canClimbUpMe)
<a name="6480"></a>               illogical(cannotClimbMsg); 
<a name="6481"></a>        }
<a name="6482"></a>    }
<a name="6483"></a>    
<a name="6484"></a>    cannotClimbMsg = BMsg(cannot climb,'{The subj dobj} {is} not something {i}
<a name="6485"></a>        {can} climb. ')
<a name="6486"></a>    
<a name="6487"></a>    canClimbDownMe = (isClimbable)
<a name="6488"></a>    
<a name="6489"></a>    dobjFor(ClimbDown)
<a name="6490"></a>    {
<a name="6491"></a>        preCond = [touchObj]
<a name="6492"></a>        verify() 
<a name="6493"></a>        { 
<a name="6494"></a>            if(!canClimbDownMe)
<a name="6495"></a>               illogical(cannotClimbDownMsg); 
<a name="6496"></a>        }
<a name="6497"></a>    }
<a name="6498"></a>    
<a name="6499"></a>    cannotClimbDownMsg = BMsg(cannot climb down, '{The subj dobj} {is} not
<a name="6500"></a>        something {i} {can} climb down. ')
<a name="6501"></a>    
<a name="6502"></a>    dobjFor(Throw)
<a name="6503"></a>    {
<a name="6504"></a>        preCond = [objHeld, objNotWorn]
<a name="6505"></a>        
<a name="6506"></a>        verify()
<a name="6507"></a>        {
<a name="6508"></a>            if(!isThrowable)
<a name="6509"></a>                illogical(cannotThrowMsg);
<a name="6510"></a>        }
<a name="6511"></a>        
<a name="6512"></a>        action()
<a name="6513"></a>        {
<a name="6514"></a>            actionMoveInto(getOutermostRoom.dropLocation);            
<a name="6515"></a>        }
<a name="6516"></a>        
<a name="6517"></a>        report()
<a name="6518"></a>        {
<a name="6519"></a>            local obj = gActionListObj;
<a name="6520"></a>            gMessageParams(obj);
<a name="6521"></a>            DMsg(throw, '{The subj obj} sail{s/ed} through the air and land{s/ed}
<a name="6522"></a>                on the ground. ' );
<a name="6523"></a>        }
<a name="6524"></a>        
<a name="6525"></a>    }
<a name="6526"></a>    
<a name="6527"></a>    
<a name="6528"></a>    dobjFor(Board)
<a name="6529"></a>    {
<a name="6530"></a>        preCond = [touchObj, actorInStagingLocation]
<a name="6531"></a>        
<a name="6532"></a>        remap = remapOn
<a name="6533"></a>        
<a name="6534"></a>        verify()
<a name="6535"></a>        {
<a name="6536"></a>            if(!isBoardable || contType != On)
<a name="6537"></a>                illogical(cannotBoardMsg);
<a name="6538"></a>            
<a name="6539"></a>            if(gActor.isIn(self))
<a name="6540"></a>                illogicalNow(actorAlreadyOnMsg);
<a name="6541"></a>            
<a name="6542"></a>            if(isIn(gActor))
<a name="6543"></a>                illogicalNow(cannotGetOnCarriedMsg);
<a name="6544"></a>        }
<a name="6545"></a>        
<a name="6546"></a>        check() { checkInsert(gActor); }
<a name="6547"></a>        
<a name="6548"></a>        action()
<a name="6549"></a>        {
<a name="6550"></a>            gActor.actionMoveInto(self);            
<a name="6551"></a>        }
<a name="6552"></a>        
<a name="6553"></a>        report()
<a name="6554"></a>        {
<a name="6555"></a>            DMsg(okay get on, '{I} {get} on {1}. ', gActionListStr);
<a name="6556"></a>        }
<a name="6557"></a>    }
<a name="6558"></a>    
<a name="6559"></a>    cannotBoardMsg = BMsg(cannot board, '{The subj dobj} {is} not something {i}
<a name="6560"></a>        {can} get on. ')
<a name="6561"></a>    actorAlreadyOnMsg = BMsg(already on, '{I}{\'m} already {in dobj}. ')
<a name="6562"></a>     
<a name="6563"></a>    cannotGetOnCarriedMsg = BMsg(cannot board carried, '{I} {can\'t} get on {the
<a name="6564"></a>        dobj} while {i}{\'m} carrying {him dobj}. ')
<a name="6565"></a>    
<a name="6566"></a>    /* 
<a name="6567"></a>     *   Since we don't track postures in this library we'll treat STAND ON as
<a name="6568"></a>     *   equivalent to BOARD
<a name="6569"></a>     */    
<a name="6570"></a>    dobjFor(StandOn) asDobjWithoutVerifyFor(Board)
<a name="6571"></a>    dobjFor(SitOn) asDobjWithoutVerifyFor(Board)
<a name="6572"></a>    dobjFor(LieOn) asDobjWithoutVerifyFor(Board)
<a name="6573"></a>    
<a name="6574"></a>    /*  
<a name="6575"></a>     *   Although we don't track postures as such, some objects may be better
<a name="6576"></a>     *   choices than other for sitting on (e.g. chairs), lying on (e.g. beds)
<a name="6577"></a>     *   and standing on (e.g. rugs), so we allow these to be tested for
<a name="6578"></a>     *   individually at the verify stage.
<a name="6579"></a>     *
<a name="6580"></a>     *   Note that none of these three properties (canSitOnMe, canLieOnMe,
<a name="6581"></a>     *   canStandOnMe) should normally be overridden to simply true, since they
<a name="6582"></a>     *   cannot make it possible to sit, lie or stand on something for which
<a name="6583"></a>     *   isBoardable is not true (or which contType is not On).
<a name="6584"></a>     */
<a name="6585"></a>    canSitOnMe = isBoardable
<a name="6586"></a>    canLieOnMe = isBoardable
<a name="6587"></a>    canStandOnMe = isBoardable
<a name="6588"></a>    
<a name="6589"></a>    
<a name="6590"></a>    /*   
<a name="6591"></a>     *   As well as ruling out certain objects for sitting, lying or standing
<a name="6592"></a>     *   on, we can also give them a score for each of these postures; e.g. a
<a name="6593"></a>     *   bed may be particularly suitable for lying on (although you could lie
<a name="6594"></a>     *   on the sofa) while a chair may be particularly suitable for sitting on
<a name="6595"></a>     *   (though you could sit on the bed.
<a name="6596"></a>     *
<a name="6597"></a>     *   By default we'll give each posture a score of 100, the normal logical
<a name="6598"></a>     *   verify score. Note that these scores have no effect if the
<a name="6599"></a>     *   corresponding can xxxOnMe property is nil.
<a name="6600"></a>     */
<a name="6601"></a>    sitOnScore = 100
<a name="6602"></a>    lieOnScore = 100
<a name="6603"></a>    standOnScore = 100
<a name="6604"></a>    
<a name="6605"></a>    dobjFor(StandOn)
<a name="6606"></a>    {
<a name="6607"></a>        verify()
<a name="6608"></a>        {
<a name="6609"></a>            if(!canStandOnMe)
<a name="6610"></a>                illogical(cannotStandOnMsg);
<a name="6611"></a>            else
<a name="6612"></a>                verifyDobjBoard();
<a name="6613"></a>            
<a name="6614"></a>            logicalRank(standOnScore);
<a name="6615"></a>        }
<a name="6616"></a>    }
<a name="6617"></a>    
<a name="6618"></a>    dobjFor(SitOn)
<a name="6619"></a>    {
<a name="6620"></a>        verify()
<a name="6621"></a>        {
<a name="6622"></a>            if(!canSitOnMe)
<a name="6623"></a>                illogical(cannotSitOnMsg);
<a name="6624"></a>            else
<a name="6625"></a>                verifyDobjBoard();            
<a name="6626"></a>            
<a name="6627"></a>            logicalRank(sitOnScore);
<a name="6628"></a>        }
<a name="6629"></a>    }
<a name="6630"></a>    
<a name="6631"></a>    dobjFor(LieOn)
<a name="6632"></a>    {
<a name="6633"></a>        verify()
<a name="6634"></a>        {
<a name="6635"></a>            if(!canLieOnMe)
<a name="6636"></a>                illogical(cannotLieOnMsg);
<a name="6637"></a>            else
<a name="6638"></a>                verifyDobjBoard();
<a name="6639"></a>            
<a name="6640"></a>            logicalRank(lieOnScore);
<a name="6641"></a>        }
<a name="6642"></a>    }
<a name="6643"></a>    
<a name="6644"></a>    cannotStandOnMsg = BMsg(cannot stand on, '{The subj dobj} {isn\'t}
<a name="6645"></a>        something {i} {can} stand on. ')
<a name="6646"></a>    cannotSitOnMsg = BMsg(cannot sit on, '{The subj dobj} {isn\'t}
<a name="6647"></a>        something {i} {can} sit on. ')
<a name="6648"></a>    cannotLieOnMsg = BMsg(cannot lie on, '{The subj dobj} {isn\'t}
<a name="6649"></a>        something {i} {can} lie on. ')
<a name="6650"></a>    
<a name="6651"></a>    
<a name="6652"></a>    /*   
<a name="6653"></a>     *   Flag, can we enter (i.e. get inside) this thing? For most objects, we
<a name="6654"></a>     *   can't
<a name="6655"></a>     */
<a name="6656"></a>    isEnterable = nil
<a name="6657"></a>    
<a name="6658"></a>    /*   Treat Enter X as equivalent to Get In X */
<a name="6659"></a>    
<a name="6660"></a>    dobjFor(Enter) 
<a name="6661"></a>    {
<a name="6662"></a>        preCond = [touchObj, containerOpen, actorInStagingLocation]
<a name="6663"></a>        
<a name="6664"></a>        remap = remapIn
<a name="6665"></a>        
<a name="6666"></a>        verify()
<a name="6667"></a>        {
<a name="6668"></a>            if(!isEnterable || contType != In)
<a name="6669"></a>                illogical(cannotEnterMsg);
<a name="6670"></a>            
<a name="6671"></a>            if(gActor.isIn(self))
<a name="6672"></a>                illogicalNow(actorAlreadyInMsg);
<a name="6673"></a>            
<a name="6674"></a>            if(isIn(gActor))
<a name="6675"></a>                illogicalNow(cannotGetInCarriedMsg);
<a name="6676"></a>        }
<a name="6677"></a>        
<a name="6678"></a>        check() { checkInsert(gActor); }
<a name="6679"></a>        
<a name="6680"></a>        action()
<a name="6681"></a>        {
<a name="6682"></a>            gActor.actionMoveInto(self);            
<a name="6683"></a>        }
<a name="6684"></a>        
<a name="6685"></a>        report()
<a name="6686"></a>        {
<a name="6687"></a>            DMsg(okay get in, '{I} {get} in {1}. ', gActionListStr);
<a name="6688"></a>        }
<a name="6689"></a>        
<a name="6690"></a>    }
<a name="6691"></a>    
<a name="6692"></a>    cannotEnterMsg = BMsg(cannot enter, '{The subj dobj} {is} not something {i}
<a name="6693"></a>        {can} enter. ')
<a name="6694"></a>    actorAlreadyInMsg = BMsg(actor already in, '{I}{\'m} already {in dobj}. ')
<a name="6695"></a>     
<a name="6696"></a>    cannotGetInCarriedMsg = BMsg(cannot enter carried, '{I} {can\'t} get in {the
<a name="6697"></a>        dobj} while {i}{\'m} carrying {him dobj}. ')
<a name="6698"></a>    
<a name="6699"></a>    
<a name="6700"></a>    /* 
<a name="6701"></a>     *   By default we'll treat standing, sitting or lying IN something as
<a name="6702"></a>     *   simply equivalent to entering it.
<a name="6703"></a>     */
<a name="6704"></a>    dobjFor(StandIn) asDobjFor(Enter)
<a name="6705"></a>    dobjFor(SitIn) asDobjFor(Enter)
<a name="6706"></a>    dobjFor(LieIn) asDobjFor(Enter)
<a name="6707"></a>    
<a name="6708"></a>    /* 
<a name="6709"></a>     *   Our exitLocation is the location an actor should be moved to when s/he
<a name="6710"></a>     *   gets off/out of us.
<a name="6711"></a>     */
<a name="6712"></a>    exitLocation = (lexicalParent == nil ? location : lexicalParent.location)
<a name="6713"></a>    
<a name="6714"></a>    /*   Our staging location is where we need to be to get on/in us */
<a name="6715"></a>    stagingLocation = (exitLocation)
<a name="6716"></a>    
<a name="6717"></a>    dobjFor(GetOff)
<a name="6718"></a>    {
<a name="6719"></a>        
<a name="6720"></a>        remap = remapOn
<a name="6721"></a>        
<a name="6722"></a>        verify()
<a name="6723"></a>        {
<a name="6724"></a>            if(!gActor.isIn(self) || contType != On)
<a name="6725"></a>                illogicalNow(actorNotOnMsg);
<a name="6726"></a>            
<a name="6727"></a>        }
<a name="6728"></a>        
<a name="6729"></a>        action()
<a name="6730"></a>        {
<a name="6731"></a>            gActor.actionMoveInto(exitLocation);            
<a name="6732"></a>        }
<a name="6733"></a>        
<a name="6734"></a>        report() { say(okayGetOutOfMsg); }
<a name="6735"></a>    }
<a name="6736"></a>            
<a name="6737"></a>    dobjFor(GetOutOf) 
<a name="6738"></a>    {
<a name="6739"></a>        preCond = [containerOpen]
<a name="6740"></a>        
<a name="6741"></a>        remap = remapIn
<a name="6742"></a>        
<a name="6743"></a>        verify()
<a name="6744"></a>        {
<a name="6745"></a>            if(!gActor.isIn(self) || contType != In)
<a name="6746"></a>                illogicalNow(actorNotInMsg);
<a name="6747"></a>            
<a name="6748"></a>        }
<a name="6749"></a>        
<a name="6750"></a>        action()
<a name="6751"></a>        {
<a name="6752"></a>            gActor.actionMoveInto(exitLocation);            
<a name="6753"></a>        }
<a name="6754"></a>        
<a name="6755"></a>        report() { say(okayGetOutOfMsg); }        
<a name="6756"></a>    }
<a name="6757"></a>    
<a name="6758"></a>    
<a name="6759"></a>    okayGetOutOfMsg = BMsg(okay get outof, 'Okay, {i} {get} {outof dobj}. ')
<a name="6760"></a>    
<a name="6761"></a>    actorNotInMsg = BMsg(actor not in,'{I}{\'m} not in {the dobj}. ')
<a name="6762"></a>    actorNotOnMsg = BMsg(actor not on,'{I}{\'m} not on {the dobj}. ')
<a name="6763"></a>    
<a name="6764"></a>    /* 
<a name="6765"></a>     *   We'll take REMOVE to mean DOFF when it's dobj is worn and TAKE
<a name="6766"></a>     *   otherwise. This handling will be dealt with by removeDoer insteadof
<a name="6767"></a>     *   remap, since this form of remap has now been discontinued. See
<a name="6768"></a>     *   english.t for removeDoer (which seems to be a language-specific
<a name="6769"></a>     *   construct)
<a name="6770"></a>     */
<a name="6771"></a>    dobjFor(Remove)
<a name="6772"></a>    {
<a name="6773"></a>        /* 
<a name="6774"></a>         *   We still need a verify() routine to help the parser find a suitable
<a name="6775"></a>         *   target for the command.
<a name="6776"></a>         */
<a name="6777"></a>             
<a name="6778"></a>        verify()
<a name="6779"></a>        {
<a name="6780"></a>            if(!isRemoveable)
<a name="6781"></a>                illogical(cannotRemoveMsg);
<a name="6782"></a>            
<a name="6783"></a>            /* 
<a name="6784"></a>             *   If we're already holding the object (and not wearing it),
<a name="6785"></a>             *   there's nothing for remove to do.
<a name="6786"></a>             */
<a name="6787"></a>            if(isDirectlyIn(gActor) &amp;&amp; wornBy != gActor)
<a name="6788"></a>                illogicalNow(alreadyHeldMsg);
<a name="6789"></a>        }
<a name="6790"></a>    
<a name="6791"></a>        
<a name="6792"></a>    }
<a name="6793"></a>    
<a name="6794"></a>    /* By default an object is removeable if it's takeable */
<a name="6795"></a>         
<a name="6796"></a>    isRemoveable = (isTakeable)
<a name="6797"></a>    
<a name="6798"></a>    /* 
<a name="6799"></a>     *   Note that this message should never display in an English-language game
<a name="6800"></a>     *   since removeDoer will intercept the action before it gets to this
<a name="6801"></a>     *   point.
<a name="6802"></a>     */
<a name="6803"></a>    cannotRemoveMsg = BMsg(cannot remove, '{The subj dobj} {cannot} be removed.
<a name="6804"></a>        ')
<a name="6805"></a>    
<a name="6806"></a>    /* Treat SEARCH as equivalent to LOOK IN */
<a name="6807"></a>    dobjFor(Search) asDobjFor(LookIn)
<a name="6808"></a>    
<a name="6809"></a>    /* 
<a name="6810"></a>     *   By default we assume anything fixed isn't moveable. That's not
<a name="6811"></a>     *   necessarily the case since we may be able to move something by pushing
<a name="6812"></a>     *   it around (say) even if we can't pick it up.     
<a name="6813"></a>     */
<a name="6814"></a>    isMoveable = (!isFixed)
<a name="6815"></a>    
<a name="6816"></a>    /* 
<a name="6817"></a>     *   Moving an object is generally possible if the object is portable, but
<a name="6818"></a>     *   there's no obvious effect, so by default this action does nothing
<a name="6819"></a>     *   except say it's done nothing.
<a name="6820"></a>     */
<a name="6821"></a>    dobjFor(Move)
<a name="6822"></a>    {
<a name="6823"></a>        preCond = [touchObj]
<a name="6824"></a>        
<a name="6825"></a>        verify()
<a name="6826"></a>        {
<a name="6827"></a>            if(!isMoveable)
<a name="6828"></a>                illogical(cannotMoveMsg);
<a name="6829"></a>        }
<a name="6830"></a>        
<a name="6831"></a>        action()  {  }
<a name="6832"></a>        
<a name="6833"></a>        report()
<a name="6834"></a>        {
<a name="6835"></a>            say(moveNoEffectMsg);
<a name="6836"></a>        }
<a name="6837"></a>    }
<a name="6838"></a>    
<a name="6839"></a>    cannotMoveMsg = (cannotTakeMsg)
<a name="6840"></a>    
<a name="6841"></a>    dobjFor(MoveWith)
<a name="6842"></a>    {
<a name="6843"></a>        preCond = [touchObj]
<a name="6844"></a>        
<a name="6845"></a>        verify()
<a name="6846"></a>        {
<a name="6847"></a>            if(!isMoveable)
<a name="6848"></a>                illogical(cannotMoveMsg);
<a name="6849"></a>                        
<a name="6850"></a>        }
<a name="6851"></a>        
<a name="6852"></a>        action() {  }
<a name="6853"></a>        
<a name="6854"></a>        report()
<a name="6855"></a>        {
<a name="6856"></a>            say(moveNoEffectMsg);
<a name="6857"></a>        }
<a name="6858"></a>    }
<a name="6859"></a>    
<a name="6860"></a>    moveNoEffectMsg = BMsg(move no effect, 'Moving {1} {dummy} {has} no effect. ',
<a name="6861"></a>                 gActionListStr)
<a name="6862"></a>    
<a name="6863"></a>    /* 
<a name="6864"></a>     *   Most things can't be used to move other things with. Note that since
<a name="6865"></a>     *   the dobj is resolved first, objects or subclasses could override this
<a name="6866"></a>     *   with a method that returns true or nil depending on the identity of the
<a name="6867"></a>     *   dobj.
<a name="6868"></a>     */
<a name="6869"></a>    canMoveWithMe = nil
<a name="6870"></a>    
<a name="6871"></a>    iobjFor(MoveWith)
<a name="6872"></a>    {
<a name="6873"></a>        preCond = [objHeld]
<a name="6874"></a>        
<a name="6875"></a>        verify() 
<a name="6876"></a>        { 
<a name="6877"></a>            if(!canMoveWithMe)
<a name="6878"></a>               illogical(cannotMoveWithMsg); 
<a name="6879"></a>            
<a name="6880"></a>            if(gVerifyDobj == self)
<a name="6881"></a>                illogicalSelf(cannotMoveWithSelfMsg);
<a name="6882"></a>        }
<a name="6883"></a>    }
<a name="6884"></a>    
<a name="6885"></a>    cannotMoveWithMsg = BMsg(cannot move with, '{I} {can\'t} move {the dobj}
<a name="6886"></a>        with {the iobj}. ')
<a name="6887"></a>    
<a name="6888"></a>    cannotMoveWithSelfMsg = BMsg(cannot move with self, '{The subj dobj}
<a name="6889"></a>        {can\'t} be used to move {itself dobj}. ')
<a name="6890"></a>    
<a name="6891"></a>    
<a name="6892"></a>    /*  
<a name="6893"></a>     *   MoveTo is a more complex case than MOVE or MOVE WITH. In this
<a name="6894"></a>     *   implementation we assume that it represents moving the direct object to
<a name="6895"></a>     *   the vicinity of the indirect object, and so we track the object it's
<a name="6896"></a>     *   been moved to.
<a name="6897"></a>     *
<a name="6898"></a>     *   This might be useful, say, if you wanted the player to have to MOVE the
<a name="6899"></a>     *   chair TO the bookcase before being able to reach the top shelf by
<a name="6900"></a>     *   standing on the chair, since you could then check the value of the
<a name="6901"></a>     *   chair's movedTo property before deciding whether the top shelf was
<a name="6902"></a>     *   accesssible.
<a name="6903"></a>     */
<a name="6904"></a>    dobjFor(MoveTo)
<a name="6905"></a>    {
<a name="6906"></a>        preCond = [touchObj]
<a name="6907"></a>        
<a name="6908"></a>        verify()
<a name="6909"></a>        {
<a name="6910"></a>            if(!isMoveable)
<a name="6911"></a>                illogical(cannotMoveMsg);
<a name="6912"></a>        }
<a name="6913"></a>        
<a name="6914"></a>        action()
<a name="6915"></a>        {
<a name="6916"></a>            makeMovedTo(gIobj);
<a name="6917"></a>        }
<a name="6918"></a>        
<a name="6919"></a>        report()
<a name="6920"></a>        {
<a name="6921"></a>            DMsg(okay move to, '{I} move{s/d} {1} {dummy} to {the iobj}. ',
<a name="6922"></a>                 gActionListStr);
<a name="6923"></a>        }
<a name="6924"></a>    }
<a name="6925"></a>    
<a name="6926"></a>    /* 
<a name="6927"></a>     *   The notional location (other object) this object has been moved to as
<a name="6928"></a>     *   the result of a MoveTo command.
<a name="6929"></a>     */
<a name="6930"></a>    movedTo = nil
<a name="6931"></a>    
<a name="6932"></a>    /* Cause this object to be moved to loc */
<a name="6933"></a>    makeMovedTo(loc) { movedTo = loc; }
<a name="6934"></a>    
<a name="6935"></a>    /* In general there's no reason why most objects can't be moved to. */
<a name="6936"></a>    canMoveToMe = true
<a name="6937"></a>    
<a name="6938"></a>    iobjFor(MoveTo)
<a name="6939"></a>    {
<a name="6940"></a>        preCond = [touchObj]
<a name="6941"></a>        
<a name="6942"></a>        verify()
<a name="6943"></a>        {
<a name="6944"></a>            if(!canMoveToMe)
<a name="6945"></a>                illogical(cannotMoveToMsg);           
<a name="6946"></a>            
<a name="6947"></a>            if(gDobj.movedTo == self)
<a name="6948"></a>                illogicalNow(alreadyMovedToMsg);
<a name="6949"></a>            
<a name="6950"></a>            if(gVerifyDobj == self)
<a name="6951"></a>                illogicalSelf(cannotMoveToSelfMsg);
<a name="6952"></a>            
<a name="6953"></a>        }
<a name="6954"></a>        
<a name="6955"></a>    }
<a name="6956"></a>    
<a name="6957"></a>    cannotMoveToMsg = BMsg(cannot move to, '{The subj dobj} {can\'t} be moved to
<a name="6958"></a>        {the iobj}. ')
<a name="6959"></a>    
<a name="6960"></a>    cannotMoveToSelfMsg = BMsg(cannot move to self, '{The subj dobj} {can\'t}
<a name="6961"></a>        be moved to {itself dobj}. ')
<a name="6962"></a>    
<a name="6963"></a>    alreadyMovedToMsg = BMsg(already moved to, '{The subj dobj} {has} already
<a name="6964"></a>        been moved to {the iobj}. ')
<a name="6965"></a>    
<a name="6966"></a>    /* 
<a name="6967"></a>     *   Lighting an object makes it a light source by making its isLit property
<a name="6968"></a>     *   true.
<a name="6969"></a>     */
<a name="6970"></a>    dobjFor(Light)
<a name="6971"></a>    {
<a name="6972"></a>        preCond = [touchObj]
<a name="6973"></a>        
<a name="6974"></a>        verify() 
<a name="6975"></a>        {
<a name="6976"></a>            if(!isLightable)
<a name="6977"></a>                illogical(cannotLightMsg); 
<a name="6978"></a>            else if(isLit)
<a name="6979"></a>                illogicalNow(alreadyLitMsg);
<a name="6980"></a>        }
<a name="6981"></a>        
<a name="6982"></a>        action()
<a name="6983"></a>        {
<a name="6984"></a>            makeLit(true);
<a name="6985"></a>        }
<a name="6986"></a>        
<a name="6987"></a>        report()
<a name="6988"></a>        {
<a name="6989"></a>            DMsg(okay lit,'Done.|{I} {light} {1}. ', gActionListStr);
<a name="6990"></a>        }
<a name="6991"></a>    }
<a name="6992"></a>    
<a name="6993"></a>    cannotLightMsg = BMsg(cannot light, '{The subj dobj} {is} not something
<a name="6994"></a>        {i} {can} light. ')
<a name="6995"></a>    
<a name="6996"></a>    alreadyLitMsg = BMsg(already lit, '{The subj dobj} {is} already lit. ')
<a name="6997"></a>    
<a name="6998"></a>    /* 
<a name="6999"></a>     *   Most things are extinguishable if they're lit, but some things (like
<a name="7000"></a>     *   the sun or a nuclear explosion) might conceivably not be. Note that
<a name="7001"></a>     *   this property should only be set to nil for things that couldn't be
<a name="7002"></a>     *   extinguished even if they were lit (the flames of Hell, for example,
<a name="7003"></a>     *   which might be considered undousable for all eternity, if you're bent
<a name="7004"></a>     *   on writing an infernal game).
<a name="7005"></a>     */
<a name="7006"></a>    isExtinguishable = true
<a name="7007"></a>    
<a name="7008"></a>    dobjFor(Extinguish)
<a name="7009"></a>    {
<a name="7010"></a>        preCond = [touchObj]
<a name="7011"></a>        
<a name="7012"></a>        verify()
<a name="7013"></a>        {
<a name="7014"></a>            if(!isLit)
<a name="7015"></a>                illogicalNow(notLitMsg);
<a name="7016"></a>            
<a name="7017"></a>            if(!isExtinguishable)
<a name="7018"></a>                illogical(cannotExtinguishMsg);
<a name="7019"></a>            
<a name="7020"></a>        }
<a name="7021"></a>        
<a name="7022"></a>        action()
<a name="7023"></a>        {
<a name="7024"></a>            makeLit(nil);            
<a name="7025"></a>        }
<a name="7026"></a>        
<a name="7027"></a>        report()
<a name="7028"></a>        {
<a name="7029"></a>            DMsg(extinguish, '{I} {put} out {1}. ', gActionListStr);
<a name="7030"></a>        }
<a name="7031"></a>    }
<a name="7032"></a>    
<a name="7033"></a>    notLitMsg = BMsg(not lit, '{The subj dobj} {isn\'t} lit. ')
<a name="7034"></a>    
<a name="7035"></a>    cannotExtinguishMsg = BMsg(cannot extinguish, '{The dobj} {cannot} be
<a name="7036"></a>        extinguished. ')
<a name="7037"></a>    
<a name="7038"></a>        
<a name="7039"></a>    dobjFor(Eat)
<a name="7040"></a>    {
<a name="7041"></a>        preCond = [objHeld]
<a name="7042"></a>        
<a name="7043"></a>        verify() 
<a name="7044"></a>        { 
<a name="7045"></a>            if(!isEdible)
<a name="7046"></a>                illogical(cannotEatMsg); 
<a name="7047"></a>        }
<a name="7048"></a>        
<a name="7049"></a>        action()
<a name="7050"></a>        {
<a name="7051"></a>            moveInto(nil);            
<a name="7052"></a>        }
<a name="7053"></a>        
<a name="7054"></a>        report()
<a name="7055"></a>        {
<a name="7056"></a>            DMsg(eat, '{I} {eat} {1}. ', gActionListStr);
<a name="7057"></a>        }
<a name="7058"></a>    }
<a name="7059"></a>    
<a name="7060"></a>    cannotEatMsg = BMsg(cannot eat, '{The subj dobj} {is} plainly inedible. ')
<a name="7061"></a>    
<a name="7062"></a>    /* Most things aren't drinkable */
<a name="7063"></a>    isDrinkable = nil
<a name="7064"></a>    
<a name="7065"></a>    dobjFor(Drink)
<a name="7066"></a>    {
<a name="7067"></a>        preCond = [touchObj]
<a name="7068"></a>        
<a name="7069"></a>        verify() 
<a name="7070"></a>        {
<a name="7071"></a>            if(!isDrinkable)
<a name="7072"></a>               illogical(cannotDrinkMsg); 
<a name="7073"></a>            
<a name="7074"></a>        }
<a name="7075"></a>                
<a name="7076"></a>    }
<a name="7077"></a>        
<a name="7078"></a>    cannotDrinkMsg = BMsg(not potable, '{I} {can\'t} drink {1}. ', fluidName)
<a name="7079"></a>    
<a name="7080"></a>    
<a name="7081"></a>    /* 
<a name="7082"></a>     *   Most things probably could be cleaned, even if they're not worth
<a name="7083"></a>     *   cleaning in practice. Some things like a mountain or the moon probably
<a name="7084"></a>     *   can't be cleaned and could reasonably define isCleanable = nil.
<a name="7085"></a>     */
<a name="7086"></a>    isCleanable = true
<a name="7087"></a>    
<a name="7088"></a>    /* Assume most things start out not as clean as they could be */
<a name="7089"></a>    isClean = nil
<a name="7090"></a>    
<a name="7091"></a>    /* But that most things don't actually need cleaning in the game */
<a name="7092"></a>    needsCleaning = nil
<a name="7093"></a>    
<a name="7094"></a>    /* 
<a name="7095"></a>     *   If this is non-nil then this is an object or a list of objects that
<a name="7096"></a>     *   must be/can be used to clean this object.
<a name="7097"></a>     */
<a name="7098"></a>    mustBeCleanedWith = nil
<a name="7099"></a>    
<a name="7100"></a>    
<a name="7101"></a>    /*  
<a name="7102"></a>     *   The handling of the Clean action is possibly more elaborate than it
<a name="7103"></a>     *   needs to be by default, and game code may wish to override it with a
<a name="7104"></a>     *   different implementation, but the aim is to provide a framework that
<a name="7105"></a>     *   covers some common cases.
<a name="7106"></a>     *
<a name="7107"></a>     *   An object starts out with isClean = nil. Cleaning the object makes
<a name="7108"></a>     *   isClean true (at which point it doesn't need cleaning again).
<a name="7109"></a>     *
<a name="7110"></a>     *   If an object needs another object to be cleaned with (e.g. if in order
<a name="7111"></a>     *   to clean the window you need a wet sponge to clean it with), this can
<a name="7112"></a>     *   be defined by setting mustBeCleanedWith to an object or a list of
<a name="7113"></a>     *   objects that can be used to clean this direct object.
<a name="7114"></a>     */
<a name="7115"></a>    dobjFor(Clean)
<a name="7116"></a>    {
<a name="7117"></a>        preCond = [touchObj]
<a name="7118"></a>        
<a name="7119"></a>        verify()
<a name="7120"></a>        {
<a name="7121"></a>            if(!isCleanable) 
<a name="7122"></a>                illogical(cannotCleanMsg);
<a name="7123"></a>            
<a name="7124"></a>            else if(isClean)
<a name="7125"></a>                illogicalNow(alreadyCleanMsg);        
<a name="7126"></a>        
<a name="7127"></a>            else if(!needsCleaning)
<a name="7128"></a>                implausible(noNeedToCleanMsg);           
<a name="7129"></a>            
<a name="7130"></a>        }
<a name="7131"></a>        
<a name="7132"></a>        
<a name="7133"></a>        action() 
<a name="7134"></a>        {
<a name="7135"></a>            if(mustBeCleanedWith != nil)
<a name="7136"></a>                askForIobj(CleanWith);
<a name="7137"></a>            
<a name="7138"></a>            makeCleaned(true); 
<a name="7139"></a>        }
<a name="7140"></a>        
<a name="7141"></a>        report()
<a name="7142"></a>        {
<a name="7143"></a>            say(okayCleanMsg);
<a name="7144"></a>        }
<a name="7145"></a>    }
<a name="7146"></a>    
<a name="7147"></a>    /* 
<a name="7148"></a>     *   Carry out the effects of cleaning. By default we just set the value of
<a name="7149"></a>     *   the isClean property, but game code could override this to carry out
<a name="7150"></a>     *   any side effects of cleaning, such as revealing the inscription on a
<a name="7151"></a>     *   dirty old gravestone.
<a name="7152"></a>     */
<a name="7153"></a>    makeCleaned(stat) { isClean = stat; }
<a name="7154"></a>    
<a name="7155"></a>    cannotCleanMsg = BMsg(cannot clean, '{The subj dobj} {is} not something {i}
<a name="7156"></a>        {can} clean. ')
<a name="7157"></a>    
<a name="7158"></a>    alreadyCleanMsg = BMsg(already clean, '{The subj dobj} {is} already quite
<a name="7159"></a>        clean enough. ')
<a name="7160"></a>    
<a name="7161"></a>    noNeedToCleanMsg = BMsg(no clean, '{The subj dobj} {doesn\'t need[ed]}
<a name="7162"></a>        cleaning. ')
<a name="7163"></a>        
<a name="7164"></a>    
<a name="7165"></a>    dontNeedCleaningObjMsg = BMsg(dont need cleaning obj, '{I} {don\'t need[ed]}
<a name="7166"></a>        anything to clean {the dobj} with. ')
<a name="7167"></a>    
<a name="7168"></a>    okayCleanMsg = DMsg(okay clean, 'Cleaned.|{I} clean{s/ed} {1}. ',
<a name="7169"></a>                        gActionListStr)
<a name="7170"></a>    
<a name="7171"></a>    dobjFor(CleanWith)
<a name="7172"></a>    {
<a name="7173"></a>        preCond = [touchObj]
<a name="7174"></a>        
<a name="7175"></a>        verify()
<a name="7176"></a>        {
<a name="7177"></a>            if(!isCleanable) 
<a name="7178"></a>                illogical(cannotCleanMsg);
<a name="7179"></a>            
<a name="7180"></a>            else if(isClean)
<a name="7181"></a>                illogicalNow(alreadyCleanMsg);
<a name="7182"></a>        
<a name="7183"></a>            else if(!needsCleaning)
<a name="7184"></a>                implausible(noNeedToCleanMsg);
<a name="7185"></a>            
<a name="7186"></a>            else if(mustBeCleanedWith == nil)
<a name="7187"></a>                implausible(dontNeedCleaningObjMsg);
<a name="7188"></a>            
<a name="7189"></a>            else if(valToList(mustBeCleanedWith).indexOf(gVerifyIobj) == nil)
<a name="7190"></a>                implausible(cannotCleanWithMsg);
<a name="7191"></a>        }
<a name="7192"></a>        
<a name="7193"></a>        
<a name="7194"></a>        action() { makeCleaned(true); }
<a name="7195"></a>        
<a name="7196"></a>        report()
<a name="7197"></a>        {
<a name="7198"></a>            say(okayCleanMsg);
<a name="7199"></a>        }
<a name="7200"></a>    }
<a name="7201"></a>    
<a name="7202"></a>    /* 
<a name="7203"></a>     *   We assume most objects aren't suitable for cleaning other objects with.
<a name="7204"></a>     *   Since the dobj is resolved first canCleanWithMe could be a method that
<a name="7205"></a>     *   checks whether the proposed iobj is suitable for cleaning gDobj; but a
<a name="7206"></a>     *   better way of doing it might be to list suitable objects in the
<a name="7207"></a>     *   mustBeCleanedWith property.
<a name="7208"></a>     */      
<a name="7209"></a>    canCleanWithMe = nil
<a name="7210"></a>    
<a name="7211"></a>    iobjFor(CleanWith)
<a name="7212"></a>    {
<a name="7213"></a>        preCond = [objHeld]
<a name="7214"></a>        verify() 
<a name="7215"></a>        { 
<a name="7216"></a>            if(!canCleanWithMe)
<a name="7217"></a>               illogical(cannotCleanWithMsg); 
<a name="7218"></a>        }
<a name="7219"></a>    }
<a name="7220"></a>    
<a name="7221"></a>    cannotCleanWithMsg = BMsg(cannot clean with, '{I} {can\'t} clean {the dobj}
<a name="7222"></a>        with {the iobj}. ')
<a name="7223"></a>    
<a name="7224"></a>    /* Most things are not suitable for digging in*/
<a name="7225"></a>    isDiggable = nil
<a name="7226"></a>    
<a name="7227"></a>    dobjFor(Dig)
<a name="7228"></a>    {
<a name="7229"></a>        preCond = [touchObj]
<a name="7230"></a>        verify() 
<a name="7231"></a>        {
<a name="7232"></a>            if(!isDiggable)
<a name="7233"></a>               illogical(cannotDigMsg); 
<a name="7234"></a>        }
<a name="7235"></a>        
<a name="7236"></a>        /* 
<a name="7237"></a>         *   If digging is allowed, then most likely we need an implement like a
<a name="7238"></a>         *   spade to dig with, so our default action is to ask for one. This
<a name="7239"></a>         *   can be overridden on objects in which the actors can effectively
<a name="7240"></a>         *   dig with their bare hands.
<a name="7241"></a>         */
<a name="7242"></a>        action() { askForIobj(DigWith); }
<a name="7243"></a>    }
<a name="7244"></a>    
<a name="7245"></a>    /* Most objects aren't suitable digging instruments */
<a name="7246"></a>    canDigWithMe = nil
<a name="7247"></a>    
<a name="7248"></a>    /* 
<a name="7249"></a>     *   For DigWith we merely provide verify handlers that rule out the action
<a name="7250"></a>     *   wih the default values of isDiggable and canDigWithMe. The library
<a name="7251"></a>     *   cannot model the effect of digging in general, so it's up to game code
<a name="7252"></a>     *   to implement this on particular objects as required.
<a name="7253"></a>     */
<a name="7254"></a>    dobjFor(DigWith)
<a name="7255"></a>    {
<a name="7256"></a>        preCond = [touchObj]
<a name="7257"></a>        verify() 
<a name="7258"></a>        {
<a name="7259"></a>            if(!isDiggable)
<a name="7260"></a>               illogical(cannotDigMsg); 
<a name="7261"></a>        }
<a name="7262"></a>    }
<a name="7263"></a>        
<a name="7264"></a>    iobjFor(DigWith)
<a name="7265"></a>    {
<a name="7266"></a>        preCond = [objHeld]
<a name="7267"></a>        verify() 
<a name="7268"></a>        { 
<a name="7269"></a>            if(!canDigWithMe)
<a name="7270"></a>               illogical(cannotDigWithMsg); 
<a name="7271"></a>            
<a name="7272"></a>            if(gVerifyDobj == self)
<a name="7273"></a>                illogicalSelf(cannotDigWithSelfMsg);
<a name="7274"></a>        }
<a name="7275"></a>    }
<a name="7276"></a>    
<a name="7277"></a>    cannotDigMsg = BMsg(cannot dig, '{I} {can\'t} dig there. ')
<a name="7278"></a>    cannotDigWithMsg = BMsg(cannot dig with, '{I} {can\'t} dig anything with
<a name="7279"></a>        {that iobj}. ')
<a name="7280"></a>    cannotDigWithSelfMsg = BMsg(cannot dig with self, '{I} {can\'t} dig {the
<a name="7281"></a>        dobj} with {itself dobj}. ')
<a name="7282"></a>    
<a name="7283"></a>    
<a name="7284"></a>    /* 
<a name="7285"></a>     *   We treat TAKE FROM as equivalent to TAKE except at the verify stage,
<a name="7286"></a>     *   where we first check that the direct object is actually in the indirect
<a name="7287"></a>     *   object.
<a name="7288"></a>     */
<a name="7289"></a>    dobjFor(TakeFrom) asDobjWithoutVerifyFor(Take)
<a name="7290"></a>    
<a name="7291"></a>    dobjFor(TakeFrom)
<a name="7292"></a>    {           
<a name="7293"></a>        verify()
<a name="7294"></a>        {
<a name="7295"></a>            if(!isTakeable)
<a name="7296"></a>                illogical(cannotTakeMsg);
<a name="7297"></a>            
<a name="7298"></a>            /* Test whether we are contained in any possible iobj. */
<a name="7299"></a>            local contained = nil;
<a name="7300"></a>            
<a name="7301"></a>            /* 
<a name="7302"></a>             *   If we already know what the indirect object is, test if we are in its contents
<a name="7303"></a>             *   (which may include one of its remapXXX subcontainers).
<a name="7304"></a>             */
<a name="7305"></a>            if(gIobj)
<a name="7306"></a>            {
<a name="7307"></a>                if(gIobj.notionalContents.indexOf(self))
<a name="7308"></a>                    contained = true;
<a name="7309"></a>            }
<a name="7310"></a>            /*  
<a name="7311"></a>             *   Otherwise, test if we are in any of the possible matches for the iobj of this
<a name="7312"></a>             *   command.
<a name="7313"></a>             */
<a name="7314"></a>            else  
<a name="7315"></a>            {                
<a name="7316"></a>                for(local obj in gTentativeIobj)
<a name="7317"></a>                {
<a name="7318"></a>                    if(obj.notionalContents.indexOf(self))
<a name="7319"></a>                    {
<a name="7320"></a>                        contained = true;
<a name="7321"></a>                        break;
<a name="7322"></a>                    }
<a name="7323"></a>                }
<a name="7324"></a>            }
<a name="7325"></a>            
<a name="7326"></a>            /* 
<a name="7327"></a>             *   If we're not in any possible iobj for this command, we can't be taken from any of
<a name="7328"></a>             *   them.
<a name="7329"></a>             */
<a name="7330"></a>            if(!contained)
<a name="7331"></a>                illogicalNow(notInMsg);
<a name="7332"></a>            
<a name="7333"></a>            /* 
<a name="7334"></a>             *   If we have a resolved iobj and it's the same as us (the dobj) or our tentative iobj
<a name="7335"></a>             *   list contains only us (the dobj) the player is trying to take us from ourselvdes,
<a name="7336"></a>             *   which we rule out as impossible.
<a name="7337"></a>             */
<a name="7338"></a>            if((gIobj == self)
<a name="7339"></a>               || (gTentativeIobj.length == 1 &amp;&amp; self == gVerifyIobj))
<a name="7340"></a>                illogicalSelf(cannotTakeFromSelfMsg);
<a name="7341"></a>        }        
<a name="7342"></a>    }
<a name="7343"></a>    
<a name="7344"></a>    iobjFor(TakeFrom)
<a name="7345"></a>    {
<a name="7346"></a>        preCond = [touchObj]
<a name="7347"></a>        
<a name="7348"></a>        verify()       
<a name="7349"></a>        {          
<a name="7350"></a>            /*We're a poor choice of indirect object if there's nothing in us */
<a name="7351"></a>            if(notionalContents.countWhich({x: !x.isFixed}) == 0)
<a name="7352"></a>                logicalRank(70);
<a name="7353"></a>            
<a name="7354"></a>            /* 
<a name="7355"></a>             *   We're also a poor choice if none of the tentative direct
<a name="7356"></a>             *   objects is in our list of notional contents
<a name="7357"></a>             */
<a name="7358"></a>            if(gTentativeDobj.overlapsWith(notionalContents) == nil)
<a name="7359"></a>                logicalRank(80);        
<a name="7360"></a>        
<a name="7361"></a>        }      
<a name="7362"></a>    }
<a name="7363"></a>    
<a name="7364"></a>    notInMsg = BMsg(not inside, '{The dobj} {is}n\'t ' + 
<a name="7365"></a>                    (gIobj ? '{in iobj}.' : '{1}.'), gVerifyIobj.objInName)
<a name="7366"></a>    
<a name="7367"></a>    cannotTakeFromSelfMsg =  BMsg(cannot take from self, '{I} {can\'t} take
<a name="7368"></a>        {the subj dobj} from {himself dobj}. ')
<a name="7369"></a>    
<a name="7370"></a>    /* 
<a name="7371"></a>     *   Flag, can we supply more items from us that are currently in scope? By
<a name="7372"></a>     *   default we can't; but a DispensingCollective may be able to.
<a name="7373"></a>     */
<a name="7374"></a>    canSupply = nil
<a name="7375"></a>        
<a name="7376"></a>    dobjFor(ThrowAt)
<a name="7377"></a>    {
<a name="7378"></a>        preCond = [objHeld, objNotWorn]
<a name="7379"></a>        
<a name="7380"></a>        verify() { verifyDobjThrow(); }
<a name="7381"></a>        
<a name="7382"></a>        action()
<a name="7383"></a>        {
<a name="7384"></a>            /* 
<a name="7385"></a>             *   Normally the action handling for the ThrowAt action is dealt
<a name="7386"></a>             *   with on the indirect object - iobjFor(ThrowAt) - but if for
<a name="7387"></a>             *   particular objects you want to handle it on the direct object
<a name="7388"></a>             *   and you don't want the iobj handling as well, then you need to
<a name="7389"></a>             *   end your dobj action method with exitAction to suppress the
<a name="7390"></a>             *   iobj action method.
<a name="7391"></a>             */
<a name="7392"></a>        }
<a name="7393"></a>    }
<a name="7394"></a>    
<a name="7395"></a>    
<a name="7396"></a>    /* 
<a name="7397"></a>     *   Most objects can the target of a throw, but it's conceivable that some
<a name="7398"></a>     *   might be obviously unsuitable
<a name="7399"></a>     */
<a name="7400"></a>    canThrowAtMe = true
<a name="7401"></a>    
<a name="7402"></a>    iobjFor(ThrowAt)
<a name="7403"></a>    {
<a name="7404"></a>        preCond = [objVisible]
<a name="7405"></a>        
<a name="7406"></a>        verify()
<a name="7407"></a>        {
<a name="7408"></a>            if(!canThrowAtMe)
<a name="7409"></a>                illogical(cannotThrowAtMsg);
<a name="7410"></a>            
<a name="7411"></a>            if(gDobj == self)
<a name="7412"></a>                illogical(cannotThrowAtSelfMsg);
<a name="7413"></a>        }
<a name="7414"></a>        
<a name="7415"></a>        
<a name="7416"></a>        action()
<a name="7417"></a>        {            
<a name="7418"></a>            gDobj.actionMoveInto(getOutermostRoom.dropLocation);
<a name="7419"></a>        }
<a name="7420"></a>        
<a name="7421"></a>        report()
<a name="7422"></a>        {
<a name="7423"></a>            local obj = gActionListObj;
<a name="7424"></a>            gMessageParams(obj);
<a name="7425"></a>            DMsg(throw at, '{The subj obj} {strikes} {the iobj} and land{s/ed}
<a name="7426"></a>                on the ground. ');            
<a name="7427"></a>        }
<a name="7428"></a>        
<a name="7429"></a>    }
<a name="7430"></a>    
<a name="7431"></a>    /* 
<a name="7432"></a>     *   Particular instances will nearly always need to override with a less
<a name="7433"></a>     *   generic and more plausible refusal message.
<a name="7434"></a>     */
<a name="7435"></a>    cannotThrowAtMsg = BMsg(cannot throw at, '{I} {can\'t} throw anything at
<a name="7436"></a>        {the iobj}. ')
<a name="7437"></a>    
<a name="7438"></a>    cannotThrowAtSelfMsg = BMsg(cannot throw at self, '{The subj dobj} {can\'t}
<a name="7439"></a>        be thrown at {itself dobj}. ')
<a name="7440"></a>    
<a name="7441"></a>    dobjFor(ThrowTo)
<a name="7442"></a>    {
<a name="7443"></a>        preCond = [objHeld, objNotWorn]
<a name="7444"></a>        
<a name="7445"></a>        verify() { verifyDobjThrow(); }
<a name="7446"></a>    }
<a name="7447"></a>    
<a name="7448"></a>    /* 
<a name="7449"></a>     *   Most objects cannot have things thrown to then, since this would imply
<a name="7450"></a>     *   that they might be able to catch them, which only animate objects can
<a name="7451"></a>     *   do.
<a name="7452"></a>     */
<a name="7453"></a>    canThrowToMe = nil
<a name="7454"></a>    
<a name="7455"></a>    iobjFor(ThrowTo)
<a name="7456"></a>    {
<a name="7457"></a>        preCond = [objVisible]
<a name="7458"></a>        
<a name="7459"></a>        verify()
<a name="7460"></a>        {
<a name="7461"></a>            if(!canThrowToMe)
<a name="7462"></a>                illogical(cannotThrowToMsg);
<a name="7463"></a>            
<a name="7464"></a>            if(gVerifyDobj == self)
<a name="7465"></a>                illogical(cannotThrowToSelfMsg);
<a name="7466"></a>        } 
<a name="7467"></a>        
<a name="7468"></a>    }
<a name="7469"></a>    
<a name="7470"></a>    cannotThrowToMsg = BMsg(cannot throw to, '{The subj iobj} {can\'t} catch
<a name="7471"></a>        anything. ')
<a name="7472"></a>    
<a name="7473"></a>    cannotThrowToSelfMsg = BMsg(cannot throw to self, '{The subj dobj} {can\'t}
<a name="7474"></a>        be thrown to {itself dobj}. ')
<a name="7475"></a>    
<a name="7476"></a>    throwFallsShortMsg = BMsg(throw falls short, '{The subj dobj} land{s/ed} far
<a name="7477"></a>        short of {the iobj}. ')
<a name="7478"></a>    
<a name="7479"></a>    canTurnMeTo = nil
<a name="7480"></a>    
<a name="7481"></a>    
<a name="7482"></a>    /* 
<a name="7483"></a>     *   Turning something To is setting it to a value by rotating it, such as
<a name="7484"></a>     *   turning a dial to point to a particular number.
<a name="7485"></a>     */
<a name="7486"></a>    dobjFor(TurnTo)
<a name="7487"></a>    {
<a name="7488"></a>        preCond = [touchObj]
<a name="7489"></a>        
<a name="7490"></a>        verify() 
<a name="7491"></a>        {
<a name="7492"></a>            if(!canTurnMeTo)
<a name="7493"></a>               illogical(cannotTurnToMsg); 
<a name="7494"></a>        }   
<a name="7495"></a>        
<a name="7496"></a>        check()
<a name="7497"></a>        {
<a name="7498"></a>            checkSetting(gLiteral);
<a name="7499"></a>        }
<a name="7500"></a>        
<a name="7501"></a>        action()
<a name="7502"></a>        {
<a name="7503"></a>            makeSetting(gLiteral);                        
<a name="7504"></a>        }
<a name="7505"></a>        
<a name="7506"></a>        report()
<a name="7507"></a>        {
<a name="7508"></a>            DMsg(okay turn to, 'Okay, {I} turn{s/ed} {1} to {2}', gActionListStr, 
<a name="7509"></a>                 gLiteral);
<a name="7510"></a>        }
<a name="7511"></a>    }
<a name="7512"></a>    
<a name="7513"></a>    /* 
<a name="7514"></a>     *   If the setting is valid, do nothing. If it's invalid display a message
<a name="7515"></a>     *   explaining why. We do nothing here but this is overridden on the
<a name="7516"></a>     *   Settable class, which may be easier to use than providing your own
<a name="7517"></a>     *   implementation on Thing.
<a name="7518"></a>     */    
<a name="7519"></a>    checkSetting(val) { }
<a name="7520"></a>    
<a name="7521"></a>    /* The value we're currently set to. */
<a name="7522"></a>    curSetting = ''
<a name="7523"></a>    
<a name="7524"></a>    cannotTurnToMsg = BMsg(cannot turn to, '{I} {cannot} turn {that dobj} to
<a name="7525"></a>        anything. ')
<a name="7526"></a>    
<a name="7527"></a>    
<a name="7528"></a>    canSetMeTo = nil
<a name="7529"></a>    
<a name="7530"></a>    dobjFor(SetTo)
<a name="7531"></a>    {
<a name="7532"></a>        preCond = [touchObj]
<a name="7533"></a>        
<a name="7534"></a>        verify() 
<a name="7535"></a>        { 
<a name="7536"></a>            if(!canSetMeTo)
<a name="7537"></a>               illogical(cannotSetToMsg); 
<a name="7538"></a>        }
<a name="7539"></a>        
<a name="7540"></a>        check()
<a name="7541"></a>        {
<a name="7542"></a>            /* This would be a good place to put code to validate the setting */
<a name="7543"></a>            checkSetting(gLiteral);
<a name="7544"></a>        }
<a name="7545"></a>        
<a name="7546"></a>        action()
<a name="7547"></a>        {
<a name="7548"></a>            makeSetting(gLiteral);                       
<a name="7549"></a>        }
<a name="7550"></a>        
<a name="7551"></a>        report()
<a name="7552"></a>        {
<a name="7553"></a>            say(okaySetMsg);
<a name="7554"></a>        }
<a name="7555"></a>    }
<a name="7556"></a>       
<a name="7557"></a>    makeSetting(val) { curSetting = val; }
<a name="7558"></a>    
<a name="7559"></a>    okaySetMsg = BMsg(okay set to, '{I} {set} {1} to {2}. ', gActionListStr,
<a name="7560"></a>        curSetting)
<a name="7561"></a>    
<a name="7562"></a>    cannotSetToMsg = BMsg(cannot set to, '{I} {cannot} set {that dobj} to
<a name="7563"></a>        anything. ')
<a name="7564"></a>    
<a name="7565"></a>    
<a name="7566"></a>    /* 
<a name="7567"></a>     *   The GoTo action allows the player character to navigate the map through
<a name="7568"></a>     *   the use of commands such as GO TO LOUNGE.
<a name="7569"></a>     */
<a name="7570"></a>    dobjFor(GoTo)
<a name="7571"></a>    {
<a name="7572"></a>        verify()
<a name="7573"></a>        {
<a name="7574"></a>            /* 
<a name="7575"></a>             *   If the actor is already in the direct object, there's no need
<a name="7576"></a>             *   to move any further.
<a name="7577"></a>             */
<a name="7578"></a>            if(gActor.isIn(self))
<a name="7579"></a>                illogicalNow(alreadyThereMsg);
<a name="7580"></a>            
<a name="7581"></a>            /*  
<a name="7582"></a>             *   If the direct object is in the actor's location, there's no
<a name="7583"></a>             *   need for the actor to move to get to it.
<a name="7584"></a>             */
<a name="7585"></a>            if(isIn(gActor.getOutermostRoom))
<a name="7586"></a>                illogicalNow(alreadyPresentMsg);
<a name="7587"></a>            
<a name="7588"></a>            /*  
<a name="7589"></a>             *   It's legal to GO TO a decoration object, but given the choice,
<a name="7590"></a>             *   it's probably best to let the parser choose a non-decoration in
<a name="7591"></a>             *   cases of ambiguity, so we'll decorations a slightly lower
<a name="7592"></a>             *   logical rank.
<a name="7593"></a>             */
<a name="7594"></a>            if(isDecoration)
<a name="7595"></a>                logicalRank(90);
<a name="7596"></a>        }
<a name="7597"></a>        
<a name="7598"></a>        /* 
<a name="7599"></a>         *   The purpose of the GO TO action is to take the player char along
<a name="7600"></a>         *   the shortest route to the destination. The action routine
<a name="7601"></a>         *   calculates the route and takes the first step.
<a name="7602"></a>         */
<a name="7603"></a>        action()
<a name="7604"></a>        {
<a name="7605"></a>            /* Get our destination. */
<a name="7606"></a>            local dest = lastSeenAt ? lastSeenAt.getOutermostRoom : nil;
<a name="7607"></a>            
<a name="7608"></a>            /* 
<a name="7609"></a>             *   Calculate the route from the actor's current room to the
<a name="7610"></a>             *   location where the target object was last seen, using the
<a name="7611"></a>             *   pcRouteFinder to carry out the calculations if it is present.
<a name="7612"></a>             */
<a name="7613"></a>            local route = defined(pcRouteFinder) &amp;&amp; lastSeenAt != nil 
<a name="7614"></a>                ? pcRouteFinder.findPath(
<a name="7615"></a>                gActor.getOutermostRoom, dest) : nil;
<a name="7616"></a>            
<a name="7617"></a>            /*  
<a name="7618"></a>             *   If we don't find a route, just display a message saying we
<a name="7619"></a>             *   don't know how to get to our destination.
<a name="7620"></a>             */
<a name="7621"></a>            if(route == nil)
<a name="7622"></a>                sayDontKnowHowToGetThere();
<a name="7623"></a>            
<a name="7624"></a>            /*  
<a name="7625"></a>             *   If the route we find has only one element in its list, that
<a name="7626"></a>             *   means that we're where we last saw the target but it's no
<a name="7627"></a>             *   longer there, so we don't know where it's gone. In which case
<a name="7628"></a>             *   we display a message saying we don't know how to reach our
<a name="7629"></a>             *   target.
<a name="7630"></a>             */
<a name="7631"></a>            else if(route.length == 1)
<a name="7632"></a>                sayDontKnowHowToReach();
<a name="7633"></a>            
<a name="7634"></a>            /*  
<a name="7635"></a>             *   If the route we found has at least two elements, then use the
<a name="7636"></a>             *   first element of the second element as the direction in which
<a name="7637"></a>             *   we need to travel, and use the Continue action to take a step
<a name="7638"></a>             *   in that direction.
<a name="7639"></a>             */
<a name="7640"></a>            else
<a name="7641"></a>            {
<a name="7642"></a>                local idx = 2;
<a name="7643"></a>                local dir = route[2][1];
<a name="7644"></a>                local oldLoc = gPlayerChar.getOutermostRoom();
<a name="7645"></a>                
<a name="7646"></a>                local commonRegions =
<a name="7647"></a>                    gPlayerChar.getOutermostRoom.regionsInCommonWith(dest);
<a name="7648"></a>                
<a name="7649"></a>                local regionFastGoTo = 
<a name="7650"></a>                    commonRegions.indexWhich({r: r.fastGoTo }) != nil;
<a name="7651"></a>                
<a name="7652"></a>                local fastGo = regionFastGoTo || gameMain.fastGoTo;
<a name="7653"></a>                
<a name="7654"></a>                Continue.takeStep(dir, getOutermostRoom, fastGo);                
<a name="7655"></a>                
<a name="7656"></a>                
<a name="7657"></a>                /* 
<a name="7658"></a>                 *   If the fastGoTo option is active, continue moving towards
<a name="7659"></a>                 *   the destination until either we reach it our we're
<a name="7660"></a>                 *   prevented from going any further.
<a name="7661"></a>                 */
<a name="7662"></a>                while((fastGo)
<a name="7663"></a>                      &amp;&amp; oldLoc != gPlayerChar.getOutermostRoom 
<a name="7664"></a>                      &amp;&amp; idx &lt; route.length)
<a name="7665"></a>                {
<a name="7666"></a>                    local dir = route[++idx][1];
<a name="7667"></a>                    Continue.takeStep(dir, getOutermostRoom, true);
<a name="7668"></a>                }               
<a name="7669"></a>            }
<a name="7670"></a>        }
<a name="7671"></a>    }
<a name="7672"></a>    
<a name="7673"></a>    /* 
<a name="7674"></a>     *   We make these two sayDontKnowHowTo... methods separate methods so that
<a name="7675"></a>     *   they can be reused on the Distant class without having to repeat the
<a name="7676"></a>     *   DMsg() definitions.
<a name="7677"></a>     */
<a name="7678"></a>    sayDontKnowHowToGetThere() 
<a name="7679"></a>        { DMsg(route unknown, '{I} {don\'t know} how to get there. ');}
<a name="7680"></a>   
<a name="7681"></a>    sayDontKnowHowToReach()
<a name="7682"></a>        {  DMsg(destination unknown, '{I} {don\'t know} how to reach
<a name="7683"></a>            {him dobj}.' );}
<a name="7684"></a>    
<a name="7685"></a>    
<a name="7686"></a>    alreadyThereMsg = BMsg(already there, '{I}{\'m} already there. ')
<a name="7687"></a>    alreadyPresentMsg = BMsg(already present, '{The subj dobj} {is} right
<a name="7688"></a>        {here}. ')    
<a name="7689"></a>    
<a name="7690"></a>    /* 
<a name="7691"></a>     *   By default most things can't be attached to any things. The base
<a name="7692"></a>     *   handling of ATTACH and DETACH on Thing merely rules them out at the
<a name="7693"></a>     *   verify stage. The SimpleAttachable and NearbyAttachable classes define
<a name="7694"></a>     *   in the optional attachables.t module provide fuller handling.
<a name="7695"></a>     */
<a name="7696"></a>    isAttachable = nil
<a name="7697"></a>    
<a name="7698"></a>    dobjFor(Attach)
<a name="7699"></a>    {
<a name="7700"></a>        preCond = [touchObj]        
<a name="7701"></a>        verify() 
<a name="7702"></a>        {
<a name="7703"></a>            if(!isAttachable)
<a name="7704"></a>               illogical(cannotAttachMsg); 
<a name="7705"></a>        }
<a name="7706"></a>        action() { askForIobj(AttachTo); }
<a name="7707"></a>    }
<a name="7708"></a>    
<a name="7709"></a>    dobjFor(AttachTo)
<a name="7710"></a>    {
<a name="7711"></a>        preCond = [touchObj]        
<a name="7712"></a>        verify() 
<a name="7713"></a>        {
<a name="7714"></a>            if(!isAttachable)
<a name="7715"></a>               illogical(cannotAttachMsg); 
<a name="7716"></a>        }
<a name="7717"></a>    }
<a name="7718"></a>    
<a name="7719"></a>    canAttachToMe = nil
<a name="7720"></a>    
<a name="7721"></a>    iobjFor(AttachTo)
<a name="7722"></a>    {
<a name="7723"></a>        preCond = [touchObj]
<a name="7724"></a>        verify() 
<a name="7725"></a>        { 
<a name="7726"></a>            if(!canAttachToMe)
<a name="7727"></a>               illogical(cannotAttachToMsg); 
<a name="7728"></a>            
<a name="7729"></a>            if(gVerifyDobj == self)
<a name="7730"></a>                illogicalSelf(cannotAttachToSelfMsg);
<a name="7731"></a>        }
<a name="7732"></a>    }
<a name="7733"></a>    
<a name="7734"></a>    cannotAttachMsg = BMsg(cannot attach, '{I} {cannot} attach {the dobj} to
<a name="7735"></a>        anything. ')
<a name="7736"></a>    cannotAttachToMsg = BMsg(cannot attach to, '{I} {cannot} attach anything to
<a name="7737"></a>        {the iobj}. ')
<a name="7738"></a>    
<a name="7739"></a>    cannotAttachToSelfMsg = BMsg(cannot attach to self, '{I} {cannot} attach
<a name="7740"></a>        {the iobj} to {itself iobj}. ')
<a name="7741"></a>   
<a name="7742"></a>    
<a name="7743"></a>    isDetachable = nil
<a name="7744"></a>    
<a name="7745"></a>    dobjFor(Detach)
<a name="7746"></a>    {
<a name="7747"></a>        preCond = [touchObj]
<a name="7748"></a>        verify() 
<a name="7749"></a>        {
<a name="7750"></a>            if(!isDetachable)
<a name="7751"></a>               illogical(cannotDetachMsg); 
<a name="7752"></a>        }            
<a name="7753"></a>    }
<a name="7754"></a>    
<a name="7755"></a>    cannotDetachMsg = BMsg(cannot detach, 'There{dummy} {is}n\'t anything from
<a name="7756"></a>        which {the subj dobj} could be detached. ')
<a name="7757"></a>    
<a name="7758"></a>    
<a name="7759"></a>    dobjFor(DetachFrom)
<a name="7760"></a>    {
<a name="7761"></a>        preCond = [touchObj]
<a name="7762"></a>        
<a name="7763"></a>        verify()
<a name="7764"></a>        {
<a name="7765"></a>            if(!isDetachable)
<a name="7766"></a>               illogical(cannotDetachMsg); 
<a name="7767"></a>            
<a name="7768"></a>            if(gVerifyIobj == self)
<a name="7769"></a>                illogicalSelf(cannotDetachFromSelfMsg);
<a name="7770"></a>        }
<a name="7771"></a>    }
<a name="7772"></a>
<a name="7773"></a>    canDetachFromMe = nil
<a name="7774"></a>    
<a name="7775"></a>    iobjFor(DetachFrom)
<a name="7776"></a>    {
<a name="7777"></a>        verify()
<a name="7778"></a>        {
<a name="7779"></a>            if(!canDetachFromMe)
<a name="7780"></a>                illogical(cannotDetachFromMsg);
<a name="7781"></a>        }
<a name="7782"></a>    }
<a name="7783"></a>    
<a name="7784"></a>    cannotDetachFromMsg = BMsg(cannot detach from, 'There{dummy} {is}n\'t
<a name="7785"></a>        anything that could be detached from {the iobj}. ')
<a name="7786"></a>    
<a name="7787"></a>    cannotDetachFromSelfMsg = BMsg(cannot detach from self, '{The subj dobj}
<a name="7788"></a>        {can\'t} be detached from {itself dobj}. ')
<a name="7789"></a>    
<a name="7790"></a>    
<a name="7791"></a>    /* 
<a name="7792"></a>     *   Fasten by itself presumably refers to objects like seat-belts. There
<a name="7793"></a>     *   are not many such fastenable objects so we may things not fastenable by
<a name="7794"></a>     *   default.
<a name="7795"></a>     */    
<a name="7796"></a>    isFastenable = nil
<a name="7797"></a>    
<a name="7798"></a>    /*   Most things start out unfastened. */
<a name="7799"></a>    isFastened = nil
<a name="7800"></a>    
<a name="7801"></a>    /*  
<a name="7802"></a>     *   Make something fastened or unfastened. By default we just change the
<a name="7803"></a>     *   value of its isFastened property, but game code could override this to
<a name="7804"></a>     *   provide further side-effects on particular objects.
<a name="7805"></a>     */
<a name="7806"></a>    makeFastened(stat) { isFastened = stat; }
<a name="7807"></a>    
<a name="7808"></a>    dobjFor(Fasten)
<a name="7809"></a>    {
<a name="7810"></a>        preCond = [touchObj]
<a name="7811"></a>        verify() 
<a name="7812"></a>        { 
<a name="7813"></a>            if(!isFastenable)
<a name="7814"></a>                illogical(cannotFastenMsg); 
<a name="7815"></a>            
<a name="7816"></a>            if(isFastened)
<a name="7817"></a>                illogicalNow(alreadyFastenedMsg);
<a name="7818"></a>        }
<a name="7819"></a>        
<a name="7820"></a>        action() { makeFastened(true); }
<a name="7821"></a>        
<a name="7822"></a>        report()
<a name="7823"></a>        {
<a name="7824"></a>            DMsg(okay fasten, 'Done|{I} fasten{s/ed} {1}. ', gActionListStr);
<a name="7825"></a>        }
<a name="7826"></a>    }
<a name="7827"></a>    
<a name="7828"></a>    cannotFastenMsg = BMsg(cannot fasten, '{That subj dobj}{\'s} not something
<a name="7829"></a>        {i} {can} fasten. ')
<a name="7830"></a>    
<a name="7831"></a>    alreadyFastenedMsg = BMsg(already fastened, '{The subj dobj} {is} already
<a name="7832"></a>        fastened. ')
<a name="7833"></a>
<a name="7834"></a>        
<a name="7835"></a>    
<a name="7836"></a>    dobjFor(FastenTo)
<a name="7837"></a>    {
<a name="7838"></a>        preCond = [objHeld]
<a name="7839"></a>        verify() 
<a name="7840"></a>        {
<a name="7841"></a>            if(!isFastenable)
<a name="7842"></a>               illogical(cannotFastenMsg); 
<a name="7843"></a>        }
<a name="7844"></a>    }
<a name="7845"></a>    
<a name="7846"></a>    canFastenToMe = nil
<a name="7847"></a>    
<a name="7848"></a>    iobjFor(FastenTo)
<a name="7849"></a>    {
<a name="7850"></a>        preCond = [touchObj]
<a name="7851"></a>        verify() 
<a name="7852"></a>        { 
<a name="7853"></a>            if(!canFastenToMe)
<a name="7854"></a>                illogical(cannotFastenToMsg); 
<a name="7855"></a>            
<a name="7856"></a>            if(gVerifyDobj == self)
<a name="7857"></a>                illogicalSelf(cannotFastenToSelfMsg);
<a name="7858"></a>        }  
<a name="7859"></a>    }
<a name="7860"></a>    
<a name="7861"></a>    cannotFastenToMsg = BMsg(cannot fasten to, '{I} {can\'t} fasten anything to
<a name="7862"></a>        {that iobj}. ')
<a name="7863"></a>    
<a name="7864"></a>    cannotFastenToSelfMsg = BMsg(cannot fasten to self, '{The subj iobj}
<a name="7865"></a>        {can\'t} be fastened to {itself iobj}. ')
<a name="7866"></a>                                
<a name="7867"></a>    isUnfastenable = nil
<a name="7868"></a>    
<a name="7869"></a>    dobjFor(Unfasten)
<a name="7870"></a>    {
<a name="7871"></a>        preCond = [touchObj]
<a name="7872"></a>        verify() 
<a name="7873"></a>        { 
<a name="7874"></a>            if(!isUnfastenable)
<a name="7875"></a>               illogical(cannotUnfastenMsg); 
<a name="7876"></a>            
<a name="7877"></a>            if(!isFastened)
<a name="7878"></a>                illogicalNow(notFastenedMsg);
<a name="7879"></a>        }
<a name="7880"></a>    }
<a name="7881"></a>    
<a name="7882"></a>    
<a name="7883"></a>    
<a name="7884"></a>    
<a name="7885"></a>    dobjFor(UnfastenFrom)
<a name="7886"></a>    {
<a name="7887"></a>        preCond = [touchObj]
<a name="7888"></a>        verify() 
<a name="7889"></a>        {
<a name="7890"></a>            if(!isUnfastenable)
<a name="7891"></a>               illogical(cannotUnfastenMsg); 
<a name="7892"></a>            
<a name="7893"></a>            if(gVerifyIobj == self)
<a name="7894"></a>                illogical(cannotUnfastenFromSelfMsg);
<a name="7895"></a>        }
<a name="7896"></a>    }
<a name="7897"></a>    
<a name="7898"></a>    canUnfastenFromMe = nil
<a name="7899"></a>    
<a name="7900"></a>    iobjFor(UnfastenFrom)
<a name="7901"></a>    {
<a name="7902"></a>        preCond = [touchObj]
<a name="7903"></a>        verify()             
<a name="7904"></a>        {
<a name="7905"></a>            if(!canUnfastenFromMe)
<a name="7906"></a>               illogical(cannotUnfastenFromMsg); 
<a name="7907"></a>        }
<a name="7908"></a>    }
<a name="7909"></a>    
<a name="7910"></a>    cannotUnfastenMsg = BMsg(cannot unfasten, '{The subj dobj} {cannot} be
<a name="7911"></a>        unfastened. ')
<a name="7912"></a>    
<a name="7913"></a>    cannotUnfastenFromMsg = BMsg(cannot unfasten from, '{I} {can\'t} unfasten
<a name="7914"></a>        anything from {that iobj}. ')
<a name="7915"></a>    
<a name="7916"></a>    cannotUnfastenFromSelfMsg = BMsg(cannot unfasten from self, '{I} {can\'t}
<a name="7917"></a>        unfasten {the dobj} from {itself dobj}. ')
<a name="7918"></a>
<a name="7919"></a>    notFastenedMsg = BMsg(not fastened, '{The subj dobj} {isn\'t} fastened. ')
<a name="7920"></a>    
<a name="7921"></a>    /* 
<a name="7922"></a>     *   Most things can't be plugged into other things or have other things
<a name="7923"></a>     *   plugged into them.
<a name="7924"></a>     */
<a name="7925"></a>    isPlugable = nil
<a name="7926"></a>    canPlugIntoMe = nil
<a name="7927"></a>    
<a name="7928"></a>                          
<a name="7929"></a>    /* 
<a name="7930"></a>     *   The base handling of PlugInto on Thing merely rules it out at the
<a name="7931"></a>     *   verify stage. A fuller implementation is provided by the PlugAttachable
<a name="7932"></a>     *   class in the optional attachables module.
<a name="7933"></a>     */                      
<a name="7934"></a>    dobjFor(PlugInto)
<a name="7935"></a>    {
<a name="7936"></a>        preCond = [touchObj]
<a name="7937"></a>        
<a name="7938"></a>        verify()
<a name="7939"></a>        {
<a name="7940"></a>            if(!isPlugable)
<a name="7941"></a>                illogical(cannotPlugMsg);
<a name="7942"></a>            
<a name="7943"></a>            if(self == gVerifyIobj)
<a name="7944"></a>                illogicalSelf(cannotPlugIntoSelfMsg);            
<a name="7945"></a>        }        
<a name="7946"></a>        
<a name="7947"></a>    }
<a name="7948"></a>    
<a name="7949"></a>    iobjFor(PlugInto)
<a name="7950"></a>    {
<a name="7951"></a>        preCond = [touchObj]
<a name="7952"></a>        verify()
<a name="7953"></a>        {          
<a name="7954"></a>            if(!canPlugIntoMe)
<a name="7955"></a>                illogical(cannotPlugIntoMsg);
<a name="7956"></a>        }
<a name="7957"></a>    }
<a name="7958"></a>    
<a name="7959"></a>    
<a name="7960"></a>    cannotPlugMsg = BMsg(cannot plug, '{The subj dobj} {can\'t} be plugged into
<a name="7961"></a>        anything. ')
<a name="7962"></a>    cannotPlugIntoSelfMsg = BMsg(cannot plug into self, '{I} {can\'t} plug
<a name="7963"></a>        {the dobj} into {itself dobj}. ')
<a name="7964"></a>    cannotPlugIntoMsg = BMsg(cannot plug into, '{I} {can\'t} plug anything into
<a name="7965"></a>        {the iobj}. ')
<a name="7966"></a>    
<a name="7967"></a>    isUnplugable = (isPlugable)
<a name="7968"></a>    canUnplugFromMe = (canPlugIntoMe)
<a name="7969"></a>    
<a name="7970"></a>    dobjFor(UnplugFrom)
<a name="7971"></a>    {
<a name="7972"></a>        preCond = [touchObj]
<a name="7973"></a>        
<a name="7974"></a>        verify()
<a name="7975"></a>        {
<a name="7976"></a>            if(!isUnplugable)
<a name="7977"></a>                illogical(cannotUnplugMsg);
<a name="7978"></a>            
<a name="7979"></a>            if(gVerifyIobj == self)
<a name="7980"></a>                illogicalSelf(cannotUnplugFromSelfMsg);
<a name="7981"></a>        }
<a name="7982"></a>    }
<a name="7983"></a>    
<a name="7984"></a>    iobjFor(UnplugFrom)
<a name="7985"></a>    {
<a name="7986"></a>        preCond = []
<a name="7987"></a>        
<a name="7988"></a>        verify()
<a name="7989"></a>        {
<a name="7990"></a>            if(!canUnplugFromMe)
<a name="7991"></a>                illogical(cannotUnplugFromMsg);
<a name="7992"></a>            
<a name="7993"></a>           
<a name="7994"></a>        }
<a name="7995"></a>    }
<a name="7996"></a>    
<a name="7997"></a>    cannotUnplugMsg = BMsg(cannot unplug, '{The subj dobj} {can\'t} be
<a name="7998"></a>        unplugged. ')
<a name="7999"></a>    
<a name="8000"></a>    cannotUnplugFromSelfMsg = BMsg(cannot unplug from self, '{I} {can\'t} unplug
<a name="8001"></a>        {the dobj} from {itself dobj}. ')
<a name="8002"></a>    
<a name="8003"></a>    cannotUnplugFromMsg = BMsg(cannot unplug from, '{I} {can\'t} unplug anything
<a name="8004"></a>        from {the iobj}. ')
<a name="8005"></a>    
<a name="8006"></a>    dobjFor(PlugIn)
<a name="8007"></a>    {
<a name="8008"></a>        preCond = [touchObj]
<a name="8009"></a>        
<a name="8010"></a>        verify()
<a name="8011"></a>        {
<a name="8012"></a>            if(!isPlugable)
<a name="8013"></a>                illogical(cannotPlugMsg);
<a name="8014"></a>        }
<a name="8015"></a>    }
<a name="8016"></a>    
<a name="8017"></a>    dobjFor(Unplug)
<a name="8018"></a>    {
<a name="8019"></a>        preCond = [touchObj]
<a name="8020"></a>        
<a name="8021"></a>        verify()
<a name="8022"></a>        {
<a name="8023"></a>            if(!isUnplugable)
<a name="8024"></a>                illogical(cannotUnplugMsg);
<a name="8025"></a>        }
<a name="8026"></a>    }
<a name="8027"></a>    
<a name="8028"></a>    /* We can try kissing most things, even if it isn't very rewarding */
<a name="8029"></a>    isKissable = true
<a name="8030"></a>    
<a name="8031"></a>    /* 
<a name="8032"></a>     *   The logical rank assigned to kissing this object if kissing is allowed.
<a name="8033"></a>     *   Kissing an inanimate object is less likely than kissing an Actor.
<a name="8034"></a>     */
<a name="8035"></a>    kissRank = 80
<a name="8036"></a>    
<a name="8037"></a>    dobjFor(Kiss)
<a name="8038"></a>    {
<a name="8039"></a>        preCond = [touchObj]
<a name="8040"></a>        
<a name="8041"></a>        
<a name="8042"></a>        verify() 
<a name="8043"></a>        { 
<a name="8044"></a>            if(!isKissable)
<a name="8045"></a>                illogical(cannotKissMsg);
<a name="8046"></a>             
<a name="8047"></a>            /* 
<a name="8048"></a>             *   It's more logical to kiss actors, so we give the Kiss action a
<a name="8049"></a>             *   lower logical rank on ordinary things.
<a name="8050"></a>             */
<a name="8051"></a>            logicalRank(kissRank); 
<a name="8052"></a>        }
<a name="8053"></a>        
<a name="8054"></a>        check()
<a name="8055"></a>        {
<a name="8056"></a>            if(dataType(&amp;checkKissMsg) != TypeNil)
<a name="8057"></a>                display(&amp;checkKissMsg);
<a name="8058"></a>        }
<a name="8059"></a>        
<a name="8060"></a>        action()
<a name="8061"></a>        {
<a name="8062"></a>            if(dataType(&amp;futileToKissMsg) != TypeNil)
<a name="8063"></a>                display(&amp;futileToKissMsg);
<a name="8064"></a>        }
<a name="8065"></a>        
<a name="8066"></a>        
<a name="8067"></a>        report()
<a name="8068"></a>        {
<a name="8069"></a>            DMsg(report kiss, 'Kissing {1} {dummy}prove{s/d} remarkably
<a name="8070"></a>                unrewarding. ',  gActionListStr); 
<a name="8071"></a>        }
<a name="8072"></a>    }
<a name="8073"></a>    
<a name="8074"></a>    futileToKissMsg = nil
<a name="8075"></a>    
<a name="8076"></a>    cannotKissMsg = BMsg(cannot kiss, '{I} really {can\'t} kiss {that dobj}. ')
<a name="8077"></a>
<a name="8078"></a>    /* 
<a name="8079"></a>     *   If we want Kissing to fail at the check stage we can supply a message
<a name="8080"></a>     *   here explaining why. This is most simply given as a single-quoted
<a name="8081"></a>     *   string, but a double-quoted string or method will also work.
<a name="8082"></a>     */
<a name="8083"></a>    checkKissMsg = nil
<a name="8084"></a>    
<a name="8085"></a>    /* 
<a name="8086"></a>     *   Flag, if this is a nested room, should an actor get out of it before
<a name="8087"></a>     *   executing an intransitive Jump command. By default it should.
<a name="8088"></a>     */
<a name="8089"></a>    getOutToJump = true
<a name="8090"></a>    
<a name="8091"></a>    /* 
<a name="8092"></a>     *   It should be possible to jump off something if and only if the actor is
<a name="8093"></a>     *   on it in the first place.
<a name="8094"></a>     */
<a name="8095"></a>    canJumpOffMe = (gActor.location == self &amp;&amp; contType == On)
<a name="8096"></a>    
<a name="8097"></a>    dobjFor(JumpOff)
<a name="8098"></a>    {
<a name="8099"></a>        preCond = [touchObj]
<a name="8100"></a>        
<a name="8101"></a>        verify()
<a name="8102"></a>        {
<a name="8103"></a>            if(!canJumpOffMe)
<a name="8104"></a>                illogical(cannotJumpOffMsg);
<a name="8105"></a>        }
<a name="8106"></a>        
<a name="8107"></a>        action()
<a name="8108"></a>        {
<a name="8109"></a>            /* 
<a name="8110"></a>             *   Jumping off something has much the same effect as getting off
<a name="8111"></a>             *   it, i.e. moving the actor to our exitLocation.
<a name="8112"></a>             */
<a name="8113"></a>            gActor.actionMoveInto(exitLocation);
<a name="8114"></a>        }
<a name="8115"></a>        
<a name="8116"></a>        report()
<a name="8117"></a>        {
<a name="8118"></a>            DMsg(jump off, '{I} jump{s/ed} off {1} and land{s/ed} on the ground', 
<a name="8119"></a>                 gActionListStr);
<a name="8120"></a>        }
<a name="8121"></a>    }
<a name="8122"></a>    
<a name="8123"></a>    cannotJumpOffMsg = BMsg(cannot jump off, '{I}{\'m} not on {the dobj}. ')
<a name="8124"></a>    
<a name="8125"></a>    /* It usually isn't possible (or at least useful) to jump over things. */
<a name="8126"></a>    canJumpOverMe = nil
<a name="8127"></a>    
<a name="8128"></a>    /* 
<a name="8129"></a>     *   The base handling of JumpOver is simply to rule it out at the verify
<a name="8130"></a>     *   stage.
<a name="8131"></a>     */
<a name="8132"></a>    dobjFor(JumpOver)
<a name="8133"></a>    {
<a name="8134"></a>        preCond = [touchObj]
<a name="8135"></a>        
<a name="8136"></a>        verify()
<a name="8137"></a>        {
<a name="8138"></a>            if(!canJumpOverMe)
<a name="8139"></a>               illogical(cannotJumpOverMsg); 
<a name="8140"></a>        }
<a name="8141"></a>    }
<a name="8142"></a>    
<a name="8143"></a>    cannotJumpOverMsg = BMsg(pointless to jump over, 'It {dummy}{is}
<a name="8144"></a>        pointless to try to jump over {the dobj}. ')
<a name="8145"></a>    
<a name="8146"></a>    
<a name="8147"></a>    /* Most things aren't settable. */
<a name="8148"></a>    isSettable = nil
<a name="8149"></a>    
<a name="8150"></a>    /* 
<a name="8151"></a>     *   The Set command by itself doesn't do much. By default we just rule it
<a name="8152"></a>     *   out at the verify stage.
<a name="8153"></a>     */
<a name="8154"></a>    dobjFor(Set)
<a name="8155"></a>    {
<a name="8156"></a>        preCond = [touchObj]
<a name="8157"></a>        verify() 
<a name="8158"></a>        {
<a name="8159"></a>            if(!isSettable)
<a name="8160"></a>               illogical(cannotSetMsg); 
<a name="8161"></a>        }
<a name="8162"></a>    }
<a name="8163"></a>    
<a name="8164"></a>    cannotSetMsg = BMsg(cannot set, '{The subj dobj} {is} not something {i}
<a name="8165"></a>        {can} set. ')
<a name="8166"></a>    
<a name="8167"></a>    /* Most things can't be typed on. */
<a name="8168"></a>    canTypeOnMe = nil
<a name="8169"></a>    
<a name="8170"></a>    /* 
<a name="8171"></a>     *   The base handling of both the vague (TYPE ON X) and specific (TYPE FOO
<a name="8172"></a>     *   ON X) forms of TypeOn is simply to rule them out at the verify stage.
<a name="8173"></a>     *   Game code that needs objects that can be typed on is responsible for
<a name="8174"></a>     *   handling these actions in custom code.
<a name="8175"></a>     */
<a name="8176"></a>    dobjFor(TypeOnVague)
<a name="8177"></a>    {
<a name="8178"></a>        preCond = [touchObj]
<a name="8179"></a>        verify() 
<a name="8180"></a>        { 
<a name="8181"></a>            if(!canTypeOnMe)
<a name="8182"></a>               illogical(cannotTypeOnMsg); 
<a name="8183"></a>        }
<a name="8184"></a>    }
<a name="8185"></a>    
<a name="8186"></a>    dobjFor(TypeOn)
<a name="8187"></a>    {
<a name="8188"></a>        preCond = [touchObj]
<a name="8189"></a>        verify() 
<a name="8190"></a>        { 
<a name="8191"></a>            if(!canTypeOnMe)
<a name="8192"></a>               illogical(cannotTypeOnMsg); 
<a name="8193"></a>        }
<a name="8194"></a>    }
<a name="8195"></a>    
<a name="8196"></a>    cannotTypeOnMsg = BMsg(cannot type on, '{I} {can\'t} type anything on {the
<a name="8197"></a>        dobj}. ')
<a name="8198"></a>    
<a name="8199"></a>    
<a name="8200"></a>    /* 
<a name="8201"></a>     *   Entering something on means ENTER FOO ON BAR where FOO is a string
<a name="8202"></a>     *   literal and BAR is an object such as a computer terminal. Most objects
<a name="8203"></a>     *   can't be entered on in this sense.
<a name="8204"></a>     */
<a name="8205"></a>    canEnterOnMe = nil
<a name="8206"></a>    
<a name="8207"></a>    
<a name="8208"></a>    /*   
<a name="8209"></a>     *   The base handling is simply to rule out EnterOn at verify. There's no
<a name="8210"></a>     *   further handling the library can provide for a 'general' case so it's
<a name="8211"></a>     *   up to game code to define it for specific cases.
<a name="8212"></a>     */
<a name="8213"></a>    dobjFor(EnterOn)
<a name="8214"></a>    {
<a name="8215"></a>        preCond = [touchObj]
<a name="8216"></a>        verify() 
<a name="8217"></a>        { 
<a name="8218"></a>            if(!canEnterOnMe)
<a name="8219"></a>               illogical(cannotEnterOnMsg); 
<a name="8220"></a>        }
<a name="8221"></a>    }
<a name="8222"></a>    
<a name="8223"></a>    cannotEnterOnMsg = BMsg(cannot enter on, '{I} {can\'t} enter anything on
<a name="8224"></a>        {the dobj}. ')
<a name="8225"></a>    
<a name="8226"></a>    
<a name="8227"></a>    /*  Most things can't be written on. */
<a name="8228"></a>    canWriteOnMe = nil
<a name="8229"></a>    
<a name="8230"></a>    /*  By default we simply rule out writing on things at the verify stage. */
<a name="8231"></a>    dobjFor(WriteOn)
<a name="8232"></a>    {
<a name="8233"></a>        preCond = [touchObj]
<a name="8234"></a>        verify() 
<a name="8235"></a>        { 
<a name="8236"></a>            if(!canWriteOnMe)
<a name="8237"></a>               illogical(cannotWriteOnMsg); 
<a name="8238"></a>        }        
<a name="8239"></a>        
<a name="8240"></a>    }
<a name="8241"></a>    
<a name="8242"></a>    cannotWriteOnMsg = BMsg(cannot write on, '{I} {can\'t} write anything on
<a name="8243"></a>        {the dobj}. ')
<a name="8244"></a>    
<a name="8245"></a>    /* Most things aren't consultable */
<a name="8246"></a>    isConsultable = nil
<a name="8247"></a>    
<a name="8248"></a>    /* 
<a name="8249"></a>     *   The base handling on Thing merely rules out the Consult action at the
<a name="8250"></a>     *   verify stage. For a fuller implementation that allows consulting use
<a name="8251"></a>     *   the Consultable class.
<a name="8252"></a>     */
<a name="8253"></a>    dobjFor(ConsultAbout)
<a name="8254"></a>    {
<a name="8255"></a>        preCond = [touchObj]
<a name="8256"></a>        verify() 
<a name="8257"></a>        { 
<a name="8258"></a>            if(!isConsultable)
<a name="8259"></a>               illogical(cannotConsultMsg); 
<a name="8260"></a>        }
<a name="8261"></a>        
<a name="8262"></a>    }
<a name="8263"></a>    
<a name="8264"></a>    cannotConsultMsg = BMsg(cannot consult, '{The subj dobj} {is} not a
<a name="8265"></a>        provider of information. ')
<a name="8266"></a>    
<a name="8267"></a>    /* 
<a name="8268"></a>     *   Most things aren't pourable (they can't be poured into or onto other
<a name="8269"></a>     *   things.
<a name="8270"></a>     */
<a name="8271"></a>    isPourable = nil
<a name="8272"></a>    
<a name="8273"></a>    
<a name="8274"></a>    /* 
<a name="8275"></a>     *   Sometimes we may have a container, such as an oilcan, from which we
<a name="8276"></a>     *   want to pour a liquid, such as oil, and we're using the same object to
<a name="8277"></a>     *   do duty for both. We can then use the fluidName property to say 'the
<a name="8278"></a>     *   oil' rather than 'the oilcan' in messages that refer specifically to
<a name="8279"></a>     *   pouring the liquid.
<a name="8280"></a>     */
<a name="8281"></a>    fluidName = theName
<a name="8282"></a>    
<a name="8283"></a>    /*  
<a name="8284"></a>     *   The base handling of Pour, PourOnto and PourInto is simply to rule out
<a name="8285"></a>     *   all three actions at the verify stage. Game code that wants to allow
<a name="8286"></a>     *   these actions on specific objects will need to provide further handling
<a name="8287"></a>     *   for them.
<a name="8288"></a>     */
<a name="8289"></a>    dobjFor(Pour)
<a name="8290"></a>    {
<a name="8291"></a>        preCond = [touchObj]
<a name="8292"></a>        verify() 
<a name="8293"></a>        { 
<a name="8294"></a>            if(!isPourable)
<a name="8295"></a>               illogical(cannotPourMsg); 
<a name="8296"></a>        }
<a name="8297"></a>    }
<a name="8298"></a>    
<a name="8299"></a>    dobjFor(PourOnto)
<a name="8300"></a>    {
<a name="8301"></a>        preCond = [touchObj]
<a name="8302"></a>        
<a name="8303"></a>        verify()
<a name="8304"></a>        { 
<a name="8305"></a>            if(!isPourable)
<a name="8306"></a>               illogical(cannotPourMsg); 
<a name="8307"></a>        }
<a name="8308"></a>    }
<a name="8309"></a>    
<a name="8310"></a>    /* 
<a name="8311"></a>     *   Most things can probably have something poured onto them in principle,
<a name="8312"></a>     *   though we might want to prevent it in practice. The canPourOntoMe
<a name="8313"></a>     *   property controls whether it's possible to pour onto this thing.
<a name="8314"></a>     */
<a name="8315"></a>      
<a name="8316"></a>    canPourOntoMe = true
<a name="8317"></a>    
<a name="8318"></a>    /* 
<a name="8319"></a>     *   The allowPourOntoMe property controls whether we want allow anything to
<a name="8320"></a>     *   be poured onto this thing (even if it's possible). By default we don't.
<a name="8321"></a>     */
<a name="8322"></a>    allowPourOntoMe = nil
<a name="8323"></a>    
<a name="8324"></a>    
<a name="8325"></a>    
<a name="8326"></a>    iobjFor(PourOnto)
<a name="8327"></a>    {
<a name="8328"></a>        preCond = [touchObj]
<a name="8329"></a>        
<a name="8330"></a>        remap = (remapOn)
<a name="8331"></a>        
<a name="8332"></a>        verify()
<a name="8333"></a>        {
<a name="8334"></a>            if(gVerifyDobj == self)
<a name="8335"></a>                illogicalSelf(cannotPourOntoSelfMsg);
<a name="8336"></a>            
<a name="8337"></a>            if(!canPourOntoMe)
<a name="8338"></a>                illogical(cannotPourOntoMsg);
<a name="8339"></a>            else if(!allowPourOntoMe)
<a name="8340"></a>                implausible(shouldNotPourOntoMsg);
<a name="8341"></a>           
<a name="8342"></a>        }    
<a name="8343"></a>    }
<a name="8344"></a>    
<a name="8345"></a>    
<a name="8346"></a>    
<a name="8347"></a>    
<a name="8348"></a>    dobjFor(PourInto)
<a name="8349"></a>    {
<a name="8350"></a>        preCond = [touchObj]
<a name="8351"></a>        verify()
<a name="8352"></a>        { 
<a name="8353"></a>            if(!isPourable)
<a name="8354"></a>               illogical(cannotPourMsg); 
<a name="8355"></a>        }
<a name="8356"></a>    }
<a name="8357"></a>    
<a name="8358"></a>    /* 
<a name="8359"></a>     *   Presumably it's possible by default to pour something into me if I'm a
<a name="8360"></a>     *   container; but this could be overridden simply to true for objects like
<a name="8361"></a>     *   the sea or a river.
<a name="8362"></a>     */
<a name="8363"></a>    canPourIntoMe = (contType == In || remapIn != nil)
<a name="8364"></a>    
<a name="8365"></a>    
<a name="8366"></a>    /*   
<a name="8367"></a>     *   While it's possible to pour stuff into any container, we probably don't
<a name="8368"></a>     *   want to allow it on most of them
<a name="8369"></a>     */
<a name="8370"></a>    allowPourIntoMe = nil
<a name="8371"></a>    
<a name="8372"></a>    iobjFor(PourInto)
<a name="8373"></a>    {
<a name="8374"></a>        preCond = [touchObj]
<a name="8375"></a>        
<a name="8376"></a>        remap = (remapIn) 
<a name="8377"></a>        
<a name="8378"></a>        verify()
<a name="8379"></a>        {
<a name="8380"></a>            if(gVerifyDobj == self)
<a name="8381"></a>                illogicalSelf(cannotPourIntoSelfMsg);
<a name="8382"></a>            
<a name="8383"></a>            if(!canPourIntoMe)
<a name="8384"></a>                illogical(cannotPourIntoMsg);
<a name="8385"></a>            else if(!allowPourIntoMe)
<a name="8386"></a>                implausible(shouldNotPourIntoMsg);
<a name="8387"></a>        }
<a name="8388"></a>    }
<a name="8389"></a>    
<a name="8390"></a>    cannotPourMsg = BMsg(cannot pour, '{I} {can\'t} pour {1} anywhere. ',
<a name="8391"></a>                         fluidName)
<a name="8392"></a>    cannotPourOntoSelfMsg = BMsg(cannot pour on self, '{I} {can\'t} pour {the
<a name="8393"></a>        dobj} onto {itself dobj}. ')
<a name="8394"></a>    cannotPourIntoSelfMsg = BMsg(cannot pour in self, '{I} {can\'t} pour {the
<a name="8395"></a>        dobj} into {itself dobj}. ')
<a name="8396"></a>    cannotPourIntoMsg = BMsg(cannot pour into, '{I} {can\'t} pour {1}
<a name="8397"></a>        into {that dobj}. ', gDobj.fluidName)
<a name="8398"></a>    cannotPourOntoMsg = BMsg(cannot pour onto, '{I} {can\'t} pour {1}
<a name="8399"></a>        into {that dobj}. ', gDobj.fluidName)
<a name="8400"></a>    shouldNotPourIntoMsg = BMsg(should not pour into, 'It{dummy}{\'s} better not
<a name="8401"></a>        to pour {1} into {the iobj}. ', gDobj.fluidName)
<a name="8402"></a>    
<a name="8403"></a>    shouldNotPourOntoMsg = BMsg(should not pour onto, 'It{dummy}{\'s} better not
<a name="8404"></a>        to pour {1} onto {the iobj}. ', gDobj.fluidName)  
<a name="8405"></a>    
<a name="8406"></a>    
<a name="8407"></a>    /* Most things can't be screwed */
<a name="8408"></a>    isScrewable = nil
<a name="8409"></a>    
<a name="8410"></a>    /* Most things can't be used to screw other things with. */
<a name="8411"></a>    canScrewWithMe = nil
<a name="8412"></a>    
<a name="8413"></a>    /* 
<a name="8414"></a>     *   In the base handling we simply rule out Screw and Unscrew actions at
<a name="8415"></a>     *   the verify stage. It's up to game code to provide specific handling for
<a name="8416"></a>     *   objects that can be screwed and unscrewed.
<a name="8417"></a>     */
<a name="8418"></a>    dobjFor(Screw)
<a name="8419"></a>    {
<a name="8420"></a>        preCond = [touchObj]
<a name="8421"></a>        verify() 
<a name="8422"></a>        { 
<a name="8423"></a>            if(!isScrewable)
<a name="8424"></a>               illogical(cannotScrewMsg); 
<a name="8425"></a>        }        
<a name="8426"></a>    }
<a name="8427"></a>    
<a name="8428"></a>    dobjFor(ScrewWith)
<a name="8429"></a>    {
<a name="8430"></a>        preCond = [touchObj]
<a name="8431"></a>        verify() 
<a name="8432"></a>        { 
<a name="8433"></a>            if(!isScrewable)
<a name="8434"></a>               illogical(cannotScrewMsg); 
<a name="8435"></a>        }       
<a name="8436"></a>    }
<a name="8437"></a>    
<a name="8438"></a>    iobjFor(ScrewWith)
<a name="8439"></a>    {
<a name="8440"></a>        preCond = [objHeld]
<a name="8441"></a>        verify() 
<a name="8442"></a>        { 
<a name="8443"></a>            if(!canScrewWithMe)
<a name="8444"></a>                illogical(cannotScrewWithMsg); 
<a name="8445"></a>            
<a name="8446"></a>            if(gVerifyDobj == self)
<a name="8447"></a>                illogical(cannotScrewWithSelfMsg);
<a name="8448"></a>        }        
<a name="8449"></a>    }
<a name="8450"></a>    
<a name="8451"></a>    isUnscrewable = (isScrewable)
<a name="8452"></a>    canUnscrewWithMe = (canScrewWithMe)
<a name="8453"></a>    
<a name="8454"></a>    dobjFor(Unscrew)
<a name="8455"></a>    {
<a name="8456"></a>        preCond = [touchObj]
<a name="8457"></a>        verify() 
<a name="8458"></a>        { 
<a name="8459"></a>            if(!isUnscrewable)
<a name="8460"></a>               illogical(cannotUnscrewMsg); 
<a name="8461"></a>        }        
<a name="8462"></a>    }
<a name="8463"></a>    
<a name="8464"></a>    dobjFor(UnscrewWith)
<a name="8465"></a>    {
<a name="8466"></a>        preCond = [touchObj]
<a name="8467"></a>        verify() 
<a name="8468"></a>        { 
<a name="8469"></a>            if(!isUnscrewable)
<a name="8470"></a>               illogical(cannotUnscrewMsg); 
<a name="8471"></a>        }      
<a name="8472"></a>    }
<a name="8473"></a>    
<a name="8474"></a>    iobjFor(UnscrewWith)
<a name="8475"></a>    {
<a name="8476"></a>        preCond = [objHeld]
<a name="8477"></a>        verify() 
<a name="8478"></a>        { 
<a name="8479"></a>            if(!canUnscrewWithMe)
<a name="8480"></a>                illogical(cannotUnscrewWithMsg); 
<a name="8481"></a>            
<a name="8482"></a>            if(gVerifyDobj == self)
<a name="8483"></a>                illogicalSelf(cannotUnscrewWithSelfMsg);
<a name="8484"></a>        }        
<a name="8485"></a>    }
<a name="8486"></a>    
<a name="8487"></a>    cannotScrewMsg = BMsg(cannot screw, '{I} {can\'t} screw {the dobj}. ')
<a name="8488"></a>    cannotScrewWithMsg = BMsg(cannot screw with, '{I} {can\'t} screw anything
<a name="8489"></a>        with {that iobj}. ') 
<a name="8490"></a>    cannotScrewWithSelfMsg = BMsg(cannot screw with self, '{I} {can\'t} screw
<a name="8491"></a>        {the iobj} with {itself iobj}. ')
<a name="8492"></a>    cannotUnscrewMsg = BMsg(cannot unscrew, '{I} {can\'t} unscrew {the dobj}. ')
<a name="8493"></a>    cannotUnscrewWithMsg = BMsg(cannot unscrew with, '{I} {can\'t} unscrew
<a name="8494"></a>        anything with {that iobj}. ')
<a name="8495"></a>    cannotUnscrewWithSelfMsg = BMsg(cannot unscrew with self, '{I} {can\'t}
<a name="8496"></a>        unscrew {the iobj} with {itself iobj}. ')
<a name="8497"></a>    
<a name="8498"></a>    
<a name="8499"></a>    /* 
<a name="8500"></a>     *   Common handler for verifying push travel actions. The via parameter may
<a name="8501"></a>     *   be a preposition object (such as Through) defining what kind of push
<a name="8502"></a>     *   traveling the actor is trying to do (e.g. through a door or up some
<a name="8503"></a>     *   stairs).
<a name="8504"></a>     */
<a name="8505"></a>    verifyPushTravel(via)
<a name="8506"></a>    {
<a name="8507"></a>        viaMode = via;
<a name="8508"></a>        
<a name="8509"></a>        if(!canPushTravel &amp;&amp; !canPullTravel)
<a name="8510"></a>            illogical(cannotPushTravelMsg);
<a name="8511"></a>        
<a name="8512"></a>        if(matchPushOnly &amp;&amp; !canPushTravel)
<a name="8513"></a>            implausible(cannotPushTravelMsg);
<a name="8514"></a>        
<a name="8515"></a>        if(matchPullOnly &amp;&amp; !canPullTravel)
<a name="8516"></a>            implausible(cannotPushTravelMsg);       
<a name="8517"></a>        
<a name="8518"></a>        
<a name="8519"></a>        if(gActor.isIn(self))
<a name="8520"></a>            illogicalNow(cannotPushOwnContainerMsg);
<a name="8521"></a>        
<a name="8522"></a>        if(gVerifyIobj == self)
<a name="8523"></a>            illogicalSelf(cannotPushViaSelfMsg);            
<a name="8524"></a>        
<a name="8525"></a>    }
<a name="8526"></a>    
<a name="8527"></a>    /* 
<a name="8528"></a>     *   Check if the player specifically asked to PUSH this object somewhere.
<a name="8529"></a>     *   In the main library we assume not, but language-specific code will need
<a name="8530"></a>     *   to override to check what that player's command actually said.
<a name="8531"></a>     */
<a name="8532"></a>    matchPushOnly = nil
<a name="8533"></a>    
<a name="8534"></a>    
<a name="8535"></a>    /* 
<a name="8536"></a>     *   Check if the player specifically asked to PULL this object somewhere.
<a name="8537"></a>     *   In the main library we assume not, but language-specific code will need
<a name="8538"></a>     *   to override to check what that player's command actually said.
<a name="8539"></a>     */
<a name="8540"></a>    matchPullOnly = nil
<a name="8541"></a>    
<a name="8542"></a>       
<a name="8543"></a>    viaMode = ''
<a name="8544"></a>    
<a name="8545"></a>    cannotPushOwnContainerMsg = BMsg(cannot push own container, '{I} {can\'t}
<a name="8546"></a>        {1} {the dobj} anywhere while {he actor}{\'s} {2} {him dobj}. ',
<a name="8547"></a>                                     gVerbWord, gDobj.objInPrep)
<a name="8548"></a>    
<a name="8549"></a>    cannotPushViaSelfMsg = BMsg(cannot push via self, '{I} {can\'t} {1} {the
<a name="8550"></a>        dobj} {2} {itself dobj}. ', gVerbWord, viaMode.prep)
<a name="8551"></a>    
<a name="8552"></a>    /* 
<a name="8553"></a>     *   By default we can't push travel most things. Push Travel means pushing
<a name="8554"></a>     *   an object from one place to another and traveling with it.
<a name="8555"></a>     */
<a name="8556"></a>    canPushTravel = nil
<a name="8557"></a>    
<a name="8558"></a>    /*  
<a name="8559"></a>     *   Normally we don't distinguish PushTravel from PullTravel, but if we
<a name="8560"></a>     *   want something to be pushable between rooms but not pullable, or vice
<a name="8561"></a>     *   versa, we can set these to different values.
<a name="8562"></a>     */
<a name="8563"></a>    canPullTravel = canPushTravel
<a name="8564"></a>    
<a name="8565"></a>    /* 
<a name="8566"></a>     *   PushTravelDir handles pushing an object in a particular direction, e.g.
<a name="8567"></a>     *   PUSH BOX NORTH
<a name="8568"></a>     */
<a name="8569"></a>    dobjFor(PushTravelDir)
<a name="8570"></a>    {
<a name="8571"></a>        preCond = [touchObj, travelPermitted]
<a name="8572"></a>        
<a name="8573"></a>        check()
<a name="8574"></a>        {
<a name="8575"></a>            /* set up a local variable to hold the connector we want to travel through. */
<a name="8576"></a>            local conn;
<a name="8577"></a>            
<a name="8578"></a>            /* note which room we're in */
<a name="8579"></a>            local loc = getOutermostRoom;
<a name="8580"></a>            
<a name="8581"></a>            /* Get the direction of travel from the command */
<a name="8582"></a>            local dirn = gCommand.verbProd.dirMatch.dir;
<a name="8583"></a>            
<a name="8584"></a>            if(loc.propType(dirn.dirProp) == TypeObject)
<a name="8585"></a>            {
<a name="8586"></a>                /* Note the connector object in the relevant direction */
<a name="8587"></a>                conn = loc.(dirn.dirProp);
<a name="8588"></a>                
<a name="8589"></a>                /* 
<a name="8590"></a>                 *   If our connector is an UnlistedProxyConnector we need to replace the direction
<a name="8591"></a>                 *   we're heading in with the one the UPC points to and our connector with the one
<a name="8592"></a>                 *   our new direction points to.
<a name="8593"></a>                 */
<a name="8594"></a>                if(conn.ofKind(UnlistedProxyConnector))
<a name="8595"></a>                {
<a name="8596"></a>                    /* get our real direction of travel. */
<a name="8597"></a>                    dirn = conn.direction; 
<a name="8598"></a>                    
<a name="8599"></a>                    /* get the connector in that direction, or nil if it's not an object */
<a name="8600"></a>                    conn = loc.propType(dirn.dirProp) == TypeObject ? loc.(dirn.dirProp) : nil;
<a name="8601"></a>                    
<a name="8602"></a>                }                                 
<a name="8603"></a>                
<a name="8604"></a>                /* If the connector we want to use is an object then check its travel barriers. */
<a name="8605"></a>                if(dataType(conn) == TypeObject)
<a name="8606"></a>                {                    
<a name="8607"></a>                    if(conn.checkTravelBarriers(self))
<a name="8608"></a>                        conn.checkTravelBarriers(gActor);
<a name="8609"></a>                }
<a name="8610"></a>            }
<a name="8611"></a>            
<a name="8612"></a>            
<a name="8613"></a>        }
<a name="8614"></a>    }
<a name="8615"></a>    
<a name="8616"></a>    /* Display a message saying we pushed the direct object in a particular direction. */
<a name="8617"></a>    sayPushTravel(dir)
<a name="8618"></a>    {
<a name="8619"></a>        DMsg(before push travel dir, '{I} &lt;&lt;gDobj.matchPullOnly ? 'pull(s/ed}' : 'push{es/ed}'&gt;&gt;
<a name="8620"></a>              {the dobj} {1}. ',  dir.departureName);   
<a name="8621"></a>        "&lt;.p&gt;";
<a name="8622"></a>    }    
<a name="8623"></a>    
<a name="8624"></a>     
<a name="8625"></a>    pushTravelRevealItems()
<a name="8626"></a>    {
<a name="8627"></a>        /* 
<a name="8628"></a>         *   Check whether moving this object revealed any items hidden behind
<a name="8629"></a>         *   or beneath it (even if we don't succeed in pushing the object to
<a name="8630"></a>         *   another room we can presumably move it far enough across its
<a name="8631"></a>         *   current one to reveal any items it was concealing.
<a name="8632"></a>         */
<a name="8633"></a>        revealOnMove();
<a name="8634"></a>        
<a name="8635"></a>        /* 
<a name="8636"></a>         *   If moving this item did reveal any hidden items, we want to see the
<a name="8637"></a>         *   report of them now, before moving to another location.
<a name="8638"></a>         */        
<a name="8639"></a>        gCommand.afterReport();
<a name="8640"></a>        
<a name="8641"></a>        /* 
<a name="8642"></a>         *   We don't want to see these reports again at the end of the action,
<a name="8643"></a>         *   so clear the list.
<a name="8644"></a>         */
<a name="8645"></a>        gCommand.afterReports = [];   
<a name="8646"></a>    }
<a name="8647"></a>    
<a name="8648"></a>    
<a name="8649"></a>    /* Display a message explaining that push travel is not possible */   
<a name="8650"></a>    cannotPushTravelMsg()
<a name="8651"></a>    {
<a name="8652"></a>        if(isFixed)
<a name="8653"></a>            return cannotTakeMsg;
<a name="8654"></a>        return BMsg(cannot push travel, 'There{dummy}{\'s} no point trying to
<a name="8655"></a>            {1} {that dobj} anywhere. ', gVerbWord);
<a name="8656"></a>    }
<a name="8657"></a>
<a name="8658"></a>    
<a name="8659"></a>    /* Check the travel barriers on the indirect object of the action */
<a name="8660"></a>    checkPushTravel()
<a name="8661"></a>    {
<a name="8662"></a>        /* 
<a name="8663"></a>         *   First check the travel barriers for the actor doing the pushing.
<a name="8664"></a>         *   Only go on to check those for the item being pushed if the actor
<a name="8665"></a>         *   can travel, so we don't see the same messages twice.
<a name="8666"></a>         */
<a name="8667"></a>        if(checkTravelBarriers(gActor))        
<a name="8668"></a>            checkTravelBarriers(gDobj);     
<a name="8669"></a>        
<a name="8670"></a>              
<a name="8671"></a>    }
<a name="8672"></a>    
<a name="8673"></a>    /*  Carry out the push travel on the direct object of the action. */
<a name="8674"></a>    doPushTravel(via)
<a name="8675"></a>    {
<a name="8676"></a>        /* 
<a name="8677"></a>         *   Check whether moving this object revealed any items hidden behind
<a name="8678"></a>         *   or beneath it (even if we don't succeed in pushing the object to
<a name="8679"></a>         *   another room we can presumably move it far enough across its
<a name="8680"></a>         *   current one to reveal any items it was concealing.
<a name="8681"></a>         */
<a name="8682"></a>        pushTravelRevealItems();       
<a name="8683"></a>                 
<a name="8684"></a>        if(!gIobj.isLocked)
<a name="8685"></a>            describePushTravel(via); 
<a name="8686"></a>        
<a name="8687"></a>        /*  
<a name="8688"></a>         *   We temporarily make the push traveler item hidden before moving it
<a name="8689"></a>         *   to the new location so that it doesn't show up listed in its former
<a name="8690"></a>         *   location when actor moves to the new location and there's a sight
<a name="8691"></a>         *   path between the two.
<a name="8692"></a>         */
<a name="8693"></a>        local wasHidden;
<a name="8694"></a>        
<a name="8695"></a>        /*   Note the actor's current location. */
<a name="8696"></a>        local oldLoc = gActor.getOutermostRoom;
<a name="8697"></a>        try
<a name="8698"></a>        {
<a name="8699"></a>            wasHidden = propType(&amp;isHidden) is in (TypeCode, TypeFuncPtr) ?
<a name="8700"></a>                    getMethod(&amp;isHidden) : isHidden;
<a name="8701"></a>            
<a name="8702"></a>            isHidden = true;
<a name="8703"></a>            
<a name="8704"></a>            gIobj.travelVia(gActor);
<a name="8705"></a>        }
<a name="8706"></a>        finally
<a name="8707"></a>        {
<a name="8708"></a>            if(dataTypeXlat(wasHidden) is in (TypeCode, TypeFuncPtr))
<a name="8709"></a>                setMethod(&amp;isHidden, wasHidden);
<a name="8710"></a>            else
<a name="8711"></a>                isHidden = wasHidden;
<a name="8712"></a>        }
<a name="8713"></a>              
<a name="8714"></a>        
<a name="8715"></a>        /*   
<a name="8716"></a>         *   Use the travelVia() method of the iobj to move the dobj to its new
<a name="8717"></a>         *   location.
<a name="8718"></a>         */        
<a name="8719"></a>        
<a name="8720"></a>        if(gActor.isIn(gIobj.getDestination(oldLoc)))
<a name="8721"></a>        {
<a name="8722"></a>            gIobj.travelVia(gDobj);
<a name="8723"></a>            gDobj.describeMovePushable(self, gActor.location);
<a name="8724"></a>        }
<a name="8725"></a>    }
<a name="8726"></a>    
<a name="8727"></a>    
<a name="8728"></a>    beforeMovePushable(connector, dir)
<a name="8729"></a>    {
<a name="8730"></a>        /* make a note of our connector */
<a name="8731"></a>        local conn = connector;
<a name="8732"></a>         
<a name="8733"></a>        /* 
<a name="8734"></a>         *   If our connector is an UnlistedProxyConnector we need some special handling to identify
<a name="8735"></a>         *   the real connector we're going to use.
<a name="8736"></a>         */
<a name="8737"></a>        if(connector.ofKind(UnlistedProxyConnector))
<a name="8738"></a>        {
<a name="8739"></a>            /* Note the room we're in. */
<a name="8740"></a>            local loc = getOutermostRoom;
<a name="8741"></a>            
<a name="8742"></a>                    
<a name="8743"></a>            /* Get the direction prop our UnlistedProxyConnector is a proxy for. */
<a name="8744"></a>            local prop = connector.direction.dirProp;
<a name="8745"></a>            
<a name="8746"></a>            if(loc.propType(prop) == TypeObject)  
<a name="8747"></a>            {
<a name="8748"></a>                
<a name="8749"></a>                /* Get the connector that direction property points to. */
<a name="8750"></a>                conn = loc.(prop);                
<a name="8751"></a>                
<a name="8752"></a>                /* Make that connector the iobj of this action. */
<a name="8753"></a>                gIobj = conn; 
<a name="8754"></a>            }
<a name="8755"></a>            else
<a name="8756"></a>            {
<a name="8757"></a>                /*  Otherwise note the direction we're actually going to try to go in. */
<a name="8758"></a>                dir = connector.direction;
<a name="8759"></a>                
<a name="8760"></a>                /* If the connector isn't an object, we don't want to deal with it here. */
<a name="8761"></a>                conn = nil;
<a name="8762"></a>            }
<a name="8763"></a>        }
<a name="8764"></a>            
<a name="8765"></a>        /* 
<a name="8766"></a>         *   Next check that there's nothing that wants to disallow this travel.. If the
<a name="8767"></a>         *   travelPermitted preCond is present for this action on this object this should already
<a name="8768"></a>         *   have been done, but if game code has overridden that we need to carry out the
<a name="8769"></a>         *   beforeTravelNotifications now.
<a name="8770"></a>         */         
<a name="8771"></a>        if(conn &amp;&amp; dataType(conn == TypeObject))
<a name="8772"></a>            conn.beforeTravelNotifications(self);        
<a name="8773"></a>        
<a name="8774"></a>       /*  If we have an indirect object, describe our PushTravel via it */
<a name="8775"></a>        if(gIobj)
<a name="8776"></a>            describePushTravel(gAction.viaMode);    
<a name="8777"></a>        
<a name="8778"></a>        /*  
<a name="8779"></a>         *   Otherwise we have a travel connector to travel through, report which direction we're
<a name="8780"></a>         *   pushing to.
<a name="8781"></a>         */
<a name="8782"></a>        else if(objOfKind(conn, TravelConnector))
<a name="8783"></a>            sayPushTravel(dir);
<a name="8784"></a>        
<a name="8785"></a>        /*  
<a name="8786"></a>         *   Otherwise do nothing, because our 'connector' must be a string or method that explains
<a name="8787"></a>         *   why travel that way isn't possible.
<a name="8788"></a>         */
<a name="8789"></a>    }
<a name="8790"></a>    
<a name="8791"></a>    describeMovePushable (connector, dest)
<a name="8792"></a>    {
<a name="8793"></a>        local obj = self;
<a name="8794"></a>        gMessageParams(obj, dest);
<a name="8795"></a>        DMsg(describe move pushable, '{The subj obj} {comes} to a halt. ' );
<a name="8796"></a>        
<a name="8797"></a>    }
<a name="8798"></a>    
<a name="8799"></a>    /* 
<a name="8800"></a>     *   This message, called on the direct object of a PushTravel command (i.e.
<a name="8801"></a>     *   the object being pushed) is displayed just before travel takes place.
<a name="8802"></a>     *   It is used when the PushTravel command also involves an indirect
<a name="8803"></a>     *   object, e.g. a Passage, Door or Stairway the direct object is being
<a name="8804"></a>     *   pushed through, up or down. The via parameter is the preposition
<a name="8805"></a>     *   relevant to the kind of pushing, e.g. Into, Through or Up.
<a name="8806"></a>     */
<a name="8807"></a>    describePushTravel(via)
<a name="8808"></a>    {
<a name="8809"></a>        /* If I have a traversalMsg, use it */
<a name="8810"></a>        if(gIobj &amp;&amp; gIobj.propType(&amp;traversalMsg) != TypeNil)
<a name="8811"></a>            DMsg(push travel traversal, '{I} &lt;&lt;if matchPullOnly&gt;&gt; pull{s/ed}
<a name="8812"></a>                &lt;&lt;else&gt;&gt; push{es/ed}&lt;&lt;end&gt;&gt; {the dobj} {1}. &lt;.p&gt;',
<a name="8813"></a>                 gIobj.traversalMsg);
<a name="8814"></a>        else
<a name="8815"></a>            DMsg(push travel somewhere, '{I} &lt;&lt;if matchPullOnly&gt;&gt; pull{s/ed}
<a name="8816"></a>                &lt;&lt;else&gt;&gt; push{es/ed}&lt;&lt;end&gt;&gt; {the dobj} {1} {the iobj}. &lt;.p&gt;', 
<a name="8817"></a>                 via.prep); 
<a name="8818"></a>        
<a name="8819"></a>        "&lt;.p&gt;";
<a name="8820"></a>    }
<a name="8821"></a>    
<a name="8822"></a>   
<a name="8823"></a>    
<a name="8824"></a>    /* 
<a name="8825"></a>     *   PushTravelThrough handles pushing something through something, such as a door or archway.
<a name="8826"></a>     *   Most of the actual handling is dealt with by the common routines defined above.
<a name="8827"></a>     */
<a name="8828"></a>    dobjFor(PushTravelThrough)    
<a name="8829"></a>    {
<a name="8830"></a>        preCond = [touchObj]
<a name="8831"></a>        verify()   {   verifyPushTravel(Through);   }
<a name="8832"></a>        
<a name="8833"></a>        action() { doPushTravel(Through); }
<a name="8834"></a>    }
<a name="8835"></a>    
<a name="8836"></a>    iobjFor(PushTravelThrough)
<a name="8837"></a>    {
<a name="8838"></a>        preCond = [travelPermitted, touchObj]
<a name="8839"></a>        verify() 
<a name="8840"></a>        {  
<a name="8841"></a>            if(!canGoThroughMe || getDestination(gActor.getOutermostRoom) == nil)
<a name="8842"></a>                illogical(cannotPushThroughMsg);
<a name="8843"></a>        }
<a name="8844"></a>        
<a name="8845"></a>        check() { checkPushTravel(); }       
<a name="8846"></a>    }
<a name="8847"></a>    
<a name="8848"></a>    cannotPushThroughMsg = BMsg(cannot push through, '{I} {can\'t} {1}
<a name="8849"></a>        anything through {the iobj}. ', gVerbWord)
<a name="8850"></a>    
<a name="8851"></a>    
<a name="8852"></a>    /* 
<a name="8853"></a>     *   PushTravelEnter handles commands like PUSH BOX INTO COFFIN, where the
<a name="8854"></a>     *   indirect object is a Booth-like object. The syntactically identical
<a name="8855"></a>     *   command for pushing things into an Enterable (e.g. PUSH BOX INTO HOUSE
<a name="8856"></a>     *   where HOUSE represents the outside of a separate location) is handled
<a name="8857"></a>     *   on the Enterable class.
<a name="8858"></a>     */         
<a name="8859"></a>    dobjFor(PushTravelEnter)
<a name="8860"></a>    {
<a name="8861"></a>        preCond = [touchObj]
<a name="8862"></a>        verify()  {  verifyPushTravel(Into);  }        
<a name="8863"></a>        
<a name="8864"></a>    }
<a name="8865"></a>    
<a name="8866"></a>    okayPushIntoMsg = BMsg(okay push into, '{I} &lt;&lt;if matchPullOnly&gt;&gt; pull{s/ed}
<a name="8867"></a>                &lt;&lt;else&gt;&gt; push{es/ed}&lt;&lt;end&gt;&gt;} {the dobj} into {the iobj}. ')
<a name="8868"></a>    
<a name="8869"></a>    iobjFor(PushTravelEnter)
<a name="8870"></a>    {
<a name="8871"></a>        preCond = [containerOpen]
<a name="8872"></a>        verify() 
<a name="8873"></a>        {  
<a name="8874"></a>            if(!isEnterable)
<a name="8875"></a>                illogical(cannotPushIntoMsg);
<a name="8876"></a>        }
<a name="8877"></a>        
<a name="8878"></a>        check() 
<a name="8879"></a>        {             
<a name="8880"></a>            checkInsert(gActor);            
<a name="8881"></a>            checkInsert(gDobj);
<a name="8882"></a>        }    
<a name="8883"></a>        
<a name="8884"></a>        action() 
<a name="8885"></a>        {
<a name="8886"></a>            gDobj.actionMoveInto(self);
<a name="8887"></a>            gActor.actionMoveInto(self);
<a name="8888"></a>            
<a name="8889"></a>            if(gDobj.isIn(self))
<a name="8890"></a>                say(okayPushIntoMsg);
<a name="8891"></a>        }
<a name="8892"></a>    }
<a name="8893"></a>    
<a name="8894"></a>    cannotPushIntoMsg = BMsg(cannot push into, '{I} {can\'t} {1}
<a name="8895"></a>        anything into {the iobj}. ', gVerbWord)
<a name="8896"></a>    
<a name="8897"></a>    dobjFor(PushTravelGetOutOf)
<a name="8898"></a>    {
<a name="8899"></a>        preCond = [touchObj]
<a name="8900"></a>        verify()
<a name="8901"></a>        {
<a name="8902"></a>            verifyPushTravel(OutOf);
<a name="8903"></a>            if(!self.isIn(gIobj))
<a name="8904"></a>                illogicalNow(notInMsg);
<a name="8905"></a>        }
<a name="8906"></a>        
<a name="8907"></a>        
<a name="8908"></a>        
<a name="8909"></a>    }
<a name="8910"></a>    
<a name="8911"></a>    iobjFor(PushTravelGetOutOf)
<a name="8912"></a>    {
<a name="8913"></a>        preCond = [touchObj]
<a name="8914"></a>        
<a name="8915"></a>        verify() 
<a name="8916"></a>        {  
<a name="8917"></a>            if(!gActor.isIn(self))
<a name="8918"></a>                illogicalNow(actorNotInMsg);   
<a name="8919"></a>            
<a name="8920"></a>        }
<a name="8921"></a>        
<a name="8922"></a>        action()
<a name="8923"></a>        {
<a name="8924"></a>            gDobj.actionMoveInto(location);
<a name="8925"></a>            if(gDobj.location ==  location)
<a name="8926"></a>            {
<a name="8927"></a>                say(okayPushOutOfMsg);
<a name="8928"></a>                gActor.actionMoveInto(location);
<a name="8929"></a>            }
<a name="8930"></a>        }
<a name="8931"></a>       
<a name="8932"></a>    }
<a name="8933"></a>    
<a name="8934"></a>    okayPushOutOfMsg = BMsg(okay push out of, '{I} &lt;&lt;if matchPullOnly&gt;&gt; pull{s/ed}
<a name="8935"></a>                &lt;&lt;else&gt;&gt; push{es/ed}&lt;&lt;end&gt;&gt; {the dobj} {outof iobj}. ')
<a name="8936"></a>    
<a name="8937"></a>    dobjFor(PushTravelClimbUp)
<a name="8938"></a>    {
<a name="8939"></a>        preCond = [touchObj]
<a name="8940"></a>        verify()  {  verifyPushTravel(Up);  }
<a name="8941"></a>        
<a name="8942"></a>        action() { doPushTravel(Up); }
<a name="8943"></a>    }
<a name="8944"></a>    
<a name="8945"></a>    iobjFor(PushTravelClimbUp)
<a name="8946"></a>    {
<a name="8947"></a>        preCond = [travelPermitted, touchObj]
<a name="8948"></a>        
<a name="8949"></a>        verify() 
<a name="8950"></a>        {  
<a name="8951"></a>            if(!isClimbable || getDestination(gActor.getOutermostRoom) == nil)
<a name="8952"></a>                illogical(cannotPushUpMsg);
<a name="8953"></a>        }
<a name="8954"></a>        
<a name="8955"></a>        check() { checkPushTravel(); }
<a name="8956"></a>    }
<a name="8957"></a>    
<a name="8958"></a>    cannotPushUpMsg = BMsg(cannot push up, '{I} {can\'t} {1}
<a name="8959"></a>        anything up {the iobj}. ', gVerbWord)
<a name="8960"></a>    
<a name="8961"></a>    dobjFor(PushTravelClimbDown)
<a name="8962"></a>    {
<a name="8963"></a>        preCond = [touchObj]
<a name="8964"></a>        verify()  { verifyPushTravel(Down);  }
<a name="8965"></a>        
<a name="8966"></a>        action() { doPushTravel(Down); }
<a name="8967"></a>    }
<a name="8968"></a>    
<a name="8969"></a>    iobjFor(PushTravelClimbDown)
<a name="8970"></a>    {
<a name="8971"></a>        preCond = [travelPermitted, touchObj]
<a name="8972"></a>        
<a name="8973"></a>        verify() 
<a name="8974"></a>        {  
<a name="8975"></a>            if(!canClimbDownMe || getDestination(gActor.getOutermostRoom) == nil)
<a name="8976"></a>                illogical(cannotPushDownMsg);
<a name="8977"></a>        }
<a name="8978"></a>        
<a name="8979"></a>        check() { checkPushTravel(); }
<a name="8980"></a>    }
<a name="8981"></a>    
<a name="8982"></a>    cannotPushDownMsg = BMsg(cannot push down, '{I} {can\'t} {1}
<a name="8983"></a>        anything down {the iobj}. ', gVerbWord)
<a name="8984"></a>    
<a name="8985"></a>    /* 
<a name="8986"></a>     *   We don't bother to define isAskable etc. properties since we assume
<a name="8987"></a>     *   that no inanimate object can be conversed with, and that game code will
<a name="8988"></a>     *   use the Actor class to allow conversation. In any case since there's
<a name="8989"></a>     *   never any difficult in talking about oneself, the various illogicalSelf
<a name="8990"></a>     *   checks aren't needed.
<a name="8991"></a>     *
<a name="8992"></a>     *   Indeed, the handling of conversational commands on Thing is minimal;
<a name="8993"></a>     *   they are simply ruled out at the verify stage, since most Things can't
<a name="8994"></a>     *   converse. The implementation of these actions that allows conversation
<a name="8995"></a>     *   to take place is on the Actor class. We do however define a canTalkToMe
<a name="8996"></a>     *   property so that Actor can use the verify handling defined on Thing by
<a name="8997"></a>     *   just overriding it.
<a name="8998"></a>     *
<a name="8999"></a>     *   Things can't be talked to, so game code shouldn't normally override
<a name="9000"></a>     *   this property; it's there to be overridden on the Actor class.
<a name="9001"></a>     */
<a name="9002"></a>    canTalkToMe = nil
<a name="9003"></a>    
<a name="9004"></a>    
<a name="9005"></a>    dobjFor(AskAbout)
<a name="9006"></a>    {
<a name="9007"></a>        preCond = [objAudible]
<a name="9008"></a>        verify() 
<a name="9009"></a>        { 
<a name="9010"></a>            if(gActor == self)
<a name="9011"></a>                illogicalSelf(cannotTalkToSelfMsg);
<a name="9012"></a>            
<a name="9013"></a>            else if(!canTalkToMe)
<a name="9014"></a>              illogical(cannotTalkToMsg); 
<a name="9015"></a>        }
<a name="9016"></a>    }
<a name="9017"></a>    
<a name="9018"></a>    dobjFor(AskFor)
<a name="9019"></a>    {
<a name="9020"></a>        preCond = [objAudible]
<a name="9021"></a>        verify() 
<a name="9022"></a>        { 
<a name="9023"></a>            if(gActor == self)
<a name="9024"></a>                illogicalSelf(cannotTalkToSelfMsg);
<a name="9025"></a>            
<a name="9026"></a>            else if(!canTalkToMe)
<a name="9027"></a>              illogical(cannotTalkToMsg); 
<a name="9028"></a>        }
<a name="9029"></a>    }
<a name="9030"></a>    
<a name="9031"></a>    
<a name="9032"></a>    dobjFor(TellAbout)
<a name="9033"></a>    {
<a name="9034"></a>        preCond = [objAudible]
<a name="9035"></a>        verify() 
<a name="9036"></a>        { 
<a name="9037"></a>            if(gActor == self)
<a name="9038"></a>                illogicalSelf(cannotTalkToSelfMsg);
<a name="9039"></a>            
<a name="9040"></a>            else if(!canTalkToMe)
<a name="9041"></a>              illogical(cannotTalkToMsg); 
<a name="9042"></a>        }
<a name="9043"></a>    }
<a name="9044"></a>    
<a name="9045"></a>        
<a name="9046"></a>    dobjFor(SayTo)
<a name="9047"></a>    {
<a name="9048"></a>        preCond = [objAudible]
<a name="9049"></a>        verify() 
<a name="9050"></a>        { 
<a name="9051"></a>            if(gActor == self)
<a name="9052"></a>                illogicalSelf(cannotTalkToSelfMsg);
<a name="9053"></a>            
<a name="9054"></a>            else if(!canTalkToMe)
<a name="9055"></a>              illogical(cannotTalkToMsg); 
<a name="9056"></a>        }
<a name="9057"></a>    }
<a name="9058"></a>    
<a name="9059"></a>    /* 
<a name="9060"></a>     *   Do we allow an implicit say command to be directed to this object? Normally we don't. Thuis
<a name="9061"></a>     *   property is only really meaningful on the Actor class but we define it here because it's
<a name="9062"></a>     *   needed by parser.t.
<a name="9063"></a>     */
<a name="9064"></a>    allowImplicitSay = nil
<a name="9065"></a>    
<a name="9066"></a>    dobjFor(QueryAbout)
<a name="9067"></a>    {
<a name="9068"></a>        preCond = [objAudible]
<a name="9069"></a>        verify() 
<a name="9070"></a>        { 
<a name="9071"></a>            if(gActor == self)
<a name="9072"></a>                illogicalSelf(cannotTalkToSelfMsg);
<a name="9073"></a>            
<a name="9074"></a>            else if(!canTalkToMe)
<a name="9075"></a>              illogical(cannotTalkToMsg); 
<a name="9076"></a>        }
<a name="9077"></a>    }
<a name="9078"></a>    
<a name="9079"></a>    dobjFor(TalkAbout)
<a name="9080"></a>    {
<a name="9081"></a>        preCond = [objAudible]
<a name="9082"></a>        verify() 
<a name="9083"></a>        { 
<a name="9084"></a>            if(gActor == self)
<a name="9085"></a>                illogicalSelf(cannotTalkToSelfMsg);
<a name="9086"></a>            
<a name="9087"></a>            else if(!canTalkToMe)
<a name="9088"></a>              illogical(cannotTalkToMsg); 
<a name="9089"></a>        }
<a name="9090"></a>    }
<a name="9091"></a>    
<a name="9092"></a>    dobjFor(TalkTo)
<a name="9093"></a>    {
<a name="9094"></a>        preCond = [objAudible]
<a name="9095"></a>        verify() 
<a name="9096"></a>        { 
<a name="9097"></a>            if(gActor == self)
<a name="9098"></a>                illogicalSelf(cannotTalkToSelfMsg);
<a name="9099"></a>            
<a name="9100"></a>            else if(!canTalkToMe)
<a name="9101"></a>              illogical(cannotTalkToMsg); 
<a name="9102"></a>        }
<a name="9103"></a>    }
<a name="9104"></a>    
<a name="9105"></a>    cannotTalkToMsg = BMsg(cannot talk, 'There{dummy}{\'s} no point trying to
<a name="9106"></a>        talk to {the cobj}. ')
<a name="9107"></a>    
<a name="9108"></a>    cannotTalkToSelfMsg = BMsg(cannot talk to self, 'Talking to oneself {dummy}
<a name="9109"></a>        {is} generally pointless. ')
<a name="9110"></a>        
<a name="9111"></a>    
<a name="9112"></a>    dobjFor(GiveTo)
<a name="9113"></a>    {
<a name="9114"></a>        preCond = [objHeld, objNotWorn]
<a name="9115"></a>        verify()
<a name="9116"></a>        {
<a name="9117"></a>            if(isIn(gIobj))
<a name="9118"></a>                illogical(alreadyHasMsg);
<a name="9119"></a>        }
<a name="9120"></a>    
<a name="9121"></a>        report()
<a name="9122"></a>        {
<a name="9123"></a>            if(gAction.summaryReport != nil)
<a name="9124"></a>                dmsg(gAction.summaryReport, gActionListStr);
<a name="9125"></a>            
<a name="9126"></a>            if(gAction.summaryProp != nil)
<a name="9127"></a>                gIobj.(gAction.summaryProp);
<a name="9128"></a>        }
<a name="9129"></a>    }
<a name="9130"></a>    
<a name="9131"></a>    alreadyHasMsg = BMsg(already has, '{The subj iobj} already {has}
<a name="9132"></a>        {the dobj}.')
<a name="9133"></a>    
<a name="9134"></a>    iobjFor(GiveTo)
<a name="9135"></a>    {
<a name="9136"></a>        preCond = [touchObj]
<a name="9137"></a>        verify() 
<a name="9138"></a>        { 
<a name="9139"></a>            if(!canTalkToMe)
<a name="9140"></a>                illogical(cannotGiveToMsg); 
<a name="9141"></a>            if(gActor == self)
<a name="9142"></a>                illogicalSelf(cannotGiveToSelfMsg);
<a name="9143"></a>        }
<a name="9144"></a>        
<a name="9145"></a>    }
<a name="9146"></a>    
<a name="9147"></a>    cannotGiveToMsg = BMsg(cannot give to, '{I} {can\'t} give anything to {that
<a name="9148"></a>        iobj}. ')
<a name="9149"></a>    
<a name="9150"></a>    cannotGiveToSelfMsg = BMsg(cannot give to self, '{I} {can\'t} give anything
<a name="9151"></a>        to {himself actor}. ')
<a name="9152"></a>    
<a name="9153"></a>    dobjFor(ShowTo)
<a name="9154"></a>    {
<a name="9155"></a>        preCond = isFixed ? [objVisible] : [objHeld]  
<a name="9156"></a>        report()
<a name="9157"></a>        {
<a name="9158"></a>            if(gAction.summaryReport != nil)
<a name="9159"></a>                dmsg(gAction.summaryReport, gActionListStr);
<a name="9160"></a>            
<a name="9161"></a>            if(gAction.summaryProp != nil)
<a name="9162"></a>                gIobj.(gAction.summaryProp);
<a name="9163"></a>        }
<a name="9164"></a>    }
<a name="9165"></a>    
<a name="9166"></a>    iobjFor(ShowTo)
<a name="9167"></a>    {
<a name="9168"></a>        preCond = [touchObj]
<a name="9169"></a>        verify() 
<a name="9170"></a>        {
<a name="9171"></a>            if(gActor == self)
<a name="9172"></a>                illogicalSelf(cannotShowToSelfMsg);
<a name="9173"></a>            else if(!canTalkToMe)
<a name="9174"></a>                illogical(cannotShowToMsg);
<a name="9175"></a>        }
<a name="9176"></a>    }
<a name="9177"></a>    
<a name="9178"></a>    cannotShowToMsg = BMsg(cannot show to, '{I} {can\'t} show anything to {that
<a name="9179"></a>        iobj}. ')
<a name="9180"></a>    
<a name="9181"></a>    cannotShowToSelfMsg = BMsg(cannot show to self, '{I} {can\'t} show anything
<a name="9182"></a>        to {himself actor}. ')
<a name="9183"></a>    
<a name="9184"></a>    
<a name="9185"></a>    dobjFor(ShowToImplicit)
<a name="9186"></a>    {
<a name="9187"></a>        preCond = isFixed ? [objVisible] : [objHeld]
<a name="9188"></a>        
<a name="9189"></a>        verify() 
<a name="9190"></a>        {
<a name="9191"></a>            if(gActor.currentInterlocutor == nil)
<a name="9192"></a>                illogical(notTalkingToAnyoneMsg);
<a name="9193"></a>            else if(!Q.canTalkTo(gActor, gActor.currentInterlocutor))
<a name="9194"></a>                illogicalNow(noLongerTalkingToAnyoneMsg);            
<a name="9195"></a>            
<a name="9196"></a>        }
<a name="9197"></a>        
<a name="9198"></a>        action()
<a name="9199"></a>        {
<a name="9200"></a>            gActor.currentInterlocutor.handleTopic(&amp;showTopics, [self]);
<a name="9201"></a>        }
<a name="9202"></a>        
<a name="9203"></a>        report()
<a name="9204"></a>        {
<a name="9205"></a>            if(gAction.summaryReport != nil)
<a name="9206"></a>                dmsg(gAction.summaryReport, gActionListStr);
<a name="9207"></a>            
<a name="9208"></a>            if(gAction.summaryProp != nil)
<a name="9209"></a>                gActor.currentInterlocutor.(gAction.summaryProp);
<a name="9210"></a>        }
<a name="9211"></a>    }
<a name="9212"></a>    
<a name="9213"></a>    dobjFor(GiveToImplicit)
<a name="9214"></a>    {
<a name="9215"></a>        preCond = [objHeld]
<a name="9216"></a>        
<a name="9217"></a>        verify() 
<a name="9218"></a>        {
<a name="9219"></a>            if(gActor.currentInterlocutor == nil)
<a name="9220"></a>                illogical(notTalkingToAnyoneMsg);
<a name="9221"></a>            else if(!Q.canTalkTo(gActor, gActor.currentInterlocutor))
<a name="9222"></a>                illogicalNow(noLongerTalkingToAnyoneMsg);            
<a name="9223"></a>            
<a name="9224"></a>        }
<a name="9225"></a>        
<a name="9226"></a>        action()
<a name="9227"></a>        {
<a name="9228"></a>             gActor.currentInterlocutor.handleTopic(&amp;giveTopics, [self]);
<a name="9229"></a>        }
<a name="9230"></a>        
<a name="9231"></a>        report()
<a name="9232"></a>        {
<a name="9233"></a>            if(gAction.summaryReport != nil)
<a name="9234"></a>                dmsg(gAction.summaryReport, gActionListStr);
<a name="9235"></a>            
<a name="9236"></a>            if(gAction.summaryProp != nil)
<a name="9237"></a>                gActor.currentInterlocutor.(gAction.summaryProp);
<a name="9238"></a>        }
<a name="9239"></a>    }
<a name="9240"></a>    
<a name="9241"></a>    notTalkingToAnyoneMsg = BMsg(not talking to anyone, '{I}{\'m} not talking to
<a name="9242"></a>        anyone. ')
<a name="9243"></a>    
<a name="9244"></a>    noLongerTalkingToAnyoneMsg = BMsg(no longer talking to anyone, '{I}{\'m} no
<a name="9245"></a>        longer talking to anyone. ')
<a name="9246"></a>    
<a name="9247"></a> #ifdef __DEBUG
<a name="9248"></a>    /* Handling of Debugging actions. */
<a name="9249"></a>    
<a name="9250"></a>    
<a name="9251"></a>    /* 
<a name="9252"></a>     *   PURLOIN allows the player to move any portable object in the game
<a name="9253"></a>     *   directly into his/her inventory, wherever it is currently. We don't
<a name="9254"></a>     *   allow absolutely anything to be purloined, as this could cause chaos.
<a name="9255"></a>     */
<a name="9256"></a>    dobjFor(Purloin)
<a name="9257"></a>    {
<a name="9258"></a>        verify()
<a name="9259"></a>        {
<a name="9260"></a>            if(isDirectlyIn(gActor))
<a name="9261"></a>                illogicalNow(alreadyHeldMsg);
<a name="9262"></a>
<a name="9263"></a>            if(self == gActor)
<a name="9264"></a>                illogicalSelf(cannotPurloinSelfMsg);
<a name="9265"></a>                        
<a name="9266"></a>            if(isFixed)
<a name="9267"></a>                illogical(cannotTakeMsg);
<a name="9268"></a>            
<a name="9269"></a>            if(ofKind(Room))
<a name="9270"></a>                illogical(cannotPurloinRoomMsg);
<a name="9271"></a>            
<a name="9272"></a>            if(gActor.isIn(self))
<a name="9273"></a>                illogicalNow(cannotPurloinContainerMsg);
<a name="9274"></a>            
<a name="9275"></a>            logical;
<a name="9276"></a>        }
<a name="9277"></a>        
<a name="9278"></a>        check() {}
<a name="9279"></a>        
<a name="9280"></a>        action()
<a name="9281"></a>        {
<a name="9282"></a>            /* 
<a name="9283"></a>             *   We use moveInto() rather than actionMoveInto() to move the item
<a name="9284"></a>             *   into the player's inventory since this isn't a regular take and
<a name="9285"></a>             *   we don't want the side-effects of movement notifications,
<a name="9286"></a>             *   neither to we want a notifyRemove() routine to veto a Purloin.
<a name="9287"></a>             */
<a name="9288"></a>            moveInto(gActor);
<a name="9289"></a>            
<a name="9290"></a>            /*   
<a name="9291"></a>             *   Make this item unhidden even if it was hidden before, otherwise
<a name="9292"></a>             *   it won't show up in inventory and we can't interact with it.
<a name="9293"></a>             */
<a name="9294"></a>            isHidden = nil;
<a name="9295"></a>            
<a name="9296"></a>            /*  
<a name="9297"></a>             *   Note that the player char has seen the purloined item. Not
<a name="9298"></a>             *   doing this can make it appear that the player character doesn't
<a name="9299"></a>             *   know about an object that's in his/her inventory.
<a name="9300"></a>             */
<a name="9301"></a>            if(gPlayerChar.canSee(self))
<a name="9302"></a>                gSetSeen(self);
<a name="9303"></a>        }
<a name="9304"></a>        
<a name="9305"></a>        report()
<a name="9306"></a>        {
<a name="9307"></a>            DMsg(purloin, '{I} suddenly {find} {myself} holding {1}. ',                 
<a name="9308"></a>                gActionListStr );
<a name="9309"></a>        }
<a name="9310"></a>    }
<a name="9311"></a>        
<a name="9312"></a>    cannotPurloinSelfMsg = BMsg(cannot purloin self, '{I} {can\'t} purloin
<a name="9313"></a>        {myself}. ')
<a name="9314"></a>    cannotPurloinRoomMsg = BMsg(cannot purloin room, '{I} {can\'t} purloin a
<a name="9315"></a>        room. ')
<a name="9316"></a>    cannotPurloinContainerMsg = BMsg(cannot purloin container, '{I} {can\'t}
<a name="9317"></a>        purloin something {i}{\'m} contained within. ')
<a name="9318"></a>    
<a name="9319"></a>    
<a name="9320"></a>    /* 
<a name="9321"></a>     *   The GoNear action allows the player character to teleport around the
<a name="9322"></a>     *   map.
<a name="9323"></a>     */
<a name="9324"></a>    dobjFor(GoNear)
<a name="9325"></a>    {       
<a name="9326"></a>        verify()
<a name="9327"></a>        {
<a name="9328"></a>            if(getOutermostRoom == nil)
<a name="9329"></a>                illogicalNow(cannotGoNearThereMsg);
<a name="9330"></a>            
<a name="9331"></a>            if(ofKind(Room))
<a name="9332"></a>                logicalRank(120);
<a name="9333"></a>        }
<a name="9334"></a>        
<a name="9335"></a>        action()
<a name="9336"></a>        {
<a name="9337"></a>            DMsg(gonear, '{I} {am} translated in the twinkling of an
<a name="9338"></a>                eye...&lt;.p&gt;');
<a name="9339"></a>            getOutermostRoom.travelVia(gActor);
<a name="9340"></a>        }
<a name="9341"></a>    }
<a name="9342"></a>    
<a name="9343"></a>     
<a name="9344"></a>    
<a name="9345"></a>    cannotGoNearThereMsg = BMsg(cannot go there, '{I} {can\'t} go there right
<a name="9346"></a>        {now}. ')
<a name="9347"></a>    
<a name="9348"></a> #endif
<a name="9349"></a>;
<a name="9350"></a>
<a name="9351"></a>thingPreinit: PreinitObject
<a name="9352"></a>    execute()
<a name="9353"></a>    {
<a name="9354"></a>        forEachInstance(Thing, {obj: obj.preinitThing }); 
<a name="9355"></a>        
<a name="9356"></a>        /* 
<a name="9357"></a>         *   The player character presumably knows about the objects s/he's
<a name="9358"></a>         *   immediately holding even without explicitly examining them or
<a name="9359"></a>         *   taking inventory
<a name="9360"></a>         */
<a name="9361"></a>        foreach(local cur in getPlayerChar().contents)
<a name="9362"></a>            gSetKnown(cur);
<a name="9363"></a>    }
<a name="9364"></a>    
<a name="9365"></a>    execBeforeMe = [pronounPreinit]
<a name="9366"></a>;
<a name="9367"></a>
<a name="9368"></a>/* 
<a name="9369"></a> *   The Player class can be used to define the player character object. If
<a name="9370"></a> *   there is only one player character in the game (the PC never changes) and
<a name="9371"></a> *   the game is in the second person this can be done very conveniently, and
<a name="9372"></a> *   the Player object will register itself with gameMain and libGlobal.
<a name="9373"></a> */
<a name="9374"></a>class Player: Actor
<a name="9375"></a>    
<a name="9376"></a>    /* The player character can't be picked up */
<a name="9377"></a>    isFixed = true       
<a name="9378"></a>    
<a name="9379"></a>    /* 
<a name="9380"></a>     *   The player character is most normally referred to in the first person,
<a name="9381"></a>     *   although this can be overridden to 1 or 3 for first- or third-person
<a name="9382"></a>     *   games.
<a name="9383"></a>     */
<a name="9384"></a>    person = 2  
<a name="9385"></a>    
<a name="9386"></a>     
<a name="9387"></a>    /*   The Player object is the initial player character. */
<a name="9388"></a>    isInitialPlayerChar = true
<a name="9389"></a>;
<a name="9390"></a>
<a name="9391"></a>/*  
<a name="9392"></a> *   A Key is any object that can be used to lock or lock selected items whose
<a name="9393"></a> *   lockabilty is lockableWithKey. We define all the special handling on the
<a name="9394"></a> *   Key class rather than on the items to be locked and/or unlocked.
<a name="9395"></a> */
<a name="9396"></a>class Key: Thing
<a name="9397"></a>    
<a name="9398"></a>    /* The list of things this key can actually be used to lock and unlock. */
<a name="9399"></a>    actualLockList = []
<a name="9400"></a>    
<a name="9401"></a>    /* 
<a name="9402"></a>     *   The list of things this key plausibly looks like it might lock and
<a name="9403"></a>     *   unlock (e.g. if we're a yale key, we might list all the doors in the
<a name="9404"></a>     *   game that have yale locks here).
<a name="9405"></a>     */
<a name="9406"></a>    plausibleLockList = []
<a name="9407"></a>    
<a name="9408"></a>    /* 
<a name="9409"></a>     *   The list of all the things the player character knows this key can lock
<a name="9410"></a>     *   and unlock. Items are automatically added to this list when this key is
<a name="9411"></a>     *   successfully used to lock or unlock them, but game code can also use
<a name="9412"></a>     *   this property to list items the player character starts out knowing,
<a name="9413"></a>     *   such as the door locked by his/her own front door key.
<a name="9414"></a>     */
<a name="9415"></a>    knownLockList = []
<a name="9416"></a>    
<a name="9417"></a>    /*  
<a name="9418"></a>     *   Determine whether we're a possible key for obj (i.e. whether we might
<a name="9419"></a>     *   be able to lock or unlock obj).
<a name="9420"></a>     */
<a name="9421"></a>    isPossibleKeyFor(obj)
<a name="9422"></a>    {
<a name="9423"></a>        /* 
<a name="9424"></a>         *   First test if we've been defined as a plausible or known key for
<a name="9425"></a>         *   our lexicalParent in the case that we're the remapIn object for our
<a name="9426"></a>         *   lexicalParent. If so return true. We do this because game code
<a name="9427"></a>         *   might easily define the plausibleKeyList and/or knownKeyList on our
<a name="9428"></a>         *   lexicalParent intending to refer to what keys might unlock is
<a name="9429"></a>         *   associated container (i.e. ourselves if we're our lexicalParent's
<a name="9430"></a>         *   remapIn object).
<a name="9431"></a>         */        
<a name="9432"></a>        if(obj.lexicalParent != nil &amp;&amp; obj.lexicalParent.remapIn == obj
<a name="9433"></a>           &amp;&amp;(knownLockList.indexOf(obj.lexicalParent) != nil
<a name="9434"></a>              || plausibleLockList.indexOf(obj.lexicalParent) != nil))
<a name="9435"></a>            return true;
<a name="9436"></a>        
<a name="9437"></a>        /* 
<a name="9438"></a>         *   Otherwise return true if obj is in either our knownLockList or our
<a name="9439"></a>         *   plausibleLockList or nil otherwise.
<a name="9440"></a>         */
<a name="9441"></a>        return knownLockList.indexOf(obj) != nil ||
<a name="9442"></a>            plausibleLockList.indexOf(obj) != nil;
<a name="9443"></a>    }
<a name="9444"></a>    
<a name="9445"></a>    /* A key is something we can unlock with. */
<a name="9446"></a>    canUnlockWithMe = true
<a name="9447"></a>    
<a name="9448"></a>    iobjFor(UnlockWith)
<a name="9449"></a>    {
<a name="9450"></a>        preCond = [objHeld]
<a name="9451"></a>        
<a name="9452"></a>               
<a name="9453"></a>        verify()
<a name="9454"></a>        {
<a name="9455"></a>            inherited;
<a name="9456"></a>            
<a name="9457"></a>            /* 
<a name="9458"></a>             *   We're a logical choice of key if we're a possible key for the
<a name="9459"></a>             *   direct object.
<a name="9460"></a>             */
<a name="9461"></a>            if(gVerifyDobj &amp;&amp; isPossibleKeyFor(gVerifyDobj))
<a name="9462"></a>                logical;
<a name="9463"></a>            
<a name="9464"></a>            /* Otherwise we're not a very good choice. */
<a name="9465"></a>            else
<a name="9466"></a>                implausible(notAPlausibleKeyMsg);            
<a name="9467"></a>        }
<a name="9468"></a>        
<a name="9469"></a>        check()
<a name="9470"></a>        {
<a name="9471"></a>            /* 
<a name="9472"></a>             *   Check whether this key *actually* fits the direct object, and
<a name="9473"></a>             *   if not display a message to say it doesn't (which halts the
<a name="9474"></a>             *   action).
<a name="9475"></a>             *
<a name="9476"></a>             *   This is complicated by the fact that if the direct object is a
<a name="9477"></a>             *   SubComponent the game author may have listed the dobj's
<a name="9478"></a>             *   lexicalParent in our actualLockList property instead of the
<a name="9479"></a>             *   actual dobj (e.g. the fridge object itself instead of the
<a name="9480"></a>             *   SubComponent representing the interior of the fridge). So in
<a name="9481"></a>             *   addition to seeing if the dobj is included in our
<a name="9482"></a>             *   actuallockList we need to check whether, if the dobj has a
<a name="9483"></a>             *   lexicalParent of which it's the remapIn object, dobj's
<a name="9484"></a>             *   lexicalParent is in our actualLockList.
<a name="9485"></a>             */
<a name="9486"></a>            
<a name="9487"></a>            if(actualLockList.indexOf(gDobj) == nil
<a name="9488"></a>               &amp;&amp; (gDobj.lexicalParent == nil
<a name="9489"></a>               || gDobj.lexicalParent.remapIn != gDobj
<a name="9490"></a>               || actualLockList.indexOf(gDobj.lexicalParent) == nil))
<a name="9491"></a>                say(keyDoesntFitMsg);              
<a name="9492"></a>        }
<a name="9493"></a>        
<a name="9494"></a>        action()
<a name="9495"></a>        {
<a name="9496"></a>            /* Make the dobj unlocked. */
<a name="9497"></a>            gDobj.makeLocked(nil);
<a name="9498"></a>            
<a name="9499"></a>            /* If the dobj is not already in our knownLockList, add it there. */
<a name="9500"></a>            if(knownLockList.indexOf(gDobj) == nil)
<a name="9501"></a>                knownLockList += gDobj;
<a name="9502"></a>        }
<a name="9503"></a>        
<a name="9504"></a>        report()
<a name="9505"></a>        {
<a name="9506"></a>            DMsg(okay unlock with, okayUnlockWithMsg, gActionListStr);
<a name="9507"></a>        }
<a name="9508"></a>        
<a name="9509"></a>    }
<a name="9510"></a>    
<a name="9511"></a>    okayUnlockWithMsg = '{I} unlock{s/ed} {the dobj} with {the iobj}. '
<a name="9512"></a>    
<a name="9513"></a>    iobjFor(LockWith)
<a name="9514"></a>    {
<a name="9515"></a>        preCond = [objHeld]
<a name="9516"></a>        
<a name="9517"></a>        verify()
<a name="9518"></a>        {
<a name="9519"></a>            inherited;
<a name="9520"></a>            
<a name="9521"></a>            if(gVerifyDobj &amp;&amp; isPossibleKeyFor(gVerifyDobj))
<a name="9522"></a>                logical;
<a name="9523"></a>            else
<a name="9524"></a>                implausible(notAPlausibleKeyMsg);            
<a name="9525"></a>        }
<a name="9526"></a>        
<a name="9527"></a>        check()
<a name="9528"></a>        {
<a name="9529"></a>            /* 
<a name="9530"></a>             *   Check whether this key *actually* fits the direct object, and
<a name="9531"></a>             *   if not display a message to say it doesn't (which halts the
<a name="9532"></a>             *   action).
<a name="9533"></a>             *
<a name="9534"></a>             *   This is complicated by the fact that if the direct object is a
<a name="9535"></a>             *   SubComponent the game author may have listed the dobj's
<a name="9536"></a>             *   lexicalParent in our actualLockList property instead of the
<a name="9537"></a>             *   actual dobj (e.g. the fridge object itself instead of the
<a name="9538"></a>             *   SubComponent representing the interior of the fridge). So in
<a name="9539"></a>             *   addition to seeing if the dobj is included in our
<a name="9540"></a>             *   actuallockList we need to check whether, if the dobj has a
<a name="9541"></a>             *   lexicalParent of which it's the remapIn object, dobj's
<a name="9542"></a>             *   lexicalParent is in our actualLockList.
<a name="9543"></a>             */
<a name="9544"></a>             if(actualLockList.indexOf(gDobj) == nil
<a name="9545"></a>               &amp;&amp; (gDobj.lexicalParent == nil
<a name="9546"></a>               || gDobj.lexicalParent.remapIn != gDobj
<a name="9547"></a>               || actualLockList.indexOf(gDobj.lexicalParent) == nil))
<a name="9548"></a>                say(keyDoesntFitMsg);              
<a name="9549"></a>        }
<a name="9550"></a>        
<a name="9551"></a>        action()
<a name="9552"></a>        {
<a name="9553"></a>            /*Make the dobj locked. */
<a name="9554"></a>            gDobj.makeLocked(true);
<a name="9555"></a>            
<a name="9556"></a>            /* If the dobj is not already in our knownLockList, add it there. */
<a name="9557"></a>            if(knownLockList.indexOf(gDobj) == nil)
<a name="9558"></a>                knownLockList += gDobj;
<a name="9559"></a>        }
<a name="9560"></a>        
<a name="9561"></a>        report()
<a name="9562"></a>        {
<a name="9563"></a>             DMsg(okay lock with, okayLockWithMsg, gActionListStr);
<a name="9564"></a>        }
<a name="9565"></a>    }
<a name="9566"></a>    
<a name="9567"></a>    /* The message to say that the actor has lock the dobj with this key. */
<a name="9568"></a>    okayLockWithMsg = '{I} lock{s/ed} {the dobj} with {the iobj}. '
<a name="9569"></a>    
<a name="9570"></a>    /* 
<a name="9571"></a>     *   The message to say that this key clearly won\'t work on the dobj
<a name="9572"></a>     *   (because it\'s the wrong sort of key for the lock; e.g. a yale key
<a name="9573"></a>     *   clearly won\'t fit the lock on a small jewel box).
<a name="9574"></a>     */
<a name="9575"></a>    notAPlausibleKeyMsg = '\^&lt;&lt;theName&gt;&gt; clearly won\'t work on &lt;&lt;gVerifyDobj.theName&gt;&gt;. '
<a name="9576"></a>    
<a name="9577"></a>    /*  The message to say that this key doesn\'t in fact fit the dobj. */
<a name="9578"></a>    keyDoesntFitMsg = '\^&lt;&lt;theName&gt;&gt; won\'t fit &lt;&lt;gVerifyDobj.theName&gt;&gt;. '
<a name="9579"></a>    
<a name="9580"></a>    preinitThing()
<a name="9581"></a>    {
<a name="9582"></a>        inherited;
<a name="9583"></a>        
<a name="9584"></a>        /* 
<a name="9585"></a>         *   Add the actualLockList to the plausibleLockList if it's not already
<a name="9586"></a>         *   there to ensure that this key will work on anything in its
<a name="9587"></a>         *   actualLockList.
<a name="9588"></a>         */
<a name="9589"></a>        plausibleLockList = plausibleLockList.appendUnique(actualLockList);
<a name="9590"></a>        
<a name="9591"></a>    }
<a name="9592"></a>    
<a name="9593"></a>;
<a name="9594"></a>
<a name="9595"></a>/* 
<a name="9596"></a> *   A SubComponent is a Thing that is part of something else and represents the
<a name="9597"></a> *   surface, container, underside or rear of the object to which it's attached.
<a name="9598"></a> *   This allows a Thing to model several types of containment at once, by
<a name="9599"></a> *   having (say) one SubComponent that represents its top (on which things can
<a name="9600"></a> *   be placed) and another to represent its interior (in which things can be
<a name="9601"></a> *   placed.
<a name="9602"></a> *
<a name="9603"></a> *   A SubComponent is normally defined as a nested anonymous object on the
<a name="9604"></a> *   remapOn, remapIn, remapUnder or remapBehind property of a Thing. There's no
<a name="9605"></a> *   need to further specify whether a SubComponent is also a Surface,
<a name="9606"></a> *   Container, Underside or RearContainer, since the library can work this out
<a name="9607"></a> *   from the property on which it is defined.
<a name="9608"></a> */
<a name="9609"></a>class SubComponent: Thing
<a name="9610"></a>   
<a name="9611"></a>    /* 
<a name="9612"></a>     *   A SubComponent is always fixed in place since it represents a fixed
<a name="9613"></a>     *   part of its lexicalParent.
<a name="9614"></a>     */
<a name="9615"></a>    isFixed = true
<a name="9616"></a>    
<a name="9617"></a>    /* Preinitialize a SubComponent. */
<a name="9618"></a>    preinitThing()
<a name="9619"></a>    {
<a name="9620"></a>        /* 
<a name="9621"></a>         *   Carry out the particular initialization of a SubComponent (see next
<a name="9622"></a>         *   method); this sets up the proper relation between the SubComponent
<a name="9623"></a>         *   and its lexicalParent.
<a name="9624"></a>         */
<a name="9625"></a>        initializeSubComponent(lexicalParent);
<a name="9626"></a>        
<a name="9627"></a>        /*  Note any vocab defined on this SubComponent */
<a name="9628"></a>        origVocab = vocab;
<a name="9629"></a>        
<a name="9630"></a>        /* Carry out the inherited handling. */
<a name="9631"></a>        inherited;
<a name="9632"></a>    }
<a name="9633"></a>    
<a name="9634"></a>    /* 
<a name="9635"></a>     *   Initialize this SubComponent. This sets up the necessary relations
<a name="9636"></a>     *   between the SubCompononent and the object of which it is a part,
<a name="9637"></a>     *   usually its lexicalParent (passed as the parent parameter).
<a name="9638"></a>     */
<a name="9639"></a>    initializeSubComponent(parent)
<a name="9640"></a>    {
<a name="9641"></a>        /* 
<a name="9642"></a>         *   If for any reason we don't have a parent (normally, our
<a name="9643"></a>         *   lexicalParent), stop here because there's nothing we can do.
<a name="9644"></a>         */
<a name="9645"></a>        if(parent == nil)
<a name="9646"></a>            return;
<a name="9647"></a>        
<a name="9648"></a>        /* A SubComponent is located in its parent. */
<a name="9649"></a>        location = parent;
<a name="9650"></a>        
<a name="9651"></a>        /* 
<a name="9652"></a>         *   A SubComponent takes its name from its parent, since it's
<a name="9653"></a>         *   effectively an aspect of its parent.
<a name="9654"></a>         */
<a name="9655"></a>        nameAs(parent);
<a name="9656"></a>       
<a name="9657"></a>        /* 
<a name="9658"></a>         *   Determine the contType of this SubComponent from the property to
<a name="9659"></a>         *   which it's attached. The contType must match the remapXX type.
<a name="9660"></a>         */
<a name="9661"></a>        if(parent.remapIn == self)
<a name="9662"></a>            contType = In;
<a name="9663"></a>        
<a name="9664"></a>        if(parent.remapOn == self)
<a name="9665"></a>            contType = On;
<a name="9666"></a>        
<a name="9667"></a>        if(parent.remapUnder == self)
<a name="9668"></a>            contType = Under;
<a name="9669"></a>        
<a name="9670"></a>        if(parent.remapBehind == self)
<a name="9671"></a>            contType = Behind;
<a name="9672"></a>        
<a name="9673"></a>        /* If we have a contType, set our listOrder to that of our contType. */
<a name="9674"></a>        if(contType != nil)
<a name="9675"></a>            listOrder = contType.listOrder;
<a name="9676"></a>    }
<a name="9677"></a>    
<a name="9678"></a>    /* 
<a name="9679"></a>     *   Take each of our name-related properties from the corresponding
<a name="9680"></a>     *   properties of our lexicalParent. Language-specific modules may need to
<a name="9681"></a>     *   override this method to cater for additional properties.
<a name="9682"></a>     *
<a name="9683"></a>     *   Note that if the lexicalParent is renamed at any point during the game,
<a name="9684"></a>     *   this nameAs() method should be called on any openable SubComponent at
<a name="9685"></a>     *   the same time to ensure the names stay in sync.
<a name="9686"></a>     */
<a name="9687"></a>    nameAs(parent)
<a name="9688"></a>    {
<a name="9689"></a>        name = parent.name;
<a name="9690"></a>        proper = parent.proper;
<a name="9691"></a>        qualified = parent.qualified;
<a name="9692"></a>        person = parent.person;
<a name="9693"></a>        plural = parent.plural;
<a name="9694"></a>        massNoun = parent.massNoun;
<a name="9695"></a>        isHim = parent.isHim;
<a name="9696"></a>        isHer = parent.isHer;
<a name="9697"></a>        isIt = parent.isIt;
<a name="9698"></a>    }
<a name="9699"></a>    
<a name="9700"></a>    makeOpen(stat)
<a name="9701"></a>    {
<a name="9702"></a>        inherited(stat);
<a name="9703"></a>        
<a name="9704"></a>        /* 
<a name="9705"></a>         *   If we close this item when the playerChar is inside it, the player
<a name="9706"></a>         *   will need to be able to refer to it with the vocab of its
<a name="9707"></a>         *   lexicalParent, since the lexicalParent will no longer be in scope
<a name="9708"></a>         */
<a name="9709"></a>        if(lexicalParent != nil &amp;&amp; gPlayerChar.isIn(self))
<a name="9710"></a>        {
<a name="9711"></a>            if(stat)
<a name="9712"></a>            {
<a name="9713"></a>                /* 
<a name="9714"></a>                 *   If this object is being opened, replace our vocab with the
<a name="9715"></a>                 *   vocab we started out with (which will normally be none),
<a name="9716"></a>                 *   since we no longer want the player to be able to refer
<a name="9717"></a>                 *   directly* to us using our lexicalParent's vocab once we're
<a name="9718"></a>                 *   open.
<a name="9719"></a>                 */
<a name="9720"></a>                replaceVocab(origVocab);
<a name="9721"></a>                
<a name="9722"></a>                /*   Restore our name to our lexicalParent's name. */
<a name="9723"></a>                nameAs(lexicalParent);
<a name="9724"></a>            }
<a name="9725"></a>            else
<a name="9726"></a>            {
<a name="9727"></a>                /* 
<a name="9728"></a>                 *   If this object is being closed, replace our vocab with that
<a name="9729"></a>                 *   of our lexicalParent (which is no longer in scope once
<a name="9730"></a>                 *   we're closed with the playerChar inside us) so that the PC
<a name="9731"></a>                 *   can still refer to us (e.g. to open us again).
<a name="9732"></a>                 */
<a name="9733"></a>                addVocab(lexicalParent.vocab);               
<a name="9734"></a>                
<a name="9735"></a>            }
<a name="9736"></a>        }
<a name="9737"></a>    }
<a name="9738"></a>    
<a name="9739"></a>    /* 
<a name="9740"></a>     *   Our original vocab. We need to store this in case makrOpen() wants to
<a name="9741"></a>     *   restore it.
<a name="9742"></a>     */
<a name="9743"></a>    origVocab = nil
<a name="9744"></a>    
<a name="9745"></a>    matchNameDisambig(tokens)
<a name="9746"></a>    {
<a name="9747"></a>        local match = inherited(tokens);
<a name="9748"></a>        
<a name="9749"></a>        /* 
<a name="9750"></a>         *   If we're being matched at a disambig prompt and we don't have any
<a name="9751"></a>         *   vocabWords of our own, try matching us against our lexicalParent's
<a name="9752"></a>         *   vocab instead, provided we have a lexicalParent.
<a name="9753"></a>         *
<a name="9754"></a>         *   This is necessary because SubComponents don't normally have any
<a name="9755"></a>         *   vocab of their own, but a SubComponent may end up as one of the
<a name="9756"></a>         *   objects that notionally matched the vocab of its lexicalParent
<a name="9757"></a>         *   among which the parser now wishes the player to disambiguate. For
<a name="9758"></a>         *   example, if the player types LOOK IN BOX and there's more than one
<a name="9759"></a>         *   box in scope, and the red box (say) has a SubComponent defined on
<a name="9760"></a>         *   its remapIn property, then since the LOOK IN action will have been
<a name="9761"></a>         *   redirected to the SubComponent, the parser will list the
<a name="9762"></a>         *   SubComponent as the object corresponding to "red box", but the
<a name="9763"></a>         *   SubComponent doesn't have any vocab of its own for the player's
<a name="9764"></a>         *   response "red" to match; when disambiguating we therefore need to
<a name="9765"></a>         *   try to match against our lexicalParent's vocab.
<a name="9766"></a>         */        
<a name="9767"></a>        if(match == 0 &amp;&amp; lexicalParent != nil)
<a name="9768"></a>            return lexicalParent.matchNameDisambig(tokens);
<a name="9769"></a>        
<a name="9770"></a>        /* 
<a name="9771"></a>         *   Otherwise just return our normal match
<a name="9772"></a>         */        
<a name="9773"></a>        return match;
<a name="9774"></a>           
<a name="9775"></a>    }
<a name="9776"></a>;
<a name="9777"></a>
<a name="9778"></a>
<a name="9779"></a>/*  
<a name="9780"></a> *   A MultiLoc is an object that can exist in several locations at once.
<a name="9781"></a> *   MultiLoc is a mix-in class that should be used in conjunction with Thing or
<a name="9782"></a> *   a Thing-derived class.
<a name="9783"></a> */
<a name="9784"></a>class MultiLoc: object
<a name="9785"></a>    
<a name="9786"></a>    /* 
<a name="9787"></a>     *   A list of the locations this object is currently present in. If this
<a name="9788"></a>     *   property is defined at the start of the game and initialLocationList
<a name="9789"></a>     *   isn't, then this list will be copied to initialLocationList, and so can
<a name="9790"></a>     *   be specified by users in exactly the same way.
<a name="9791"></a>     */
<a name="9792"></a>    locationList = []
<a name="9793"></a>    
<a name="9794"></a>    
<a name="9795"></a>    /* 
<a name="9796"></a>     *   A list of the locations this object is to start out in. Locations may
<a name="9797"></a>     *   be specified as Things, Rooms or Regions, or as some mix of all three.
<a name="9798"></a>     */   
<a name="9799"></a>    initialLocationList = []
<a name="9800"></a>    
<a name="9801"></a>    /* 
<a name="9802"></a>     *   A list of locations this object is not to be present in. This is
<a name="9803"></a>     *   intended mainly to allow certain rooms to be excepted from a specified
<a name="9804"></a>     *   region.
<a name="9805"></a>     */    
<a name="9806"></a>    exceptions = []
<a name="9807"></a>    
<a name="9808"></a>    
<a name="9809"></a>    /* 
<a name="9810"></a>     *   If the initialLocationClass property is defined, then this MultiLoc is
<a name="9811"></a>     *   initially located in every instance of this class. Note that this would
<a name="9812"></a>     *   be in addition to the locations defined in the locationList class and
<a name="9813"></a>     *   would likewise be subject to anything defined in the exceptions
<a name="9814"></a>     *   property.
<a name="9815"></a>     */
<a name="9816"></a>    initialLocationClass = nil
<a name="9817"></a>    
<a name="9818"></a>    /*
<a name="9819"></a>     *   Test an object for inclusion in our initial location list.  By
<a name="9820"></a>     *   default, we'll simply return true to include every object.  We
<a name="9821"></a>     *   return true by default so that an instance can merely specify a
<a name="9822"></a>     *   value for initialLocationClass in order to place this object in
<a name="9823"></a>     *   every instance of the given class.
<a name="9824"></a>     */
<a name="9825"></a>    isInitiallyIn(obj) { return true; }
<a name="9826"></a>    
<a name="9827"></a>    /*   
<a name="9828"></a>     *   In Preinit, add this MultiLoc into the contents list of every item in
<a name="9829"></a>     *   its locationList and every object of class initialLocationClass (if
<a name="9830"></a>     *   this is not nil) and then remove it from the contents list of every
<a name="9831"></a>     *   item in its exceptions list.
<a name="9832"></a>     */    
<a name="9833"></a>    addToLocations()
<a name="9834"></a>    {
<a name="9835"></a>        /* 
<a name="9836"></a>         *   If there's nothing in the initialLocationList, we'll assume the
<a name="9837"></a>         *   author used the locationList property to specify the initial
<a name="9838"></a>         *   locations of this MultiLoc, since this was correct in earlier
<a name="9839"></a>         *   versions and should be maintained for backward compatibility. In
<a name="9840"></a>         *   That case copy the locationList to the initialLocationList and then
<a name="9841"></a>         *   set the locationList to an empty list before attempting to build
<a name="9842"></a>         *   it.
<a name="9843"></a>         */
<a name="9844"></a>        if(initialLocationList.length == 0)
<a name="9845"></a>        {
<a name="9846"></a>            initialLocationList = locationList;
<a name="9847"></a>            locationList = [];               
<a name="9848"></a>        }
<a name="9849"></a>        
<a name="9850"></a>        /* Create a new Vector to keep track of our list of locations. */
<a name="9851"></a>        local locationVec = new Vector(10);
<a name="9852"></a>        
<a name="9853"></a>        /* 
<a name="9854"></a>         *   Add ourselves to the content property of all the items listed in
<a name="9855"></a>         *   our initialLocationList. At the same time append each item listed
<a name="9856"></a>         *   to our locationVec vector.
<a name="9857"></a>         */
<a name="9858"></a>        foreach(local loc in valToList(initialLocationList))
<a name="9859"></a>        {           
<a name="9860"></a>            loc.addToContents(self, locationVec);             
<a name="9861"></a>        }
<a name="9862"></a>        
<a name="9863"></a>        /* 
<a name="9864"></a>         *   If we have an initialLocationClass, add ourselves to the location
<a name="9865"></a>         *   list of every object of that class for which our isInitiallyIn(obj)
<a name="9866"></a>         *   method returns true; at the last time add all such objects to our
<a name="9867"></a>         *   locationVec vector.
<a name="9868"></a>         */
<a name="9869"></a>        if(initialLocationClass != nil)
<a name="9870"></a>        {
<a name="9871"></a>            for(local obj = firstObj(initialLocationClass); obj != nil; obj =
<a name="9872"></a>                nextObj(obj, initialLocationClass))   
<a name="9873"></a>            {
<a name="9874"></a>                if(isInitiallyIn(obj))
<a name="9875"></a>                    obj.addToContents(self, locationVec);
<a name="9876"></a>            }
<a name="9877"></a>        }
<a name="9878"></a>        
<a name="9879"></a>        /*  
<a name="9880"></a>         *   Now remove ourselves from the contents list of all objects listed
<a name="9881"></a>         *   as exceptions in our exceptions property, and remove those objects
<a name="9882"></a>         *   from our locationVec vector.
<a name="9883"></a>         */
<a name="9884"></a>        foreach(local loc in valToList(exceptions))            
<a name="9885"></a>        {
<a name="9886"></a>            loc.removeFromContents(self, locationVec); 
<a name="9887"></a>        }
<a name="9888"></a>        
<a name="9889"></a>        /* 
<a name="9890"></a>         *   Store our resulting list of locations in our locationList property.
<a name="9891"></a>         */
<a name="9892"></a>        locationList = locationVec.toList();
<a name="9893"></a>    }
<a name="9894"></a>      
<a name="9895"></a>    /* 
<a name="9896"></a>     *   Move this MultiLoc into an additional location.
<a name="9897"></a>     */      
<a name="9898"></a>    moveIntoAdd(loc)
<a name="9899"></a>    {
<a name="9900"></a>        /* 
<a name="9901"></a>         *   Let the new location handle it, so it will work whether the new
<a name="9902"></a>         *   location is a Thing, a Room or a Region.
<a name="9903"></a>         */
<a name="9904"></a>        loc.moveMLIntoAdd(self);
<a name="9905"></a>        
<a name="9906"></a>    }
<a name="9907"></a>    
<a name="9908"></a>    /* 
<a name="9909"></a>     *   Remove this MultiLoc from loc.
<a name="9910"></a>     */         
<a name="9911"></a>    moveOutOf(loc)
<a name="9912"></a>    {
<a name="9913"></a>        /* 
<a name="9914"></a>         *   Let the new location handle it, so it will work whether the new
<a name="9915"></a>         *   location is a Thing, a Room or a Region.
<a name="9916"></a>         */
<a name="9917"></a>        loc.moveMLOutOf(self);        
<a name="9918"></a>    }
<a name="9919"></a>    
<a name="9920"></a>    /* 
<a name="9921"></a>     *   To move a MultiLoc into a single location, first remove it from every
<a name="9922"></a>     *   location in its location list, then add it to the single location it's
<a name="9923"></a>     *   now in.
<a name="9924"></a>     */    
<a name="9925"></a>    moveInto(loc)
<a name="9926"></a>    {
<a name="9927"></a>        foreach(local cur in locationList)
<a name="9928"></a>            cur.removeFromContents(self);
<a name="9929"></a>        
<a name="9930"></a>        locationList = [];
<a name="9931"></a>        
<a name="9932"></a>        if(loc != nil)
<a name="9933"></a>            moveIntoAdd(loc);
<a name="9934"></a>    }
<a name="9935"></a>    
<a name="9936"></a>        
<a name="9937"></a>    /* 
<a name="9938"></a>     *   A MultiLoc is directly in another object if it's listed in that other
<a name="9939"></a>     *   object's contents list.     
<a name="9940"></a>     */    
<a name="9941"></a>    isDirectlyIn(loc)
<a name="9942"></a>    {               
<a name="9943"></a>        if(loc != nil)
<a name="9944"></a>            return valToList(loc.contents).indexOf(self) != nil;
<a name="9945"></a>        
<a name="9946"></a>        /* 
<a name="9947"></a>         *   We only reach this point if loc is nil, in which case we're testing
<a name="9948"></a>         *   whether this MultiLoc is in nil, i.e. nowhere at all. This will be
<a name="9949"></a>         *   the case if and only if its location list is empty.
<a name="9950"></a>         */
<a name="9951"></a>        return locationList == [];
<a name="9952"></a>    }
<a name="9953"></a>    
<a name="9954"></a>    /* 
<a name="9955"></a>     *   A MultiLoc is in another object either if it's directly in that object
<a name="9956"></a>     *   or if one of the items in its location list is in that object.
<a name="9957"></a>     */    
<a name="9958"></a>    isIn(loc)
<a name="9959"></a>    {
<a name="9960"></a>        return isDirectlyIn(loc) 
<a name="9961"></a>            || locationList.indexWhich({x: x.isIn(loc)}) != nil;    
<a name="9962"></a>    }
<a name="9963"></a>    
<a name="9964"></a>    
<a name="9965"></a>    
<a name="9966"></a>    /* 
<a name="9967"></a>     *   For certain purposes, such as sense path calculations, a Multiloc needs
<a name="9968"></a>     *   a notional location. We assume the enquiry is made from the perspective
<a name="9969"></a>     *   of the current actor, or, failing that, the player char, so we return
<a name="9970"></a>     *   the current actor's (or the player char's) current location if the
<a name="9971"></a>     *   MultiLoc is present there, or the last place where the MultiLoc was
<a name="9972"></a>     *   seen otherwise. The intention is to select the most currently
<a name="9973"></a>     *   significant location where we're present.
<a name="9974"></a>     */    
<a name="9975"></a>    location()
<a name="9976"></a>    {
<a name="9977"></a>        /* 
<a name="9978"></a>         *   If our locationList is empty, then we aren't anywhere, so our
<a name="9979"></a>         *   location is nil.
<a name="9980"></a>         */
<a name="9981"></a>         if(locationList.length == 0)
<a name="9982"></a>            return nil;       
<a name="9983"></a>        
<a name="9984"></a>        /* 
<a name="9985"></a>         *   Get the room either of the current actor (if there is one) or else
<a name="9986"></a>         *   of the player char.
<a name="9987"></a>         */
<a name="9988"></a>        local rm = gActor == nil ? gPlayerChar.getOutermostRoom :
<a name="9989"></a>        gActor.getOutermostRoom;
<a name="9990"></a>             
<a name="9991"></a>        
<a name="9992"></a>        /* 
<a name="9993"></a>         *   First see if we're directly in the actor's enclosing room. If so,
<a name="9994"></a>         *   return that room as our location.
<a name="9995"></a>         */        
<a name="9996"></a>        if(isDirectlyIn(rm))
<a name="9997"></a>            return rm;
<a name="9998"></a>        
<a name="9999"></a>        /* 
<a name="10000"></a>         *   If that doesn't work, check if anything in our location list is in
<a name="10001"></a>         *   the actor's room; if so, use that.
<a name="10002"></a>         */        
<a name="10003"></a>        local loc = locationList.valWhich({x: x.isIn(rm)});
<a name="10004"></a>        
<a name="10005"></a>        if(loc != nil)
<a name="10006"></a>            return loc;
<a name="10007"></a>        
<a name="10008"></a>        /* 
<a name="10009"></a>         *   If that doesn't work, return the location we were last seen at,
<a name="10010"></a>         *   provided we have one and we're still there.
<a name="10011"></a>         */
<a name="10012"></a>        if(lastSeenAt != nil &amp;&amp; locationList.indexOf(lastSeenAt) != nil)        
<a name="10013"></a>            return lastSeenAt;    
<a name="10014"></a>        
<a name="10015"></a>         /* 
<a name="10016"></a>          *   If all else fails, return the first location from our locationList
<a name="10017"></a>          *   (if we've reached this point we know for sure there is one, since
<a name="10018"></a>          *   if our locationList were empty this method would have already
<a name="10019"></a>          *   returned nil).
<a name="10020"></a>          */         
<a name="10021"></a>        return locationList[1];
<a name="10022"></a>    }   
<a name="10023"></a>    
<a name="10024"></a>    /* 
<a name="10025"></a>     *   If we're a MultiLoc we don't want to carry out any of the normal
<a name="10026"></a>     *   preinitialization related to our location.
<a name="10027"></a>     */
<a name="10028"></a>    preinitThing()
<a name="10029"></a>    {
<a name="10030"></a>        /* if we have a global parameter name, add it to the global table */
<a name="10031"></a>        if (globalParamName != nil)
<a name="10032"></a>            libGlobal.nameTable_[globalParamName] = self;
<a name="10033"></a>    }
<a name="10034"></a>;
<a name="10035"></a>
<a name="10036"></a>/*  
<a name="10037"></a> *   The Floor Class is used to provide a floor or ground object to each room
<a name="10038"></a> *   that wants one (by default, every Room). While this serves the secondary
<a name="10039"></a> *   purpose of allowing the player to refer to the ground/floor of the current
<a name="10040"></a> *   location (which is nearly always implicitly present), it's primary purpose
<a name="10041"></a> *   is to allow the parser to refer to the floor/ground when it wants to
<a name="10042"></a> *   distinguish items directly in a Room (and hence notionally on the ground)
<a name="10043"></a> *   from those in or on some other object.
<a name="10044"></a> */
<a name="10045"></a>class Floor: MultiLoc, Thing
<a name="10046"></a>    /* 
<a name="10047"></a>     *   A Floor is a Decoration, but since the extras.t module is optional we
<a name="10048"></a>     *   have to define is as isFixed = true and isDecoration = true.
<a name="10049"></a>     */
<a name="10050"></a>    isFixed = true
<a name="10051"></a>    
<a name="10052"></a>    isDecoration = true
<a name="10053"></a>    
<a name="10054"></a>    /* By default, every room has a floor. */
<a name="10055"></a>    initialLocationClass = Room
<a name="10056"></a>    
<a name="10057"></a>    /* A Floor is something we can put things on. */
<a name="10058"></a>    contType = On
<a name="10059"></a>    
<a name="10060"></a>    /* 
<a name="10061"></a>     *   We narrow down our list of locations to those Rooms that actually
<a name="10062"></a>     *   define this Floor as their floorObj. Some rooms may wish to define a
<a name="10063"></a>     *   custom floorObj, and some (e.g. those representing the top of a mast or
<a name="10064"></a>     *   tree) may want to have no floorObj at all.
<a name="10065"></a>     */
<a name="10066"></a>    isInitiallyIn(obj) { return obj.floorObj == self; }
<a name="10067"></a>    
<a name="10068"></a>    /* 
<a name="10069"></a>     *   The Floor object needs to appear to share the contents of the player
<a name="10070"></a>     *   character's room (or other enclosing container) for certain purposes
<a name="10071"></a>     *   (such as disambiguating by container or the TakeFrom command), but
<a name="10072"></a>     *   nothing is really moved into or out of a Floor).
<a name="10073"></a>     */
<a name="10074"></a>    contents = (gPlayerChar.outermostVisibleParent().contents - self)
<a name="10075"></a>    
<a name="10076"></a>    /*   
<a name="10077"></a>     *   We can examine a Floor or take something from it, but other actions are
<a name="10078"></a>     *   ruled out. A Floor should generally be treated as a Decoration object
<a name="10079"></a>     *   rather than something with which any extensive interaction is allowed.
<a name="10080"></a>     */
<a name="10081"></a>    decorationActions = [Examine, TakeFrom]
<a name="10082"></a>    
<a name="10083"></a>    
<a name="10084"></a>    /* 
<a name="10085"></a>     *   By default we probably want to keep the description of a Floor object
<a name="10086"></a>     *   as minimalistic as possible to discourage players from trying to
<a name="10087"></a>     *   interact with it, so we won't listed the 'contents' of a Floor when
<a name="10088"></a>     *   it's examined. This can of course be overridden if desired.
<a name="10089"></a>     */    
<a name="10090"></a>    contentsListed = nil        
<a name="10091"></a>;
<a name="10092"></a>
<a name="10093"></a>
<a name="10094"></a>/* 
<a name="10095"></a> *   The defaultGround object is the specific Floor object that's present in
<a name="10096"></a> *   every Room by default.
<a name="10097"></a> */
<a name="10098"></a>defaultGround: Floor
<a name="10099"></a>;
<a name="10100"></a>
<a name="10101"></a>/* Preinitilizer for MultiLocs */
<a name="10102"></a>multiLocInitiator: PreinitObject
<a name="10103"></a>    execute()
<a name="10104"></a>    {
<a name="10105"></a>        /* 
<a name="10106"></a>         *   Add every MultiLoc to the contents list of all its locations. This
<a name="10107"></a>         *   also builds each MultiLoc's locationList as it goes.
<a name="10108"></a>         */
<a name="10109"></a>        for(local cur = firstObj(MultiLoc); cur !=nil ; cur = nextObj(cur,
<a name="10110"></a>            MultiLoc))
<a name="10111"></a>            
<a name="10112"></a>            cur.addToLocations();
<a name="10113"></a>    }
<a name="10114"></a>    
<a name="10115"></a>    /* 
<a name="10116"></a>     *   Make sure we've preinitialized Regions first, so that their roomLists
<a name="10117"></a>     *   are ready when we want to use them.
<a name="10118"></a>     */
<a name="10119"></a>    execBeforeMe = [regionPreinit]
<a name="10120"></a>;
<a name="10121"></a>
<a name="10122"></a>
<a name="10123"></a>/*  
<a name="10124"></a> *   A Topic is something that the player character can refer to in the course
<a name="10125"></a> *   of conversation or look up in a book, but which is not implemented as a
<a name="10126"></a> *   physical object in the game. Topics can be used for abstract concepts such
<a name="10127"></a> *   as life, liberty and happiness, or for physical objects that are referred
<a name="10128"></a> *   to but not actually implemented as Things in the game, such as Alfred the
<a name="10129"></a> *   Great or the Great Wall of China.
<a name="10130"></a> */
<a name="10131"></a>class Topic: Mentionable
<a name="10132"></a>    construct(name_)
<a name="10133"></a>    {        
<a name="10134"></a>        vocab = name_;
<a name="10135"></a>        initVocab();
<a name="10136"></a>    }
<a name="10137"></a>    
<a name="10138"></a>    /*
<a name="10139"></a>     *   Whether the player character knows of the existence of this topic. By
<a name="10140"></a>     *   default we assume this is true.
<a name="10141"></a>     */    
<a name="10142"></a>    familiar = true
<a name="10143"></a>    
<a name="10144"></a>    /*   Make this topic known to the player character */   
<a name="10145"></a>    setKnown() { gPlayerChar.setKnowsAbout(self); }
<a name="10146"></a>    
<a name="10147"></a>    /* Test whether this topic is known to the player character */
<a name="10148"></a>    known = (gPlayerChar.knowsAbout(self)) 
<a name="10149"></a>    
<a name="10150"></a>    /* 
<a name="10151"></a>     *   Return a textual description of this topic, which will normally be just
<a name="10152"></a>     *   its name. We use the vocab as fall-back alternative.
<a name="10153"></a>     */
<a name="10154"></a>    getTopicText()
<a name="10155"></a>    {
<a name="10156"></a>        return name == nil ? vocab : name;
<a name="10157"></a>    }
<a name="10158"></a>    
<a name="10159"></a>    /* For internal use by the parser; has the parser newly created us for its own purposes? */
<a name="10160"></a>    newlyCreated = nil
<a name="10161"></a>;
<a name="10162"></a>
<a name="10163"></a>/* Stub definitions to allow Actor to be modfied in actor.t */
<a name="10164"></a>class EndConvBlocker: object;
<a name="10165"></a>class AgendaManager: object;
<a name="10166"></a>class ActorTopicDatabase: TopicDatabase;
<a name="10167"></a>class TopicDatabase: object;
<a name="10168"></a>
<a name="10169"></a>
<a name="10170"></a>/* 
<a name="10171"></a> *   Very basic Actor class with a few basic properties defined. This allows code that need to
<a name="10172"></a> *   references the Actor class to compile in adv3Liter and adv3Litest. It also allows the Player
<a name="10173"></a> *   class to descend from Actor. The implementation here is replaced by the much more sophisticated
<a name="10174"></a> *   one in actor.t when actor.t is present.
<a name="10175"></a> */
<a name="10176"></a>class Actor: EndConvBlocker, AgendaManager, ActorTopicDatabase, Thing
<a name="10177"></a>    isFixed = true
<a name="10178"></a>    contType = Carrier
<a name="10179"></a>    ownsContents = true
<a name="10180"></a>    mood = nil
<a name="10181"></a>    stance = nil
<a name="10182"></a>    cannotTalkToMsg = BMsg(cannot talk basicactor, '{The subj cobj} {doesn\'t seem} interested. ')
<a name="10183"></a>    cannotGiveToMsg = cannotTalkToMsg
<a name="10184"></a>    cannotShowToMsg = cannotTalkToMsg
<a name="10185"></a>    isAttackable = true
<a name="10186"></a>    checkAttackMsg = cannotAttackMsg
<a name="10187"></a>    checkKissMsg = BMsg(not like kiss, '{The sub dobj} probably wouldn\'t {like|have liked} that. ')
<a name="10188"></a>;
<a name="10189"></a>
<a name="10190"></a>/* A Mood object can be used to represent the mood of an actor (happy, sad, bored, etc.) */
<a name="10191"></a>class Mood: object
<a name="10192"></a>    /* 
<a name="10193"></a>     *   A single-quoted string giving the name of this Mood, which will normally correspond to the
<a name="10194"></a>     *   name of the Mood object; e.g. happyMood.name = 'happy'
<a name="10195"></a>     */
<a name="10196"></a>    name = nil
<a name="10197"></a>    
<a name="10198"></a>    objToString() { return name; }
<a name="10199"></a>;
<a name="10200"></a>
<a name="10201"></a>
<a name="10202"></a>/* 
<a name="10203"></a> *   A Stance object can be used to represent the stance of an actor towards the player character
<a name="10204"></a> *   (neutral, friendly, hostile, etc.).
<a name="10205"></a> */
<a name="10206"></a>class Stance: object
<a name="10207"></a>    /* 
<a name="10208"></a>     *   A single-quoted string giving the name of this Stance which will normally correspond to the
<a name="10209"></a>     *   name of the Mood object; e.g. friendlyStance.name = 'friendly'
<a name="10210"></a>     */
<a name="10211"></a>    name = nil
<a name="10212"></a>    
<a name="10213"></a>    /* 
<a name="10214"></a>     *   The score is a measure of how positive or negative an actor with this stance is towards the
<a name="10215"></a>     *   player character. Each Stance object defines its own score.
<a name="10216"></a>     */
<a name="10217"></a>    score = 0
<a name="10218"></a>    
<a name="10219"></a>    operator &gt;&gt; (x) { return self.score &gt; x.score;  }
<a name="10220"></a>    operator &lt;&lt; (x) { return self.score &lt; x.score; }
<a name="10221"></a>    operator &gt;&gt;&gt; (x) { return self.score &gt;= x.score;  }
<a name="10222"></a>    operator []= (x, y) { x.setStanceToward(y, self); }
<a name="10223"></a>    
<a name="10224"></a>    
<a name="10225"></a>    objToString() { return name; }
<a name="10226"></a>;
<a name="10227"></a>
<a name="10228"></a>
<a name="10229"></a>/* ------------------------------------------------------------------------ */
<a name="10230"></a>/*
<a name="10231"></a> *   LocType objects are used for Thing.locType property values to specify
<a name="10232"></a> *   the relationship between an object and its container.
<a name="10233"></a> *   
<a name="10234"></a> *   The language module must set appropriate vocabulary properties for
<a name="10235"></a> *   each LocType object during pre-initialization.  The exact vocabulary
<a name="10236"></a> *   needed is up to the language to define.  For the English module, we
<a name="10237"></a> *   set the 'prep' property to a suitable preposition for constructing
<a name="10238"></a> *   locational phrases ("the book *on* the table", etc).  
<a name="10239"></a> */
<a name="10240"></a>class LocType: object
<a name="10241"></a>    
<a name="10242"></a>    listOrder = 100
<a name="10243"></a>;
<a name="10244"></a>
<a name="10245"></a>/*
<a name="10246"></a> *   An IntLocType is an interior location type.  These represent objects
<a name="10247"></a> *   on the inside of an enclosed space. 
<a name="10248"></a> */
<a name="10249"></a>IntLocType: LocType
<a name="10250"></a>    
<a name="10251"></a>;
<a name="10252"></a>
<a name="10253"></a>/*
<a name="10254"></a> *   An ExtLocType is an exterior location type.  These represent objects
<a name="10255"></a> *   on the outside of an object, such as atop it or attached to it. 
<a name="10256"></a> */
<a name="10257"></a>ExtLocType: LocType
<a name="10258"></a>;
<a name="10259"></a>
<a name="10260"></a>/* 
<a name="10261"></a> *   "In" location type - specifies that an object is contained within its
<a name="10262"></a> *   location; its location encloses it.
<a name="10263"></a> */
<a name="10264"></a>In: IntLocType
<a name="10265"></a>    listOrder = 10
<a name="10266"></a>;
<a name="10267"></a>
<a name="10268"></a>/*
<a name="10269"></a> *   "Outside" location type - specifies that an object is situated
<a name="10270"></a> *   somewhere on the exterior of the object.  This can be used for
<a name="10271"></a> *   components, attachments, things stuck to an object, things nailed to
<a name="10272"></a> *   it, messages painted on it, etc.  
<a name="10273"></a> */
<a name="10274"></a>Outside: ExtLocType
<a name="10275"></a>;
<a name="10276"></a>
<a name="10277"></a>/*
<a name="10278"></a> *   "On" location type - specifies that an object is sitting on the top
<a name="10279"></a> *   surface of its container.  
<a name="10280"></a> */
<a name="10281"></a>On: ExtLocType
<a name="10282"></a>    listOrder = 20
<a name="10283"></a>;
<a name="10284"></a>
<a name="10285"></a>/*
<a name="10286"></a> *   "Under" location type - specifies that an object is situated
<a name="10287"></a> *   underneath its container. 
<a name="10288"></a> */
<a name="10289"></a>Under: ExtLocType
<a name="10290"></a>    listOrder = 30
<a name="10291"></a>;
<a name="10292"></a>
<a name="10293"></a>/*
<a name="10294"></a> *   "Behind" location type - specifies that an object is situated behind
<a name="10295"></a> *   its container. 
<a name="10296"></a> */
<a name="10297"></a>Behind: ExtLocType
<a name="10298"></a>    listOrder = 40
<a name="10299"></a>;
<a name="10300"></a>
<a name="10301"></a>/*
<a name="10302"></a> *   "Held" location type - specifies that an object is being held by its
<a name="10303"></a> *   container, in the sense of a person holding an object in her hands.
<a name="10304"></a> *   An object being held is exterior to the holder, not enclosed.  
<a name="10305"></a> */
<a name="10306"></a>Held: ExtLocType
<a name="10307"></a>;
<a name="10308"></a>
<a name="10309"></a>/*
<a name="10310"></a> *   "Worn" location type - specifies that an object is being worn by its
<a name="10311"></a> *   container, in the sense of a person wearing a coat. 
<a name="10312"></a> */
<a name="10313"></a>Worn: ExtLocType
<a name="10314"></a>;
<a name="10315"></a>
<a name="10316"></a>/*  
<a name="10317"></a> *   "Attached" location type - specifies that an object is attached to its
<a name="10318"></a> *   container.
<a name="10319"></a> */
<a name="10320"></a>Attached: ExtLocType
<a name="10321"></a>;
<a name="10322"></a>    
<a name="10323"></a>/* 
<a name="10324"></a> *   "PartOf" location type - specifies that an object is part of -- a component
<a name="10325"></a> *   of -- its container.
<a name="10326"></a> */
<a name="10327"></a>PartOf: ExtLocType
<a name="10328"></a>;
<a name="10329"></a>
<a name="10330"></a>/*  
<a name="10331"></a> *   "Carrier" location type - specifies that the object is being carried by its
<a name="10332"></a> *   container (which will then normally be the actor holding this object). Any
<a name="10333"></a> *   actor-type object should define Carrier as its contType.
<a name="10334"></a> */
<a name="10335"></a>Carrier: ExtLocType
<a name="10336"></a>;
<a name="10337"></a>
<a name="10338"></a>/* 
<a name="10339"></a> *   A ViaType is an object used to define the preposition to use to describe
<a name="10340"></a> *   various kinds of PushTravel. The language-specific part of the libary needs
<a name="10341"></a> *   to override the various ViaType objects to give the names of the
<a name="10342"></a> *   prepositions in the target language.
<a name="10343"></a> */
<a name="10344"></a>class ViaType: object
<a name="10345"></a>    prep = ''
<a name="10346"></a>;
<a name="10347"></a>
<a name="10348"></a>Into: ViaType;
<a name="10349"></a>OutOf: ViaType;
<a name="10350"></a>Down: ViaType;
<a name="10351"></a>Up: ViaType;
<a name="10352"></a>Through: ViaType;
<a name="10353"></a>
<a name="10354"></a>/* 
<a name="10355"></a> *   The displayProbe object is used to store the result of capturing text in
<a name="10356"></a> *   Thing.checkDisplay() before undoing the trial display of the string. By
<a name="10357"></a> *   making displayProbe transient we preserve the value of its displayed
<a name="10358"></a> *   property across the undo.
<a name="10359"></a> */
<a name="10360"></a>transient displayProbe: object
<a name="10361"></a>    displayed = nil
<a name="10362"></a>;
<a name="10363"></a>
<a name="10364"></a>
<a name="10365"></a>/*  
<a name="10366"></a> *   The failVerifyObj is intended for internal library use only as a fallback value for gVerifyIobj
<a name="10367"></a> *   or gVerifyDobj when these might otherwise evailuate to nil and potentially cause nil object
<a name="10368"></a> *   reference runtime errors. Since this is never intended to be a valid verify result,
<a name="10369"></a> *   failVerifyObj is designed to fail the verify stage of any action.
<a name="10370"></a> */
<a name="10371"></a>
<a name="10372"></a>failVerifyObj: Thing
<a name="10373"></a>    dobjFor(Default) { verify {inaccessible(inaccessibleMsg);}}
<a name="10374"></a>    iobjFor(Default) { verify {inaccessible(inaccessibleMsg);}}    
<a name="10375"></a>    aobjFor(Default) { verify {inaccessible(inaccessibleMsg);}}   
<a name="10376"></a>    
<a name="10377"></a>    inaccessibleMsg = BMsg(dummy object inaccessible, 'The dummy failVerifyObj is not a valid object
<a name="10378"></a>        of a command. ')
<a name="10379"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/04/2024 from adv3Lite version 2.0</div>
</body>
</html>

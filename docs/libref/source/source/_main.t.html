<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>_main.t</title></head><body>
<table class=ban><tr><td><h1>_main.t</h1><td align=right><a href="../file/_main.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *   
<a name="6"></a> *   This module defines a number of low-level functions and classes that
<a name="7"></a> *   most TADS 3 programs will need, whether based on the adv3 library or
<a name="8"></a> *   not.  This module includes the main program entrypoint, the basic
<a name="9"></a> *   Exception classes, and the modular initialization framework.
<a name="10"></a> *   
<a name="11"></a> *   The compiler automatically links this module into every program by
<a name="12"></a> *   default, but you can override this by specifying the "-nodef" option
<a name="13"></a> *   to t3make.  If you remove this module, you'll have to provide your own
<a name="14"></a> *   implementations for many of the functions and classes defined here.  
<a name="15"></a> */
<a name="16"></a>
<a name="17"></a>#include "tads.h"
<a name="18"></a>#include "reflect.h"
<a name="19"></a>#include "strbuf.h"
<a name="20"></a>
<a name="21"></a>
<a name="22"></a>/* ------------------------------------------------------------------------ */
<a name="23"></a>/*
<a name="24"></a> *   Main program entrypoint.  The VM invokes this function at program
<a name="25"></a> *   startup.  
<a name="26"></a> */
<a name="27"></a>_main(args)
<a name="28"></a>{
<a name="29"></a>    /* call the common main entrypoint, with no startup file specified */
<a name="30"></a>    _mainCommon(args, nil);
<a name="31"></a>}
<a name="32"></a>
<a name="33"></a>/* declare 'main' as a function, in case it's not otherwise defined */
<a name="34"></a>extern function main;
<a name="35"></a>
<a name="36"></a>/*
<a name="37"></a> *   Main program entrypoint for restoring a saved state.  The VM invokes
<a name="38"></a> *   this function at startup instead of _main() when the user explicitly
<a name="39"></a> *   specifies a saved state file to restore when starting the program.
<a name="40"></a> *   (On a command-line interpreter, this would involve using a special
<a name="41"></a> *   option on the T3 interpreter command line; for a GUI shell, this
<a name="42"></a> *   might simply involve double-clicking on the desktop icon for a saved
<a name="43"></a> *   state file.)
<a name="44"></a> *   
<a name="45"></a> *   Note that we must export this as the 'mainRestore' symbol so that the
<a name="46"></a> *   interpreter knows how to find it.  
<a name="47"></a> */
<a name="48"></a>export _mainRestore 'mainRestore';
<a name="49"></a>_mainRestore(args, restoreFile)
<a name="50"></a>{
<a name="51"></a>    /* call the common main entrypoint */
<a name="52"></a>    _mainCommon(args, restoreFile);
<a name="53"></a>}
<a name="54"></a>
<a name="55"></a>/*
<a name="56"></a> *   Common main entrypoint.  This function can be called with or without
<a name="57"></a> *   a saved state file to restore.  
<a name="58"></a> */
<a name="59"></a>_mainCommon(args, restoreFile)
<a name="60"></a>{    
<a name="61"></a>    try
<a name="62"></a>    {
<a name="63"></a>        /* 
<a name="64"></a>         *   Keep going as long as we keep restarting.  Note that the
<a name="65"></a>         *   restoreFile only counts on the first iteration, so we clear it
<a name="66"></a>         *   out after each iteration; if we RESTART after that, we'll want
<a name="67"></a>         *   to just start the game from the beginning.  
<a name="68"></a>         */
<a name="69"></a>        for ( ; ; restoreFile = nil)
<a name="70"></a>        {
<a name="71"></a>            /* perform load-time initialization */
<a name="72"></a>            initAfterLoad();
<a name="73"></a>
<a name="74"></a>            /* if we're in preinit-only mode, we're done */
<a name="75"></a>            if (t3GetVMPreinitMode())
<a name="76"></a>                return;
<a name="77"></a>
<a name="78"></a>            /* catch any RESTART signals thrown out of the main entrypoint */
<a name="79"></a>            try
<a name="80"></a>            {
<a name="81"></a>                /* 
<a name="82"></a>                 *   If there's a saved state file to restore, call our
<a name="83"></a>                 *   mainRestore() function instead of main().  If
<a name="84"></a>                 *   mainRestore() isn't defined, show a message to this
<a name="85"></a>                 *   effect but keep going.  
<a name="86"></a>                 */
<a name="87"></a>                if (restoreFile != nil
<a name="88"></a>                    &amp;&amp; dataType(mainGlobal.mainRestoreFunc) == TypeFuncPtr)
<a name="89"></a>                {
<a name="90"></a>                    /* 
<a name="91"></a>                     *   Call the user's main startup-and-restore
<a name="92"></a>                     *   entrypoint function.  Note that we call indirectly
<a name="93"></a>                     *   through our function pointer so that we don't
<a name="94"></a>                     *   force a function called mainRestore() to be linked
<a name="95"></a>                     *   with the program.  
<a name="96"></a>                     */
<a name="97"></a>                    (mainGlobal.mainRestoreFunc)(args, restoreFile);
<a name="98"></a>                }
<a name="99"></a>                else
<a name="100"></a>                {
<a name="101"></a>                    /* 
<a name="102"></a>                     *   if we have a restore file but no mainRestore
<a name="103"></a>                     *   routine, explain to the user that they'll have to
<a name="104"></a>                     *   restore manually 
<a name="105"></a>                     */
<a name="106"></a>                    if (restoreFile != nil)
<a name="107"></a>                    {
<a name="108"></a>                        "\n[This program cannot restore the saved position
<a name="109"></a>                        file automatically.  Please try restoring the
<a name="110"></a>                        saved position file again using a command within
<a name="111"></a>                        the program.]\b";
<a name="112"></a>                    }
<a name="113"></a>
<a name="114"></a>                    /* call the selected main entrypoint */
<a name="115"></a>                    flexcall(&amp;main, args);
<a name="116"></a>                }
<a name="117"></a>
<a name="118"></a>                /* 
<a name="119"></a>                 *   we made it through the main entrypoint without a
<a name="120"></a>                 *   restart, so we're done 
<a name="121"></a>                 */
<a name="122"></a>                break;
<a name="123"></a>            }
<a name="124"></a>            catch (RestartSignal rsig)
<a name="125"></a>            {
<a name="126"></a>                /* 
<a name="127"></a>                 *   call the intrinsic restartGame function to reset all
<a name="128"></a>                 *   of the static objects to their initial state 
<a name="129"></a>                 */
<a name="130"></a>                restartGame();
<a name="131"></a>
<a name="132"></a>                /* 
<a name="133"></a>                 *   Now that we've reset the VM, update the restart ID in
<a name="134"></a>                 *   the main globals.  Note that we waited until now to do
<a name="135"></a>                 *   this, because this change would have been lost in the
<a name="136"></a>                 *   reset if we'd made the change before the reset.  Note
<a name="137"></a>                 *   also that the 'rsig' object itself will survive the
<a name="138"></a>                 *   reset because the thrower presumably allocated it
<a name="139"></a>                 *   dynamically, hence it's not a static object subject to
<a name="140"></a>                 *   reset.  
<a name="141"></a>                 */
<a name="142"></a>                mainGlobal.restartID = rsig.restartID;
<a name="143"></a>
<a name="144"></a>                /*
<a name="145"></a>                 *   Now we can just continue on to the next iteration of
<a name="146"></a>                 *   the restart loop.  This will take us back to the
<a name="147"></a>                 *   initialization and enter the game as though we'd just
<a name="148"></a>                 *   started the program again.  
<a name="149"></a>                 */
<a name="150"></a>            }
<a name="151"></a>        }
<a name="152"></a>    }
<a name="153"></a>    catch (ProgramException exc)
<a name="154"></a>    {
<a name="155"></a>        /* 
<a name="156"></a>         *   just re-throw these out to the VM, so that the VM exits to
<a name="157"></a>         *   the operating system with an error indication 
<a name="158"></a>         */
<a name="159"></a>        throw exc;
<a name="160"></a>    }
<a name="161"></a>    catch (Exception exc)
<a name="162"></a>    {
<a name="163"></a>        /* write output to the main console */
<a name="164"></a>        t3SetSay(_default_display_fn);
<a name="165"></a>        
<a name="166"></a>        /* display the unhandled exception */
<a name="167"></a>        "\n&lt;&lt;exc.displayException()&gt;&gt;\n";
<a name="168"></a>    }
<a name="169"></a>    finally
<a name="170"></a>    {
<a name="171"></a>        /* before exiting, call registered exit handlers */
<a name="172"></a>        mainAtExit.callHandlers();
<a name="173"></a>    }
<a name="174"></a>}
<a name="175"></a>
<a name="176"></a>/* ------------------------------------------------------------------------ */
<a name="177"></a>/*
<a name="178"></a> *   Flexible function call.  This calls the given function, passing as
<a name="179"></a> *   many arguments from the given argument list as the function actually
<a name="180"></a> *   wants.  If the list doesn't have enough arguments to satisfy the
<a name="181"></a> *   function's minimum requirements, we add 'nil' arguments to pad out the
<a name="182"></a> *   minimum.  If the list exceeds the function's maximum, we drop
<a name="183"></a> *   arguments past the maximum.
<a name="184"></a> */
<a name="185"></a>flexcall(func, [args])
<a name="186"></a>{
<a name="187"></a>    /* get the function's desired argument list */
<a name="188"></a>    local paramDesc = getFuncParams(func);
<a name="189"></a>
<a name="190"></a>    /* add or remove arguments as needed to fit the limits */
<a name="191"></a>    local n = args.length();
<a name="192"></a>    if (n &lt; paramDesc[1])
<a name="193"></a>    {
<a name="194"></a>        /* we need more to satisfy the minimum - add nil values */
<a name="195"></a>        args += makeList(nil, paramDesc[1] - n);
<a name="196"></a>    }
<a name="197"></a>    else if (n &gt; paramDesc[1] + paramDesc[2] &amp;&amp; !paramDesc[3])
<a name="198"></a>    {
<a name="199"></a>        /* 
<a name="200"></a>         *   the function doesn't take infinite arguments, and we have more
<a name="201"></a>         *   than it allows in the fixed plus optional parts, so drop the
<a name="202"></a>         *   extra elements 
<a name="203"></a>         */
<a name="204"></a>        args = args.sublist(1, paramDesc[1] + paramDesc[2]);
<a name="205"></a>    }
<a name="206"></a>
<a name="207"></a>    /* call the function */
<a name="208"></a>    func(args...);
<a name="209"></a>}
<a name="210"></a>
<a name="211"></a>/* ------------------------------------------------------------------------ */
<a name="212"></a>/*
<a name="213"></a> *   Restart signal.  This can be used to restart from the main
<a name="214"></a> *   entrypoint.  The caller should create one of these objects, then use
<a name="215"></a> *   restartGame() (or an equivalent from a different function set, if
<a name="216"></a> *   appropriate) to reset static object state to the initial program load
<a name="217"></a> *   conditions, then throw the signal object.  
<a name="218"></a> */
<a name="219"></a>class RestartSignal: Exception
<a name="220"></a>    construct()
<a name="221"></a>    {
<a name="222"></a>        /* 
<a name="223"></a>         *   use the next restart ID, so we can tell that we're on a fresh
<a name="224"></a>         *   run on this session 
<a name="225"></a>         */
<a name="226"></a>        restartID = mainGlobal.restartID + 1;
<a name="227"></a>    }
<a name="228"></a>;
<a name="229"></a>
<a name="230"></a>/* ------------------------------------------------------------------------ */
<a name="231"></a>/*
<a name="232"></a> *   General post-load initialization.  The main program entrypoint
<a name="233"></a> *   _main() calls this routine to set up the default display function,
<a name="234"></a> *   run pre-initialization if necessary, and run initialization.  This
<a name="235"></a> *   routine is also useful for the target of a restartGame() routine, to
<a name="236"></a> *   perform all of the basic load-time initialization again after a
<a name="237"></a> *   restart.  
<a name="238"></a> */
<a name="239"></a>initAfterLoad()
<a name="240"></a>{
<a name="241"></a>    /* establish the default display function */
<a name="242"></a>    t3SetSay(_default_display_fn);
<a name="243"></a>
<a name="244"></a>    /* if we haven't run preinit, do so now */
<a name="245"></a>    if (!mainGlobal.preinited_)
<a name="246"></a>    {
<a name="247"></a>        /* 
<a name="248"></a>         *   Explicitly run garbage collection prior to preinit.
<a name="249"></a>         *   
<a name="250"></a>         *   In most cases, this is unnecessary, but in some cases it's
<a name="251"></a>         *   important.  In particular, object loops (over all objects, or
<a name="252"></a>         *   over all instances of a given class) can still see otherwise
<a name="253"></a>         *   unreachable objects.  It's common to do object loops in
<a name="254"></a>         *   preinit to set up static data caches and tables and so on.  If
<a name="255"></a>         *   there *were* any garbage objects lying around, preinit could
<a name="256"></a>         *   find them via object loops, and might register them into
<a name="257"></a>         *   tables or what not.
<a name="258"></a>         *   
<a name="259"></a>         *   Even considering the preinit object loop, doing a garbage
<a name="260"></a>         *   collection sweep would *still* be redundant in most cases,
<a name="261"></a>         *   since preinit is normally done right after compilation, when
<a name="262"></a>         *   the program wouldn't yet have had a chance to create any
<a name="263"></a>         *   garbage objects to be worried about in object loops.  However,
<a name="264"></a>         *   there's still one more case to consider, and that's RESTART:
<a name="265"></a>         *   in a debug build, or even in some release builds, we'd have to
<a name="266"></a>         *   re-run preinit after a RESTART, and there certainly could be
<a name="267"></a>         *   garbage objects left around from before the RESTART.
<a name="268"></a>         *   
<a name="269"></a>         *   To ensure that we deal gracefully with this combination of
<a name="270"></a>         *   conditions - garbage objects, RESTART, and object loops in
<a name="271"></a>         *   preinit - simply do an explicit garbage collection run before
<a name="272"></a>         *   invoking preinit.  
<a name="273"></a>         */
<a name="274"></a>        t3RunGC();
<a name="275"></a>
<a name="276"></a>        /* run our internal preinit */
<a name="277"></a>        _preinit();
<a name="278"></a>        
<a name="279"></a>        /* remember that we've run preinit */
<a name="280"></a>        mainGlobal.preinited_ = true;
<a name="281"></a>    }
<a name="282"></a>
<a name="283"></a>    /* if we're not in preinit-only mode, run internal initialization */
<a name="284"></a>    if (!t3GetVMPreinitMode())
<a name="285"></a>        _init();
<a name="286"></a>}
<a name="287"></a>
<a name="288"></a>
<a name="289"></a>
<a name="290"></a>/* ------------------------------------------------------------------------ */
<a name="291"></a>/*
<a name="292"></a> *   Module Execution Object.  This is an abstract base class for various
<a name="293"></a> *   classes that provide modular execution hooks.  This class and its
<a name="294"></a> *   subclasses are mix-in classes - they can be multiply inherited by any
<a name="295"></a> *   object (as long as it's not already some other kind of module
<a name="296"></a> *   execution object).
<a name="297"></a> *   
<a name="298"></a> *   The point of the Module Execution Object and its subclasses is to
<a name="299"></a> *   allow libraries and user code to define execution hooks, without
<a name="300"></a> *   having to worry about what other libraries and user code bits are
<a name="301"></a> *   defining the same hook.  When we need to execute a hook defined via
<a name="302"></a> *   this object, we iterate over all of the instances of the appropriate
<a name="303"></a> *   subclass and invoke its execute() method.
<a name="304"></a> *   
<a name="305"></a> *   By default, the order of execution is arbitrary.  In some cases,
<a name="306"></a> *   though, dependencies will exist, so that one object cannot be invoked
<a name="307"></a> *   until another object has already been invoked.  In these cases, you
<a name="308"></a> *   must set the execBeforeMe property to contain a list of the objects
<a name="309"></a> *   whose execute() methods must be invoked before this object's
<a name="310"></a> *   execute() method is invoked.  The library will check this list before
<a name="311"></a> *   calling execute() on this object, and ensure that each object in the
<a name="312"></a> *   list has been invoked before calling this object's execute().  
<a name="313"></a> */
<a name="314"></a>class ModuleExecObject: object
<a name="315"></a>    /* 
<a name="316"></a>     *   List of objects that must be executed before me - by default, the
<a name="317"></a>     *   order doesn't matter, so we'll set this to an empty list.
<a name="318"></a>     *   Instances can override this if it is necessary to execute other
<a name="319"></a>     *   objects before this object can be executed.  
<a name="320"></a>     */
<a name="321"></a>    execBeforeMe = []
<a name="322"></a>
<a name="323"></a>    /*
<a name="324"></a>     *   List of objects that must be executed after me - this is
<a name="325"></a>     *   analogous to execBeforeMe, but we make sure we run before these. 
<a name="326"></a>     */
<a name="327"></a>    execAfterMe = []
<a name="328"></a>
<a name="329"></a>    /* 
<a name="330"></a>     *   Subclass-specific execution method.  Each subclass should
<a name="331"></a>     *   override this method to provide its execution code.  
<a name="332"></a>     */
<a name="333"></a>    execute() { }
<a name="334"></a>
<a name="335"></a>
<a name="336"></a>    /* 
<a name="337"></a>     *   PRIVATE METHODS AND PROPERTIES.  Subclasses and instances should
<a name="338"></a>     *   not need to override or invoke these.  
<a name="339"></a>     */
<a name="340"></a>
<a name="341"></a>    /* flag - true if we've been executed on this round */
<a name="342"></a>    isExecuted_ = nil
<a name="343"></a>
<a name="344"></a>    /* flag - true if we're in the process of executing */
<a name="345"></a>    isDoingExec_ = nil
<a name="346"></a>
<a name="347"></a>    /* execute - internal method: checks dependency order */
<a name="348"></a>    _execute()
<a name="349"></a>    {
<a name="350"></a>        /*
<a name="351"></a>         *   If I've already been executed, there's nothing more that I
<a name="352"></a>         *   need to do.  We might be called by the arbitrarily-ordered
<a name="353"></a>         *   iteration over all objects after we've already been executed,
<a name="354"></a>         *   because we might be executed explicitly by an object that
<a name="355"></a>         *   depends upon us if it's reached before we are.  
<a name="356"></a>         */
<a name="357"></a>        if (isExecuted_)
<a name="358"></a>            return;
<a name="359"></a>
<a name="360"></a>        /* 
<a name="361"></a>         *   If we're in the process of executing any of the objects we
<a name="362"></a>         *   depend upon, and a dependent calls us, we have a circular
<a name="363"></a>         *   dependency.  
<a name="364"></a>         */
<a name="365"></a>        if (isDoingExec_)
<a name="366"></a>            throw new CircularExecException(self);
<a name="367"></a>
<a name="368"></a>        /*
<a name="369"></a>         *   Mark ourselves as being in the process of executing.  If
<a name="370"></a>         *   there are any circular dependencies (i.e., if we depend on an
<a name="371"></a>         *   object, which in turn depends on us), it's clearly an error,
<a name="372"></a>         *   in that both objects can't be executed before the other.
<a name="373"></a>         *   This flag allows us to detect circular dependencies by
<a name="374"></a>         *   noticing if we're called by a dependent while we're in the
<a name="375"></a>         *   process of calling the things we depend upon.  
<a name="376"></a>         */
<a name="377"></a>        isDoingExec_ = true;
<a name="378"></a>        
<a name="379"></a>        /*
<a name="380"></a>         *   Check each entry in my 'before' list to ensure that they've
<a name="381"></a>         *   all been executed already.  Invoke execute() now for any that
<a name="382"></a>         *   haven't.  
<a name="383"></a>         */
<a name="384"></a>        for (local i = 1, local cnt = execBeforeMe.length() ;
<a name="385"></a>             i &lt;= cnt ; ++i)
<a name="386"></a>        {
<a name="387"></a>            local cur;
<a name="388"></a>
<a name="389"></a>            /* get this object */
<a name="390"></a>            cur = execBeforeMe[i];
<a name="391"></a>            
<a name="392"></a>            /* if this one hasn't been executed yet, do so now */
<a name="393"></a>            if (!cur.isExecuted_)
<a name="394"></a>            {
<a name="395"></a>                /* 
<a name="396"></a>                 *   This one hasn't been executed yet - explicitly
<a name="397"></a>                 *   execute it now.  Note that we do this recursively
<a name="398"></a>                 *   through the internal execution method, so that 'cur'
<a name="399"></a>                 *   has a chance to execute any objects that it depends
<a name="400"></a>                 *   upon.  
<a name="401"></a>                 */
<a name="402"></a>                cur._execute();
<a name="403"></a>            }
<a name="404"></a>        }
<a name="405"></a>
<a name="406"></a>        /* 
<a name="407"></a>         *   we've resolved all of our dependencies, so we're good to go -
<a name="408"></a>         *   run the user's execution code 
<a name="409"></a>         */
<a name="410"></a>        execute();
<a name="411"></a>
<a name="412"></a>        /* 
<a name="413"></a>         *   mark ourselves as having been executed, so we don't run the
<a name="414"></a>         *   user's code again should we be called again by a dependent or
<a name="415"></a>         *   by the global iteration loop later in the scan 
<a name="416"></a>         */
<a name="417"></a>        isExecuted_ = true;
<a name="418"></a>        isDoingExec_ = nil;
<a name="419"></a>    }
<a name="420"></a>
<a name="421"></a>    /* flag to indicate that this is the first time running classExec */
<a name="422"></a>    hasInitialized_ = nil
<a name="423"></a>
<a name="424"></a>    /*
<a name="425"></a>     *   Class execution.  Call this method on the particular class of
<a name="426"></a>     *   modules to execute.  We'll iterate over all instances of that
<a name="427"></a>     *   class and invoke each instance's _execute() method. 
<a name="428"></a>     */
<a name="429"></a>    classExec()
<a name="430"></a>    {
<a name="431"></a>        /*
<a name="432"></a>         *   If this is the first time running this classExec, turn
<a name="433"></a>         *   execAfterMe dependencies into appropriate execBeforeMe
<a name="434"></a>         *   dependencies.  
<a name="435"></a>         */
<a name="436"></a>        if (!hasInitialized_)
<a name="437"></a>        {
<a name="438"></a>            /* 
<a name="439"></a>             *   Go through all instances of this type of initializer, and
<a name="440"></a>             *   re-cast the execAfterMe lists as execBeforeMe lists.  
<a name="441"></a>             */
<a name="442"></a>            forEachInstance(self,
<a name="443"></a>                function(obj)
<a name="444"></a>                {
<a name="445"></a>                    foreach(local dependent in obj.execAfterMe)
<a name="446"></a>                        dependent.execBeforeMe += obj;
<a name="447"></a>                });
<a name="448"></a>
<a name="449"></a>            /* remember that we're now initialized */
<a name="450"></a>            hasInitialized_ = true;
<a name="451"></a>        }
<a name="452"></a>        
<a name="453"></a>        /* 
<a name="454"></a>         *   since we're starting a new round, clear all of the 'executed'
<a name="455"></a>         *   flags in all of the objects, to ensure that we execute all
<a name="456"></a>         *   objects on this round (this cleans up the flag settings from
<a name="457"></a>         *   any previous rounds) 
<a name="458"></a>         */
<a name="459"></a>        forEachInstance(self,
<a name="460"></a>            { obj: obj.isExecuted_ = obj.isDoingExec_ = nil });
<a name="461"></a>
<a name="462"></a>        /* execute all objects */
<a name="463"></a>        forEachInstance(self, { obj: obj._execute() });
<a name="464"></a>    }
<a name="465"></a>;
<a name="466"></a>
<a name="467"></a>/*
<a name="468"></a> *   Pre-Initialization object.  During pre-initialization, we'll invoke
<a name="469"></a> *   the execute() method on each instance of this class.  
<a name="470"></a> */
<a name="471"></a>class PreinitObject: ModuleExecObject
<a name="472"></a>    /*
<a name="473"></a>     *   Each instance of this object MUST override execute() with the
<a name="474"></a>     *   specific pre-initialization code that the instance wants to
<a name="475"></a>     *   perform.
<a name="476"></a>     *   
<a name="477"></a>     *   In addition, each instance can optionally set the property
<a name="478"></a>     *   execBeforeMe to a list of the other PreinitObject's that must be
<a name="479"></a>     *   invoked before this object is.  If this property is not set, this
<a name="480"></a>     *   object's place in the preinit execution order will be arbitrary.  
<a name="481"></a>     */
<a name="482"></a>;
<a name="483"></a>
<a name="484"></a>/*
<a name="485"></a> *   Initialization object.  During initialization, just before calling
<a name="486"></a> *   the user's main(args) function, we'll invoke the execute() method on
<a name="487"></a> *   each instance of this class. 
<a name="488"></a> */
<a name="489"></a>class InitObject: ModuleExecObject
<a name="490"></a>    /*
<a name="491"></a>     *   Each instance of this object MUST override execute() with the
<a name="492"></a>     *   specific initialization code that the instance wants to perform.
<a name="493"></a>     *   
<a name="494"></a>     *   In addition, each instance can optionally set the property
<a name="495"></a>     *   execBeforeMe to a list of the other InitObject's that must be
<a name="496"></a>     *   invoked before this object is.  If this property is not set, this
<a name="497"></a>     *   object's place in the initialization execution order will be
<a name="498"></a>     *   arbitrary.  
<a name="499"></a>     */
<a name="500"></a>;
<a name="501"></a>
<a name="502"></a>
<a name="503"></a>/*
<a name="504"></a> *   Exception: circular execution dependency in ModuleExecObject
<a name="505"></a> */
<a name="506"></a>class CircularExecException: Exception
<a name="507"></a>    construct(obj) { obj_ = obj; }
<a name="508"></a>    displayException()
<a name="509"></a>    {
<a name="510"></a>        "circular module dependency detected (refer to
<a name="511"></a>        ModuleExecObject._execute() in _main.t)";
<a name="512"></a>    }
<a name="513"></a>
<a name="514"></a>    /* 
<a name="515"></a>     *   The object that detected the circular dependency.  We can't use
<a name="516"></a>     *   this for much ourselves, but it might be useful to store this
<a name="517"></a>     *   information so that it's available to the programmer from within
<a name="518"></a>     *   the debugger.  
<a name="519"></a>     */
<a name="520"></a>    obj_ = nil
<a name="521"></a>;
<a name="522"></a>
<a name="523"></a>/*
<a name="524"></a> *   Library pre-initialization.  This is called immediately after
<a name="525"></a> *   compilation to pre-initialize the program.  Any changes made here to
<a name="526"></a> *   object states become part of the initial state stored in the image
<a name="527"></a> *   file, so this establishes the static initial state of the program.
<a name="528"></a> *   
<a name="529"></a> *   The advantage of doing work during pre-initialization is that this
<a name="530"></a> *   work is done once, during compilation, and is thus not repeated each
<a name="531"></a> *   time a user starts the program.  Time-consuming initialization work
<a name="532"></a> *   can thus be made invisible to the user.
<a name="533"></a> *   
<a name="534"></a> *   Note that the pre-initialization code should never do anything that
<a name="535"></a> *   involves the user interface, since this code runs during compilation
<a name="536"></a> *   and does not run again when users start the program.  So, anything
<a name="537"></a> *   that you want a user to see must be done during normal initialization
<a name="538"></a> *   (such as in the main() routine), not here.  
<a name="539"></a> */
<a name="540"></a>_preinit()
<a name="541"></a>{
<a name="542"></a>    local symtab;
<a name="543"></a>
<a name="544"></a>    /* try getting the mainRestore() function from the global symbol table */
<a name="545"></a>    if ((symtab = t3GetGlobalSymbols()) != nil)
<a name="546"></a>        mainGlobal.mainRestoreFunc = symtab['mainRestore'];
<a name="547"></a>
<a name="548"></a>    /* execute all preinit objects */
<a name="549"></a>    PreinitObject.classExec();
<a name="550"></a>}
<a name="551"></a>
<a name="552"></a>/*
<a name="553"></a> *   Library initialization.  This is called during each program start-up
<a name="554"></a> *   to initialize the program.  Since this is run each time the user
<a name="555"></a> *   starts the program, this can display any introductory messages, set
<a name="556"></a> *   up the user interface, and so on.  
<a name="557"></a> */
<a name="558"></a>_init()
<a name="559"></a>{
<a name="560"></a>    /* execute all init objects */
<a name="561"></a>    InitObject.classExec();
<a name="562"></a>}
<a name="563"></a>
<a name="564"></a>/* ------------------------------------------------------------------------ */
<a name="565"></a>/*
<a name="566"></a> *   For convenience, a simple object iterator function.  This function
<a name="567"></a> *   invokes a callback function for each instance of the given class, in
<a name="568"></a> *   arbitrary order.
<a name="569"></a> *   
<a name="570"></a> *   The callback is invoked with one argument, which gives the current
<a name="571"></a> *   instance.  The callback can "break" out of the loop by throwing a
<a name="572"></a> *   BreakLoopSignal, which can be done conveniently using the breakLoop
<a name="573"></a> *   macro.  
<a name="574"></a> */
<a name="575"></a>forEachInstance(cls, func)
<a name="576"></a>{
<a name="577"></a>    try
<a name="578"></a>    {
<a name="579"></a>        /* loop over all objects of the given class */
<a name="580"></a>        for (local obj = firstObj(cls) ; obj != nil ; obj = nextObj(obj, cls))
<a name="581"></a>            func(obj);
<a name="582"></a>    }
<a name="583"></a>    catch (BreakLoopSignal sig)
<a name="584"></a>    {
<a name="585"></a>        /* 
<a name="586"></a>         *   ignore the signal - it simply means we want to terminate the
<a name="587"></a>         *   loop and return to the caller 
<a name="588"></a>         */
<a name="589"></a>    }
<a name="590"></a>}
<a name="591"></a>
<a name="592"></a>/*
<a name="593"></a> *   Find an instance of the given class for which the given function
<a name="594"></a> *   returns true.  We iterate over objects of the given class in
<a name="595"></a> *   arbitrary order, and return the first instance for which the function
<a name="596"></a> *   returns true.  Retursn nil if there is no such instance.  
<a name="597"></a> */
<a name="598"></a>instanceWhich(cls, func)
<a name="599"></a>{
<a name="600"></a>    /* loop over all objects of the given class */
<a name="601"></a>    for (local obj = firstObj(cls) ; obj != nil ; obj = nextObj(obj, cls))
<a name="602"></a>    {
<a name="603"></a>        /* if the callback returns true for this object, return the object */
<a name="604"></a>        if (func(obj))
<a name="605"></a>            return obj;
<a name="606"></a>    }
<a name="607"></a>
<a name="608"></a>    /* 
<a name="609"></a>     *   we didn't find any instances for which the callback returns true;
<a name="610"></a>     *   indicate this by returning nil 
<a name="611"></a>     */
<a name="612"></a>    return nil;
<a name="613"></a>}
<a name="614"></a>
<a name="615"></a>/*
<a name="616"></a> *   An exception object for breaking out of a callback loop, such as
<a name="617"></a> *   forEachInstance. 
<a name="618"></a> */
<a name="619"></a>class BreakLoopSignal: Exception
<a name="620"></a>    displayException() { "loop break signal"; }
<a name="621"></a>;
<a name="622"></a>
<a name="623"></a>
<a name="624"></a>/* ------------------------------------------------------------------------ */
<a name="625"></a>/*
<a name="626"></a> *   Get the "translated" datatype of a value.  This is essentially the
<a name="627"></a> *   same as dataType(), except that anonymous function objects and dynamic
<a name="628"></a> *   function objects are treated as being "function pointer" types
<a name="629"></a> *   (TypeFuncPtr).  
<a name="630"></a> */
<a name="631"></a>dataTypeXlat(val)
<a name="632"></a>{
<a name="633"></a>    local t;
<a name="634"></a>
<a name="635"></a>    /* get the base type */
<a name="636"></a>    t = dataType(val);
<a name="637"></a>    
<a name="638"></a>    /* if it's an anonymous function, return TypeFuncPtr */
<a name="639"></a>    if (t == TypeObject
<a name="640"></a>        &amp;&amp; (val.ofKind(AnonFuncPtr)
<a name="641"></a>            || (defined(DynamicFunc) &amp;&amp; val.ofKind(DynamicFunc))))
<a name="642"></a>        return TypeFuncPtr;
<a name="643"></a>
<a name="644"></a>    /* otherwise, just return the base type */
<a name="645"></a>    return t;
<a name="646"></a>}
<a name="647"></a>
<a name="648"></a>/* ------------------------------------------------------------------------ */
<a name="649"></a>/*
<a name="650"></a> *   Base class for all exception objects.  We derive all exceptions from
<a name="651"></a> *   this base class so that we can write 'catch' blocks that catch all
<a name="652"></a> *   exceptions by catching 'Exception'.
<a name="653"></a> *   
<a name="654"></a> *   The displayException() method displays a message describing the
<a name="655"></a> *   exception.  Subclasses should override this method.  
<a name="656"></a> */
<a name="657"></a>class Exception: object
<a name="658"></a>    /* construct, with an optional message describing the error */
<a name="659"></a>    construct(msg?, ...)
<a name="660"></a>    {
<a name="661"></a>        /* if there's a message, save it, otherwise keep the default */
<a name="662"></a>        if (msg != nil)
<a name="663"></a>            errmsg_ = msg;
<a name="664"></a>    }
<a name="665"></a>
<a name="666"></a>    /* display the exception - should always be overridden */
<a name="667"></a>    displayException()
<a name="668"></a>    {
<a name="669"></a>        "&lt;&lt;errmsg_&gt;&gt;";
<a name="670"></a>    }
<a name="671"></a>
<a name="672"></a>    /* 
<a name="673"></a>     *   Get the exception message as a string.  This captures the output
<a name="674"></a>     *   of displayException() and returns it a string.  Use this instead
<a name="675"></a>     *   of accessing errmsg_, since that member is private and might not
<a name="676"></a>     *   reflect the actual displayed message. 
<a name="677"></a>     */
<a name="678"></a>    getExceptionMessage()
<a name="679"></a>    {
<a name="680"></a>        /* capture and return the displayed exception message as a string */
<a name="681"></a>        return _outputCapture({: displayException() });
<a name="682"></a>    }
<a name="683"></a>
<a name="684"></a>    /* 
<a name="685"></a>     *   Private member: The error message passed to the constructor, if
<a name="686"></a>     *   any.  Note that this doesn't necessarily contain the actual
<a name="687"></a>     *   displayed exception message, since displayException() can be
<a name="688"></a>     *   overridden in subclasses to display additional parameters or other
<a name="689"></a>     *   text entirely.  The definitive message is the one that
<a name="690"></a>     *   displayException() generates.  If you want the displayed message
<a name="691"></a>     *   as a string, use getExceptionMessage().  
<a name="692"></a>     */
<a name="693"></a>    errmsg_ = 'Unknown exception'
<a name="694"></a>
<a name="695"></a>    /* 
<a name="696"></a>     *   Display a stack trace, given a list of T3StackInfo objects.  Note
<a name="697"></a>     *   that, for efficiency, we do not by default cache a stack trace
<a name="698"></a>     *   when an exception occurs; individual subclasses can obtain a
<a name="699"></a>     *   stack trace if desired at construction and use the information to
<a name="700"></a>     *   show a stack trace for the exception. 
<a name="701"></a>     */
<a name="702"></a>    showStackTrace(stackList)
<a name="703"></a>    {
<a name="704"></a>        local haveSrc;
<a name="705"></a>
<a name="706"></a>        /* check to see if there's any source info in the stack trace */
<a name="707"></a>        haveSrc = nil;
<a name="708"></a>        foreach (local cur in stackList)
<a name="709"></a>        {
<a name="710"></a>            /* note if we have source info here */
<a name="711"></a>            if (cur.srcInfo_ != nil)
<a name="712"></a>            {
<a name="713"></a>                /* 
<a name="714"></a>                 *   we have source information - note it and stop
<a name="715"></a>                 *   searching, since even one bit of source info is
<a name="716"></a>                 *   enough to show the stack 
<a name="717"></a>                 */
<a name="718"></a>                haveSrc = true;
<a name="719"></a>                break;
<a name="720"></a>            }
<a name="721"></a>        }
<a name="722"></a>
<a name="723"></a>        /* 
<a name="724"></a>         *   if we have any source information at all, or we have
<a name="725"></a>         *   reflection services available to decode the stack trace
<a name="726"></a>         *   symbolically, show the stack 
<a name="727"></a>         */
<a name="728"></a>        if (haveSrc || mainGlobal.reflectionObj != nil)
<a name="729"></a>        {
<a name="730"></a>            for (local i = 1, local cnt = stackList.length() ; i &lt;= cnt ; ++i)
<a name="731"></a>            {
<a name="732"></a>                local cur = stackList[i];
<a name="733"></a>                
<a name="734"></a>                /* show a mark next to level 1, spaces elsewhere */
<a name="735"></a>                if (i == 1)
<a name="736"></a>                    "--&amp;gt;";
<a name="737"></a>                else
<a name="738"></a>                    "\ \ \ ";
<a name="739"></a>
<a name="740"></a>                /* 
<a name="741"></a>                 *   if there's a system reflection object, show symbolic
<a name="742"></a>                 *   information on the current function call; otherwise,
<a name="743"></a>                 *   simply show the source location 
<a name="744"></a>                 */
<a name="745"></a>                if (mainGlobal.reflectionObj != nil)
<a name="746"></a>                {
<a name="747"></a>                    /* reflection is available - show full symbolic info */
<a name="748"></a>                    "&lt;&lt;mainGlobal.reflectionObj.
<a name="749"></a>                      formatStackFrame(cur, true)&gt;&gt;";
<a name="750"></a>                }
<a name="751"></a>                else
<a name="752"></a>                {
<a name="753"></a>                    /* no reflection information - show source only */
<a name="754"></a>                    if (cur.srcInfo_ != nil)
<a name="755"></a>                        "&lt;&lt;cur.srcInfo_[1]&gt;&gt;, line &lt;&lt;cur.srcInfo_[2]&gt;&gt;";
<a name="756"></a>                    else if (cur.isSystem())
<a name="757"></a>                        "&amp;lt;System&amp;gt;";
<a name="758"></a>                    else
<a name="759"></a>                        "???";
<a name="760"></a>                }
<a name="761"></a>
<a name="762"></a>                /* end the line */
<a name="763"></a>                "\n";
<a name="764"></a>            }
<a name="765"></a>        }
<a name="766"></a>    }
<a name="767"></a>;
<a name="768"></a>
<a name="769"></a>
<a name="770"></a>/* ------------------------------------------------------------------------ */
<a name="771"></a>/*
<a name="772"></a> *   RuntimeError exception class.  The VM creates and throws an instance
<a name="773"></a> *   of this class when any run-time error occurs.  The VM explicitly sets
<a name="774"></a> *   the exceptionMessage property to a string giving the VM error message
<a name="775"></a> *   for the run-time error that occurred.  
<a name="776"></a> */
<a name="777"></a>class RuntimeError: Exception
<a name="778"></a>    construct(errno, ...)
<a name="779"></a>    {
<a name="780"></a>        /* remember the VM error number */
<a name="781"></a>        errno_ = errno;
<a name="782"></a>
<a name="783"></a>        /* 
<a name="784"></a>         *   Store a stack trace for the current location.  Always discard
<a name="785"></a>         *   the first element of the result, since this will reflect
<a name="786"></a>         *   RuntimeError.construct, which is obviously not interesting.  
<a name="787"></a>         */
<a name="788"></a>        stack_ = t3GetStackTrace().sublist(2);
<a name="789"></a>
<a name="790"></a>        /* 
<a name="791"></a>         *   The next element of the stack trace is usually a native code
<a name="792"></a>         *   frame, because the VM itself invokes our constructor in
<a name="793"></a>         *   response to a runtime exception; this is not an interesting
<a name="794"></a>         *   frame, so if it's present, remove it.  
<a name="795"></a>         */
<a name="796"></a>        if (stack_.length() &gt; 0 &amp;&amp; stack_[1].isSystem())
<a name="797"></a>            stack_ = stack_.sublist(2);
<a name="798"></a>    }
<a name="799"></a>
<a name="800"></a>    /* create a runtime error with a given error message */
<a name="801"></a>    newRuntimeError(errno, msg)
<a name="802"></a>    {
<a name="803"></a>        local e = new RuntimeError(errno);
<a name="804"></a>        e.exceptionMessage = msg;
<a name="805"></a>        return e;
<a name="806"></a>    }
<a name="807"></a>
<a name="808"></a>    /* display the exception */
<a name="809"></a>    displayException()
<a name="810"></a>    {
<a name="811"></a>        /* show the exception message */
<a name="812"></a>        "Runtime error: &lt;&lt;exceptionMessage&gt;&gt;\n";
<a name="813"></a>
<a name="814"></a>        /* show a stack trace if possible */
<a name="815"></a>        showStackTrace(stack_);
<a name="816"></a>    }
<a name="817"></a>
<a name="818"></a>    /* check to see if it's a debugger signal of some kind */
<a name="819"></a>    isDebuggerSignal()
<a name="820"></a>    {
<a name="821"></a>        return errno_ is in (
<a name="822"></a>            2391,                        /* debugger 'abort command' signal */
<a name="823"></a>            2392                               /* debugger 'restart' signal */
<a name="824"></a>        );
<a name="825"></a>    }
<a name="826"></a>
<a name="827"></a>    /* the VM error number of the exception */
<a name="828"></a>    errno_ = 0
<a name="829"></a>
<a name="830"></a>    /* the exception message, provided to us by the VM after creation */
<a name="831"></a>    exceptionMessage = ''
<a name="832"></a>
<a name="833"></a>    /* the stack trace, which we store at the time we're created */
<a name="834"></a>    stack_ = nil
<a name="835"></a>;
<a name="836"></a>
<a name="837"></a>/*
<a name="838"></a> *   Export our RuntimeError class so that the VM knows about it and can
<a name="839"></a> *   create instances of it.  Also export our exceptionMessage property,
<a name="840"></a> *   so the VM can store its explanatory text there.
<a name="841"></a> */
<a name="842"></a>export RuntimeError;
<a name="843"></a>export exceptionMessage;
<a name="844"></a>
<a name="845"></a>/*
<a name="846"></a> *   Unknown character set exception - this is thrown from any routine that
<a name="847"></a> *   needs a local character set mapping when no mapping exists on the local
<a name="848"></a> *   platform. 
<a name="849"></a> */
<a name="850"></a>class UnknownCharSetException: Exception
<a name="851"></a>    displayException = "Unknown character set"
<a name="852"></a>;
<a name="853"></a>
<a name="854"></a>/* 
<a name="855"></a> *   this exception object must be exported for use by the CharacterSet
<a name="856"></a> *   intrinsic class 
<a name="857"></a> */
<a name="858"></a>export UnknownCharSetException 'CharacterSet.UnknownCharSetException';
<a name="859"></a>
<a name="860"></a>
<a name="861"></a>/*
<a name="862"></a> *   A Program Exception terminates the entire program, passing an error
<a name="863"></a> *   indication to the operating system.  The VM doesn't provide a way to
<a name="864"></a> *   specify the *particular* error code to return to the OS, as there's no
<a name="865"></a> *   portable set of error codes; rather, the VM simply returns a code to
<a name="866"></a> *   the OS that means generically that an error occurred, if there's any
<a name="867"></a> *   such concept on the local operating system.  The VM will normally
<a name="868"></a> *   display this message just before it terminates the program, possibly
<a name="869"></a> *   with some additional text mentioning that a program error occurred
<a name="870"></a> *   (such as "unhandled exception: &lt;your message&gt;").
<a name="871"></a> */
<a name="872"></a>class ProgramException: Exception
<a name="873"></a>    construct(msg) { exceptionMessage = msg.htmlify(); }
<a name="874"></a>    displayException() { "&lt;&lt;exceptionMessage&gt;&gt; "; }
<a name="875"></a>;
<a name="876"></a>
<a name="877"></a>/*
<a name="878"></a> *   A StorageServerError is thrown when a file operation on a remote
<a name="879"></a> *   storage server fails.  The storage server is used when the game runs
<a name="880"></a> *   on a Web game server in client/server mode.  In Web mode, files are
<a name="881"></a> *   stored on a separate storage server rather than on the Web server
<a name="882"></a> *   itself, so that the files can be transparently accessed if the game is
<a name="883"></a> *   continued from another Web server.  This exception is used when a
<a name="884"></a> *   request to the storage server fails, which could be due to an error on
<a name="885"></a> *   the storage server, a network error communicating between the game
<a name="886"></a> *   server and the storage server, or an invalid request (e.g., incorrect
<a name="887"></a> *   user credentials).  
<a name="888"></a> */
<a name="889"></a>class StorageServerError: RuntimeError
<a name="890"></a>    construct(errno, msg)
<a name="891"></a>    {
<a name="892"></a>        /* 
<a name="893"></a>         *   Do the base class construction.  Note that errno is the
<a name="894"></a>         *   VM-level error number, which is usually just the generic
<a name="895"></a>         *   "storage server error" code.  The storage server provides a
<a name="896"></a>         *   separate, more specific error code of its own as the first
<a name="897"></a>         *   token of the message string.  
<a name="898"></a>         */
<a name="899"></a>        inherited(errno);
<a name="900"></a>        
<a name="901"></a>        /* 
<a name="902"></a>         *   storage server error messages are formatted with an error code
<a name="903"></a>         *   as the first space-delimited token, and a human-readable
<a name="904"></a>         *   message following 
<a name="905"></a>         */
<a name="906"></a>        local sp = msg.find(' ');
<a name="907"></a>        errCode = msg.substr(1, sp - 1);
<a name="908"></a>        msg = msg.substr(sp + 1);
<a name="909"></a>
<a name="910"></a>        /* 
<a name="911"></a>         *   If the error code is a negative integer, it's an error on the
<a name="912"></a>         *   client side sending the HTTP request to the storage server.
<a name="913"></a>         *   If it's a positive integer, it's an HTTP error code from the
<a name="914"></a>         *   storage server.  Otherwise it's an error abbreviation token
<a name="915"></a>         *   from the server. 
<a name="916"></a>         */
<a name="917"></a>        local errNum = toInteger(errCode);
<a name="918"></a>        if (errNum &lt; 0)
<a name="919"></a>        {
<a name="920"></a>            local reqErrs = [
<a name="921"></a>                -1 -&gt; 'out of memory',
<a name="922"></a>                -2 -&gt; 'unable to connect',
<a name="923"></a>                -3 -&gt; 'network error',
<a name="924"></a>                -4 -&gt; 'invalid parameters',
<a name="925"></a>                -5 -&gt; 'error reading temporary file',
<a name="926"></a>                -6 -&gt; 'error writing temporary file',
<a name="927"></a>                * -&gt; 'error code &lt;&lt;errNum&gt;&gt;'
<a name="928"></a>            ];
<a name="929"></a>            errMsg = reqErrs[errNum];
<a name="930"></a>        }
<a name="931"></a>        else if (errNum &gt; 0)
<a name="932"></a>            errMsg = 'HTTP error (status code &lt;&lt;errCode&gt;&gt;)';
<a name="933"></a>        else
<a name="934"></a>            errMsg = msg;
<a name="935"></a>    }
<a name="936"></a>
<a name="937"></a>    /* the storage server error code */
<a name="938"></a>    errCode = nil
<a name="939"></a>
<a name="940"></a>    /* 
<a name="941"></a>     *   error message - this is the message text we get back from the
<a name="942"></a>     *   storage server for a request that's successful at the HTTP level
<a name="943"></a>     *   but fails on the storage server, OR a message describing the HTTP
<a name="944"></a>     *   error or network error that caused the request to fail 
<a name="945"></a>     */
<a name="946"></a>    errMsg = 'no details available'
<a name="947"></a>
<a name="948"></a>    /* display the exception */
<a name="949"></a>    displayException()
<a name="950"></a>    {
<a name="951"></a>        /* show the exception message */
<a name="952"></a>        "Storage server error: &lt;&lt;errMsg&gt;&gt;\n";
<a name="953"></a>
<a name="954"></a>        /* show a stack trace if possible */
<a name="955"></a>        showStackTrace(stack_);
<a name="956"></a>    }
<a name="957"></a>;
<a name="958"></a>
<a name="959"></a>/* export this for use by the interpreter networking package */
<a name="960"></a>export StorageServerError 'StorageServerError';
<a name="961"></a>
<a name="962"></a>
<a name="963"></a>/* ------------------------------------------------------------------------ */
<a name="964"></a>/*
<a name="965"></a> *   Default string display function.  Our main entrypoint code
<a name="966"></a> *   establishes this function as the default output function.  
<a name="967"></a> */
<a name="968"></a>_default_display_fn(str) { _tads_io_say(str); }
<a name="969"></a>
<a name="970"></a>/*
<a name="971"></a> *   Raw output capture.  This bypasses any filtering and directly captures
<a name="972"></a> *   any output generated by the callback. 
<a name="973"></a> */
<a name="974"></a>_outputCapture(func)
<a name="975"></a>{
<a name="976"></a>    /* temporarily set the low-level string output to capture output */
<a name="977"></a>    local buf = new StringBuffer();
<a name="978"></a>    local oldSay = t3SetSay({str: buf.append(str)});
<a name="979"></a>
<a name="980"></a>    /* make sure we restore the "say" function on the way out */
<a name="981"></a>    try
<a name="982"></a>    {
<a name="983"></a>        /* call the callback in the new capture context */
<a name="984"></a>        func();
<a name="985"></a>
<a name="986"></a>        /* return the captured data */
<a name="987"></a>        return toString(buf);
<a name="988"></a>    }
<a name="989"></a>    finally
<a name="990"></a>    {
<a name="991"></a>        /* restore the old "say" function */
<a name="992"></a>        t3SetSay(oldSay);
<a name="993"></a>    }
<a name="994"></a>}
<a name="995"></a>
<a name="996"></a>
<a name="997"></a>/* ------------------------------------------------------------------------ */
<a name="998"></a>/*
<a name="999"></a> *   The stack information object.  The intrinsic function
<a name="1000"></a> *   t3GetStackTrace() in the 't3vm' function set returns a list of these
<a name="1001"></a> *   objects; each object represents a level in the stack trace.  
<a name="1002"></a> */
<a name="1003"></a>class T3StackInfo: object
<a name="1004"></a>    /*
<a name="1005"></a>     *   Construct a stack level object.  The system invokes this
<a name="1006"></a>     *   constructor with information on the stack level.
<a name="1007"></a>     */
<a name="1008"></a>    construct(func, obj, prop, selfObj, argList, srcInfo,
<a name="1009"></a>              locals, namedArgs, frameDesc)
<a name="1010"></a>    {
<a name="1011"></a>        /* remember the values */
<a name="1012"></a>        func_ = func;
<a name="1013"></a>        obj_ = obj;
<a name="1014"></a>        prop_ = prop;
<a name="1015"></a>        self_ = selfObj;
<a name="1016"></a>        argList_ = argList;
<a name="1017"></a>        srcInfo_ = srcInfo;
<a name="1018"></a>        locals_ = locals;
<a name="1019"></a>        namedArgs_ = namedArgs;
<a name="1020"></a>        frameDesc_ = frameDesc;
<a name="1021"></a>    }
<a name="1022"></a>
<a name="1023"></a>    /*
<a name="1024"></a>     *   Is this a system routine?  This returns true if an intrinsic
<a name="1025"></a>     *   function or an intrinsic class method is running at this level. 
<a name="1026"></a>     */
<a name="1027"></a>    isSystem()
<a name="1028"></a>    {
<a name="1029"></a>        /*
<a name="1030"></a>         *   It's a system function if:
<a name="1031"></a>         *   
<a name="1032"></a>         *   - we have NEITHER a function nor a method
<a name="1033"></a>         *.  - the function is a built-in function pointer
<a name="1034"></a>         *.  - the defining object is an intrinsic class
<a name="1035"></a>         *   
<a name="1036"></a>         *   The first case applies to pre-3.0.19 VMs, where no information
<a name="1037"></a>         *   was available for native callers.  Starting in 3.0.19, full
<a name="1038"></a>         *   information is available.  
<a name="1039"></a>         */
<a name="1040"></a>        return ((func_ == nil &amp;&amp; obj_ == nil)
<a name="1041"></a>                || dataType(func_) == TypeBifPtr
<a name="1042"></a>                || (obj_ != nil &amp;&amp; IntrinsicClass.isIntrinsicClass(obj_)));
<a name="1043"></a>    }
<a name="1044"></a>
<a name="1045"></a>    /* 
<a name="1046"></a>     *   the function running at this stack level - this is nil if an
<a name="1047"></a>     *   object property is running instead of a function 
<a name="1048"></a>     */
<a name="1049"></a>    func_ = nil
<a name="1050"></a>
<a name="1051"></a>    /* 
<a name="1052"></a>     *   The object and property running at this stack level - these are
<a name="1053"></a>     *   nil if a function is running instead of an object method.  The
<a name="1054"></a>     *   object is the object where the method is actually defined - this
<a name="1055"></a>     *   might not be the same as self, because the object might have
<a name="1056"></a>     *   inherited the method from a base class.  
<a name="1057"></a>     */
<a name="1058"></a>    obj_ = nil
<a name="1059"></a>    prop_ = nil
<a name="1060"></a>
<a name="1061"></a>    /* 
<a name="1062"></a>     *   the 'self' object at this level - this is nil if a function is
<a name="1063"></a>     *   running at this level instead of an object method 
<a name="1064"></a>     */
<a name="1065"></a>    self_ = nil
<a name="1066"></a>
<a name="1067"></a>    /* 
<a name="1068"></a>     *   The list of positional arguments to the function or method.  Each
<a name="1069"></a>     *   element is the value of an argument; the list is arranged in the
<a name="1070"></a>     *   same order as the arguments. 
<a name="1071"></a>     */
<a name="1072"></a>    argList_ = []
<a name="1073"></a>
<a name="1074"></a>    /*
<a name="1075"></a>     *   Local variables.  This is a LookupTable containing the local
<a name="1076"></a>     *   variables currently in scope at this stack level.  Each element in
<a name="1077"></a>     *   the table has a string key (index) giving the name of the local
<a name="1078"></a>     *   variable, and each corresponding value is the local's current
<a name="1079"></a>     *   value.  The table is only included when the stack listing was
<a name="1080"></a>     *   produced by a call to t3GetStackTrace() with the T3GetStackLocals
<a name="1081"></a>     *   flag set; otherwise it's nil.  If the locals were requested, and
<a name="1082"></a>     *   the stack level has no local variables, this will be an empty
<a name="1083"></a>     *   lookup table.  
<a name="1084"></a>     */
<a name="1085"></a>    locals_ = nil
<a name="1086"></a>
<a name="1087"></a>    /*
<a name="1088"></a>     *   Named arguments.  This is a LookupTable containing the named
<a name="1089"></a>     *   arguments passed in from this stack level.  Each element in the
<a name="1090"></a>     *   table has a string key (index) giving the name of the argument,
<a name="1091"></a>     *   and each corresponding value is the value of that argument.  If
<a name="1092"></a>     *   there are no named arguments, this value is nil.  
<a name="1093"></a>     */
<a name="1094"></a>    namedArgs_ = nil
<a name="1095"></a>
<a name="1096"></a>    /*
<a name="1097"></a>     *   The source location of the next code to be executed in the
<a name="1098"></a>     *   function or method in this frame.  If source-level debugging
<a name="1099"></a>     *   information is available for the current execution point in this
<a name="1100"></a>     *   frame, this will contain a list of two values:
<a name="1101"></a>     *   
<a name="1102"></a>     *   srcInfo_[1] = string giving the name of the source file
<a name="1103"></a>     *.  srcInfo_[2] = integer giving the line number in the source file
<a name="1104"></a>     *   
<a name="1105"></a>     *   If the program wasn't compiled with source-level debugging
<a name="1106"></a>     *   information, or the current code location in the frame doesn't
<a name="1107"></a>     *   have any source information, this will be set to nil.
<a name="1108"></a>     *   
<a name="1109"></a>     *   Note that the location reflected here is the *return address* in
<a name="1110"></a>     *   this frame - that is, the code location that will be executed when
<a name="1111"></a>     *   control returns to the frame.  This means that the source location
<a name="1112"></a>     *   will frequently appear as the next executable line after the one
<a name="1113"></a>     *   that called the next inner frame, because this is where execution
<a name="1114"></a>     *   will resume when control returns to the frame.  
<a name="1115"></a>     */
<a name="1116"></a>    srcInfo_ = nil
<a name="1117"></a>
<a name="1118"></a>    /*
<a name="1119"></a>     *   A StackFrameDesc object that can be used to get information from
<a name="1120"></a>     *   the frame and change local variables in the frame.  
<a name="1121"></a>     */
<a name="1122"></a>    frameDesc_ = nil
<a name="1123"></a>;
<a name="1124"></a>
<a name="1125"></a>/* export T3StackInfo for use by the system */
<a name="1126"></a>export T3StackInfo;
<a name="1127"></a>
<a name="1128"></a>
<a name="1129"></a>/* ------------------------------------------------------------------------ */
<a name="1130"></a>/*
<a name="1131"></a> *   Stream state object for String.specialsToHtml().
<a name="1132"></a> */
<a name="1133"></a>class SpecialsToHtmlState: object
<a name="1134"></a>    /* 
<a name="1135"></a>     *   Reset the state.  This should be used when the output stream
<a name="1136"></a>     *   context is reset, such as when clearing the window.  
<a name="1137"></a>     */
<a name="1138"></a>    resetState()
<a name="1139"></a>    {
<a name="1140"></a>        flags_ = 0;
<a name="1141"></a>        tag_ = '';
<a name="1142"></a>    }
<a name="1143"></a>
<a name="1144"></a>    /* 
<a name="1145"></a>     *   Explicitly reset to the start of a line.  This can be called after
<a name="1146"></a>     *   a non-output operation that resets the line position, such as
<a name="1147"></a>     *   reading an input line.  
<a name="1148"></a>     */
<a name="1149"></a>    resetLine()
<a name="1150"></a>    {
<a name="1151"></a>        /* reset the in-line flag, space flag, qspace flag, and tab column */
<a name="1152"></a>        flags_ &amp;= ~(0x0001 | 0x0040 | 0x0080 | 0x0300);
<a name="1153"></a>    }
<a name="1154"></a>
<a name="1155"></a>    /* 
<a name="1156"></a>     *   Internal output state flags at end of last string parsed.  This is
<a name="1157"></a>     *   a combination of bit flags:
<a name="1158"></a>     *   
<a name="1159"></a>     *   0x0001 - last string ended within a line of text
<a name="1160"></a>     *.  0x0002 - caps flag '\^' pending
<a name="1161"></a>     *.  0x0004 - lowercase flag '\v' pending
<a name="1162"></a>     *.  0x0008 - last string ended within an HTML tag
<a name="1163"></a>     *.  0x0010 - last string ended in double-quoted HTML tag attribute text
<a name="1164"></a>     *.  0x0020 - last string ended in single-quoted HTML tag attribute text
<a name="1165"></a>     *.  0x0040 - last string ended with an ordinary space
<a name="1166"></a>     *.  0x0080 - last string ended with a quoted space '\ '
<a name="1167"></a>     *.  0x0100 - &lt;Q&gt; parity level: 0=double quotes, 1=single quotes
<a name="1168"></a>     *.  0x0300 - distance from last '\t' tab column (0..3)
<a name="1169"></a>     */
<a name="1170"></a>    flags_ = 0
<a name="1171"></a>
<a name="1172"></a>    /* tag in progress at end of last string parsed */
<a name="1173"></a>    tag_ = ''
<a name="1174"></a>;
<a name="1175"></a>    
<a name="1176"></a>
<a name="1177"></a>
<a name="1178"></a>/* ------------------------------------------------------------------------ */
<a name="1179"></a>/*
<a name="1180"></a> *   global data object for this module
<a name="1181"></a> */
<a name="1182"></a>mainGlobal: object
<a name="1183"></a>    /* flag: we've run pre-initialization */
<a name="1184"></a>    preinited_ = nil
<a name="1185"></a>
<a name="1186"></a>    /* 
<a name="1187"></a>     *   The global reflection object - if the program is compiled with
<a name="1188"></a>     *   the standard reflection module, that module will set this
<a name="1189"></a>     *   property to point to the reflection object.
<a name="1190"></a>     *   
<a name="1191"></a>     *   We use this so that we don't require the reflection module to be
<a name="1192"></a>     *   included.  If the module isn't included, this will be nil, so
<a name="1193"></a>     *   we'll know not to use reflection.  If this is not nil, we'll know
<a name="1194"></a>     *   we can use reflection services.  
<a name="1195"></a>     */
<a name="1196"></a>    reflectionObj = nil
<a name="1197"></a>
<a name="1198"></a>    /*
<a name="1199"></a>     *   Restart ID.  This is an integer that indicates how the main
<a name="1200"></a>     *   entrypoint was last reached.  This is initially zero; each time
<a name="1201"></a>     *   we restart the game, this is incremented.
<a name="1202"></a>     *   
<a name="1203"></a>     *   The restart ID is the only information that survives across a
<a name="1204"></a>     *   restart boundary.  Other than this, entering via a restart is
<a name="1205"></a>     *   exactly like loading the program from scratch; all other
<a name="1206"></a>     *   information about the program state before the restart is lost in
<a name="1207"></a>     *   the restart operation.  
<a name="1208"></a>     */
<a name="1209"></a>    restartID = 0
<a name="1210"></a>
<a name="1211"></a>    /* pointer to mainRestore function, if defined */
<a name="1212"></a>    mainRestoreFunc = nil
<a name="1213"></a>;
<a name="1214"></a>
<a name="1215"></a>/* ------------------------------------------------------------------------ */
<a name="1216"></a>/*
<a name="1217"></a> *   At-exit handlers.  This is a registry for custom handlers that are to
<a name="1218"></a> *   be invoked just before the program terminates.  
<a name="1219"></a> */
<a name="1220"></a>transient mainAtExit: object
<a name="1221"></a>    /*
<a name="1222"></a>     *   Add an at-exit handler.  User code can call this to register a
<a name="1223"></a>     *   handler that will be invoked just before the program exits. 
<a name="1224"></a>     */
<a name="1225"></a>    addHandler(func)
<a name="1226"></a>    {
<a name="1227"></a>        handlers.append(func);
<a name="1228"></a>    }
<a name="1229"></a>
<a name="1230"></a>    /* call our exit handlers */
<a name="1231"></a>    callHandlers()
<a name="1232"></a>    {
<a name="1233"></a>        /* call each handler in the list */
<a name="1234"></a>        foreach (local f in handlers)
<a name="1235"></a>        {
<a name="1236"></a>            try
<a name="1237"></a>            {
<a name="1238"></a>                /* call this handler */
<a name="1239"></a>                f();
<a name="1240"></a>            }
<a name="1241"></a>            catch (Exception exc)
<a name="1242"></a>            {
<a name="1243"></a>                /* display and ignore any exceptions it throws */
<a name="1244"></a>                "\nError in exit handler: &lt;&lt;exc.displayException()&gt;&gt;\n";
<a name="1245"></a>            }
<a name="1246"></a>        }
<a name="1247"></a>    }
<a name="1248"></a>
<a name="1249"></a>    /* list of exit handlers */
<a name="1250"></a>    handlers = static new Vector()
<a name="1251"></a>;
<a name="1252"></a>
<a name="1253"></a>/* ------------------------------------------------------------------------ */
<a name="1254"></a>/*
<a name="1255"></a> *   &lt;&lt;one of&gt;&gt; index generator.  The compiler generates an anonymous
<a name="1256"></a> *   instance of this class for each &lt;&lt;one of&gt;&gt; list in string, setting the
<a name="1257"></a> *   property 'numItems' to the number of items in the list, and
<a name="1258"></a> *   'listAttrs' property to a string giving the sequence type.  The
<a name="1259"></a> *   compiler generates a call to getNextIndex() within the string to get
<a name="1260"></a> *   the next index value, which is an integer from 1 to numItems.  
<a name="1261"></a> */
<a name="1262"></a>class OneOfIndexGen: object
<a name="1263"></a>    /* number of list items */
<a name="1264"></a>    numItems = 1
<a name="1265"></a>
<a name="1266"></a>    /* 
<a name="1267"></a>     *   List attributes.  This is a string with a comma-delimited list of
<a name="1268"></a>     *   tokens describing the treatment on the list for each fetch.  The
<a name="1269"></a>     *   first call to getNextIndex() takes the first token off the list
<a name="1270"></a>     *   and generates an appropriate return value, possibly queuing up a
<a name="1271"></a>     *   list of future values.  The next call to getNextIndex() reads from
<a name="1272"></a>     *   the queue.  Once the queue is exhausted, the next call takes the
<a name="1273"></a>     *   second token off the attribute list and repeats the process.  Once
<a name="1274"></a>     *   the attribute list is down to one token, we don't remove the
<a name="1275"></a>     *   token, but simply repeat it forever.
<a name="1276"></a>     *   
<a name="1277"></a>     *   For example, 'seq,rand' runs through the entire list in sequence
<a name="1278"></a>     *   once, then generates independently random values from then on.
<a name="1279"></a>     *   'shuffle,stop' runs through the list once in shuffled order, then
<a name="1280"></a>     *   repeats the last pick from the shuffled list forever.
<a name="1281"></a>     *   
<a name="1282"></a>     *   The individual attribute values are:
<a name="1283"></a>     *   
<a name="1284"></a>     *   rand - pick an item at random, independently of past selections.
<a name="1285"></a>     *   
<a name="1286"></a>     *   rand-norpt - pick an item at random, but don't pick the single
<a name="1287"></a>     *   most recent item chosen, to avoid repeating the same thing twice
<a name="1288"></a>     *   in a row.
<a name="1289"></a>     *   
<a name="1290"></a>     *   rand-wt - pick an item by random, weighting the items with
<a name="1291"></a>     *   decreasing probabilities.  The last item is given relative weight
<a name="1292"></a>     *   1, the second to last weight 2, the third to last weight 3, etc.
<a name="1293"></a>     *   In other words, the nth item from the end of the list is n times
<a name="1294"></a>     *   as likely to be picked as the last item.  The picks are
<a name="1295"></a>     *   independent.
<a name="1296"></a>     *   
<a name="1297"></a>     *   seq - run through the items in sequence (1, 2, ... numItems).
<a name="1298"></a>     *   
<a name="1299"></a>     *   shuffle - run through the list in a shuffled order.
<a name="1300"></a>     *   
<a name="1301"></a>     *   shuffle2 - shuffle the list into a random order, but only run
<a name="1302"></a>     *   through half before reshuffling
<a name="1303"></a>     *   
<a name="1304"></a>     *   stop - repeat the previous selection forever.  (This should only
<a name="1305"></a>     *   be used as the second or later attribute in the list, since it
<a name="1306"></a>     *   depends on a prior selection being made.)  
<a name="1307"></a>     */
<a name="1308"></a>    listAttrs = ''
<a name="1309"></a>
<a name="1310"></a>    /* 
<a name="1311"></a>     *   Get the next index value.  Returns an integer from 1 to numItems.
<a name="1312"></a>     *   The algorithm for choosing the index depends on the list type, as
<a name="1313"></a>     *   defined by listAttrs.  
<a name="1314"></a>     */
<a name="1315"></a>    getNextIndex()
<a name="1316"></a>    {
<a name="1317"></a>        /* if we're out of items, generate the next iteration of the list */
<a name="1318"></a>        if (idx_ &gt; lst_.length())
<a name="1319"></a>        {
<a name="1320"></a>            /* pull out the first item from the attributes */
<a name="1321"></a>            local alst = listAttrs.split(',', 2);
<a name="1322"></a>
<a name="1323"></a>            /* 
<a name="1324"></a>             *   If we have more than one attribute, keep only the
<a name="1325"></a>             *   remaining attributes, since the first attribute is for the
<a name="1326"></a>             *   first list iteration only. 
<a name="1327"></a>             */
<a name="1328"></a>            if (alst.length() &gt; 1)
<a name="1329"></a>                listAttrs = alst[2];
<a name="1330"></a>
<a name="1331"></a>            /* some of the attributes are interested in the last item */
<a name="1332"></a>            local last = lst_.length() &gt;= 1 ? lst_[lst_.length()] : nil;
<a name="1333"></a>
<a name="1334"></a>            /* build the list for the head attribute */
<a name="1335"></a>            local pick;
<a name="1336"></a>            switch (alst[1])
<a name="1337"></a>            {
<a name="1338"></a>            case 'stop':
<a name="1339"></a>                /* reuse the last item every time from now on */
<a name="1340"></a>                lst_ = [last ?? 1];
<a name="1341"></a>                break;
<a name="1342"></a>
<a name="1343"></a>            case 'seq':
<a name="1344"></a>                /* run through the list in sequence */
<a name="1345"></a>                lst_ = List.generate({i: i}, numItems);
<a name="1346"></a>                break;
<a name="1347"></a>                
<a name="1348"></a>            case 'rand':
<a name="1349"></a>                /* 
<a name="1350"></a>                 *   pick an item at random, independent of other picks -
<a name="1351"></a>                 *   just generate a single item list, since we'll want to
<a name="1352"></a>                 *   pick at random again next time 
<a name="1353"></a>                 */
<a name="1354"></a>                lst_ = [rand(numItems) + 1];
<a name="1355"></a>                break;
<a name="1356"></a>
<a name="1357"></a>            case 'rand-norpt':
<a name="1358"></a>                /* 
<a name="1359"></a>                 *   Pick an item at random, but don't repeat the last item
<a name="1360"></a>                 *   chosen.  Pick repeatedly until we select an item that
<a name="1361"></a>                 *   doesn't match the last selection, if there is one.
<a name="1362"></a>                 *   Exception: if the list has only one item, it's
<a name="1363"></a>                 *   impossible to choose a different item, so don't try.  
<a name="1364"></a>                 */
<a name="1365"></a>                do
<a name="1366"></a>                {
<a name="1367"></a>                    pick = rand(numItems) + 1;
<a name="1368"></a>                }
<a name="1369"></a>                while (numItems &gt; 1 &amp;&amp; pick == last);
<a name="1370"></a>                lst_ = [pick];
<a name="1371"></a>                break;
<a name="1372"></a>
<a name="1373"></a>            case 'rand-wt':
<a name="1374"></a>                /* 
<a name="1375"></a>                 *   Pick an item at random, independently of other trials,
<a name="1376"></a>                 *   weighting the list in decreasing order of probability.
<a name="1377"></a>                 *   The relative weights are 1 for the last item, 2 for
<a name="1378"></a>                 *   the second to last item, 3 for the third to last, etc.
<a name="1379"></a>                 *   This gives us a total weight of n(n+1)/2, so start by
<a name="1380"></a>                 *   picking a number in that range.  1 represents the last
<a name="1381"></a>                 *   item, 2..3 the second to last, 3..5 the third, etc.  
<a name="1382"></a>                 */
<a name="1383"></a>                pick = rand(numItems*(numItems+1)/2) + 1;
<a name="1384"></a>                for (local i in 1..numItems ; ; pick -= i)
<a name="1385"></a>                {
<a name="1386"></a>                    /* if pick is &lt;= i, it's this item */
<a name="1387"></a>                    if (pick &lt;= i)
<a name="1388"></a>                    {
<a name="1389"></a>                        lst_ = [numItems - i + 1];
<a name="1390"></a>                        break;
<a name="1391"></a>                    }
<a name="1392"></a>                }
<a name="1393"></a>                break;
<a name="1394"></a>
<a name="1395"></a>            case 'shuffle':
<a name="1396"></a>            case 'shuffle2':
<a name="1397"></a>                /* 
<a name="1398"></a>                 *   Shuffle the list.  Populate the list with the integer
<a name="1399"></a>                 *   values from 1 to numItems, then shuffle the list into
<a name="1400"></a>                 *   a random order.
<a name="1401"></a>                 *   
<a name="1402"></a>                 *   The shuffling algorithm, as a physical analogy: Start
<a name="1403"></a>                 *   with a deck of cards labeled 1 to numItems.  Put all
<a name="1404"></a>                 *   of the cards in a hat.  Pick a card at random from the
<a name="1405"></a>                 *   hat and set it aside - call this the "pile".  Pick
<a name="1406"></a>                 *   another random card from the hat and put it on the top
<a name="1407"></a>                 *   of the pile.  Repeat until the hat is empty.  We now
<a name="1408"></a>                 *   have a pile of the cards arranged in random order.
<a name="1409"></a>                 *   
<a name="1410"></a>                 *   To implement this, we create a vector and fill it with
<a name="1411"></a>                 *   integers from 1 to numItems.  Partition the vector
<a name="1412"></a>                 *   with an index 'i': items from 1..i are the hat, items
<a name="1413"></a>                 *   from i+1..numItems are the deck.  To draw a card at
<a name="1414"></a>                 *   random, we pick a random number from 1..i.  To remove
<a name="1415"></a>                 *   it from the hat, we swap it into position 'i', because
<a name="1416"></a>                 *   that will effectively shrink the hat by one slot and
<a name="1417"></a>                 *   grow the pile by one slot.  Decrement i and repeat.  
<a name="1418"></a>                 */
<a name="1419"></a>                lst_ = Vector.generate({i: i}, numItems);
<a name="1420"></a>                for (local i in numItems..2 step -1)
<a name="1421"></a>                {
<a name="1422"></a>                    /* pick a random element from the remaining set */
<a name="1423"></a>                    pick = rand(i) + 1;
<a name="1424"></a>                    
<a name="1425"></a>                    /* swap the chosen item and the last element */
<a name="1426"></a>                    local tmp = lst_[i];
<a name="1427"></a>                    lst_[i] = lst_[pick];
<a name="1428"></a>                    lst_[pick] = tmp;
<a name="1429"></a>                }
<a name="1430"></a>
<a name="1431"></a>                /* 
<a name="1432"></a>                 *   The whole point of shuffling is to avoid obvious
<a name="1433"></a>                 *   repetition, so make sure we don't repeat any previous
<a name="1434"></a>                 *   item from a previous run through the list as the first
<a name="1435"></a>                 *   item of the new list.  If the first item matches the
<a name="1436"></a>                 *   previous item, reshuffle it into a random spot in the
<a name="1437"></a>                 *   list.  (If the list only has one item, of course, this
<a name="1438"></a>                 *   is pointless, so don't bother in that case.)  
<a name="1439"></a>                 */
<a name="1440"></a>                if (lst_[1] == last &amp;&amp; numItems &gt; 1)
<a name="1441"></a>                {
<a name="1442"></a>                    pick = rand(numItems - 1) + 2;
<a name="1443"></a>                    lst_[1] = lst_[pick];
<a name="1444"></a>                    lst_[pick] = last;
<a name="1445"></a>                }
<a name="1446"></a>
<a name="1447"></a>                /* 
<a name="1448"></a>                 *   in half-shuffle mode, only keep the first half of the
<a name="1449"></a>                 *   list, so that we re-shuffle halfway through 
<a name="1450"></a>                 */
<a name="1451"></a>                if (alst[1] == 'shuffle2' &amp;&amp; numItems &gt; 2)
<a name="1452"></a>                    lst_ = lst_.toList(1, numItems/2);
<a name="1453"></a>                break;
<a name="1454"></a>            }
<a name="1455"></a>
<a name="1456"></a>            /* start from the first item in the list */
<a name="1457"></a>            idx_ = 1;
<a name="1458"></a>        }
<a name="1459"></a>
<a name="1460"></a>        /* return and consume the next item */
<a name="1461"></a>        return lst_[idx_++];
<a name="1462"></a>    }
<a name="1463"></a>
<a name="1464"></a>    /* generated list */
<a name="1465"></a>    lst_ = []
<a name="1466"></a>
<a name="1467"></a>    /* current position in the list */
<a name="1468"></a>    idx_ = 1
<a name="1469"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/04/2024 from adv3Lite version 2.0</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>events.t</title></head><body>
<table class=ban><tr><td><h1>events.t</h1><td align=right><a href="../file/events.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>
<a name="5"></a>/*
<a name="6"></a> *   *************************************************************************
<a name="7"></a> *   events.t This module forms an optional part of the adv3Lite library. Note,
<a name="8"></a> *   however, that it must be present for certain other modules such as actor.t
<a name="9"></a> *   and scene.t to function properly, so it must be included if any of them
<a name="10"></a> *   are.
<a name="11"></a> *
<a name="12"></a> *   (c) 2012-13 Eric Eve (but based largely on code borrowed from the adv3
<a name="13"></a> *   library (c) Michael J. Roberts).
<a name="14"></a> */
<a name="15"></a>
<a name="16"></a>/* 
<a name="17"></a> *   The eventManager is the object that manages the execution of Events such as
<a name="18"></a> *   Fuses and Daemons.
<a name="19"></a> */
<a name="20"></a>eventManager: object
<a name="21"></a>    
<a name="22"></a>    /* Add an event to the list of events to be executed. */
<a name="23"></a>    addEvent(event)
<a name="24"></a>    {
<a name="25"></a>        eventList.append(event);
<a name="26"></a>    }
<a name="27"></a>    
<a name="28"></a>    /* Remove an event from the list of events to be executed. */
<a name="29"></a>    removeEvent(event)
<a name="30"></a>    {
<a name="31"></a>        eventList.removeElement(event); 
<a name="32"></a>    }
<a name="33"></a>    
<a name="34"></a>     /* 
<a name="35"></a>     *   Remove events matching the given object and property combination.
<a name="36"></a>     *   We remove all events that match both the object and property
<a name="37"></a>     *   (events matching only the object or only the property are not
<a name="38"></a>     *   affected).
<a name="39"></a>     *   
<a name="40"></a>     *   This is provided mostly as a convenience for cases where an event
<a name="41"></a>     *   is known to be uniquely identifiable by its object and property
<a name="42"></a>     *   values; this saves the caller the trouble of keeping track of the
<a name="43"></a>     *   Event object created when the event was first registered.
<a name="44"></a>     *   
<a name="45"></a>     *   When a particular object/property combination might be used in
<a name="46"></a>     *   several different events, it's better to keep a reference to the
<a name="47"></a>     *   Event object representing each event, and use removeEvent() to
<a name="48"></a>     *   remove the specific Event object of interest.
<a name="49"></a>     *   
<a name="50"></a>     *   Returns true if we find any matching events, nil if not.  
<a name="51"></a>     */
<a name="52"></a>    removeMatchingEvents(obj, prop)
<a name="53"></a>    {
<a name="54"></a>        local found;
<a name="55"></a>        
<a name="56"></a>        /* 
<a name="57"></a>         *   Scan our list, and remove each event matching the parameters.
<a name="58"></a>         *   Note that it's safe to remove things from a vector that we're
<a name="59"></a>         *   iterating with foreach(), since foreach() makes a safe copy
<a name="60"></a>         *   of the vector for the iteration. 
<a name="61"></a>         */
<a name="62"></a>        found = nil;
<a name="63"></a>        foreach (local cur in eventList)
<a name="64"></a>        {
<a name="65"></a>            /* if this one matches, remove it */
<a name="66"></a>            if (cur.eventMatches(obj, prop))
<a name="67"></a>            {
<a name="68"></a>                /* remove the event */
<a name="69"></a>                removeEvent(cur);
<a name="70"></a>
<a name="71"></a>                /* note that we found a match */
<a name="72"></a>                found = true;
<a name="73"></a>            }
<a name="74"></a>        }
<a name="75"></a>
<a name="76"></a>        /* return our 'found' indication */
<a name="77"></a>        return found;
<a name="78"></a>    }
<a name="79"></a>
<a name="80"></a>    /* 
<a name="81"></a>     *   Remove the current event - this is provided for convenience so
<a name="82"></a>     *   that an event can cancel itself in the course of its execution.
<a name="83"></a>     *   
<a name="84"></a>     *   Note that this has no effect on the current event execution -
<a name="85"></a>     *   this simply prevents the event from receiving additional
<a name="86"></a>     *   notifications in the future.  
<a name="87"></a>     */
<a name="88"></a>    removeCurrentEvent()
<a name="89"></a>    {
<a name="90"></a>        /* remove the currently active event from our list */
<a name="91"></a>        removeEvent(curEvent_);
<a name="92"></a>    }
<a name="93"></a>  
<a name="94"></a>     /*
<a name="95"></a>     *   Execute a turn.  We'll execute each fuse and each daemon that is
<a name="96"></a>     *   currently schedulable.  
<a name="97"></a>     */
<a name="98"></a>    executeTurn()
<a name="99"></a>    {
<a name="100"></a>        local lst;
<a name="101"></a>        
<a name="102"></a>        /* 
<a name="103"></a>         *   first execute all the 'Schedulables' that need to run each turn. In
<a name="104"></a>         *   practice this will be all the actor takeTurn routines that will be
<a name="105"></a>         *   registered by the actor module if present.
<a name="106"></a>         */
<a name="107"></a>        executeList(schedulableList);
<a name="108"></a>        
<a name="109"></a>        
<a name="110"></a>        /* 
<a name="111"></a>         *   build a list of all of our events with the current game clock time
<a name="112"></a>         *   - these are the events that are currently schedulable. Also include
<a name="113"></a>         *   any events that have never been executed but whose next run time is
<a name="114"></a>         *   greater than the current turn count (otherwise these events will
<a name="115"></a>         *   never be executed).
<a name="116"></a>         */
<a name="117"></a>        lst = eventList.subset({x: x.getNextRunTime() == libGlobal.totalTurns
<a name="118"></a>                               || (x.executed == nil &amp;&amp; x.getNextRunTime() 
<a name="119"></a>                                   &amp;&amp; x.getNextRunTime() &lt; libGlobal.totalTurns)
<a name="120"></a>                                   });
<a name="121"></a>
<a name="122"></a>        /* execute the items in this list */
<a name="123"></a>        executeList(lst);
<a name="124"></a>
<a name="125"></a>        /* no change in scheduling priorities */
<a name="126"></a>        return true;
<a name="127"></a>    }
<a name="128"></a>
<a name="129"></a>    /*
<a name="130"></a>     *   Execute a command prompt turn.  We'll execute each
<a name="131"></a>     *   per-command-prompt daemon. 
<a name="132"></a>     */
<a name="133"></a>    executePrompt()
<a name="134"></a>    {
<a name="135"></a>        /* execute all of the per-command-prompt daemons */
<a name="136"></a>        executeList(eventList.subset({x: x.isPromptDaemon}));
<a name="137"></a>    }
<a name="138"></a>
<a name="139"></a>    /*
<a name="140"></a>     *   internal service routine - execute the fuses and daemons in the
<a name="141"></a>     *   given list, in eventOrder priority order 
<a name="142"></a>     */
<a name="143"></a>    executeList(lst)
<a name="144"></a>    {
<a name="145"></a>        /* sort the list in ascending event order */
<a name="146"></a>        lst = lst.toList()
<a name="147"></a>              .sort(SortAsc, {a, b: a.eventOrder - b.eventOrder});
<a name="148"></a>
<a name="149"></a>        /* run through the list and execute each item ready to run */
<a name="150"></a>        foreach (local cur in lst)
<a name="151"></a>        {
<a name="152"></a>            /* remember our old active event, then establish the new one */
<a name="153"></a>            local oldEvent = curEvent_;
<a name="154"></a>            curEvent_ = cur;
<a name="155"></a>
<a name="156"></a>            /* make sure we restore things on the way out */
<a name="157"></a>            try
<a name="158"></a>            {
<a name="159"></a>                /* execute the event */
<a name="160"></a>                cur.executeEvent();
<a name="161"></a>                
<a name="162"></a>                /* note that the event has been executed */
<a name="163"></a>                cur.executed = true;
<a name="164"></a>
<a name="165"></a>            }
<a name="166"></a>            catch (Exception exc)
<a name="167"></a>            {
<a name="168"></a>                /* 
<a name="169"></a>                 *   If an event throws an exception out of its handler,
<a name="170"></a>                 *   remove the event from the active list.  If we were to
<a name="171"></a>                 *   leave it active, we'd go back and execute the same
<a name="172"></a>                 *   event again the next time we look for something to
<a name="173"></a>                 *   schedule, and that would in turn probably just
<a name="174"></a>                 *   encounter the same exception - so we'd be stuck in an
<a name="175"></a>                 *   infinite loop executing this erroneous code.  To
<a name="176"></a>                 *   ensure that we don't get stuck, remove the event. 
<a name="177"></a>                 */
<a name="178"></a>                removeCurrentEvent();
<a name="179"></a>
<a name="180"></a>                /* re-throw the exception */
<a name="181"></a>                throw exc;
<a name="182"></a>            }
<a name="183"></a>            finally
<a name="184"></a>            {
<a name="185"></a>                /* restore the enclosing current event */
<a name="186"></a>                curEvent_ = oldEvent;
<a name="187"></a>            }
<a name="188"></a>        }
<a name="189"></a>    }
<a name="190"></a>
<a name="191"></a>    
<a name="192"></a>    curEvent_ = nil
<a name="193"></a>    
<a name="194"></a>    eventList = static new Vector(20)
<a name="195"></a>    
<a name="196"></a>    /* 
<a name="197"></a>     *   A list of 'schedulables'. These are objects whose executeEvent() method
<a name="198"></a>     *   should be called each turn prior to other events such as Fuses and
<a name="199"></a>     *   Daemons. The main use for this in the library is to provide a mechanism
<a name="200"></a>     *   for the takeTurn method of each Actor to be called before Fuses and
<a name="201"></a>     *   Daemons are run, mainly in case an AgendaItem sets up a Fuse or Daemon
<a name="202"></a>     *   that may need to execute on the same turn, or if a Scene wants to do
<a name="203"></a>     *   so.
<a name="204"></a>     */
<a name="205"></a>    schedulableList = []
<a name="206"></a>;
<a name="207"></a>
<a name="208"></a>/* 
<a name="209"></a> *   An Event is an object such as a Fuse or Daemon that is executed according
<a name="210"></a> *   to certain conditions. Game code will normally use one of its subclasses
<a name="211"></a> *   rather than the Event class directly.
<a name="212"></a> */
<a name="213"></a>class Event: object
<a name="214"></a>   
<a name="215"></a>    /* Construct a new Event */
<a name="216"></a>    construct(obj, prop)
<a name="217"></a>    {
<a name="218"></a>        /* 
<a name="219"></a>         *   Note the object we refer to and the property of that object to
<a name="220"></a>         *   execute.
<a name="221"></a>         */
<a name="222"></a>        obj_ = obj;
<a name="223"></a>        prop_ = prop;
<a name="224"></a>        
<a name="225"></a>        /* Add this Event to the eventManager's list of events/ */
<a name="226"></a>        eventManager.addEvent(self);
<a name="227"></a>    }
<a name="228"></a>    
<a name="229"></a>    /* The object we're associated with */    
<a name="230"></a>    obj_ = nil
<a name="231"></a>    
<a name="232"></a>    /* A pointer to the property of that object to execute */
<a name="233"></a>    prop_ = nil
<a name="234"></a>    
<a name="235"></a>    /* The interval at which this Event is to be executed. */
<a name="236"></a>    interval_ = nil
<a name="237"></a>    
<a name="238"></a>    /* 
<a name="239"></a>     *   Get the next run time, i.e. the next turn on which this Event should
<a name="240"></a>     *   execute obj_.(prop_).
<a name="241"></a>     */
<a name="242"></a>    getNextRunTime()
<a name="243"></a>    {
<a name="244"></a>        return nextRunTime;
<a name="245"></a>    }
<a name="246"></a>    
<a name="247"></a>    /* delay our scheduled run time by the given number of turns */
<a name="248"></a>    delayEvent(turns) { nextRunTime += turns; }
<a name="249"></a>    
<a name="250"></a>     /* 
<a name="251"></a>     *   Execute the event.  This must be overridden by the subclass to
<a name="252"></a>     *   perform the appropriate operation when executed.  In particular,
<a name="253"></a>     *   the subclass must reschedule or unschedule the event, as
<a name="254"></a>     *   appropriate. 
<a name="255"></a>     */
<a name="256"></a>    executeEvent() { }
<a name="257"></a>
<a name="258"></a>    /* does this event match the given object/property combination? */
<a name="259"></a>    eventMatches(obj, prop) { return obj == obj_ &amp;&amp; prop == prop_; }
<a name="260"></a>    
<a name="261"></a>    /* 
<a name="262"></a>     *   Event order - this establishes the order we run relative to other
<a name="263"></a>     *   events scheduled to run at the same game clock time.  Lowest
<a name="264"></a>     *   number goes first.  By default, we provide an event order of 100,
<a name="265"></a>     *   which should leave plenty of room for custom events before and
<a name="266"></a>     *   after default events.  
<a name="267"></a>     */
<a name="268"></a>    eventOrder = 100
<a name="269"></a>    
<a name="270"></a>    /* 
<a name="271"></a>     *   our next execution time, expressed in game clock time; by
<a name="272"></a>     *   default, we'll set this to nil, which means that we are not
<a name="273"></a>     *   scheduled to execute at all 
<a name="274"></a>     */
<a name="275"></a>    nextRunTime = nil
<a name="276"></a>
<a name="277"></a>    /* by default, we're not a per-command-prompt daemon */
<a name="278"></a>    isPromptDaemon = nil   
<a name="279"></a>    
<a name="280"></a>    /* Call the method this Event should execute when it's ready to do so */
<a name="281"></a>    callMethod()
<a name="282"></a>    {
<a name="283"></a>        /* 
<a name="284"></a>         *   If we don't define a senseObj_ or the player character can sense
<a name="285"></a>         *   our senseObj_ via the appropriate sense, simply execute the prop_
<a name="286"></a>         *   method on our obj_. This check allows game code to ensure that the
<a name="287"></a>         *   player doesn't see messages relating to events the player character
<a name="288"></a>         *   cannot perceive.
<a name="289"></a>         */
<a name="290"></a>        if(senseObj_ == nil || Q.(senseProp_)(gPlayerChar, senseObj_))
<a name="291"></a>            obj_.(prop_);
<a name="292"></a>        
<a name="293"></a>        /* Otherwise capture the output from executing obj_.(prop_) */
<a name="294"></a>        else
<a name="295"></a>        {
<a name="296"></a>            captureText = gOutStream.captureOutput({: obj_.(prop_) });
<a name="297"></a>            
<a name="298"></a>            /* 
<a name="299"></a>             *   It's possible that executing the Event changes the sensory
<a name="300"></a>             *   context, so we need to check whether the object in question can
<a name="301"></a>             *   now be sensed, and if so, display the text we've just captured.
<a name="302"></a>             */            
<a name="303"></a>            if(Q.(senseProp_)(gPlayerChar, senseObj_))
<a name="304"></a>                say(captureText);
<a name="305"></a>        }
<a name="306"></a>    }
<a name="307"></a>    
<a name="308"></a>    /* Remove this event from the eventManager's list of events. */
<a name="309"></a>    removeEvent()
<a name="310"></a>    {
<a name="311"></a>        eventManager.removeEvent(self);
<a name="312"></a>    }
<a name="313"></a>    
<a name="314"></a>    /* 
<a name="315"></a>     *   If the senseObj_ property is defined (normally via our constructor),
<a name="316"></a>     *   the player character must be able to sense the senseObj_ via the sense
<a name="317"></a>     *   defined in senseProp_ for any textual output from obj_.(prop_) to be
<a name="318"></a>     *   displayed when this Event is executed.
<a name="319"></a>     */
<a name="320"></a>    senseObj_ = nil
<a name="321"></a>    
<a name="322"></a>    /*   
<a name="323"></a>     *   The sense via which we test whether senseObj_ can be sensed by the
<a name="324"></a>     *   player character. This must be given as an appropriate property of the
<a name="325"></a>     *   Query object, e.g. &amp;canSee or &amp;canHear.
<a name="326"></a>     */
<a name="327"></a>    senseProp_ = nil
<a name="328"></a>    
<a name="329"></a>    /*   Text captured from callMethod() */
<a name="330"></a>    captureText = nil
<a name="331"></a>    
<a name="332"></a>    /*   Flag - has this event ever been executed */
<a name="333"></a>    executed = nil
<a name="334"></a>;
<a name="335"></a>
<a name="336"></a>/*
<a name="337"></a> *   Fuse.  A fuse is an event that fires once at a given time in the
<a name="338"></a> *   future.  Once a fuse is executed, it is removed from further
<a name="339"></a> *   scheduling.  
<a name="340"></a> */
<a name="341"></a>class Fuse: Event
<a name="342"></a>    /* 
<a name="343"></a>     *   Creation.  'turns' is the number of turns in the future at which
<a name="344"></a>     *   the fuse is executed; if turns is 0, the fuse will be executed on
<a name="345"></a>     *   the current turn.  
<a name="346"></a>     */
<a name="347"></a>    construct(obj, prop, interval)
<a name="348"></a>    {
<a name="349"></a>        /* inherit the base class constructor */
<a name="350"></a>        inherited(obj, prop);
<a name="351"></a>
<a name="352"></a>        /* 
<a name="353"></a>         *   set my scheduled time to the current game clock time plus the
<a name="354"></a>         *   number of turns into the future 
<a name="355"></a>         */
<a name="356"></a>        nextRunTime = libGlobal.totalTurns + interval;
<a name="357"></a>    }
<a name="358"></a>
<a name="359"></a>    /* execute the fuse */
<a name="360"></a>    executeEvent()
<a name="361"></a>    {
<a name="362"></a>        /* call my method */
<a name="363"></a>        callMethod();
<a name="364"></a>
<a name="365"></a>        /* a fuse fires only once, so remove myself from further scheduling */
<a name="366"></a>        eventManager.removeEvent(self);
<a name="367"></a>    }
<a name="368"></a>;
<a name="369"></a>
<a name="370"></a>/* 
<a name="371"></a> *   A SenseFuse is just like a Fuse except that any text produced during its
<a name="372"></a> *   execution is only displayed if the player char is able to sense the
<a name="373"></a> *   relevant object either at the start or at the end of the Fuse's execution.
<a name="374"></a> */
<a name="375"></a>class SenseFuse: Fuse
<a name="376"></a>    
<a name="377"></a>    /* 
<a name="378"></a>     *   senseObj is the object which must be sensed for this Fuse's text to be
<a name="379"></a>     *   displayed. senseProp is one of &amp;canSee, &amp;canReach, &amp;canHear, &amp;canSmell.
<a name="380"></a>     *   If these parameters are omitted then the senseObj will be the same as
<a name="381"></a>     *   the obj whose prop property is executed by the Fuse, and the senseProp
<a name="382"></a>     *   will be &amp;canSee, probably the most common case.
<a name="383"></a>     */
<a name="384"></a>    construct(obj, prop, interval,  senseProp = &amp;canSee, senseObj = obj)
<a name="385"></a>    {
<a name="386"></a>        inherited(obj, prop, interval);
<a name="387"></a>        
<a name="388"></a>         senseObj_ = senseObj;
<a name="389"></a>         senseProp_ = senseProp;       
<a name="390"></a>            
<a name="391"></a>    }   
<a name="392"></a>    
<a name="393"></a>;
<a name="394"></a>
<a name="395"></a>/*  A Daemon is an Event that executes once every defined number of turns. */
<a name="396"></a>class Daemon: Event
<a name="397"></a>     /*
<a name="398"></a>     *   Creation.  'interval' is the number of turns between invocations
<a name="399"></a>     *   of the daemon; this should be at least 1, which causes the daemon
<a name="400"></a>     *   to be invoked on each turn.  The first execution will be
<a name="401"></a>     *   (interval-1) turns in the future - so if interval is 1, the
<a name="402"></a>     *   daemon will first be executed on the current turn, and if
<a name="403"></a>     *   interval is 2, the daemon will be executed on the next turn.  
<a name="404"></a>     */
<a name="405"></a>    construct(obj, prop, interval)
<a name="406"></a>    {
<a name="407"></a>        /* inherit the base class constructor */
<a name="408"></a>        inherited(obj, prop);
<a name="409"></a>
<a name="410"></a>        /* 
<a name="411"></a>         *   an interval of less than 0 is meaningless, so make sure it's
<a name="412"></a>         *   at least 1 
<a name="413"></a>         */
<a name="414"></a>        if (interval &lt; 0)
<a name="415"></a>            interval = 1;
<a name="416"></a>
<a name="417"></a>        /* 
<a name="418"></a>         *   remember my interval. In the special case where the interval is 0,
<a name="419"></a>         *   store an interval of 1 but schedule first execution for the current
<a name="420"></a>         *   turn.
<a name="421"></a>         */
<a name="422"></a>        interval_ = interval == 0 ? 1 : interval;
<a name="423"></a>
<a name="424"></a>        /* 
<a name="425"></a>         *   set my initial execution time, in game clock time 
<a name="426"></a>         */
<a name="427"></a>//        nextRunTime = libGlobal.totalTurns + interval - 1;
<a name="428"></a>        nextRunTime = libGlobal.totalTurns + interval;
<a name="429"></a>        
<a name="430"></a>        
<a name="431"></a>    }
<a name="432"></a>    
<a name="433"></a>    /* execute the daemon */
<a name="434"></a>    executeEvent()
<a name="435"></a>    {
<a name="436"></a>        /* call my method */
<a name="437"></a>        callMethod();
<a name="438"></a>
<a name="439"></a>        /* advance our next run time by our interval */
<a name="440"></a>        nextRunTime += interval_;
<a name="441"></a>    }
<a name="442"></a>
<a name="443"></a>    /* our execution interval, in turns */
<a name="444"></a>    interval_ = 1
<a name="445"></a>    
<a name="446"></a>    
<a name="447"></a>;
<a name="448"></a>
<a name="449"></a>
<a name="450"></a>/* 
<a name="451"></a> *   A SenseDaemon is just like a Daemon except that any text produced during
<a name="452"></a> *   its execution is only displayed if the player char is able to sense the
<a name="453"></a> *   relevant object either at the start or at the end of the Daemon's
<a name="454"></a> *   execution.
<a name="455"></a> */
<a name="456"></a>class SenseDaemon: Daemon
<a name="457"></a>    
<a name="458"></a>    /* 
<a name="459"></a>     *   Creation: in addition to the parameters passed to Daemon's constructor,
<a name="460"></a>     *   senseObj is the object which must be sensed for this Daemon's text to
<a name="461"></a>     *   be displayed. senseProp is one of &amp;canSee, &amp;canReach, &amp;canHear,
<a name="462"></a>     *   &amp;canSmell. If these parameters are omitted then the senseObj will be
<a name="463"></a>     *   the same as the obj whose prop property is executed by the Daemon, and
<a name="464"></a>     *   the senseProp will be &amp;canSee, probably the most common case.
<a name="465"></a>     */
<a name="466"></a>    construct(obj, prop, interval, senseProp = &amp;canSee, senseObj = obj)
<a name="467"></a>    {
<a name="468"></a>        inherited(obj, prop, interval);
<a name="469"></a>        
<a name="470"></a>         senseObj_ = senseObj;
<a name="471"></a>         senseProp_ = senseProp;       
<a name="472"></a>            
<a name="473"></a>    }  
<a name="474"></a>    
<a name="475"></a>;
<a name="476"></a>
<a name="477"></a>/*
<a name="478"></a> *   Command Prompt Daemon.  This is a special type of daemon that
<a name="479"></a> *   executes not according to the game clock, but rather once per command
<a name="480"></a> *   prompt.  The system executes all of these daemons just before each
<a name="481"></a> *   time it prompts for a command line.  
<a name="482"></a> */
<a name="483"></a>class PromptDaemon: Event
<a name="484"></a>    /* execute the daemon */
<a name="485"></a>    executeEvent()
<a name="486"></a>    {
<a name="487"></a>        /* 
<a name="488"></a>         *   call my method - there's nothing else to do for this type of
<a name="489"></a>         *   daemon, since our scheduling is not affected by the game
<a name="490"></a>         *   clock 
<a name="491"></a>         */
<a name="492"></a>        callMethod();
<a name="493"></a>    }
<a name="494"></a>
<a name="495"></a>    /* flag: we are a special per-command-prompt daemon */
<a name="496"></a>    isPromptDaemon = true
<a name="497"></a>;
<a name="498"></a>
<a name="499"></a>/*
<a name="500"></a> *   A one-time-only prompt daemon is a regular command prompt daemon,
<a name="501"></a> *   except that it fires only once.  After it fires once, the daemon
<a name="502"></a> *   automatically deactivates itself, so that it won't fire again.
<a name="503"></a> *   
<a name="504"></a> *   Prompt daemons are occasionally useful for non-recurring processing,
<a name="505"></a> *   when you want to defer some bit of code until a "safe" time between
<a name="506"></a> *   turns.  In these cases, the regular PromptDaemon is inconvenient to
<a name="507"></a> *   use because it automatically recurs.  This subclass is handy for these
<a name="508"></a> *   cases, since it lets you schedule some bit of processing for a single
<a name="509"></a> *   deferred execution.
<a name="510"></a> *   
<a name="511"></a> *   One special situation where one-time prompt daemons can be handy is in
<a name="512"></a> *   triggering conversational events - such as initiating a conversation -
<a name="513"></a> *   at the very beginning of the game.  Initiating a conversation can only
<a name="514"></a> *   be done from within an action context, but no action context is in
<a name="515"></a> *   effect during the game's initialization.  An easy way to deal with
<a name="516"></a> *   this is to create a one-time prompt daemon during initialization, and
<a name="517"></a> *   then trigger the event from the daemon's callback method.  The prompt
<a name="518"></a> *   daemon will set up a daemon action environment just before the first
<a name="519"></a> *   command prompt is displayed, at which point the callback will be able
<a name="520"></a> *   to trigger the event as though it were in ordinary action handler
<a name="521"></a> *   code.  
<a name="522"></a> */
<a name="523"></a>class OneTimePromptDaemon: PromptDaemon
<a name="524"></a>    executeEvent()
<a name="525"></a>    {
<a name="526"></a>        /* execute as normal */
<a name="527"></a>        inherited();
<a name="528"></a>
<a name="529"></a>        /* remove myself from the event list, so that I don't fire again */
<a name="530"></a>        removeEvent();
<a name="531"></a>    }
<a name="532"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/04/2024 from adv3Lite version 2.0</div>
</body>
</html>

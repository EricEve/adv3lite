<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>dynfunc.t</title></head><body>
<table class=ban><tr><td><h1>dynfunc.t</h1><td align=right><a href="../file/dynfunc.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2001, 2006 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.
<a name="7"></a> *   
<a name="8"></a> *   This module defines classes related to the DynamicFunc intrinsic
<a name="9"></a> *   class.  You should include this source file in your build if you're
<a name="10"></a> *   using the DynamicFunc class.  
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>#include &lt;tads.h&gt;
<a name="14"></a>#include &lt;dynfunc.h&gt;
<a name="15"></a>
<a name="16"></a>
<a name="17"></a>/* ------------------------------------------------------------------------ */
<a name="18"></a>/*
<a name="19"></a> *   Compiler: This object provides a simplified interface to the dynamic
<a name="20"></a> *   compiler.  The methods here can be used instead of manually creating
<a name="21"></a> *   DynamicFunc instances.
<a name="22"></a> *   
<a name="23"></a> *   The main advantage of using this object to compile code is that it
<a name="24"></a> *   automatically provides access to the global symbol table that was used
<a name="25"></a> *   to compile the current program, for use in dynamic code.  Without the
<a name="26"></a> *   global symbol table, dynamic code won't have access to object names,
<a name="27"></a> *   property names, function names, and so on.  That doesn't stop you from
<a name="28"></a> *   compiling code that only depends upon its own function parameters and
<a name="29"></a> *   local variables, but for most purposes the global symbols are useful
<a name="30"></a> *   to have around.
<a name="31"></a> *   
<a name="32"></a> *   Note that including this object in a project will automatically save
<a name="33"></a> *   the global symbol table in the compiled .t3 file.  This increases the
<a name="34"></a> *   size of the .t3 file, as well as memory usage during execution.  If
<a name="35"></a> *   you're concerned about minimizing the .t3 file size or the run-time
<a name="36"></a> *   memory footprint, *and* you don't need global symbols for dynamic code
<a name="37"></a> *   (or you don't use the dynamic compiler at all), you can save some
<a name="38"></a> *   space by omitting this whole module from the build.  
<a name="39"></a> */
<a name="40"></a>Compiler: PreinitObject
<a name="41"></a>    /*
<a name="42"></a>     *   Compile an expression or function.  'str' is a string giving the
<a name="43"></a>     *   code to compile.  This can be a simple value expression, such as
<a name="44"></a>     *   'Me.location' or 'new BigNumber(12345).sqrt()'.  Or, it can be a
<a name="45"></a>     *   complete unnamed function definition, using this syntax:
<a name="46"></a>     *   
<a name="47"></a>     *.    'function(x, y, z) { ...body of function... }'
<a name="48"></a>     *   
<a name="49"></a>     *   The body of the function can contain any executable code that you
<a name="50"></a>     *   could write in a regular function in static code: if, while,
<a name="51"></a>     *   switch, return, etc.
<a name="52"></a>     *   
<a name="53"></a>     *   The return value is a DynamicFunc containing the compiled
<a name="54"></a>     *   expression or function.  You call it by using the return value as
<a name="55"></a>     *   though it were a function:
<a name="56"></a>     *   
<a name="57"></a>     *.    local f = Compiler.compile('Me.location');
<a name="58"></a>     *.    local loc = f();  
<a name="59"></a>     *   
<a name="60"></a>     *   If the source string was just an expression, it acts like a
<a name="61"></a>     *   function that takes zero arguments, and returns the computed value
<a name="62"></a>     *   of the expression.  The expression is evaluated anew each time you
<a name="63"></a>     *   invoke it, so you'll get the "live" value of an expression that
<a name="64"></a>     *   refers to object properties or other external data.  In the
<a name="65"></a>     *   example above, we'd get the current value of Me.location every
<a name="66"></a>     *   time we call f().
<a name="67"></a>     *   
<a name="68"></a>     *   The source string is actually compiled immediately when you call
<a name="69"></a>     *   this function.  This means it's checked for errors, such as syntax
<a name="70"></a>     *   errors and unknown symbol names.  If the code contains any errors,
<a name="71"></a>     *   this method throws a CompilerException describing the problem.
<a name="72"></a>     */
<a name="73"></a>    compile(str, locals?)
<a name="74"></a>    {
<a name="75"></a>        /* compile the string, using our saved global symbol table */
<a name="76"></a>        return new DynamicFunc(str, symtab_, locals, macros_);
<a name="77"></a>    }
<a name="78"></a>
<a name="79"></a>    /*
<a name="80"></a>     *   Compile a dynamic function string, and add it to the global symbol
<a name="81"></a>     *   table as a function with the given name.  This effectively creates
<a name="82"></a>     *   a new named function that you can call from other dynamic code
<a name="83"></a>     *   objects. 
<a name="84"></a>     */
<a name="85"></a>    defineFunc(name, str, locals?)
<a name="86"></a>    {
<a name="87"></a>        /* 
<a name="88"></a>         *   compile the string, and add it to our symbol table under the
<a name="89"></a>         *   given function name 
<a name="90"></a>         */
<a name="91"></a>        symtab_[name] = new DynamicFunc(str, symtab_, locals, macros_);
<a name="92"></a>    }
<a name="93"></a>
<a name="94"></a>    /*
<a name="95"></a>     *   Evaluate an expression.  'str' is a string giving code to compile.
<a name="96"></a>     *   In most cases, this is simply a simple value expression, although
<a name="97"></a>     *   it's also acceptable to use the 'function()' syntax to create a
<a name="98"></a>     *   function that takes no arguments.
<a name="99"></a>     *   
<a name="100"></a>     *   This method compiles the source string and immediately calls the
<a name="101"></a>     *   resulting compiled code.  The return value is the value returned
<a name="102"></a>     *   from the compiled code itself.  This method thus provides a quick
<a name="103"></a>     *   way to evaluate an expression.
<a name="104"></a>     *   
<a name="105"></a>     *   If the string contains any syntax errors or other compilation
<a name="106"></a>     *   errors, the method throws a CompilerException.  In addition, it's
<a name="107"></a>     *   possible for the compiled code to throw exceptions of its own;
<a name="108"></a>     *   this method doesn't catch those, leaving it up to the caller to
<a name="109"></a>     *   handle them.
<a name="110"></a>     *   
<a name="111"></a>     *   If you expect to evaluate the same expression repeatedly, you're
<a name="112"></a>     *   better off using compile() to get the compiled representation of
<a name="113"></a>     *   the expression, and then call that compiled code each time the
<a name="114"></a>     *   value is needed.  That's more efficient than using eval() each
<a name="115"></a>     *   time, since eval() to recompile the expression on every call,
<a name="116"></a>     *   which is a fairly complex process.  
<a name="117"></a>     */
<a name="118"></a>    eval(str, locals?)
<a name="119"></a>    {
<a name="120"></a>        /* 
<a name="121"></a>         *   compile the string, call the resulting function, and return
<a name="122"></a>         *   the result from the function 
<a name="123"></a>         */
<a name="124"></a>        return (new DynamicFunc(str, symtab_, locals, macros_))();
<a name="125"></a>    }
<a name="126"></a>
<a name="127"></a>    /*
<a name="128"></a>     *   During preinit, save a reference to the program's global symbol
<a name="129"></a>     *   table in a property of self.  The VM always makes the global
<a name="130"></a>     *   symbols available during preinit, but by default it discards the
<a name="131"></a>     *   table after that because most programs don't need it.  That means
<a name="132"></a>     *   that the symbols aren't available by default during normal
<a name="133"></a>     *   execution.  However, saving a reference here prevents the garbage
<a name="134"></a>     *   collector from discarding the table when preinit finishes, which
<a name="135"></a>     *   forces it to be saved in the final .t3 file and thus makes it
<a name="136"></a>     *   available permanently.  
<a name="137"></a>     */
<a name="138"></a>    execute()
<a name="139"></a>    {
<a name="140"></a>        /* save the global symbol table */
<a name="141"></a>        symtab_ = t3GetGlobalSymbols(T3GlobalSymbols);
<a name="142"></a>        macros_ = t3GetGlobalSymbols(T3PreprocMacros);
<a name="143"></a>    }
<a name="144"></a>
<a name="145"></a>    /* a saved reference to the global symbol table */
<a name="146"></a>    symtab_ = nil
<a name="147"></a>
<a name="148"></a>    /* a saved referenced to the preprocessor macro table */
<a name="149"></a>    macros_ = nil
<a name="150"></a>;
<a name="151"></a>    
<a name="152"></a>
<a name="153"></a>/* ------------------------------------------------------------------------ */
<a name="154"></a>/*
<a name="155"></a> *   Compiler Exception.  'new DynamicFunc()' throws an exception of this
<a name="156"></a> *   class if an error occurs compiling the source code of the new object.
<a name="157"></a> */
<a name="158"></a>class CompilerException: Exception
<a name="159"></a>    construct(msg) { errmsg_ = msg; }
<a name="160"></a>    displayException()
<a name="161"></a>    {
<a name="162"></a>        if (errmsg_ != nil)
<a name="163"></a>            "&lt;&lt;errmsg_&gt;&gt;";
<a name="164"></a>        else
<a name="165"></a>            "Source code compilation error";
<a name="166"></a>    }
<a name="167"></a>
<a name="168"></a>    /* the error message from the compiler */
<a name="169"></a>    errmsg_ = nil
<a name="170"></a>;
<a name="171"></a>
<a name="172"></a>/* export the compiler exception for use by the intrinsic class */
<a name="173"></a>export CompilerException 'DynamicFunc.CompilerException';
<a name="174"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/04/2024 from adv3Lite version 2.0</div>
</body>
</html>

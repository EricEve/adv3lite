<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>actions.t</title></head><body>
<table class=ban><tr><td><h1>actions.t</h1><td align=right><a href="../file/actions.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>property handleTopic;
<a name="5"></a>property showSuggestions;
<a name="6"></a>property sayHello;
<a name="7"></a>property showScore;
<a name="8"></a>property scoreNotify;
<a name="9"></a>property showHints;
<a name="10"></a>property disableHints;
<a name="11"></a>property activated;
<a name="12"></a>property extraHintsExist;
<a name="13"></a>property showExitsCommand;
<a name="14"></a>property exitsOnOffCommand;
<a name="15"></a>property isOdor;
<a name="16"></a>property isNoise;
<a name="17"></a>
<a name="18"></a>
<a name="19"></a>DefineSystemAction(Quit)
<a name="20"></a>   
<a name="21"></a>    
<a name="22"></a>    execAction(cmd)
<a name="23"></a>    {        
<a name="24"></a>        DMsg(quit query, '&lt;.p&gt;Do you really want to quit? (y/n)?\n&gt;');
<a name="25"></a>       
<a name="26"></a>        if(yesOrNo())
<a name="27"></a>            throw new QuittingException;        
<a name="28"></a>    }
<a name="29"></a>;
<a name="30"></a>
<a name="31"></a>DefineSystemAction(Undo)
<a name="32"></a>   
<a name="33"></a>    
<a name="34"></a>    execAction(cmd)
<a name="35"></a>    {
<a name="36"></a>        if(undo())
<a name="37"></a>        {
<a name="38"></a>            DMsg(undo okay, 'One turn undone: {1}', 
<a name="39"></a>                 libGlobal.lastCommandForUndo);
<a name="40"></a>            
<a name="41"></a>            /* notify all PostUndoObject instances */
<a name="42"></a>            PostUndoObject.classExec();
<a name="43"></a>            
<a name="44"></a>            return true;
<a name="45"></a>        }
<a name="46"></a>        else
<a name="47"></a>        {
<a name="48"></a>            DMsg(undo failed, 'Undo failed. ');
<a name="49"></a>            return nil;
<a name="50"></a>        }
<a name="51"></a>    }
<a name="52"></a>    
<a name="53"></a>;
<a name="54"></a>
<a name="55"></a>DefineSystemAction(Restart)
<a name="56"></a>    
<a name="57"></a>    
<a name="58"></a>    execAction(cmd)
<a name="59"></a>    {
<a name="60"></a>        DMsg(restart query, 
<a name="61"></a>             'Do you really want to start again from the beginning (y/n)?\n&gt;');
<a name="62"></a>        
<a name="63"></a>        if(inputManager.getInputLine().toLower.startsWith(affirmativeLetter))
<a name="64"></a>            doRestartGame();
<a name="65"></a>        
<a name="66"></a>    }
<a name="67"></a>    
<a name="68"></a>    affirmativeLetter = 'y'
<a name="69"></a>    
<a name="70"></a>    doRestartGame()
<a name="71"></a>    {
<a name="72"></a>        /* before restarting, notify anyone interested of our intentions */
<a name="73"></a>        PreRestartObject.classExec();
<a name="74"></a>
<a name="75"></a>        /* 
<a name="76"></a>         *   Throw a 'restart' signal; the main entrypoint loop will catch
<a name="77"></a>         *   this and actually perform the restart.
<a name="78"></a>         *   
<a name="79"></a>         *   Note that we *could* do the VM reset (via restartGame()) here,
<a name="80"></a>         *   but there's an advantage to doing it in the main loop: we
<a name="81"></a>         *   won't be in the stack context of whatever command we're
<a name="82"></a>         *   performing.  If we did the restart here, it's possible that
<a name="83"></a>         *   some useless objects would survive the VM reset just because
<a name="84"></a>         *   they're referenced from within a caller's stack frame.  Those
<a name="85"></a>         *   objects would immediately go out of scope when we get back to
<a name="86"></a>         *   the main loop, but they might survive long enough to create
<a name="87"></a>         *   apparent inconsistencies.  In particular, if we did a
<a name="88"></a>         *   firstObj/nextObj loop, we could discover those objects and
<a name="89"></a>         *   re-establish more lasting references to them, which we
<a name="90"></a>         *   certainly don't want to do.  By deferring the VM reset until
<a name="91"></a>         *   we get back to the main loop, we'll ensure that objects won't
<a name="92"></a>         *   survive the reset just because they're on the stack
<a name="93"></a>         *   momentarily here.  
<a name="94"></a>         */
<a name="95"></a>        throw new RestartSignal();
<a name="96"></a>        
<a name="97"></a>    }
<a name="98"></a>;
<a name="99"></a>
<a name="100"></a>DefineSystemAction(Credits)
<a name="101"></a>    
<a name="102"></a>    
<a name="103"></a>    execAction(cmd)
<a name="104"></a>    {
<a name="105"></a>        versionInfo.showCredit();
<a name="106"></a>        "&lt;.p&gt;";
<a name="107"></a>    }
<a name="108"></a>;
<a name="109"></a>
<a name="110"></a>DefineSystemAction(About)
<a name="111"></a>    execAction(cmd)
<a name="112"></a>    {
<a name="113"></a>        versionInfo.showAbout();
<a name="114"></a>        "&lt;.p&gt;";
<a name="115"></a>    }
<a name="116"></a>;
<a name="117"></a>
<a name="118"></a>DefineSystemAction(Version)
<a name="119"></a>    execAction(cmd)
<a name="120"></a>    {
<a name="121"></a>        local lst = ModuleID.getModuleList();
<a name="122"></a>        foreach(local cur in lst)    
<a name="123"></a>           cur.showVersion();
<a name="124"></a>        
<a name="125"></a>        "&lt;.p&gt;";          
<a name="126"></a>    }
<a name="127"></a>;
<a name="128"></a>
<a name="129"></a>DefineSystemAction(Exits)
<a name="130"></a>    execAction(cmd)
<a name="131"></a>    {
<a name="132"></a>        if(gExitLister == nil)
<a name="133"></a>            sayNoExitLister();
<a name="134"></a>        else
<a name="135"></a>            gExitLister.showExitsCommand();
<a name="136"></a>    }
<a name="137"></a>;
<a name="138"></a>
<a name="139"></a>DefineSystemAction(ExitsMode)
<a name="140"></a>    execAction(cmd)
<a name="141"></a>    {
<a name="142"></a>        if(gExitLister == nil)
<a name="143"></a>        {
<a name="144"></a>            sayNoExitLister();
<a name="145"></a>            return;
<a name="146"></a>        }
<a name="147"></a>        
<a name="148"></a>        if(cmd.verbProd.on_ != nil)
<a name="149"></a>            gExitLister.exitsOnOffCommand(true, true);
<a name="150"></a>        
<a name="151"></a>        if(cmd.verbProd.off_ != nil)
<a name="152"></a>            gExitLister.exitsOnOffCommand(nil, nil);
<a name="153"></a>        
<a name="154"></a>        if(cmd.verbProd.look_ != nil)
<a name="155"></a>            gExitLister.exitsOnOffCommand(nil, true);
<a name="156"></a>        
<a name="157"></a>        if(cmd.verbProd.stat_ != nil)
<a name="158"></a>            gExitLister.exitsOnOffCommand(true, nil);
<a name="159"></a>    }
<a name="160"></a>        
<a name="161"></a>;
<a name="162"></a>
<a name="163"></a>DefineSystemAction(ExitsColour)
<a name="164"></a>    execAction(cmd)
<a name="165"></a>    {
<a name="166"></a>        if(gExitLister == nil)
<a name="167"></a>        {
<a name="168"></a>            sayNoExitLister(); 
<a name="169"></a>            return;
<a name="170"></a>        }
<a name="171"></a>        
<a name="172"></a>        if(defined(statuslineExitLister) &amp;&amp; cmd.verbProd.on_ != nil)
<a name="173"></a>        {
<a name="174"></a>            statuslineExitLister.highlightUnvisitedExits = 
<a name="175"></a>                (cmd.verbProd.on_ == 'on');
<a name="176"></a>            
<a name="177"></a>            DMsg(exit color onoff, 'Okay, colouring of unvisited exits is now
<a name="178"></a>                {1}.&lt;.p&gt;', cmd.verbProd.on_);
<a name="179"></a>        }
<a name="180"></a>        
<a name="181"></a>        if(defined(statuslineExitLister) &amp;&amp; cmd.verbProd.colour_ != nil)
<a name="182"></a>        {
<a name="183"></a>            statuslineExitLister.unvisitedExitColour = cmd.verbProd.colour_;
<a name="184"></a>            statuslineExitLister.highlightUnvisitedExits = true;
<a name="185"></a>            DMsg(exit color change, 'Okay, unvisited exits in the status line
<a name="186"></a>                will now be shown in {1}. ', cmd.verbProd.colour_);
<a name="187"></a>        }
<a name="188"></a>    }
<a name="189"></a>;
<a name="190"></a>
<a name="191"></a>sayNoExitLister()
<a name="192"></a>{
<a name="193"></a>    DMsg(no exit lister, 'Sorry, that command is not available in this
<a name="194"></a>                game, since there\'s no exit lister. ');    
<a name="195"></a>}
<a name="196"></a>
<a name="197"></a>
<a name="198"></a>DefineSystemAction(Score)
<a name="199"></a>    execAction(cmd)
<a name="200"></a>    {
<a name="201"></a>        /* show the simple score */
<a name="202"></a>        if (libGlobal.scoreObj != nil)
<a name="203"></a>        {
<a name="204"></a>            /* show the score */
<a name="205"></a>            libGlobal.scoreObj.showScore();
<a name="206"></a>
<a name="207"></a>            /* 
<a name="208"></a>             *   Mention the FULL SCORE command to the player if we haven't
<a name="209"></a>             *   already.  Note that we only want to mention 
<a name="210"></a>             */
<a name="211"></a>            if (!mentionedFullScore)
<a name="212"></a>            {
<a name="213"></a>                /* explain about it */
<a name="214"></a>                htmlSay(BMsg(mention full score, 'To see your complete list of
<a name="215"></a>                    achievements, use the &lt;&lt;aHref('full score', 'FULL SCORE',
<a name="216"></a>                                                  'show full score')&gt;&gt; command. 
<a name="217"></a>                    '));
<a name="218"></a>
<a name="219"></a>                /* don't mention it again */
<a name="220"></a>                Score.mentionedFullScore = true;
<a name="221"></a>            }
<a name="222"></a>        }
<a name="223"></a>        else
<a name="224"></a>            /* this game doesn't use scoring */
<a name="225"></a>            scoreNotPresent(); 
<a name="226"></a>        
<a name="227"></a>    }
<a name="228"></a>    
<a name="229"></a>    scoreNotPresent()
<a name="230"></a>    {
<a name="231"></a>          DMsg(score not present, '&lt;.parser&gt;This story doesn&amp;rsquo;t use
<a name="232"></a>               scoring.&lt;./parser&gt; ');            
<a name="233"></a>    }
<a name="234"></a>    
<a name="235"></a>    mentionedFullScore = nil
<a name="236"></a>;
<a name="237"></a>
<a name="238"></a>DefineSystemAction(FullScore)
<a name="239"></a>    execAction(cmd)
<a name="240"></a>    {
<a name="241"></a>        /* show the full score in response to an explicit player request */
<a name="242"></a>        showFullScore();
<a name="243"></a>
<a name="244"></a>        /* this counts as a mention of the FULL SCORE command */
<a name="245"></a>        Score.mentionedFullScore = true;
<a name="246"></a>    }
<a name="247"></a>
<a name="248"></a>    /* show the full score */
<a name="249"></a>    showFullScore()
<a name="250"></a>    {
<a name="251"></a>        /* show the full score */
<a name="252"></a>        if (libGlobal.scoreObj != nil)
<a name="253"></a>            libGlobal.scoreObj.showFullScore();
<a name="254"></a>        else
<a name="255"></a>            Score.scoreNotPresent;
<a name="256"></a>    }
<a name="257"></a>   
<a name="258"></a>;
<a name="259"></a>
<a name="260"></a>DefineSystemAction(Notify)
<a name="261"></a>    execAction(cmd)
<a name="262"></a>    {
<a name="263"></a>        /* show the current notification status */
<a name="264"></a>        if (libGlobal.scoreObj != nil)
<a name="265"></a>            showNotifyStatus(libGlobal.scoreObj.scoreNotify.isOn);        
<a name="266"></a>        else
<a name="267"></a>            commandNotPresent;
<a name="268"></a>    }
<a name="269"></a>    
<a name="270"></a>      /* show the current score notify status */
<a name="271"></a>    showNotifyStatus(stat)
<a name="272"></a>    {
<a name="273"></a>        DMsg(show notify status, '&lt;.parser&gt;Score notifications are
<a name="274"></a>        currently &lt;&lt;stat ? 'on' : 'off'&gt;&gt;.&lt;./parser&gt; ');
<a name="275"></a>    }
<a name="276"></a>;
<a name="277"></a>
<a name="278"></a>DefineSystemAction(NotifyOn)
<a name="279"></a>    execAction(cmd)
<a name="280"></a>    {
<a name="281"></a>        /* turn notifications on, and acknowledge the status */
<a name="282"></a>        if (libGlobal.scoreObj != nil)
<a name="283"></a>        {
<a name="284"></a>            libGlobal.scoreObj.scoreNotify.isOn = true;
<a name="285"></a>            acknowledgeNotifyStatus(true);
<a name="286"></a>        }
<a name="287"></a>        else
<a name="288"></a>            commandNotPresent;
<a name="289"></a>    }
<a name="290"></a>;
<a name="291"></a>
<a name="292"></a>DefineSystemAction(NotifyOff)
<a name="293"></a>    execAction(cmd)
<a name="294"></a>    {
<a name="295"></a>        /* turn notifications off, and acknowledge the status */
<a name="296"></a>        if (libGlobal.scoreObj != nil)
<a name="297"></a>        {
<a name="298"></a>            libGlobal.scoreObj.scoreNotify.isOn = nil;
<a name="299"></a>            acknowledgeNotifyStatus(nil);
<a name="300"></a>        }
<a name="301"></a>        else
<a name="302"></a>            commandNotPresent;
<a name="303"></a>    }
<a name="304"></a>;
<a name="305"></a>
<a name="306"></a>DefineSystemAction(ToggleDisambigEnumeration)    
<a name="307"></a>    execAction(cmd)
<a name="308"></a>    {
<a name="309"></a>        if(libGlobal.enumerateDisambigOptions)
<a name="310"></a>        {
<a name="311"></a>            libGlobal.enumerateDisambigOptions = nil;
<a name="312"></a>            DMsg(disambig enum off, 'Enumeration of disambiguation choices is now off. ');
<a name="313"></a>        }
<a name="314"></a>        else
<a name="315"></a>        {
<a name="316"></a>            libGlobal.enumerateDisambigOptions = true;
<a name="317"></a>            DMsg(disambig enum off, 'Enumeration of disambiguation choices is now on. ');
<a name="318"></a>        }
<a name="319"></a>    }
<a name="320"></a>;
<a name="321"></a>
<a name="322"></a>
<a name="323"></a>DefineSystemAction(Hints)
<a name="324"></a>    execAction(cmd)
<a name="325"></a>    {
<a name="326"></a>        if(gHintManager == nil)
<a name="327"></a>            sayHintsNotPresent();
<a name="328"></a>        else        
<a name="329"></a>            gHintManager.showHints();
<a name="330"></a>        
<a name="331"></a>    }
<a name="332"></a>    
<a name="333"></a>    sayHintsNotPresent() 
<a name="334"></a>    {
<a name="335"></a>        DMsg(hints not present, '&lt;.parser&gt;Sorry, this story doesn&amp;rsquo;t
<a name="336"></a>                have any built-in hints.&lt;./parser&gt; ');
<a name="337"></a>    }
<a name="338"></a>;
<a name="339"></a>        
<a name="340"></a>
<a name="341"></a>DefineSystemAction(HintsOff)
<a name="342"></a>    execAction(cmd)
<a name="343"></a>    {
<a name="344"></a>        if(gHintManager == nil)
<a name="345"></a>            DMsg(no hints to disable, '&lt;.parser&gt;This game doesn\'t have any
<a name="346"></a>                hints to turn off.&lt;./parser&gt; ');
<a name="347"></a>        else
<a name="348"></a>            gHintManager.disableHints();
<a name="349"></a>    }
<a name="350"></a>;
<a name="351"></a>
<a name="352"></a>DefineSystemAction(ExtraHints)
<a name="353"></a>    execAction(cmd)
<a name="354"></a>    {
<a name="355"></a>        if(gExtraHintManager == nil || !gExtraHintManager.extraHintsExist())
<a name="356"></a>        {
<a name="357"></a>            DMsg(no extra hints, 'Sorry, there are no extra hints in this game.
<a name="358"></a>                ');
<a name="359"></a>            return;
<a name="360"></a>        }
<a name="361"></a>        
<a name="362"></a>        onOff = cmd.verbProd.onOff;
<a name="363"></a>        
<a name="364"></a>        if(onOff == nil)
<a name="365"></a>        {
<a name="366"></a>            showExtraHintStatus();
<a name="367"></a>            
<a name="368"></a>            return;
<a name="369"></a>                    
<a name="370"></a>        }
<a name="371"></a>        onOff = onOff.toLower();
<a name="372"></a>        
<a name="373"></a>        if(onOff == hintsOff)
<a name="374"></a>            gExtraHintManager.deactivate();
<a name="375"></a>        else
<a name="376"></a>            gExtraHintManager.activate();
<a name="377"></a>        
<a name="378"></a>        DMsg(extra hints on or off, 'Okay; extra hints are now {1}. ', onOff );
<a name="379"></a>    }
<a name="380"></a>    
<a name="381"></a>    /* 
<a name="382"></a>     *   Routine to display message saying that extra hints are on or off.
<a name="383"></a>     *   Translators may want to override this method to display a message if it
<a name="384"></a>     *   can't readily be done in a CustomMessages object.
<a name="385"></a>     */
<a name="386"></a>    showExtraHintStatus()
<a name="387"></a>    {
<a name="388"></a>        local cmdstr = extraHintsCmd + onOrOff(!extraHintsActive).toUpper();
<a name="389"></a>        
<a name="390"></a>        DMsg(extra hints status,            
<a name="391"></a>            'Extra hints are currently &lt;&lt;onOrOff(extraHintsActive)&gt;&gt;. To turn
<a name="392"></a>            them &lt;&lt;onOrOff(!extraHintsActive)&gt;&gt; use the command &lt;&lt;aHref(cmdstr,
<a name="393"></a>                cmdstr, 'Turn extra hints ' + onOrOff(!extraHintsActive))&gt;&gt;. ',
<a name="394"></a>                 cmdstr);
<a name="395"></a>            return;
<a name="396"></a>    }
<a name="397"></a>    
<a name="398"></a>    extraHintsActive = (gExtraHintManager != nil &amp;&amp; gExtraHintManager.activated)
<a name="399"></a>    
<a name="400"></a>    onOrOff(stat) { return stat ? hintsOn : hintsOff; }
<a name="401"></a>    
<a name="402"></a>    onOff = nil
<a name="403"></a>    
<a name="404"></a>    hintsOff = BMsg(extra hints off, 'off')
<a name="405"></a>    hintsOn = BMsg(extra hints on, 'on')
<a name="406"></a>    
<a name="407"></a>    extraHintsCmd = BMsg(extra hints command, 'EXTRA ')
<a name="408"></a>;
<a name="409"></a>
<a name="410"></a>DefineSystemAction(Brief)
<a name="411"></a>    execAction(cmd)
<a name="412"></a>    {
<a name="413"></a>        if(gameMain.verbose)
<a name="414"></a>        {
<a name="415"></a>            gameMain.verbose = nil;
<a name="416"></a>            DMsg(game now brief, 'The game is now in BRIEF mode. &lt;&lt;first
<a name="417"></a>                  time&gt;&gt;Full room descriptions will now only be shown on the
<a name="418"></a>                first visit to a room or in response to an explicit
<a name="419"></a>                &lt;&lt;aHref('LOOK', 'LOOK', 'Look
<a name="420"></a>                    around')&gt;&gt; command.&lt;&lt;only&gt;&gt; ');
<a name="421"></a>        }
<a name="422"></a>        else
<a name="423"></a>            DMsg(game already brief, 'The game is already in BRIEF mode. ');
<a name="424"></a>    }
<a name="425"></a>;
<a name="426"></a>
<a name="427"></a>DefineSystemAction(Verbose)
<a name="428"></a>    execAction(cmd)
<a name="429"></a>    {
<a name="430"></a>        if(gameMain.verbose)            
<a name="431"></a>            DMsg(game already verbose, 'The game is already in VERBOSE mode. ');        
<a name="432"></a>        else
<a name="433"></a>        {
<a name="434"></a>            gameMain.verbose = true;
<a name="435"></a>            DMsg(game now verbose, 'The game is now in VERBOSE mode. &lt;&lt;first
<a name="436"></a>                  time&gt;&gt;Full room descriptions be shown each time a room is
<a name="437"></a>                visited.&lt;&lt;only&gt;&gt; ');
<a name="438"></a>        }            
<a name="439"></a>    }
<a name="440"></a>;
<a name="441"></a>
<a name="442"></a>
<a name="443"></a>/* Set Inventory to TALL format */
<a name="444"></a>DefineSystemAction(InventoryTall)
<a name="445"></a>    execAction(cmd)
<a name="446"></a>    {
<a name="447"></a>        /* Register with libGlobal that inventory listing should now be in tall format. */
<a name="448"></a>        libGlobal.inventoryTall = true;
<a name="449"></a>        
<a name="450"></a>        /* Display a confirmation that this change has just taken place. */
<a name="451"></a>        DMsg(inventory tall, 'Inventory Listing is now set to TALL');
<a name="452"></a>    }
<a name="453"></a>;
<a name="454"></a>  
<a name="455"></a>/* Set Inventory to WIDE format */
<a name="456"></a>DefineSystemAction(InventoryWide)        
<a name="457"></a>    execAction(cmd)
<a name="458"></a>    {
<a name="459"></a>        /* Register with libGlobal that inventory listing should now be in wide format. */
<a name="460"></a>        libGlobal.inventoryTall = nil;
<a name="461"></a>        
<a name="462"></a>        /* Display a confirmation that this change has just taken place. */
<a name="463"></a>        DMsg(inventory wide, 'Inventory Listing is now set to WIDE');
<a name="464"></a>    }
<a name="465"></a>;
<a name="466"></a>
<a name="467"></a>
<a name="468"></a>DefineIAction(Inventory)
<a name="469"></a>    execAction(cmd)
<a name="470"></a>    {
<a name="471"></a>        /* 
<a name="472"></a>         *   If splitListing is true, we potentially need to display two lists,
<a name="473"></a>         *   one of what the actor is wearing and one of what the actor is
<a name="474"></a>         *   carrying.
<a name="475"></a>         */
<a name="476"></a>        if(splitListing)
<a name="477"></a>        {
<a name="478"></a>            /* Construct a list of what the actor is wearing */
<a name="479"></a>            local wornList = gActor.contents.subset({o: o.wornBy == gActor });
<a name="480"></a>            
<a name="481"></a>            /* Construst a list of what the actor is carrying */
<a name="482"></a>            local carriedList = gActor.contents.subset({o: o.wornBy == nil &amp;&amp;
<a name="483"></a>                o.isFixed == nil});
<a name="484"></a>            
<a name="485"></a>            /* Note whether we've displayed the worn list */
<a name="486"></a>            local wornListShown = 0;
<a name="487"></a>            
<a name="488"></a>            /* 
<a name="489"></a>                 *   If anything is being worn, get a list of it minus the final
<a name="490"></a>             *   paragraph break and then display it.
<a name="491"></a>             */
<a name="492"></a>            if(wornList.length &gt; 0)
<a name="493"></a>            {               
<a name="494"></a>                gActor.myWornLister.show(wornList, 0, nil);
<a name="495"></a>                
<a name="496"></a>                /* 
<a name="497"></a>                 *   If nothing is being carried, terminate the list with a full
<a name="498"></a>                 *   stop and a paragraph break.
<a name="499"></a>                 */
<a name="500"></a>                if(carriedList.length == 0)
<a name="501"></a>                    ".&lt;.p&gt;";
<a name="502"></a>                
<a name="503"></a>                /*  
<a name="504"></a>                 *   Note that the worn list has been shown.                 
<a name="505"></a>                 */
<a name="506"></a>                wornListShown = 1;
<a name="507"></a>                
<a name="508"></a>            }
<a name="509"></a>            /* 
<a name="510"></a>             *   If something's being carried or nothing's being worn, display
<a name="511"></a>             *   an inventory list of what's being carried. If nothing's being
<a name="512"></a>             *   worn or carried, this will display the "You are empty-handed"
<a name="513"></a>             *   message.
<a name="514"></a>             */
<a name="515"></a>            if(carriedList.length &gt; 0 || wornList.length == 0)
<a name="516"></a>                gActor.myInventoryLister.show(carriedList, wornListShown);
<a name="517"></a>        }
<a name="518"></a>        else
<a name="519"></a>        {
<a name="520"></a>            gActor.myInventoryLister.show(gActor.contents, 0);
<a name="521"></a>        }
<a name="522"></a>        
<a name="523"></a>        /* Mark eveything just listed as having been seen. */
<a name="524"></a>        gActor.contents.forEach({x: x.noteSeen()});
<a name="525"></a>    }
<a name="526"></a>   
<a name="527"></a>        
<a name="528"></a>    /* 
<a name="529"></a>     *   Do we want separate lists of what's worn and what's carried?  By default we do unless we're
<a name="530"></a>     *   doing a tall inventory listing
<a name="531"></a>     */
<a name="532"></a>    splitListing = !libGlobal.inventoryTall
<a name="533"></a>;
<a name="534"></a>
<a name="535"></a>DefineIAction(Look)
<a name="536"></a>    execAction(cmd)
<a name="537"></a>    {
<a name="538"></a>        gActor.outermostVisibleParent().lookAroundWithin();
<a name="539"></a>    }
<a name="540"></a>
<a name="541"></a>;
<a name="542"></a>
<a name="543"></a>DefineIAction(Wait)
<a name="544"></a>    execAction(cmd)
<a name="545"></a>    {
<a name="546"></a>        DMsg(wait, 'Time {dummy} pass{es/ed}. ');
<a name="547"></a>    }
<a name="548"></a>   
<a name="549"></a>;
<a name="550"></a>
<a name="551"></a>DefineIAction(Jump)
<a name="552"></a>    execAction(cmd)
<a name="553"></a>    {
<a name="554"></a>        DMsg(jump, '{I} jump{s/ed} on the spot, fruitlessly. ');
<a name="555"></a>    }
<a name="556"></a>    
<a name="557"></a>    preCond = (gActor.location &amp;&amp; gActor.location.getOutToJump ?
<a name="558"></a>    [actorOutOfNested]: nil)
<a name="559"></a>;
<a name="560"></a>
<a name="561"></a>DefineIAction(Yell)
<a name="562"></a>    execAction(cmd)
<a name="563"></a>    {
<a name="564"></a>        DMsg(yell, '{I} shout{s/ed} very loudly. ');
<a name="565"></a>    }
<a name="566"></a>;
<a name="567"></a>
<a name="568"></a>DefineIAction(Smell)
<a name="569"></a>    execAction(cmd)
<a name="570"></a>    {
<a name="571"></a>        /* 
<a name="572"></a>         *   Build a list of all the objects in scope that both (1) define a
<a name="573"></a>         *   smellDesc property that will display something and (2) whose
<a name="574"></a>         *   isProminentSmell property is true
<a name="575"></a>         */
<a name="576"></a>        local s_list = gActor.getOutermostRoom.allContents.subset(
<a name="577"></a>            {x: Q.canSmell(gActor, x)  &amp;&amp;  x.isProminentSmell});
<a name="578"></a>        
<a name="579"></a>        /* Include the current room in the list. */
<a name="580"></a>        s_list += gActor.getOutermostRoom;
<a name="581"></a>        
<a name="582"></a>        s_list = s_list.getUnique();
<a name="583"></a>        
<a name="584"></a>        /*  Obtain the corresponding list for remote rooms */
<a name="585"></a>        local r_list = getRemoteSmellList().getUnique() - s_list;
<a name="586"></a>               
<a name="587"></a>        /* 
<a name="588"></a>         *   Create a local variable to keep track of whether we've displayed
<a name="589"></a>         *   anything.
<a name="590"></a>         */
<a name="591"></a>        local somethingDisplayed = nil;
<a name="592"></a>        
<a name="593"></a>        
<a name="594"></a>        /* 
<a name="595"></a>         *   Display the smellDesc of every item in our local smell list,
<a name="596"></a>         *   keeping track of whether anything has actually been displayed as a
<a name="597"></a>         *   result.
<a name="598"></a>         */
<a name="599"></a>        foreach(local cur in s_list)
<a name="600"></a>        {
<a name="601"></a>            if(cur.displayAlt(&amp;smellDesc))
<a name="602"></a>                somethingDisplayed = true;
<a name="603"></a>        }
<a name="604"></a>        
<a name="605"></a>        /* Then list any smells from remote locations */
<a name="606"></a>        if(listRemoteSmells(r_list))
<a name="607"></a>            somethingDisplayed = true;
<a name="608"></a>        
<a name="609"></a>        
<a name="610"></a>        /*  If nothing has been displayed report that there is nothing to smell */        
<a name="611"></a>        if(!somethingDisplayed)            
<a name="612"></a>            DMsg(smell nothing intransitive, '{I} {smell} nothing out of the
<a name="613"></a>                ordinary.&lt;.p&gt;');
<a name="614"></a>
<a name="615"></a>    }
<a name="616"></a>    
<a name="617"></a>    /* Do nothing in the core library; senseRegion.t will override if present */
<a name="618"></a>    getRemoteSmellList() { return []; }
<a name="619"></a>    
<a name="620"></a>    /* Do nothing in the core library; senseRegion.t will override if present */
<a name="621"></a>    listRemoteSmells(lst) { return nil; }
<a name="622"></a>;
<a name="623"></a>
<a name="624"></a>
<a name="625"></a>DefineIAction(Listen)
<a name="626"></a>    execAction(cmd)
<a name="627"></a>    {
<a name="628"></a>        /* 
<a name="629"></a>         *   I may be able to hear things that aren't technically in scope,
<a name="630"></a>         *   since they may be hidden in containers that allow sound through.
<a name="631"></a>         */        
<a name="632"></a>        local s_list = gActor.getOutermostRoom.allContents.subset(
<a name="633"></a>            {x: Q.canHear(gActor,x) &amp;&amp; x.isProminentNoise});
<a name="634"></a>        
<a name="635"></a>        /* Include the current room in the list. */
<a name="636"></a>        s_list += gActor.getOutermostRoom;
<a name="637"></a>        
<a name="638"></a>        s_list = s_list.getUnique();
<a name="639"></a>        
<a name="640"></a>        local r_list = getRemoteSoundList().getUnique() - s_list;
<a name="641"></a>        
<a name="642"></a>        /* 
<a name="643"></a>         *   Create a local variable to keep track of whether we've displayed
<a name="644"></a>         *   anything.
<a name="645"></a>         */
<a name="646"></a>        local somethingDisplayed = nil;
<a name="647"></a>        
<a name="648"></a>        foreach(local cur in s_list)
<a name="649"></a>        {
<a name="650"></a>            if(cur.displayAlt(&amp;listenDesc))
<a name="651"></a>                somethingDisplayed = true;
<a name="652"></a>        }
<a name="653"></a>        
<a name="654"></a>        if(listRemoteSounds(r_list))
<a name="655"></a>            somethingDisplayed = true;
<a name="656"></a>        
<a name="657"></a>        
<a name="658"></a>        if(!somethingDisplayed)
<a name="659"></a>            DMsg(hear nothing listen, '{I} hear{s/d} nothing out of the
<a name="660"></a>                ordinary.&lt;.p&gt;');
<a name="661"></a>
<a name="662"></a>        
<a name="663"></a>    }
<a name="664"></a>    
<a name="665"></a>    /* Do nothing in the core library; senseRegion.t will override if present */
<a name="666"></a>    getRemoteSoundList() { return []; }
<a name="667"></a>    
<a name="668"></a>    /* Do nothing in the core library; senseRegion.t will override if present */
<a name="669"></a>    listRemoteSounds(lst) { return nil; }
<a name="670"></a>;
<a name="671"></a>
<a name="672"></a>DefineIAction(Sleep)
<a name="673"></a>    execAction(cmd)
<a name="674"></a>    {
<a name="675"></a>        DMsg(no sleeping, 'This {dummy} {is} no time for sleeping. ');
<a name="676"></a>    }
<a name="677"></a>;
<a name="678"></a>
<a name="679"></a>
<a name="680"></a>
<a name="681"></a>
<a name="682"></a>GoIn: TravelAction
<a name="683"></a>    direction = inDir
<a name="684"></a>    predefinedDirection = true
<a name="685"></a>;
<a name="686"></a>
<a name="687"></a>GoOut: TravelAction
<a name="688"></a>    direction = outDir
<a name="689"></a>    predefinedDirection = true
<a name="690"></a>    
<a name="691"></a>    execAction(cmd)
<a name="692"></a>    {
<a name="693"></a>        if(!gActor.location.ofKind(Room))
<a name="694"></a>        {
<a name="695"></a>            local getOffAction;
<a name="696"></a>            getOffAction = gActor.location.contType == On ? GetOff : GetOutOf;
<a name="697"></a>            replaceAction(getOffAction, gActor.location);
<a name="698"></a>        }
<a name="699"></a>        else
<a name="700"></a>        {
<a name="701"></a>            "&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;";
<a name="702"></a>            doTravel();
<a name="703"></a>        }
<a name="704"></a>    }
<a name="705"></a>;
<a name="706"></a>
<a name="707"></a>/* 
<a name="708"></a> *   The GO action is never triggered directly by a player command but can be
<a name="709"></a> *   used to synthesize a travel action in the direction supplied by the dobj.
<a name="710"></a> */
<a name="711"></a>
<a name="712"></a>Go: TravelAction
<a name="713"></a>    predefinedDirection = true
<a name="714"></a>    
<a name="715"></a>    execAction(cmd)
<a name="716"></a>    {
<a name="717"></a>        direction = cmd.dobj;
<a name="718"></a>        inherited(cmd);
<a name="719"></a>    }
<a name="720"></a>    
<a name="721"></a>    /* Define this so that this action can be called from execNestedAction */
<a name="722"></a>    resolvedObjectsInScope() { return true; }
<a name="723"></a>
<a name="724"></a>;
<a name="725"></a>    
<a name="726"></a>DefineIAction(GetOut)
<a name="727"></a>    execAction(cmd)
<a name="728"></a>    {        
<a name="729"></a>        GoOut.execAction(cmd);
<a name="730"></a>    }
<a name="731"></a>;
<a name="732"></a>
<a name="733"></a>/* 
<a name="734"></a> *   We'll take STAND to be a request to get out of the actor's immediate
<a name="735"></a> *   container, unless the actor is directly in a room in which case we'll
<a name="736"></a> *   simply say that he is standing.
<a name="737"></a> */
<a name="738"></a>
<a name="739"></a>DefineIAction(Stand)
<a name="740"></a>    execAction(cmd)
<a name="741"></a>    {
<a name="742"></a>        if(!gActor.location.ofKind(Room))
<a name="743"></a>            replaceAction(GetOff, gActor.location);
<a name="744"></a>        else
<a name="745"></a>        {
<a name="746"></a>            DMsg(already standing, '{I} {am} standing. ');
<a name="747"></a>        }
<a name="748"></a>        
<a name="749"></a>    }
<a name="750"></a>;
<a name="751"></a>
<a name="752"></a>
<a name="753"></a>DefineIAction(Sit)
<a name="754"></a>    execAction(cmd)
<a name="755"></a>    {
<a name="756"></a>        askForDobj(SitOn);          
<a name="757"></a>    }
<a name="758"></a>;
<a name="759"></a>
<a name="760"></a>DefineIAction(Lie)
<a name="761"></a>    execAction(cmd)
<a name="762"></a>    {
<a name="763"></a>        askForDobj(LieOn);
<a name="764"></a>    }   
<a name="765"></a>;
<a name="766"></a>
<a name="767"></a>
<a name="768"></a>Travel: TravelAction
<a name="769"></a>    direction = (dirMatch.dir)
<a name="770"></a>;
<a name="771"></a>
<a name="772"></a>DefineIAction(VagueTravel)
<a name="773"></a>    execAction(cmd)
<a name="774"></a>    {
<a name="775"></a>        DMsg(vague travel, 'Which way do you want to go? ');       
<a name="776"></a>    }
<a name="777"></a>;
<a name="778"></a>
<a name="779"></a>
<a name="780"></a>DefineIAction(GoBack)
<a name="781"></a>    execAction(cmd)
<a name="782"></a>    {
<a name="783"></a>        local pathBack = nil;
<a name="784"></a>        
<a name="785"></a>        if(libGlobal.lastLoc == nil)
<a name="786"></a>        {
<a name="787"></a>            DMsg(nowhere back, '{I} {have} nowhere to go back to. ');
<a name="788"></a>            return;            
<a name="789"></a>        }
<a name="790"></a>        
<a name="791"></a>        pathBack = defined(routeFinder) ? 
<a name="792"></a>             routeFinder.findPath(gActor.getOutermostRoom,
<a name="793"></a>                libGlobal.lastLoc) : nil;
<a name="794"></a>               
<a name="795"></a>        
<a name="796"></a>        if(pathBack == nil)
<a name="797"></a>        {
<a name="798"></a>            DMsg(no way back, 'There{dummy}{\'s} no way back. ');
<a name="799"></a>            return;
<a name="800"></a>        }
<a name="801"></a>        
<a name="802"></a>        if(pathBack.length == 1)
<a name="803"></a>        {
<a name="804"></a>            DMsg(already back there, '{I}{\'m} already there. ');
<a name="805"></a>            return;
<a name="806"></a>        }
<a name="807"></a>        
<a name="808"></a>        local dir = pathBack[2][1];
<a name="809"></a>        
<a name="810"></a>        DMsg(going back dir, '(going {1})\n', dir.name);
<a name="811"></a>        
<a name="812"></a>        gActor.getOutermostRoom.(dir.dirProp).travelVia(gActor);
<a name="813"></a>        
<a name="814"></a>    }
<a name="815"></a>;
<a name="816"></a>
<a name="817"></a>DefineTAction(GoTo)
<a name="818"></a>    
<a name="819"></a>    /* Add all known items to scope */
<a name="820"></a>    addExtraScopeItems(whichRole?)
<a name="821"></a>    {
<a name="822"></a>       scopeList = scopeList.appendUnique(Q.knownScopeList);
<a name="823"></a>    }
<a name="824"></a>    
<a name="825"></a>    againRepeatsParse = nil
<a name="826"></a>    
<a name="827"></a>    reportImplicitActions = nil
<a name="828"></a>;
<a name="829"></a>
<a name="830"></a>DefineIAction(Continue)
<a name="831"></a>    execAction(cmd)
<a name="832"></a>    {
<a name="833"></a>        local path;
<a name="834"></a>        path = defined(pcRouteFinder) ? pcRouteFinder.cachedRoute : nil;
<a name="835"></a>        if(path == nil)
<a name="836"></a>        {
<a name="837"></a>            DMsg(no journey, '{I}{\'m} not going anywhere. ');
<a name="838"></a>            return;
<a name="839"></a>        }
<a name="840"></a>        
<a name="841"></a>        local idx = path.indexWhich({x: x[2] == gActor.getOutermostRoom});
<a name="842"></a>        
<a name="843"></a>        if(idx == nil)
<a name="844"></a>        {
<a name="845"></a>            path = defined(pcRouteFinder) ?
<a name="846"></a>                pcRouteFinder.findPath(gActor.getOutermostRoom,
<a name="847"></a>                                       pcRouteFinder.currentDestination) : nil;
<a name="848"></a>            
<a name="849"></a>            if(path == nil)
<a name="850"></a>            {
<a name="851"></a>                DMsg(off route, '{I}{\'m} no longer on {my} route. Use the GO TO
<a name="852"></a>                    command to set up a new route. ');
<a name="853"></a>                return;
<a name="854"></a>            }
<a name="855"></a>            else
<a name="856"></a>                idx = 1;                
<a name="857"></a>        }
<a name="858"></a>        
<a name="859"></a>        if(idx == path.length)
<a name="860"></a>        {
<a name="861"></a>            say(gActor.getOutermostRoom.alreadyThereMsg);
<a name="862"></a>            return;
<a name="863"></a>        }
<a name="864"></a>        
<a name="865"></a>        local dir = path[idx + 1][1];
<a name="866"></a>        
<a name="867"></a>        takeStep(dir, path[path.length][2]);
<a name="868"></a>        
<a name="869"></a>        
<a name="870"></a>    }
<a name="871"></a>    
<a name="872"></a>    takeStep(dir, dest, fastGo?)
<a name="873"></a>    {
<a name="874"></a>        DMsg(going dir, '(going {1})\n', dir.name);
<a name="875"></a>        
<a name="876"></a>        gActor.getOutermostRoom.(dir.dirProp).travelVia(gActor);
<a name="877"></a>        
<a name="878"></a>        if(!gActor.isIn(dest) &amp;&amp; !fastGo)           
<a name="879"></a>            htmlSay(contMsg);
<a name="880"></a>        
<a name="881"></a>    }
<a name="882"></a>    
<a name="883"></a>    contMsg =  BMsg(explain continue, 'To continue the journey
<a name="884"></a>                use the command
<a name="885"></a>                &lt;&lt;aHref('Continue','CONTINUE','Continue')&gt;&gt; or C. ')
<a name="886"></a>    
<a name="887"></a>    
<a name="888"></a>;
<a name="889"></a>
<a name="890"></a>DefineSystemAction(Topics)
<a name="891"></a>    execAction(cmd)
<a name="892"></a>    {
<a name="893"></a>        local otherActor = gPlayerChar.currentInterlocutor;
<a name="894"></a>        
<a name="895"></a>        if(otherActor == nil)
<a name="896"></a>            DMsg(no interlocutor, '{I}{\'m} not talking to anyone. ');
<a name="897"></a>        else
<a name="898"></a>        {            
<a name="899"></a>            otherActor.showSuggestions(true);
<a name="900"></a>        }
<a name="901"></a>    }
<a name="902"></a>    
<a name="903"></a>    afterAction() {}
<a name="904"></a>;
<a name="905"></a>    
<a name="906"></a>
<a name="907"></a>DefineTAction(Examine)
<a name="908"></a>    announceMultiAction = true
<a name="909"></a>    
<a name="910"></a>    getAll(cmd, role)
<a name="911"></a>    {
<a name="912"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="913"></a>    }
<a name="914"></a>
<a name="915"></a>    againRepeatsParse = nil
<a name="916"></a>;
<a name="917"></a>
<a name="918"></a>/* 
<a name="919"></a> *   The ExamineOrGoTo action is used as the default action by the Parser; it is
<a name="920"></a> *   not an action the player can directly command. If the player enters a room
<a name="921"></a> *   (and nothing else) on the command line, and the room is known to the player
<a name="922"></a> *   character, and the player character is not already in the room, the command
<a name="923"></a> *   will be treated as a GoTo action; otherwise it will be treated as an
<a name="924"></a> *   Examine action.
<a name="925"></a> */
<a name="926"></a>   
<a name="927"></a>DefineTAction(ExamineOrGoTo)
<a name="928"></a>    exec(cmd)
<a name="929"></a>    {        
<a name="930"></a>        if(defined(pcRouteFinder) &amp;&amp; cmd.dobj.ofKind(Room)
<a name="931"></a>           &amp;&amp; !cmd.actor.isIn(cmd.dobj))        
<a name="932"></a>            cmd.action = GoTo;
<a name="933"></a>        else
<a name="934"></a>            cmd.action = Examine;
<a name="935"></a>        
<a name="936"></a>        gAction = cmd.action;
<a name="937"></a>        gAction.reset();
<a name="938"></a>        gAction.exec(cmd);     
<a name="939"></a>    }
<a name="940"></a>    
<a name="941"></a>    
<a name="942"></a>    /* For this action to work all known rooms also need to be in scope */
<a name="943"></a>    addExtraScopeItems(whichRole?)
<a name="944"></a>    {
<a name="945"></a>        scopeList = scopeList.appendUnique(Q.knownScopeList.subset({x:
<a name="946"></a>            x.ofKind(Room)}));
<a name="947"></a>    }
<a name="948"></a>    
<a name="949"></a>    
<a name="950"></a>;
<a name="951"></a>
<a name="952"></a>DefineTAction(Follow)
<a name="953"></a>    againRepeatsParse = nil   
<a name="954"></a>;
<a name="955"></a>
<a name="956"></a>
<a name="957"></a>DefineTAction(Read)
<a name="958"></a>    announceMultiAction = true
<a name="959"></a>    
<a name="960"></a>    getAll(cmd, role)
<a name="961"></a>    {
<a name="962"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="963"></a>    }
<a name="964"></a>
<a name="965"></a>    againRepeatsParse = nil
<a name="966"></a>;
<a name="967"></a>
<a name="968"></a>DefineTAction(SmellSomething)
<a name="969"></a>    announceMultiAction = true
<a name="970"></a>    againRepeatsParse = nil
<a name="971"></a>    
<a name="972"></a>    /* Add any Odors the actor can smell */
<a name="973"></a>    addExtraScopeItems(whichRole?)
<a name="974"></a>    {
<a name="975"></a>        if(defined(Odor))
<a name="976"></a>        {
<a name="977"></a>            local odorList = gActor.getOutermostRoom.allContents.subset(
<a name="978"></a>                { o: o.isOdor &amp;&amp; Q.canSmell(gActor, o) } );
<a name="979"></a>            
<a name="980"></a>            scopeList = scopeList.appendUnique(odorList);
<a name="981"></a>        }
<a name="982"></a>    }
<a name="983"></a>    
<a name="984"></a>;
<a name="985"></a>
<a name="986"></a>DefineTAction(ListenTo)
<a name="987"></a>    announceMultiAction = true
<a name="988"></a>    againRepeatsParse = nil
<a name="989"></a>    
<a name="990"></a>    /* Add any Noises the actor can hear */
<a name="991"></a>    addExtraScopeItems(whichRole?)
<a name="992"></a>    {
<a name="993"></a>        if(defined(Noise))
<a name="994"></a>        {
<a name="995"></a>            local noiseList = gActor.getOutermostRoom.allContents.subset(
<a name="996"></a>                { n: n.isNoise &amp;&amp; Q.canHear(gActor, n) } );
<a name="997"></a>            
<a name="998"></a>            scopeList = scopeList.appendUnique(noiseList);
<a name="999"></a>        }
<a name="1000"></a>    }    
<a name="1001"></a>    
<a name="1002"></a>;
<a name="1003"></a>
<a name="1004"></a>DefineTAction(Taste)
<a name="1005"></a>    announceMultiAction = true
<a name="1006"></a>    getAll(cmd, role)
<a name="1007"></a>    {
<a name="1008"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="1009"></a>    }
<a name="1010"></a>    againRepeatsParse = nil
<a name="1011"></a>;
<a name="1012"></a>
<a name="1013"></a>DefineTAction(Feel)
<a name="1014"></a>    announceMultiAction = true
<a name="1015"></a>    getAll(cmd, role)
<a name="1016"></a>    {
<a name="1017"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="1018"></a>    }
<a name="1019"></a>    againRepeatsParse = nil
<a name="1020"></a>;
<a name="1021"></a>
<a name="1022"></a>DefineTAction(Take)
<a name="1023"></a>    
<a name="1024"></a>    getAll(cmd, role)
<a name="1025"></a>    {
<a name="1026"></a>        return scopeList.subset({ x: !x.isDirectlyIn(cmd.actor) &amp;&amp; !x.isFixed});
<a name="1027"></a>    }
<a name="1028"></a>    
<a name="1029"></a>    
<a name="1030"></a>    announceMultiAction = nil
<a name="1031"></a>    allowAll = true
<a name="1032"></a>   
<a name="1033"></a>;
<a name="1034"></a>
<a name="1035"></a>DefineTAction(Drop)      
<a name="1036"></a>    allowAll = true
<a name="1037"></a>    
<a name="1038"></a>    getAll(cmd, role)
<a name="1039"></a>    {
<a name="1040"></a>        return scopeList.subset({ x: x.isDirectlyIn(cmd.actor) &amp;&amp; !x.isFixed});
<a name="1041"></a>    }  
<a name="1042"></a>;
<a name="1043"></a>
<a name="1044"></a>DefineTAction(Throw)
<a name="1045"></a>    getAll(cmd, role)
<a name="1046"></a>    {
<a name="1047"></a>        return scopeList.subset({ x: !x.isFixed});
<a name="1048"></a>    }   
<a name="1049"></a>;
<a name="1050"></a>
<a name="1051"></a>
<a name="1052"></a>DefineTAction(Attack)
<a name="1053"></a>    againRepeatsParse = nil
<a name="1054"></a>;
<a name="1055"></a>
<a name="1056"></a>DefineTAction(Strike)
<a name="1057"></a>    againRepeatsParse = nil
<a name="1058"></a>;
<a name="1059"></a>
<a name="1060"></a>DefineTAction(Open)       
<a name="1061"></a>;
<a name="1062"></a>
<a name="1063"></a>DefineTAction(Close)        
<a name="1064"></a>;
<a name="1065"></a>
<a name="1066"></a>DefineTAction(LookIn)  
<a name="1067"></a>    againRepeatsParse = nil
<a name="1068"></a>;
<a name="1069"></a>
<a name="1070"></a>DefineTAction(LookUnder)    
<a name="1071"></a>    againRepeatsParse = nil
<a name="1072"></a>;
<a name="1073"></a>
<a name="1074"></a>DefineTAction(LookBehind)
<a name="1075"></a>    againRepeatsParse = nil
<a name="1076"></a>;
<a name="1077"></a>
<a name="1078"></a>DefineTAction(LookThrough)
<a name="1079"></a>    againRepeatsParse = nil
<a name="1080"></a>;
<a name="1081"></a>
<a name="1082"></a>DefineTAction(Unlock)    
<a name="1083"></a>;
<a name="1084"></a>
<a name="1085"></a>DefineTAction(Lock)        
<a name="1086"></a>;
<a name="1087"></a>
<a name="1088"></a>DefineTAction(SwitchOn)        
<a name="1089"></a>;
<a name="1090"></a>
<a name="1091"></a>DefineTAction(SwitchOff)        
<a name="1092"></a>;
<a name="1093"></a>
<a name="1094"></a>DefineTAction(Turn)  
<a name="1095"></a>    againRepeatsParse = nil
<a name="1096"></a>;
<a name="1097"></a>
<a name="1098"></a>DefineTAction(Wear)       
<a name="1099"></a>;
<a name="1100"></a>
<a name="1101"></a>DefineTAction(Doff)    
<a name="1102"></a>    allowAll = true    
<a name="1103"></a>;
<a name="1104"></a>
<a name="1105"></a>DefineTAction(Break)
<a name="1106"></a>    againRepeatsParse = nil
<a name="1107"></a>;
<a name="1108"></a>
<a name="1109"></a>DefineTAction(Climb)       
<a name="1110"></a>;
<a name="1111"></a>
<a name="1112"></a>DefineTAction(ClimbUp)      
<a name="1113"></a>;
<a name="1114"></a>
<a name="1115"></a>DefineTAction(ClimbDown)        
<a name="1116"></a>;
<a name="1117"></a>
<a name="1118"></a>DefineIAction(ClimbUpVague)
<a name="1119"></a>    execAction(cmd)  { askForDobj(ClimbUp); }
<a name="1120"></a>;    
<a name="1121"></a>
<a name="1122"></a>DefineIAction(ClimbDownVague)
<a name="1123"></a>    execAction(cmd)  { askForDobj(ClimbDown); }
<a name="1124"></a>;
<a name="1125"></a>
<a name="1126"></a>DefineTAction(Board)        
<a name="1127"></a>;
<a name="1128"></a>
<a name="1129"></a>DefineTAction(StandOn)   
<a name="1130"></a>;
<a name="1131"></a>
<a name="1132"></a>DefineTAction(SitOn)    
<a name="1133"></a>;
<a name="1134"></a>
<a name="1135"></a>DefineTAction(LieOn)    
<a name="1136"></a>;
<a name="1137"></a>
<a name="1138"></a>
<a name="1139"></a>DefineTAction(StandIn)    
<a name="1140"></a>;
<a name="1141"></a>
<a name="1142"></a>DefineTAction(SitIn)    
<a name="1143"></a>;
<a name="1144"></a>
<a name="1145"></a>DefineTAction(LieIn)   
<a name="1146"></a>;
<a name="1147"></a>
<a name="1148"></a>DefineTAction(Enter)   
<a name="1149"></a>;
<a name="1150"></a>
<a name="1151"></a>DefineTAction(GetOff)        
<a name="1152"></a>;
<a name="1153"></a>
<a name="1154"></a>DefineTAction(GetOutOf)    
<a name="1155"></a>;
<a name="1156"></a>    
<a name="1157"></a>DefineTAction(GoThrough)    
<a name="1158"></a>;
<a name="1159"></a>
<a name="1160"></a>DefineTAction(GoAlong)    
<a name="1161"></a>;
<a name="1162"></a>
<a name="1163"></a>DefineTAction(TravelVia)
<a name="1164"></a>;
<a name="1165"></a>
<a name="1166"></a>DefineTAction(Push)
<a name="1167"></a>    againRepeatsParse = nil
<a name="1168"></a>;
<a name="1169"></a>
<a name="1170"></a>DefineTAction(Pull)
<a name="1171"></a>    againRepeatsParse = nil
<a name="1172"></a>;
<a name="1173"></a>
<a name="1174"></a>DefineTAction(Search)
<a name="1175"></a>    againRepeatsParse = nil
<a name="1176"></a>;
<a name="1177"></a>
<a name="1178"></a>DefineTAction(Remove)
<a name="1179"></a>    againRepeatsParse = nil
<a name="1180"></a>;
<a name="1181"></a>
<a name="1182"></a>DefineTAction(Move)
<a name="1183"></a>    againRepeatsParse = nil
<a name="1184"></a>;
<a name="1185"></a>    
<a name="1186"></a>DefineTAction(Light)   
<a name="1187"></a>;
<a name="1188"></a>
<a name="1189"></a>DefineTAction(Extinguish)    
<a name="1190"></a>;
<a name="1191"></a>
<a name="1192"></a>DefineTAction(Eat)
<a name="1193"></a>;
<a name="1194"></a>
<a name="1195"></a>DefineTAction(Drink)
<a name="1196"></a>;
<a name="1197"></a>
<a name="1198"></a>DefineTAction(Clean)
<a name="1199"></a>    againRepeatsParse = nil
<a name="1200"></a>;
<a name="1201"></a>
<a name="1202"></a>DefineTAction(Dig)
<a name="1203"></a>    againRepeatsParse = nil
<a name="1204"></a>;
<a name="1205"></a>
<a name="1206"></a>DefineTAction(Kiss)
<a name="1207"></a>    againRepeatsParse = nil
<a name="1208"></a>;
<a name="1209"></a>
<a name="1210"></a>DefineTAction(Detach)
<a name="1211"></a>    getAll(cmd, role)
<a name="1212"></a>    {
<a name="1213"></a>        return scopeList.subset({ x: x.attachedTo != nil});
<a name="1214"></a>    }
<a name="1215"></a>;
<a name="1216"></a>
<a name="1217"></a>DefineTIAction(DigWith)
<a name="1218"></a>    resolveIobjFirst = nil
<a name="1219"></a>    againRepeatsParse = nil
<a name="1220"></a>;
<a name="1221"></a>
<a name="1222"></a>DefineTIAction(CleanWith)
<a name="1223"></a>    resolveIobjFirst = nil
<a name="1224"></a>    againRepeatsParse = nil
<a name="1225"></a>;
<a name="1226"></a>
<a name="1227"></a>DefineTIAction(MoveTo)
<a name="1228"></a>    resolveIobjFirst = nil
<a name="1229"></a>    getAll(cmd, role)
<a name="1230"></a>    {
<a name="1231"></a>        return scopeList.subset({ x: x.isMoveable});
<a name="1232"></a>    }
<a name="1233"></a>    againRepeatsParse = nil
<a name="1234"></a>;
<a name="1235"></a>
<a name="1236"></a>DefineTIAction(MoveWith)
<a name="1237"></a>    resolveIobjFirst = nil
<a name="1238"></a>    
<a name="1239"></a>    getAll(cmd, role)
<a name="1240"></a>    {
<a name="1241"></a>        return scopeList.subset({ x: x.isMoveable});
<a name="1242"></a>    }
<a name="1243"></a>    againRepeatsParse = nil
<a name="1244"></a>;
<a name="1245"></a>
<a name="1246"></a>DefineTIAction(PutOn)       
<a name="1247"></a>    announceMultiAction = nil
<a name="1248"></a>    allowAll = true
<a name="1249"></a>    getAll(cmd, role)   
<a name="1250"></a>    {
<a name="1251"></a>        return putAllScope(curIobj, scopeList);
<a name="1252"></a>    }
<a name="1253"></a>;
<a name="1254"></a>
<a name="1255"></a>/* 
<a name="1256"></a> *   Return a suitable list of direct objects for a PUT ALL PREP XXX command,
<a name="1257"></a> *   where iobj is the indirect object of the command and slist is the full
<a name="1258"></a> *   scopelist for the action.
<a name="1259"></a> *
<a name="1260"></a> *   Ideally we want to return a list of all the objects that can be put in
<a name="1261"></a> *   iobj, namely all the objects in scope that are portable and not already in
<a name="1262"></a> *   iobj, and not the iobj. But if no objects fit the bill we have to fall back
<a name="1263"></a> *   on first, all portable objects in scope and, failing that, all objects in
<a name="1264"></a> *   scope except the room and the actor.
<a name="1265"></a> */
<a name="1266"></a>
<a name="1267"></a>putAllScope(iobj, slist)
<a name="1268"></a>{
<a name="1269"></a>    /* Get a list of all the portable objects in scope. */
<a name="1270"></a>    local portables = slist.subset({x: !x.isFixed});
<a name="1271"></a>    
<a name="1272"></a>    /* If there are none, return the scope list less the actor and any rooms */
<a name="1273"></a>    if(portables.length &lt; 1)
<a name="1274"></a>        return slist.subset({x: !x.ofKind(Room) &amp;&amp; x != gActor});
<a name="1275"></a>    
<a name="1276"></a>    /* 
<a name="1277"></a>     *   Get a list of suitable objects, i.e. portable objects that are not in
<a name="1278"></a>     *   the iobj and are not the iobj.
<a name="1279"></a>     */
<a name="1280"></a>    local suitables = portables.subset({x: iobj == nil || !x.isOrIsIn(iobj)});
<a name="1281"></a>    
<a name="1282"></a>    /* if there's anything in this list, return it */
<a name="1283"></a>    if(suitables.length &gt; 0)
<a name="1284"></a>        return suitables;
<a name="1285"></a>    
<a name="1286"></a>    /* Otherwise return the list of portable objects. */
<a name="1287"></a>    
<a name="1288"></a>    return portables;
<a name="1289"></a>}
<a name="1290"></a>
<a name="1291"></a>
<a name="1292"></a>DefineTIAction(PutIn)          
<a name="1293"></a>    announceMultiAction = nil
<a name="1294"></a>    allowAll = true
<a name="1295"></a>    
<a name="1296"></a>    getAll(cmd, role)   
<a name="1297"></a>    {
<a name="1298"></a>        return putAllScope(curIobj, scopeList);
<a name="1299"></a>    }
<a name="1300"></a>    
<a name="1301"></a>; 
<a name="1302"></a>
<a name="1303"></a>
<a name="1304"></a>
<a name="1305"></a>
<a name="1306"></a>DefineTIAction(PutUnder)      
<a name="1307"></a>    announceMultiAction = nil
<a name="1308"></a>    allowAll = true
<a name="1309"></a>    
<a name="1310"></a>    getAll(cmd, role)   
<a name="1311"></a>    {
<a name="1312"></a>        return putAllScope(curIobj, scopeList);
<a name="1313"></a>    }
<a name="1314"></a>;
<a name="1315"></a>
<a name="1316"></a>DefineTIAction(PutBehind)      
<a name="1317"></a>    nnounceMultiAction = nil
<a name="1318"></a>    allowAll = true
<a name="1319"></a>    
<a name="1320"></a>    getAll(cmd, role)   
<a name="1321"></a>    {
<a name="1322"></a>        return putAllScope(curIobj, scopeList);
<a name="1323"></a>    }
<a name="1324"></a>;
<a name="1325"></a>
<a name="1326"></a>
<a name="1327"></a>
<a name="1328"></a>DefineTIAction(UnlockWith)      
<a name="1329"></a>    resolveIobjFirst = nil
<a name="1330"></a>;
<a name="1331"></a>
<a name="1332"></a>DefineTIAction(LockWith)      
<a name="1333"></a>    resolveIobjFirst = nil
<a name="1334"></a>;
<a name="1335"></a>
<a name="1336"></a>DefineTAction(Attach)
<a name="1337"></a>;
<a name="1338"></a>
<a name="1339"></a>DefineTIAction(AttachTo)    
<a name="1340"></a>    resolveIobjFirst = nil
<a name="1341"></a>;
<a name="1342"></a>
<a name="1343"></a>DefineTIAction(DetachFrom)    
<a name="1344"></a>    getAll(cmd, role)
<a name="1345"></a>    {
<a name="1346"></a>        return scopeList.subset({ x: x.attachedTo == curIobj});
<a name="1347"></a>    }
<a name="1348"></a>;
<a name="1349"></a>
<a name="1350"></a>DefineTIAction(FastenTo)     
<a name="1351"></a>    resolveIobjFirst = nil
<a name="1352"></a>;
<a name="1353"></a>
<a name="1354"></a>DefineTIAction(TurnWith)
<a name="1355"></a>    resolveIobjFirst = nil
<a name="1356"></a>    againRepeatsParse = nil
<a name="1357"></a>;
<a name="1358"></a>
<a name="1359"></a>DefineTAction(Cut)
<a name="1360"></a>;
<a name="1361"></a>
<a name="1362"></a>DefineTIAction(CutWith)
<a name="1363"></a>    resolveIobjFirst = nil
<a name="1364"></a>    againRepeatsParse = nil
<a name="1365"></a>;
<a name="1366"></a>
<a name="1367"></a>DefineTIAction(TakeFrom)    
<a name="1368"></a>    /* 
<a name="1369"></a>     *   If the command matched ALL filter out dobjs that aren't in the iobj by
<a name="1370"></a>     *   not executing the command for them.
<a name="1371"></a>     */
<a name="1372"></a>    
<a name="1373"></a>    exec(cmd)
<a name="1374"></a>    {
<a name="1375"></a>        if(!cmd.matchedAll || cmd.iobj.notionalContents.indexOf(cmd.dobj) != nil)
<a name="1376"></a>            inherited(cmd);
<a name="1377"></a>        
<a name="1378"></a>        /* Otherwise note the current dobj in any case */
<a name="1379"></a>        else 
<a name="1380"></a>            curDobj = cmd.dobj;
<a name="1381"></a>    }
<a name="1382"></a>    
<a name="1383"></a>    reportAction()
<a name="1384"></a>    {
<a name="1385"></a>        if(reportList.length &gt; 0)
<a name="1386"></a>            inherited;
<a name="1387"></a>        
<a name="1388"></a>        /* 
<a name="1389"></a>         *   If the player tried to TAKE ALL FRMO IOBJ and there was nothing to
<a name="1390"></a>         *   take we need to report this
<a name="1391"></a>         */
<a name="1392"></a>        else if(gCommand.matchedAll)
<a name="1393"></a>            DMsg(nothing to take, 'There{dummy}{\'s} nothing available to
<a name="1394"></a>                    take from {1}. ', gCommand.iobj.theName);
<a name="1395"></a>    }
<a name="1396"></a>    
<a name="1397"></a>    getAll(cmd, role)
<a name="1398"></a>    {        
<a name="1399"></a>        return scopeList.subset({ x: !x.isFixed});
<a name="1400"></a>    }
<a name="1401"></a>    
<a name="1402"></a>    allowAll = true
<a name="1403"></a>    
<a name="1404"></a>    
<a name="1405"></a>;
<a name="1406"></a>
<a name="1407"></a>DefineTIAction(ThrowAt)    
<a name="1408"></a>    resolveIobjFirst = nil
<a name="1409"></a>;
<a name="1410"></a>
<a name="1411"></a>DefineTIAction(ThrowTo)    
<a name="1412"></a>    resolveIobjFirst = nil
<a name="1413"></a>;
<a name="1414"></a>
<a name="1415"></a>DefineTIAction(AttackWith)
<a name="1416"></a>    resolveIobjFirst = nil
<a name="1417"></a>    againRepeatsParse = nil
<a name="1418"></a>;
<a name="1419"></a>
<a name="1420"></a>DefineTAction(ThrowDir)
<a name="1421"></a>    execAction(cmd)
<a name="1422"></a>    {
<a name="1423"></a>        direction = cmd.verbProd.dirMatch.dir;
<a name="1424"></a>        inherited(cmd);
<a name="1425"></a>    }
<a name="1426"></a>    
<a name="1427"></a>    direction = nil
<a name="1428"></a>    againRepeatsParse = nil
<a name="1429"></a>;
<a name="1430"></a>
<a name="1431"></a>DefineIAction(JumpOffIntransitive)    
<a name="1432"></a>    execAction(cmd)
<a name="1433"></a>    {
<a name="1434"></a>        if(gActor.location.contType == On)
<a name="1435"></a>            replaceAction(JumpOff, gActor.location);
<a name="1436"></a>        else
<a name="1437"></a>            DMsg(not on anything, '{I}{\'m} not on anything. ');
<a name="1438"></a>    }    
<a name="1439"></a>;
<a name="1440"></a>
<a name="1441"></a>DefineTAction(JumpOff)    
<a name="1442"></a>;
<a name="1443"></a>
<a name="1444"></a>DefineTAction(JumpOver)
<a name="1445"></a>    againRepeatsParse = nil
<a name="1446"></a>;
<a name="1447"></a>
<a name="1448"></a>
<a name="1449"></a>DefineLiteralTAction(TurnTo)    
<a name="1450"></a>;
<a name="1451"></a>
<a name="1452"></a>DefineLiteralTAction(SetTo)    
<a name="1453"></a>;
<a name="1454"></a>
<a name="1455"></a>DefineTAction(Set)
<a name="1456"></a>;
<a name="1457"></a>
<a name="1458"></a>DefineTAction(TypeOnVague)
<a name="1459"></a>;
<a name="1460"></a>
<a name="1461"></a>DefineLiteralTAction(TypeOn)
<a name="1462"></a>    againRepeatsParse = nil   
<a name="1463"></a>    
<a name="1464"></a>    doActionOnce()
<a name="1465"></a>    {
<a name="1466"></a>        libGlobal.lastTypedOnObj = curDobj;
<a name="1467"></a>        return inherited();
<a name="1468"></a>    }
<a name="1469"></a>;
<a name="1470"></a>
<a name="1471"></a>DefineLiteralAction(Type)
<a name="1472"></a>    againRepeatsParse = nil
<a name="1473"></a>    
<a name="1474"></a>    execAction(cmd) { askForIobj(TypeOn); }
<a name="1475"></a>;
<a name="1476"></a>
<a name="1477"></a>DefineLiteralTAction(EnterOn)
<a name="1478"></a>    againRepeatsParse = nil
<a name="1479"></a>;
<a name="1480"></a>
<a name="1481"></a>DefineLiteralTAction(WriteOn)
<a name="1482"></a>    againRepeatsParse = nil
<a name="1483"></a>    
<a name="1484"></a>    doActionOnce()
<a name="1485"></a>    {
<a name="1486"></a>        libGlobal.lastWrittenOnObj = curDobj;
<a name="1487"></a>        return inherited();
<a name="1488"></a>    }
<a name="1489"></a>;
<a name="1490"></a>
<a name="1491"></a>DefineLiteralAction(Write)
<a name="1492"></a>    againRepeatsParse = nil
<a name="1493"></a>
<a name="1494"></a>    execAction(cmd) { askForIobj(WriteOn); }
<a name="1495"></a>;
<a name="1496"></a>
<a name="1497"></a>DefineTopicTAction(ConsultAbout)
<a name="1498"></a>    againRepeatsParse = nil
<a name="1499"></a>;
<a name="1500"></a>
<a name="1501"></a>DefineTopicAction(ConsultWhatAbout)
<a name="1502"></a>    execAction(cmd)
<a name="1503"></a>    {
<a name="1504"></a>        askForDobj(ConsultAbout);
<a name="1505"></a>    }
<a name="1506"></a>;
<a name="1507"></a>
<a name="1508"></a>DefineTAction(SwitchVague)
<a name="1509"></a>    againRepeatsParse = nil
<a name="1510"></a>;
<a name="1511"></a>
<a name="1512"></a>DefineTAction(Flip)
<a name="1513"></a>    againRepeatsParse = nil
<a name="1514"></a>;
<a name="1515"></a>
<a name="1516"></a>DefineTAction(Fasten)   
<a name="1517"></a>;
<a name="1518"></a>
<a name="1519"></a>
<a name="1520"></a>DefineTAction(Burn)   
<a name="1521"></a>;
<a name="1522"></a>
<a name="1523"></a>DefineTIAction(BurnWith)
<a name="1524"></a>    resolveIobjFirst = nil
<a name="1525"></a>;
<a name="1526"></a>
<a name="1527"></a>DefineTAction(Pour)
<a name="1528"></a>    againRepeatsParse = nil
<a name="1529"></a>;
<a name="1530"></a>
<a name="1531"></a>DefineTIAction(PourOnto)    
<a name="1532"></a>    resolveIobjFirst = nil
<a name="1533"></a>    againRepeatsParse = nil
<a name="1534"></a>;
<a name="1535"></a>
<a name="1536"></a>DefineTIAction(PourInto)
<a name="1537"></a>    resolveIobjFirst = nil
<a name="1538"></a>    againRepeatsParse = nil
<a name="1539"></a>;
<a name="1540"></a>
<a name="1541"></a>DefineTAction(Screw)    
<a name="1542"></a>;
<a name="1543"></a>
<a name="1544"></a>DefineTIAction(ScrewWith)    
<a name="1545"></a>    resolveIobjFirst = nil
<a name="1546"></a>;
<a name="1547"></a>    
<a name="1548"></a>DefineTAction(Unscrew)
<a name="1549"></a>;
<a name="1550"></a>
<a name="1551"></a>DefineTIAction(UnscrewWith)    
<a name="1552"></a>    resolveIobjFirst = nil
<a name="1553"></a>;
<a name="1554"></a>
<a name="1555"></a>DefineTAction(Unfasten)
<a name="1556"></a>;
<a name="1557"></a>
<a name="1558"></a>DefineTIAction(UnfastenFrom)    
<a name="1559"></a>;
<a name="1560"></a>
<a name="1561"></a>DefineTIAction(PlugInto)   
<a name="1562"></a>    resolveIobjFirst = nil
<a name="1563"></a>;
<a name="1564"></a>
<a name="1565"></a>DefineTAction(PlugIn)    
<a name="1566"></a>;
<a name="1567"></a>
<a name="1568"></a>DefineTIAction(UnplugFrom)        
<a name="1569"></a>;
<a name="1570"></a>
<a name="1571"></a>DefineTAction(Unplug)    
<a name="1572"></a>;
<a name="1573"></a>
<a name="1574"></a>
<a name="1575"></a>DefineTAction(PushTravelDir)
<a name="1576"></a>    
<a name="1577"></a>    isPushTravelAction = true
<a name="1578"></a>    
<a name="1579"></a>    execAction(cmd)
<a name="1580"></a>    {
<a name="1581"></a>        local conn;
<a name="1582"></a>        
<a name="1583"></a>        /* Note whether travel is allowed. This can be adjusted by the dobj */
<a name="1584"></a>        travelAllowed = nil;
<a name="1585"></a>        
<a name="1586"></a>        /* Get the direction of travel from the command */
<a name="1587"></a>        direction = cmd.verbProd.dirMatch.dir;
<a name="1588"></a>        
<a name="1589"></a>        /* Note the actor's location. */
<a name="1590"></a>        local loc = gActor.getOutermostRoom; 
<a name="1591"></a>        
<a name="1592"></a>//        /* Note whether we meed the lighting conditions to permit travel */
<a name="1593"></a>//        local illum = loc.allowDarkTravel || loc.isIlluminated;
<a name="1594"></a>        
<a name="1595"></a>        /* 
<a name="1596"></a>         *   first find out what our direction might take us to; if it's an object that defines the
<a name="1597"></a>         *   PushTravlVia property, change the action to PushTravelVia that connector
<a name="1598"></a>         */
<a name="1599"></a>        
<a name="1600"></a>    retry:
<a name="1601"></a>        /* 
<a name="1602"></a>         *   See if the direction we're due to go in points to an object and if so process it
<a name="1603"></a>         *   accordingly.
<a name="1604"></a>         */
<a name="1605"></a>        if(loc.propType(direction.dirProp) == TypeObject)
<a name="1606"></a>        {
<a name="1607"></a>            /* Note the connector object in the relevant direction */
<a name="1608"></a>            conn = loc.(direction.dirProp); 
<a name="1609"></a>            
<a name="1610"></a>            /* 
<a name="1611"></a>             *   If this connector is an UnlistedProxy Connector we need to carry out the rest of
<a name="1612"></a>             *   the processing on whatever it's a proxy for.
<a name="1613"></a>             */
<a name="1614"></a>            if(conn.ofKind(UnlistedProxyConnector))
<a name="1615"></a>            {
<a name="1616"></a>                /* Reset our direction to that of the UnlistedProxyConnector. */
<a name="1617"></a>                direction = conn.direction;
<a name="1618"></a>                
<a name="1619"></a>                /* Start over again with our new direction. */
<a name="1620"></a>                goto retry;                  
<a name="1621"></a>            }
<a name="1622"></a>            
<a name="1623"></a>            /*  
<a name="1624"></a>             *   If the connector object defines a PushTravelVia action, then replace the current
<a name="1625"></a>             *   action with that PushTravelVia action (e.g. PushTravelGoThrough or
<a name="1626"></a>             *   PushTravelClimbUp).
<a name="1627"></a>             */
<a name="1628"></a>            if(conn.PushTravelVia)
<a name="1629"></a>                replaceAction(conn.PushTravelVia, gDobj, conn);
<a name="1630"></a>            
<a name="1631"></a>            /* 
<a name="1632"></a>             *   Maybe conn looks like an object but is actually an anonymous or dynamic function,
<a name="1633"></a>             *   in which case we can try to execute it.
<a name="1634"></a>             */
<a name="1635"></a>            if(dataTypeXlat(conn) == TypeFuncPtr)
<a name="1636"></a>            {
<a name="1637"></a>                try
<a name="1638"></a>                {
<a name="1639"></a>                    conn();                    
<a name="1640"></a>                }
<a name="1641"></a>                catch (Exception ex)
<a name="1642"></a>                {
<a name="1643"></a>                    "Problem with function object attached to the &lt;&lt;direction.name&gt;&gt; property of
<a name="1644"></a>                    &lt;&lt;loc.name&gt;&gt;.&lt;.p&gt;";
<a name="1645"></a>                    
<a name="1646"></a>                    ex.displayException();
<a name="1647"></a>                }
<a name="1648"></a>            }
<a name="1649"></a>            else        
<a name="1650"></a>                
<a name="1651"></a>            /* 
<a name="1652"></a>             *   if we reach this point, there must be something fishy going on, since we really
<a name="1653"></a>             *   shouldn't have any other kind of object attached to a direction property, so
<a name="1654"></a>             *   display a message saying so.
<a name="1655"></a>             */                
<a name="1656"></a>                "&lt;b&gt;ERROR!&lt;/b&gt; Illegal object &lt;&lt;conn&gt;&gt; attached to the &lt;&lt;direction.name&gt;&gt; property 
<a name="1657"></a>                of &lt;&lt;loc.name&gt;&gt;. ";
<a name="1658"></a>            
<a name="1659"></a>        }
<a name="1660"></a>        /* 
<a name="1661"></a>         *   If our direction isn't attached to an object, it must be to a method or string that's
<a name="1662"></a>         *   going to display a message explaining why we can't travel. So call the nonTravel()
<a name="1663"></a>         *   function to handle it.            
<a name="1664"></a>         */
<a name="1665"></a>        else
<a name="1666"></a>            nonTravel(loc, direction);
<a name="1667"></a>    }
<a name="1668"></a>    
<a name="1669"></a>    
<a name="1670"></a>
<a name="1671"></a>    travelAllowed = nil
<a name="1672"></a>    direction = nil
<a name="1673"></a>    curIobj = nil
<a name="1674"></a>    
<a name="1675"></a>    
<a name="1676"></a>    doTravel() { delegated TravelAction(); }
<a name="1677"></a>;
<a name="1678"></a>
<a name="1679"></a>DefineTIAction(PushTravelThrough)
<a name="1680"></a>    viaMode = Through
<a name="1681"></a>    
<a name="1682"></a>    isPushTravelAction = true
<a name="1683"></a>    
<a name="1684"></a>    addExtraScopeItems(role)
<a name="1685"></a>    {
<a name="1686"></a>        /* 
<a name="1687"></a>         *   If our indirect object is a TravelConnector it may not be a physical object that would
<a name="1688"></a>         *   normally be considered in scope, so we need to add it to our scope list.
<a name="1689"></a>         */        
<a name="1690"></a>        if(objOfKind(curIobj, TravelConnector))
<a name="1691"></a>            scopeList = scopeList.appendUnique(valToList(curIobj));
<a name="1692"></a>        
<a name="1693"></a>        /* 
<a name="1694"></a>         *   Append the extra scope items defined on this Room to the action's
<a name="1695"></a>         *   scope list.
<a name="1696"></a>         */
<a name="1697"></a>        inherited(role);
<a name="1698"></a>    }
<a name="1699"></a>;
<a name="1700"></a>
<a name="1701"></a>DefineTIAction(PushTravelEnter)
<a name="1702"></a>    viaMode = Into
<a name="1703"></a>    
<a name="1704"></a>    isPushTravelAction = true
<a name="1705"></a>;
<a name="1706"></a>
<a name="1707"></a>DefineTIAction(PushTravelGetOutOf)
<a name="1708"></a>    viaMode = OutOf
<a name="1709"></a>    
<a name="1710"></a>    isPushTravelAction = true
<a name="1711"></a>;
<a name="1712"></a>
<a name="1713"></a>DefineTIAction(PushTravelClimbUp)
<a name="1714"></a>    viaMode = Up
<a name="1715"></a>    
<a name="1716"></a>    isPushTravelAction = true
<a name="1717"></a>;
<a name="1718"></a>
<a name="1719"></a>DefineTIAction(PushTravelClimbDown)
<a name="1720"></a>    viaMode = Down
<a name="1721"></a>    
<a name="1722"></a>    isPushTravelAction = true
<a name="1723"></a>;
<a name="1724"></a>
<a name="1725"></a>
<a name="1726"></a>
<a name="1727"></a>
<a name="1728"></a>
<a name="1729"></a>DefineTAction(TalkTo)
<a name="1730"></a>    isConversational = true
<a name="1731"></a>;
<a name="1732"></a>
<a name="1733"></a>class MiscConvAction: IAction
<a name="1734"></a>    execAction(cmd)
<a name="1735"></a>    {
<a name="1736"></a>        if(gPlayerChar.currentInterlocutor == nil 
<a name="1737"></a>           || !Q.canTalkTo(gPlayerChar, gPlayerChar.currentInterlocutor))
<a name="1738"></a>            sayNotTalking();
<a name="1739"></a>        else
<a name="1740"></a>        {           
<a name="1741"></a>            curObj = gPlayerChar.currentInterlocutor;
<a name="1742"></a>            gPlayerChar.currentInterlocutor.handleTopic(responseProp, 
<a name="1743"></a>                [topicObj]);
<a name="1744"></a>        }
<a name="1745"></a>            
<a name="1746"></a>    }
<a name="1747"></a>    curObj = nil
<a name="1748"></a>    
<a name="1749"></a>    getMessageParam(objName)
<a name="1750"></a>    {
<a name="1751"></a>        switch(objName)
<a name="1752"></a>        {
<a name="1753"></a>        case 'dobj':
<a name="1754"></a>            /* return the current direct object */
<a name="1755"></a>            return curObj;
<a name="1756"></a>            
<a name="1757"></a>        case 'cobj':
<a name="1758"></a>            /* return the current object */
<a name="1759"></a>            return curObj;
<a name="1760"></a>
<a name="1761"></a>        default:
<a name="1762"></a>            /* inherit default handling */
<a name="1763"></a>            return inherited(objName);
<a name="1764"></a>        }
<a name="1765"></a>    }
<a name="1766"></a>    
<a name="1767"></a>    responseProp = nil
<a name="1768"></a>    topicObj = nil
<a name="1769"></a>    
<a name="1770"></a>    isConversational = true
<a name="1771"></a>;
<a name="1772"></a>
<a name="1773"></a>sayNotTalking()
<a name="1774"></a>{
<a name="1775"></a>    DMsg(not talking, '{I}{\'m} not talking to anyone. ');
<a name="1776"></a>}
<a name="1777"></a>
<a name="1778"></a>
<a name="1779"></a>/* 
<a name="1780"></a> *   Singleton object used to trigger a YesTopic; we must make it familiar so
<a name="1781"></a> *   that YesTopics can be listed as suggested topics. We define this as
<a name="1782"></a> *   noTopicObj in actions.t rather than actor.t so that the SayYes and SayNo
<a name="1783"></a> *   actions in actions.t will compile even if actor.t is absent from the build.
<a name="1784"></a> */
<a name="1785"></a>yesTopicObj: object familiar = true;
<a name="1786"></a>
<a name="1787"></a>/* Singleton object used to trigger a NoTopic */
<a name="1788"></a>noTopicObj: object familiar = true;
<a name="1789"></a>
<a name="1790"></a>SayYes: MiscConvAction
<a name="1791"></a>    baseActionClass = SayYes
<a name="1792"></a>    responseProp = &amp;miscTopics
<a name="1793"></a>    topicObj = yesTopicObj
<a name="1794"></a>;
<a name="1795"></a>
<a name="1796"></a>SayNo: MiscConvAction
<a name="1797"></a>    baseActionClass = SayNo
<a name="1798"></a>    responseProp = &amp;miscTopics
<a name="1799"></a>    topicObj = noTopicObj
<a name="1800"></a>;
<a name="1801"></a>
<a name="1802"></a>QueryVague: MiscConvAction
<a name="1803"></a>    baseActionClass = QueryVague
<a name="1804"></a>    execAction(cmd)
<a name="1805"></a>    {
<a name="1806"></a>        qType = cmd.verbProd.qType;
<a name="1807"></a>        /* 
<a name="1808"></a>         *   Mark this as a special Topic designed to match a QueryTopic of the appropriate type.
<a name="1809"></a>         */
<a name="1810"></a>        topicObj = new Topic(qType + '!');
<a name="1811"></a>        
<a name="1812"></a>        inherited(cmd);
<a name="1813"></a>    }
<a name="1814"></a>    
<a name="1815"></a>    qType = nil
<a name="1816"></a>    responseProp = &amp;queryTopics
<a name="1817"></a>;
<a name="1818"></a>
<a name="1819"></a>Goodbye: IAction
<a name="1820"></a>    baseActionClass = Goodbye
<a name="1821"></a>    
<a name="1822"></a>    execAction(cmd)
<a name="1823"></a>    {
<a name="1824"></a>        curObj = gPlayerChar.currentInterlocutor;
<a name="1825"></a>    
<a name="1826"></a>        if(gPlayerChar.currentInterlocutor == nil ||
<a name="1827"></a>           !Q.canTalkTo(gPlayerChar, gPlayerChar.currentInterlocutor))	
<a name="1828"></a>            sayNotTalking();
<a name="1829"></a>        else if(defined(endConvBye) &amp;&amp;
<a name="1830"></a>            gPlayerChar.currentInterlocutor.endConversation(endConvBye));
<a name="1831"></a>    }    
<a name="1832"></a>    
<a name="1833"></a>    curObj = nil   
<a name="1834"></a>    
<a name="1835"></a>    isConversational = true
<a name="1836"></a>;
<a name="1837"></a>
<a name="1838"></a>Hello: IAction
<a name="1839"></a>    baseActionClass = Hello
<a name="1840"></a>    
<a name="1841"></a>    execAction(cmd)
<a name="1842"></a>    {
<a name="1843"></a>        /* first build the scope list so we know which actors are in scope */
<a name="1844"></a>        buildScopeList();
<a name="1845"></a>        
<a name="1846"></a>        /* 
<a name="1847"></a>         *   if the pc isn't already talking to someone then this is an attempt
<a name="1848"></a>         *   to engage a new interlocutor in conversation.
<a name="1849"></a>         */
<a name="1850"></a>        if(gPlayerChar.currentInterlocutor == nil)
<a name="1851"></a>        {
<a name="1852"></a>            /* 
<a name="1853"></a>             *   Ascertain how many actors other than the player char are in
<a name="1854"></a>             *   scope (and thus potentially greetable.
<a name="1855"></a>             */
<a name="1856"></a>
<a name="1857"></a>            local greetList;
<a name="1858"></a>            
<a name="1859"></a>            /* 
<a name="1860"></a>             *   We do this a slightly roundabout way to avoid compilation
<a name="1861"></a>             *   errors and warnings when actor.t is omitted from the build.
<a name="1862"></a>             */
<a name="1863"></a>            local cls = (defined(Actor) ? Actor : nil);
<a name="1864"></a>            
<a name="1865"></a>            if(cls)                
<a name="1866"></a>                greetList = scopeList.subset(
<a name="1867"></a>                    { x: x.ofKind(cls) &amp;&amp; x != gPlayerChar });            
<a name="1868"></a>            else
<a name="1869"></a>                greetList = [];
<a name="1870"></a>            
<a name="1871"></a>            local greetCount = greetList.length;
<a name="1872"></a>            
<a name="1873"></a>            /* If there are no other actors in scope, say so. */            
<a name="1874"></a>            if(greetCount == 0)
<a name="1875"></a>            {
<a name="1876"></a>                DMsg(no one here, 'There{dummy}{\'s} no one {here} to talk to.
<a name="1877"></a>                    ');
<a name="1878"></a>            }
<a name="1879"></a>            /* 
<a name="1880"></a>             *   Otherwise construct a list of all the actors in scope and greet
<a name="1881"></a>             *   all of them (rather than asking the player to disambiguate -
<a name="1882"></a>             *   after all the pc may have just said 'hello' to a room full of
<a name="1883"></a>             *   people and there's no reason why they shouldn't all respond).
<a name="1884"></a>             */
<a name="1885"></a>            else
<a name="1886"></a>            {               
<a name="1887"></a>                foreach(local greeted in greetList)
<a name="1888"></a>                {
<a name="1889"></a>                    curObj = greeted;
<a name="1890"></a>                    greeted.sayHello();
<a name="1891"></a>                }
<a name="1892"></a>            }
<a name="1893"></a>        }
<a name="1894"></a>        /* 
<a name="1895"></a>         *   If the player char is currently talking to someone, say so and
<a name="1896"></a>         *   carry out a repeat greeting.
<a name="1897"></a>         */
<a name="1898"></a>        else
<a name="1899"></a>        {            
<a name="1900"></a>            gPlayerChar.currentInterlocutor.sayHello();
<a name="1901"></a>        }
<a name="1902"></a>    }
<a name="1903"></a>    
<a name="1904"></a>    curObj = nil
<a name="1905"></a>    
<a name="1906"></a>    isConversational = true
<a name="1907"></a>;
<a name="1908"></a>
<a name="1909"></a>DefineLiteralTAction(TellTo)
<a name="1910"></a>    exec(cmd)
<a name="1911"></a>    {
<a name="1912"></a>        /* 
<a name="1913"></a>         *   Take a command of the form of TELL FOO TO BAR, turn it into FOO,
<a name="1914"></a>         *   BAR and then send it back to parser to execute
<a name="1915"></a>         */
<a name="1916"></a>        local str = cmd.dobj.name + ', ' + cmd.iobj.name;
<a name="1917"></a>        Parser.parse(str);
<a name="1918"></a>    }
<a name="1919"></a>    afterAction() {}
<a name="1920"></a>    
<a name="1921"></a>    isConversational = true
<a name="1922"></a>;
<a name="1923"></a>
<a name="1924"></a>
<a name="1925"></a>DefineTopicTAction(AskAbout)    
<a name="1926"></a>    isConversational = true
<a name="1927"></a>;
<a name="1928"></a>
<a name="1929"></a>DefineTopicTAction(AskFor)    
<a name="1930"></a>    isConversational = true
<a name="1931"></a>;
<a name="1932"></a>
<a name="1933"></a>DefineTopicTAction(TellAbout)   
<a name="1934"></a>    isConversational = true
<a name="1935"></a>;
<a name="1936"></a>
<a name="1937"></a>DefineTopicTAction(TalkAbout)    
<a name="1938"></a>    isConversational = true
<a name="1939"></a>;
<a name="1940"></a>
<a name="1941"></a>DefineTopicTAction(QueryAbout)    
<a name="1942"></a>    execAction(cmd)
<a name="1943"></a>    {
<a name="1944"></a>        qType = cmd.verbProd.qtype;
<a name="1945"></a>
<a name="1946"></a>        inherited(cmd);
<a name="1947"></a>    }
<a name="1948"></a>    qType = nil
<a name="1949"></a>    
<a name="1950"></a>    #ifdef __DEBUG    
<a name="1951"></a>    iqinfo = (gCommand.verbProd.qtype)
<a name="1952"></a>    #endif
<a name="1953"></a>    
<a name="1954"></a>    isConversational = true
<a name="1955"></a>;
<a name="1956"></a>
<a name="1957"></a>DefineTopicTAction(SayTo)    
<a name="1958"></a>    isConversational = true
<a name="1959"></a>;
<a name="1960"></a>
<a name="1961"></a>DefineTIAction(GiveTo)     
<a name="1962"></a>    /* 
<a name="1963"></a>     *   The summaryReport can be set by a GiveTopic to a single-quoted string in
<a name="1964"></a>     *   BMsg format, with {1} standing in for gActionListStr, in order to
<a name="1965"></a>     *   report on a whole set of objects given at once; e.g. '{I} {give} Bob
<a name="1966"></a>     *   {1}. '
<a name="1967"></a>     */
<a name="1968"></a>    summaryReport = nil
<a name="1969"></a>    
<a name="1970"></a>    /* 
<a name="1971"></a>     *   The summaryProp can be a propertyPointer to a method on the Actor being
<a name="1972"></a>     *   conversed with that's called at once a whole set of objects has been
<a name="1973"></a>     *   given. It will normally be set by a gAction.summaryProp = &amp;prop
<a name="1974"></a>     *   statement in a GiveTopic.
<a name="1975"></a>     */
<a name="1976"></a>    summaryProp = nil
<a name="1977"></a>    
<a name="1978"></a>    /* 
<a name="1979"></a>     *   Reset the summaryReport and the summaryProp to nil for the whole group
<a name="1980"></a>     *   of objects this action may act on, so that they're only used if they're
<a name="1981"></a>     *   explicitly requested this turn.
<a name="1982"></a>     */
<a name="1983"></a>    execGroup(cmd) 
<a name="1984"></a>    { 
<a name="1985"></a>        summaryReport = nil; 
<a name="1986"></a>        summaryProp = nil;
<a name="1987"></a>    }
<a name="1988"></a>;
<a name="1989"></a>
<a name="1990"></a>DefineTIAction(ShowTo)   
<a name="1991"></a>    showReport = nil
<a name="1992"></a>    summaryProp = nil
<a name="1993"></a>    
<a name="1994"></a>    /* 
<a name="1995"></a>     *   Reset the showReport to nil for the whole group of objects this action
<a name="1996"></a>     *   may act on.
<a name="1997"></a>     */
<a name="1998"></a>    execGroup(cmd) 
<a name="1999"></a>    { 
<a name="2000"></a>        summaryReport = nil; 
<a name="2001"></a>        summaryProp = nil;
<a name="2002"></a>    }
<a name="2003"></a>    
<a name="2004"></a>    isConversational = true
<a name="2005"></a>;
<a name="2006"></a>
<a name="2007"></a>ThinkAbout: TopicAction
<a name="2008"></a>    baseActionClass = ThinkAbout
<a name="2009"></a>    
<a name="2010"></a>    execAction(cmd)
<a name="2011"></a>    {
<a name="2012"></a>        /* 
<a name="2013"></a>         *   We don't want this action treated as conversational if it results in the use of reveal
<a name="2014"></a>         *   tags, so we store the current interlocutor and then set the current interlocutor to nil
<a name="2015"></a>         *   before proceeding.
<a name="2016"></a>         */                 
<a name="2017"></a>        local interlocutor = gPlayerChar.currentInterlocutor;
<a name="2018"></a>        
<a name="2019"></a>        try
<a name="2020"></a>        {
<a name="2021"></a>            
<a name="2022"></a>            gPlayerChar.currentInterlocutor = nil;            
<a name="2023"></a>            
<a name="2024"></a>            if(libGlobal.thoughtManagerObj != nil)
<a name="2025"></a>                libGlobal.thoughtManagerObj.handleTopic(cmd.dobj.topicList);
<a name="2026"></a>            else
<a name="2027"></a>                Think.execAction(cmd);
<a name="2028"></a>        }
<a name="2029"></a>        finally
<a name="2030"></a>        {
<a name="2031"></a>            /* Restore the current interlocutor. */
<a name="2032"></a>            gPlayerChar.currentInterlocutor = interlocutor;
<a name="2033"></a>        }
<a name="2034"></a>    }
<a name="2035"></a>    againRepeatsParse = nil
<a name="2036"></a>;
<a name="2037"></a>
<a name="2038"></a>DefineIAction(Think)
<a name="2039"></a>    execAction(cmd)
<a name="2040"></a>    {
<a name="2041"></a>        DMsg(think, '{I} {think}, therefore {i} {am}. ');
<a name="2042"></a>    }    
<a name="2043"></a>;
<a name="2044"></a>
<a name="2045"></a>class ImplicitConversationAction: TopicAction
<a name="2046"></a>    execAction(cmd)
<a name="2047"></a>    {
<a name="2048"></a>        if(cmd.iobj == nil &amp;&amp; cmd.dobj != nil)
<a name="2049"></a>        {
<a name="2050"></a>            if(cmd.dobj.ofKind(ResolvedTopic))
<a name="2051"></a>                topics = cmd.dobj.topicList;
<a name="2052"></a>            else
<a name="2053"></a>                topics = cmd.dobj;
<a name="2054"></a>            
<a name="2055"></a>            curTopic = cmd.dobj;
<a name="2056"></a>        }
<a name="2057"></a>        else if (cmd.dobj == nil &amp;&amp; cmd.iobj != nil)
<a name="2058"></a>        {
<a name="2059"></a>            if(cmd.iobj.ofKind(ResolvedTopic))
<a name="2060"></a>                topics = cmd.iobj.topicList;
<a name="2061"></a>            else
<a name="2062"></a>                topics = cmd.iobj;
<a name="2063"></a>            
<a name="2064"></a>            curTopic = cmd.iobj;
<a name="2065"></a>        }
<a name="2066"></a>        
<a name="2067"></a>        if(gPlayerChar.currentInterlocutor == nil ||
<a name="2068"></a>           !Q.canTalkTo(gPlayerChar, gPlayerChar.currentInterlocutor))	
<a name="2069"></a>            sayNotTalking();
<a name="2070"></a>        else
<a name="2071"></a>        {
<a name="2072"></a>            notePronounAntecedent(gPlayerChar.currentInterlocutor);
<a name="2073"></a>            resolvePronouns();
<a name="2074"></a>            curObj = gPlayerChar.currentInterlocutor;
<a name="2075"></a>            gPlayerChar.currentInterlocutor.handleTopic(topicListProperty, 
<a name="2076"></a>                topics, defaultProperty);
<a name="2077"></a>        }
<a name="2078"></a>    }
<a name="2079"></a>    
<a name="2080"></a>    /* The default property to call on the Actor if there's not matching TopicEntry */
<a name="2081"></a>    defaultProperty = &amp;noResponseMsg
<a name="2082"></a>    
<a name="2083"></a>    
<a name="2084"></a>    /* 
<a name="2085"></a>     *   This is a bit of a kludge to deal with the fact that the Parser doesn't
<a name="2086"></a>     *   seem able to resolve pronouns within ResolvedTopics. We do it here
<a name="2087"></a>     *   instead.
<a name="2088"></a>     */
<a name="2089"></a>    
<a name="2090"></a>    resolvePronouns()
<a name="2091"></a>    {
<a name="2092"></a>        local actor = gPlayerChar.currentInterlocutor;
<a name="2093"></a>        for(local cur in topics, local i = 1;; ++i)
<a name="2094"></a>        {
<a name="2095"></a>            if(cur == Him &amp;&amp; actor.isHim)
<a name="2096"></a>                topics[i] = actor;
<a name="2097"></a>            
<a name="2098"></a>            if(cur == Her &amp;&amp; actor.isHer)
<a name="2099"></a>                topics[i] = actor;
<a name="2100"></a>            
<a name="2101"></a>            if(cur == It &amp;&amp; actor.isIt)
<a name="2102"></a>                topics[i] = actor;
<a name="2103"></a>            
<a name="2104"></a>            if(cur == Them &amp;&amp; actor.plural)
<a name="2105"></a>                topics[i] = actor;
<a name="2106"></a>        }
<a name="2107"></a>    }
<a name="2108"></a>    
<a name="2109"></a>    
<a name="2110"></a>    topicListProperty = nil
<a name="2111"></a>    topics = nil
<a name="2112"></a>    
<a name="2113"></a>    isConversational = true
<a name="2114"></a>;
<a name="2115"></a>
<a name="2116"></a>        
<a name="2117"></a>AskAboutImplicit: ImplicitConversationAction
<a name="2118"></a>    baseActionClass = AskAboutImplicit
<a name="2119"></a>    topicListProperty = &amp;askTopics
<a name="2120"></a>;
<a name="2121"></a>
<a name="2122"></a>AskForImplicit: ImplicitConversationAction
<a name="2123"></a>    baseActionClass = AskForImplicit
<a name="2124"></a>    topicListProperty = &amp;askForTopics
<a name="2125"></a>;
<a name="2126"></a>
<a name="2127"></a>TellAboutImplicit: ImplicitConversationAction
<a name="2128"></a>    baseActionClass = TellAboutImplicit
<a name="2129"></a>    topicListProperty = &amp;tellTopics
<a name="2130"></a>;
<a name="2131"></a>
<a name="2132"></a>TalkAboutImplicit: ImplicitConversationAction
<a name="2133"></a>    baseActionClass = TalkAboutImplicit
<a name="2134"></a>    topicListProperty = &amp;talkTopics
<a name="2135"></a>;
<a name="2136"></a>
<a name="2137"></a>DefineTAction(ShowToImplicit)
<a name="2138"></a>    showReport = nil
<a name="2139"></a>    
<a name="2140"></a>    /* 
<a name="2141"></a>     *   The summaryProp can be a propertyPointer to a method on the Actor being
<a name="2142"></a>     *   conversed with that's called at once a whole set of objects has been
<a name="2143"></a>     *   given. It will normally be set by a gAction.summaryProp = &amp;prop
<a name="2144"></a>     *   statement in a ShowTopic.
<a name="2145"></a>     */
<a name="2146"></a>    summaryProp = nil
<a name="2147"></a>    
<a name="2148"></a>    /* 
<a name="2149"></a>     *   Reset the showReport to nil for the whole group of objects this action
<a name="2150"></a>     *   may act on.
<a name="2151"></a>     */
<a name="2152"></a>    execGroup(cmd) 
<a name="2153"></a>    { 
<a name="2154"></a>        summaryReport = nil; 
<a name="2155"></a>        summaryProp = nil;
<a name="2156"></a>    }
<a name="2157"></a>;
<a name="2158"></a>
<a name="2159"></a>DefineTAction(GiveToImplicit)
<a name="2160"></a>    showReport = nil
<a name="2161"></a>    
<a name="2162"></a>    /* 
<a name="2163"></a>     *   The summaryProp can be a propertyPointer to a method on the Actor being
<a name="2164"></a>     *   conversed with that's called at once a whole set of objects has been
<a name="2165"></a>     *   given. It will normally be set by a gAction.summaryProp = &amp;prop
<a name="2166"></a>     *   statement in a GiveTopic.
<a name="2167"></a>     */
<a name="2168"></a>    summaryProp = nil
<a name="2169"></a>    /* 
<a name="2170"></a>     *   Reset the showReport to nil for the whole group of objects this action
<a name="2171"></a>     *   may act on.
<a name="2172"></a>     */
<a name="2173"></a>    execGroup(cmd) 
<a name="2174"></a>    { 
<a name="2175"></a>        summaryReport = nil; 
<a name="2176"></a>        summaryProp = nil;
<a name="2177"></a>    }
<a name="2178"></a>;
<a name="2179"></a>              
<a name="2180"></a>
<a name="2181"></a>Query: ImplicitConversationAction
<a name="2182"></a>    baseActionClass = Query
<a name="2183"></a>    execAction(cmd)
<a name="2184"></a>    {
<a name="2185"></a>        qType = cmd.verbProd.qtype;
<a name="2186"></a>
<a name="2187"></a>        inherited(cmd);
<a name="2188"></a>    }
<a name="2189"></a>    qType = nil
<a name="2190"></a>    topicListProperty = &amp;queryTopics
<a name="2191"></a>    
<a name="2192"></a>    #ifdef __DEBUG
<a name="2193"></a>    dqinfo = (gCommand.verbProd.qtype)
<a name="2194"></a>    #endif
<a name="2195"></a>;
<a name="2196"></a>
<a name="2197"></a>SayAction: ImplicitConversationAction
<a name="2198"></a>    baseActionClass = SayAction
<a name="2199"></a>    topicListProperty = &amp;sayTopics
<a name="2200"></a>    defaultProperty = &amp;defaultSayResponse
<a name="2201"></a>;
<a name="2202"></a>
<a name="2203"></a>
<a name="2204"></a>
<a name="2205"></a>
<a name="2206"></a>/*
<a name="2207"></a> *   A state object that keeps track of our logging (scripting) status.
<a name="2208"></a> *   This is transient, because logging is controlled through the output
<a name="2209"></a> *   layer in the interpreter, which does not participate in any of the
<a name="2210"></a> *   persistence mechanisms.  
<a name="2211"></a> */
<a name="2212"></a>transient scriptStatus: object
<a name="2213"></a>    /*
<a name="2214"></a>     *   Script file name.  This is nil when logging is not in effect, and
<a name="2215"></a>     *   is set to the name of the scripting file when a log file is
<a name="2216"></a>     *   active. 
<a name="2217"></a>     */
<a name="2218"></a>    scriptFile = nil
<a name="2219"></a>
<a name="2220"></a>    /* RECORD file name */
<a name="2221"></a>    recordFile = nil
<a name="2222"></a>
<a name="2223"></a>    /* have we warned about using NOTE without logging in effect? */
<a name="2224"></a>    noteWithoutScriptWarning = nil
<a name="2225"></a>;
<a name="2226"></a>
<a name="2227"></a>
<a name="2228"></a>
<a name="2229"></a>/* 
<a name="2230"></a> *   Property: object is a web temp file.  The Web UI uses this to flag
<a name="2231"></a> *   that a file we're saving to is actually a temp file that will be
<a name="2232"></a> *   offered as a downloadable file to the client after the file is written
<a name="2233"></a> *   and closed. 
<a name="2234"></a> */
<a name="2235"></a>property isWebTempFile;
<a name="2236"></a>
<a name="2237"></a>/*
<a name="2238"></a> *   A base class for file-oriented actions, such as SCRIPT, RECORD, and
<a name="2239"></a> *   REPLAY.  We provide common handling that prompts interactively for a
<a name="2240"></a> *   filename; subclasses must override a few methods and properties to
<a name="2241"></a> *   carry out the specific subclassed operation on the file.  
<a name="2242"></a> */
<a name="2243"></a>class FileOpAction: SystemAction
<a name="2244"></a>    /* our file dialog prompt message */
<a name="2245"></a>    filePromptMsg = ''
<a name="2246"></a>
<a name="2247"></a>    /* the file dialog open/save type */
<a name="2248"></a>    fileDisposition = InFileSave
<a name="2249"></a>
<a name="2250"></a>    /* the file dialog type ID */
<a name="2251"></a>    fileTypeID = FileTypeLog
<a name="2252"></a>
<a name="2253"></a>    /* show our cancellation mesage */
<a name="2254"></a>    showCancelMsg = ""
<a name="2255"></a>
<a name="2256"></a>    /* 
<a name="2257"></a>     *   Carry out our file operation.
<a name="2258"></a>     *   
<a name="2259"></a>     *   'desc' is an optional named argument giving a description string
<a name="2260"></a>     *   entered by the user via the Save Game dialog.  Some versions of
<a name="2261"></a>     *   the Save Game dialog let the user enter this additional
<a name="2262"></a>     *   information, which can be stored as part of the saved game
<a name="2263"></a>     *   metadata.  
<a name="2264"></a>     */
<a name="2265"></a>    performFileOp(fname, ack, desc:?)
<a name="2266"></a>    {
<a name="2267"></a>        /* 
<a name="2268"></a>         *   Each concrete action subclass must override this to carry out
<a name="2269"></a>         *   our operation.  This is called when the user has successfully
<a name="2270"></a>         *   selected a filename for the operation.  
<a name="2271"></a>         */
<a name="2272"></a>    }
<a name="2273"></a>
<a name="2274"></a>    execAction(cmd)
<a name="2275"></a>    {
<a name="2276"></a>        /* 
<a name="2277"></a>         *   ask for a file and carry out our action; since the command is
<a name="2278"></a>         *   being performed directly from the command line, we want an
<a name="2279"></a>         *   acknowledgment message on success 
<a name="2280"></a>         */
<a name="2281"></a>        setUpFileOp(true);
<a name="2282"></a>    }
<a name="2283"></a>
<a name="2284"></a>    /* ask for a file, and carry out our operation is we get one */
<a name="2285"></a>    setUpFileOp(ack)
<a name="2286"></a>    {
<a name="2287"></a>        local result;
<a name="2288"></a>
<a name="2289"></a>
<a name="2290"></a>        /* ask for a file */
<a name="2291"></a>        result = getInputFile(filePromptMsg, fileDisposition, fileTypeID, 0);
<a name="2292"></a>
<a name="2293"></a>        /* check the inputFile result */
<a name="2294"></a>        switch(result[1])
<a name="2295"></a>        {
<a name="2296"></a>        case InFileSuccess:
<a name="2297"></a>            /* carry out our file operation */
<a name="2298"></a>            if (result.length &gt;= 3)
<a name="2299"></a>                performFileOp(result[2], ack, desc:result[3]);
<a name="2300"></a>            else
<a name="2301"></a>                performFileOp(result[2], ack);
<a name="2302"></a>            break;
<a name="2303"></a>
<a name="2304"></a>        case InFileFailure:
<a name="2305"></a>            /* advise of the failure of the prompt */
<a name="2306"></a>            if (result.length() &gt; 1)
<a name="2307"></a>                filePromptFailedMsg(result[2]);
<a name="2308"></a>            else
<a name="2309"></a>                filePromptFailed();
<a name="2310"></a>            break;
<a name="2311"></a>
<a name="2312"></a>        case InFileCancel:
<a name="2313"></a>            /* acknowledge the cancellation */
<a name="2314"></a>            showCancelMsg();
<a name="2315"></a>            break;
<a name="2316"></a>        }
<a name="2317"></a>
<a name="2318"></a>        
<a name="2319"></a>    }
<a name="2320"></a>
<a name="2321"></a>    /* we can't include this in undo, as it affects external files */
<a name="2322"></a>    includeInUndo = nil
<a name="2323"></a>
<a name="2324"></a>    /* don't allow repeating with AGAIN */
<a name="2325"></a>    isRepeatable = nil
<a name="2326"></a>;
<a name="2327"></a>
<a name="2328"></a>/*
<a name="2329"></a> *   Turn scripting on.  This creates a text file that contains a
<a name="2330"></a> *   transcript of all commands and responses from this point forward.
<a name="2331"></a> */
<a name="2332"></a>DefineAction(ScriptOn, FileOpAction)
<a name="2333"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="2334"></a>    filePromptMsg = (BMsg(get scripting prompt, 'Please select a name for the
<a name="2335"></a>        new script file'))
<a name="2336"></a>    
<a name="2337"></a>    fileTypeID = FileTypeLog
<a name="2338"></a>    fileDisposition = InFileSave
<a name="2339"></a>
<a name="2340"></a>    /* show our cancellation mesasge */
<a name="2341"></a>    showCancelMsg() { DMsg(scripting canceled, '&lt;.parser&gt;Canceled.&lt;./parser&gt;'); }
<a name="2342"></a>
<a name="2343"></a>    /* 
<a name="2344"></a>     *   set up scripting - this can be used to set up scripting
<a name="2345"></a>     *   programmatically, in the course of carrying out another action 
<a name="2346"></a>     */
<a name="2347"></a>    setUpScripting(ack) { setUpFileOp(ack); }
<a name="2348"></a>
<a name="2349"></a>    /* turn on scripting to the given file */
<a name="2350"></a>    performFileOp(fname, ack)
<a name="2351"></a>    {
<a name="2352"></a>        /* turn on logging */
<a name="2353"></a>        local ok = nil, exc = nil;
<a name="2354"></a>        try
<a name="2355"></a>        {
<a name="2356"></a>            ok = aioSetLogFile(fname, LogTypeTranscript);
<a name="2357"></a>        }
<a name="2358"></a>        catch (Exception e)
<a name="2359"></a>        {
<a name="2360"></a>            exc = e;
<a name="2361"></a>        }
<a name="2362"></a>        if (ok)
<a name="2363"></a>        {
<a name="2364"></a>            /* remember that scripting is in effect */
<a name="2365"></a>            scriptStatus.scriptFile = fname;
<a name="2366"></a>
<a name="2367"></a>            /* 
<a name="2368"></a>             *   forget any past warning that we've issued about NOTE
<a name="2369"></a>             *   without a script in effect; the next time scripting isn't
<a name="2370"></a>             *   active, we'll want to issue a new warning, since they
<a name="2371"></a>             *   might not be aware at that point that the scripting we're
<a name="2372"></a>             *   starting now has ended 
<a name="2373"></a>             */
<a name="2374"></a>            scriptStatus.noteWithoutScriptWarning = nil;
<a name="2375"></a>
<a name="2376"></a>            /* note that logging is active, if acknowledgment is desired */
<a name="2377"></a>            if (ack)
<a name="2378"></a>            {
<a name="2379"></a>                if (fname.isWebTempFile)
<a name="2380"></a>                    htmlSay(scriptingOkayWebTemp);                  
<a name="2381"></a>                else
<a name="2382"></a>                    htmlSay(scriptingOkay);
<a name="2383"></a>                    
<a name="2384"></a>            }
<a name="2385"></a>        }
<a name="2386"></a>        else
<a name="2387"></a>        {
<a name="2388"></a>            /* scripting is no longer in effect */
<a name="2389"></a>            scriptStatus.scriptFile = nil;
<a name="2390"></a>
<a name="2391"></a>            /* show an error, if acknowledgment is desired */
<a name="2392"></a>            if (ack)
<a name="2393"></a>            {
<a name="2394"></a>                if (exc != nil)
<a name="2395"></a>                    DMsg(scripting failed exception, '&lt;.parser&gt;Failed; 
<a name="2396"></a>                        &lt;&lt;exc.displayException&gt;&gt;&lt;./parser&gt;');
<a name="2397"></a>                    
<a name="2398"></a>                else
<a name="2399"></a>                    DMsg(scripting failed, '&lt;.parser&gt;Failed; an error occurred
<a name="2400"></a>                        opening the script file.&lt;./parser&gt; ');
<a name="2401"></a>                   
<a name="2402"></a>            }
<a name="2403"></a>        }
<a name="2404"></a>    }
<a name="2405"></a>    
<a name="2406"></a>    scriptingOkayWebTemp = BMsg(scripting okay web temp,
<a name="2407"></a>                                '&lt;.parser&gt;The transcript will be saved.
<a name="2408"></a>                                Type &lt;&lt;aHref('script off', 'SCRIPT OFF', 
<a name="2409"></a>                                             'Turn off scripting')&gt;&gt;
<a name="2410"></a>                                to discontinue scripting and download the saved
<a name="2411"></a>                                transcript.&lt;./parser&gt; ')
<a name="2412"></a>    
<a name="2413"></a>    scriptingOkay = BMsg(scripting okay, '&lt;.parser&gt;The transcript will
<a name="2414"></a>                        be saved to the file. Type &lt;&lt;aHref('script off', 
<a name="2415"></a>                            'SCRIPT OFF', 'Turn off scripting')&gt;&gt; to
<a name="2416"></a>                        discontinue scripting.&lt;./parser&gt; ')
<a name="2417"></a>;
<a name="2418"></a>
<a name="2419"></a>/*
<a name="2420"></a> *   Subclass of Script action taking a quoted string as part of the
<a name="2421"></a> *   command syntax.  The grammar rule must set our fname_ property to a
<a name="2422"></a> *   quotedStringPhrase subproduction. 
<a name="2423"></a> */
<a name="2424"></a>DefineAction(ScriptString, ScriptOn)
<a name="2425"></a>    execAction(cmd)
<a name="2426"></a>    {
<a name="2427"></a>        /* if there's a filename, we don't need to prompt */
<a name="2428"></a>        if (fname_ != nil)
<a name="2429"></a>        {
<a name="2430"></a>            /* set up scripting to the filename specified in the command */
<a name="2431"></a>            performFileOp(fname_.getStringText(), true);
<a name="2432"></a>        }
<a name="2433"></a>        else
<a name="2434"></a>        {
<a name="2435"></a>            /* there's no filename, so prompt as usual */
<a name="2436"></a>            inherited();
<a name="2437"></a>        }
<a name="2438"></a>    }
<a name="2439"></a>;
<a name="2440"></a>
<a name="2441"></a>/*
<a name="2442"></a> *   Turn scripting off.  This stops recording the game transcript started
<a name="2443"></a> *   with the most recent SCRIPT command. 
<a name="2444"></a> */
<a name="2445"></a>DefineSystemAction(ScriptOff)
<a name="2446"></a>    execAction(cmd)
<a name="2447"></a>    {
<a name="2448"></a>        /* turn off scripting */
<a name="2449"></a>        turnOffScripting(true);
<a name="2450"></a>    }
<a name="2451"></a>
<a name="2452"></a>    /* turn off scripting */
<a name="2453"></a>    turnOffScripting(ack)
<a name="2454"></a>    {
<a name="2455"></a>        /* if we're not in a script file, ignore it */
<a name="2456"></a>        if (scriptStatus.scriptFile == nil)
<a name="2457"></a>        {
<a name="2458"></a>            DMsg(script off ignored, '&lt;.parser&gt;No script is currently being
<a name="2459"></a>                        recorded.&lt;./parser&gt;');
<a name="2460"></a>
<a name="2461"></a>            return;
<a name="2462"></a>        }
<a name="2463"></a>
<a name="2464"></a>        /* cancel scripting in the interpreter's output layer */
<a name="2465"></a>        aioSetLogFile(nil, LogTypeTranscript);
<a name="2466"></a>
<a name="2467"></a>        /* remember that scripting is no longer in effect */
<a name="2468"></a>        scriptStatus.scriptFile = nil;
<a name="2469"></a>
<a name="2470"></a>        /* acknowledge the change, if desired */
<a name="2471"></a>        if (ack)
<a name="2472"></a>            DMsg(script off okay, '&lt;.parser&gt;Scripting ended.&lt;./parser&gt;');
<a name="2473"></a>           
<a name="2474"></a>    }
<a name="2475"></a>
<a name="2476"></a>    /* we can't include this in undo, as it affects external files */
<a name="2477"></a>    includeInUndo = nil
<a name="2478"></a>;
<a name="2479"></a>
<a name="2480"></a>/*
<a name="2481"></a> *   RECORD - this is similar to SCRIPT, but stores a file containing only
<a name="2482"></a> *   the command input, not the output. 
<a name="2483"></a> */
<a name="2484"></a>DefineAction(Record, FileOpAction)
<a name="2485"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="2486"></a>    filePromptMsg = (BMsg(get recording prompt, 'Please select a name for the 
<a name="2487"></a>        new command log file'))
<a name="2488"></a>    
<a name="2489"></a>    fileTypeID = FileTypeCmd
<a name="2490"></a>    fileDisposition = InFileSave
<a name="2491"></a>
<a name="2492"></a>    /* show our cancellation mesasge */
<a name="2493"></a>    showCancelMsg() { DMsg(recording canceled, '&lt;.parser&gt;Canceled.&lt;./parser&gt; '); }
<a name="2494"></a>
<a name="2495"></a>    /* 
<a name="2496"></a>     *   set up recording - this can be used to set up scripting
<a name="2497"></a>     *   programmatically, in the course of carrying out another action 
<a name="2498"></a>     */
<a name="2499"></a>    setUpRecording(ack) { setUpFileOp(ack); }
<a name="2500"></a>
<a name="2501"></a>    /* turn on recording to the given file */
<a name="2502"></a>    performFileOp(fname, ack)
<a name="2503"></a>    {
<a name="2504"></a>        /* turn on command logging */
<a name="2505"></a>        local ok = nil, exc = nil;
<a name="2506"></a>        try
<a name="2507"></a>        {
<a name="2508"></a>            ok = aioSetLogFile(fname, logFileType);
<a name="2509"></a>        }
<a name="2510"></a>        catch (Exception e)
<a name="2511"></a>        {
<a name="2512"></a>            exc = e;
<a name="2513"></a>        }
<a name="2514"></a>        if (ok)
<a name="2515"></a>        {
<a name="2516"></a>            /* remember that recording is in effect */
<a name="2517"></a>            scriptStatus.recordFile = fname;
<a name="2518"></a>
<a name="2519"></a>            /* note that logging is active, if acknowledgment is desired */
<a name="2520"></a>            if (ack)
<a name="2521"></a>                 htmlSay(BMsg(recording okay, 
<a name="2522"></a>                              '&lt;.parser&gt;Commands will now be recorded.  Type
<a name="2523"></a>                     &lt;&lt;aHref('record off', 'RECORD OFF',
<a name="2524"></a>                             'Turn off recording')&gt;&gt;
<a name="2525"></a>                              to stop recording commands.&lt;./parser&gt; '));                
<a name="2526"></a>                
<a name="2527"></a>        }
<a name="2528"></a>        else
<a name="2529"></a>        {
<a name="2530"></a>            /* recording failed */
<a name="2531"></a>            scriptStatus.recordFile = nil;
<a name="2532"></a>
<a name="2533"></a>            /* show an error if acknowledgment is desired */
<a name="2534"></a>            if (ack)
<a name="2535"></a>            {
<a name="2536"></a>                if (exc != nil)
<a name="2537"></a>                    DMsg(recording failed exception, '&lt;.parser&gt;Failed; 
<a name="2538"></a>                        &lt;&lt;exc.displayException()&gt;&gt;&lt;./parser&gt;');
<a name="2539"></a>                    
<a name="2540"></a>                else
<a name="2541"></a>                    DMsg(recording failed, '&lt;.parser&gt;Failed; an error occurred
<a name="2542"></a>                        opening the command recording file.&lt;./parser&gt;');
<a name="2543"></a>            }
<a name="2544"></a>        }
<a name="2545"></a>    }
<a name="2546"></a>
<a name="2547"></a>    /* the log file type - by default, we open a regular command log */
<a name="2548"></a>    logFileType = LogTypeCommand
<a name="2549"></a>;
<a name="2550"></a>
<a name="2551"></a>/* subclass of Record action that sets up an event script recording */
<a name="2552"></a>DefineAction(RecordEvents, Record)
<a name="2553"></a>    logFileType = LogTypeScript
<a name="2554"></a>;
<a name="2555"></a>
<a name="2556"></a>/* subclass of Record action taking a quoted string for the filename */
<a name="2557"></a>DefineAction(RecordString, Record)
<a name="2558"></a>    execAction(cmd)
<a name="2559"></a>    {
<a name="2560"></a>        /* set up scripting to the filename specified in the command */
<a name="2561"></a>        performFileOp(fname_.getStringText(), true);
<a name="2562"></a>    }
<a name="2563"></a>;
<a name="2564"></a>
<a name="2565"></a>/* subclass of RecordString action that sets up an event script recording */
<a name="2566"></a>DefineAction(RecordEventsString, RecordString)
<a name="2567"></a>    logFileType = LogTypeScript
<a name="2568"></a>;
<a name="2569"></a>
<a name="2570"></a>/*
<a name="2571"></a> *   Turn command recording off.  This stops recording the command log
<a name="2572"></a> *   started with the most recent RECORD command.  
<a name="2573"></a> */
<a name="2574"></a>DefineSystemAction(RecordOff)
<a name="2575"></a>    execAction(cmd)
<a name="2576"></a>    {
<a name="2577"></a>        /* turn off recording */
<a name="2578"></a>        turnOffRecording(true);
<a name="2579"></a>    }
<a name="2580"></a>
<a name="2581"></a>    /* turn off recording */
<a name="2582"></a>    turnOffRecording(ack)
<a name="2583"></a>    {
<a name="2584"></a>        /* if we're not recording anything, ignore it */
<a name="2585"></a>        if (scriptStatus.recordFile == nil)
<a name="2586"></a>        {
<a name="2587"></a>            DMsg(record off ignored, '&lt;.parser&gt;No command recording is currently
<a name="2588"></a>                being made.&lt;./parser&gt; ');
<a name="2589"></a>           
<a name="2590"></a>            return;
<a name="2591"></a>        }
<a name="2592"></a>
<a name="2593"></a>        /* cancel recording in the interpreter's output layer */
<a name="2594"></a>        aioSetLogFile(nil, LogTypeCommand);
<a name="2595"></a>
<a name="2596"></a>        /* remember that recording is no longer in effect */
<a name="2597"></a>        scriptStatus.recordFile = nil;
<a name="2598"></a>
<a name="2599"></a>        /* acknowledge the change, if desired */
<a name="2600"></a>        if (ack)
<a name="2601"></a>            DMsg(record off okay, '&lt;.parser&gt;Command recording ended.&lt;./parser&gt; ');
<a name="2602"></a>    }
<a name="2603"></a>
<a name="2604"></a>    /* we can't include this in undo, as it affects external files */
<a name="2605"></a>    includeInUndo = nil
<a name="2606"></a>;
<a name="2607"></a>
<a name="2608"></a>/*
<a name="2609"></a> *   REPLAY - play back a command log previously recorded. 
<a name="2610"></a> */
<a name="2611"></a>DefineAction(Replay, FileOpAction)
<a name="2612"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="2613"></a>    filePromptMsg = (BMsg(get replay prompt, 'Please select the command log file
<a name="2614"></a>        to replay'))
<a name="2615"></a>    
<a name="2616"></a>    fileTypeID = FileTypeCmd
<a name="2617"></a>    fileDisposition = InFileOpen
<a name="2618"></a>
<a name="2619"></a>    /* show our cancellation mesasge */
<a name="2620"></a>    showCancelMsg() { DMsg(replay canceled, '&lt;.parser&gt;Canceled.&lt;./parser&gt; '); }
<a name="2621"></a>
<a name="2622"></a>    /* script flags passed to setScriptFile */
<a name="2623"></a>    scriptOptionFlags = 0
<a name="2624"></a>
<a name="2625"></a>    /* replay the given file */
<a name="2626"></a>    performFileOp(fname, ack)
<a name="2627"></a>    {
<a name="2628"></a>        /* 
<a name="2629"></a>         *   Note that we're reading from the script file if desired.  Do
<a name="2630"></a>         *   this before opening the script, so that we display the
<a name="2631"></a>         *   acknowledgment even if we're in 'quiet' mode. 
<a name="2632"></a>         */
<a name="2633"></a>        if (ack)
<a name="2634"></a>            inputScriptOkay(
<a name="2635"></a>                fname.ofKind(TemporaryFile) ? fname.getFilename() : fname);
<a name="2636"></a>
<a name="2637"></a>        /* activate the script file */
<a name="2638"></a>        local ok = nil, exc = nil;
<a name="2639"></a>        try
<a name="2640"></a>        {
<a name="2641"></a>            ok = setScriptFile(fname, scriptOptionFlags);
<a name="2642"></a>        }
<a name="2643"></a>        catch (Exception e)
<a name="2644"></a>        {
<a name="2645"></a>            exc = e;
<a name="2646"></a>        }
<a name="2647"></a>        if (!ok)
<a name="2648"></a>        {
<a name="2649"></a>            if (exc != nil)
<a name="2650"></a>                DMsg(input script failed exception, '&lt;.parser&gt;Failed; 
<a name="2651"></a>                    &lt;&lt;exc.displayException&gt;&gt;&lt;./parser&gt;');               
<a name="2652"></a>            else
<a name="2653"></a>                DMsg(input script failed, '&lt;.parser&gt;Failed; the script input
<a name="2654"></a>                    file could not be opened.&lt;./parser&gt;');
<a name="2655"></a>              
<a name="2656"></a>        }
<a name="2657"></a>    }
<a name="2658"></a>    
<a name="2659"></a>    /* acknowledge starting an input script */
<a name="2660"></a>    inputScriptOkay(fname)
<a name="2661"></a>    {
<a name="2662"></a>        DMsg(input script okay, '&lt;.parser&gt;Reading commands from &lt;q&gt;&lt;&lt;
<a name="2663"></a>          File.getRootName(fname).htmlify()&gt;&gt;&lt;/q&gt;...&lt;./parser&gt;\n ');
<a name="2664"></a>    }
<a name="2665"></a>
<a name="2666"></a>    
<a name="2667"></a>;
<a name="2668"></a>
<a name="2669"></a>/* subclass of Replay action taking a quoted string for the filename */
<a name="2670"></a>DefineAction(ReplayString, Replay)
<a name="2671"></a>    execAction(cmd)
<a name="2672"></a>    {
<a name="2673"></a>        /* 
<a name="2674"></a>         *   if there's a string, use the string as the filename;
<a name="2675"></a>         *   otherwise, inherit the default handling to ask for a filename 
<a name="2676"></a>         */
<a name="2677"></a>        if (fname_ != nil)
<a name="2678"></a>        {
<a name="2679"></a>            /* set up scripting to the filename specified in the command */
<a name="2680"></a>            performFileOp(fname_.getStringText(), true);
<a name="2681"></a>        }
<a name="2682"></a>        else
<a name="2683"></a>        {
<a name="2684"></a>            /* inherit the default handling to ask for a filename */
<a name="2685"></a>            inherited();
<a name="2686"></a>        }
<a name="2687"></a>    }
<a name="2688"></a>;
<a name="2689"></a>
<a name="2690"></a>
<a name="2691"></a>/* ------------------------------------------------------------------------ */
<a name="2692"></a>/*
<a name="2693"></a> *   Special "save" action.  This command saves the current game state to
<a name="2694"></a> *   an external file for later restoration. 
<a name="2695"></a> */
<a name="2696"></a>DefineAction(Save, FileOpAction)
<a name="2697"></a>    /* the file dialog prompt */
<a name="2698"></a>    filePromptMsg = (BMsg(get save prompt, 'Save game to file'))
<a name="2699"></a>
<a name="2700"></a>    /* we're asking for a file to save, or type t3-save */
<a name="2701"></a>    fileDisposition = InFileSave
<a name="2702"></a>    fileTypeID = FileTypeT3Save
<a name="2703"></a>
<a name="2704"></a>    /* cancel message */
<a name="2705"></a>    showCancelMsg() { DMsg(save cancelled, '&lt;.parser&gt;Canceled.&lt;./parser&gt; '); }
<a name="2706"></a>    
<a name="2707"></a>    /* perform a save */
<a name="2708"></a>    performFileOp(fname, ack, desc:?)
<a name="2709"></a>    {
<a name="2710"></a>        /* before saving the game, notify all PreSaveObject instances */
<a name="2711"></a>        PreSaveObject.classExec();
<a name="2712"></a>        
<a name="2713"></a>        /* 
<a name="2714"></a>         *   Save the game to the given file.  If an error occurs, the
<a name="2715"></a>         *   save routine will throw a runtime error.  
<a name="2716"></a>         */
<a name="2717"></a>        try
<a name="2718"></a>        {
<a name="2719"></a>            /* try saving the game */
<a name="2720"></a>            saveGame(fname, gameMain.getSaveDesc(desc));
<a name="2721"></a>        }
<a name="2722"></a>        catch (StorageServerError sse)
<a name="2723"></a>        {
<a name="2724"></a>            /* the save failed due to a storage server problem - explain */           
<a name="2725"></a>            DMsg(save failed on server, '&lt;.parser&gt;Failed, because of a problem
<a name="2726"></a>                accessing the storage server:
<a name="2727"></a>                &lt;&lt;makeSentence(sse.errMsg)&gt;&gt;&lt;./parser&gt;');
<a name="2728"></a>
<a name="2729"></a>            /* done */
<a name="2730"></a>            return;
<a name="2731"></a>        }
<a name="2732"></a>        catch (RuntimeError err)
<a name="2733"></a>        {
<a name="2734"></a>            /* the save failed - mention the problem */
<a name="2735"></a>            DMsg(save failed, '&lt;.parser&gt;Failed; your computer might be running
<a name="2736"></a>                low on disk space, or you might not have the necessary
<a name="2737"></a>                permissions to write this file.&lt;./parser&gt;');            
<a name="2738"></a>            
<a name="2739"></a>            /* done */
<a name="2740"></a>            return;
<a name="2741"></a>        }
<a name="2742"></a>        
<a name="2743"></a>        /* note the successful save */
<a name="2744"></a>        DMsg(save okay, '&lt;.parser&gt;Saved.&lt;./parser&gt; ');
<a name="2745"></a>        
<a name="2746"></a>    }
<a name="2747"></a>
<a name="2748"></a>    /* 
<a name="2749"></a>     *   Saving has no effect on game state, so it's irrelevant whether or
<a name="2750"></a>     *   not it's undoable; but it might be confusing to say we undid a
<a name="2751"></a>     *   "save" command, because the player might think we deleted the
<a name="2752"></a>     *   saved file.  To avoid such confusion, do not include "save"
<a name="2753"></a>     *   commands in the undo log.  
<a name="2754"></a>     */
<a name="2755"></a>    includeInUndo = nil
<a name="2756"></a>
<a name="2757"></a>    /* 
<a name="2758"></a>     *   Don't allow this to be repeated with AGAIN.  There's no point in
<a name="2759"></a>     *   repeating a SAVE immediately, as nothing will have changed in the
<a name="2760"></a>     *   game state to warrant saving again.  
<a name="2761"></a>     */
<a name="2762"></a>    isRepeatable = nil
<a name="2763"></a>;
<a name="2764"></a>
<a name="2765"></a>/*
<a name="2766"></a> *   Subclass of Save action that takes a literal string as part of the
<a name="2767"></a> *   command.  The filename must be a literal enclosed in quotes, and the
<a name="2768"></a> *   string (with the quotes) must be stored in our fname_ property by
<a name="2769"></a> *   assignment of a quotedStringPhrase production in the grammar rule.  
<a name="2770"></a> */
<a name="2771"></a>DefineAction(SaveString, Save)
<a name="2772"></a>    execAction(cmd)
<a name="2773"></a>    {
<a name="2774"></a>        /* 
<a name="2775"></a>         *   Perform the save, using the filename given in our fname_
<a name="2776"></a>         *   parameter, trimmed of quotes.  
<a name="2777"></a>         */
<a name="2778"></a>        performFileOp(fname_.getStringText(), true);
<a name="2779"></a>    }
<a name="2780"></a>;
<a name="2781"></a>
<a name="2782"></a>DefineSystemAction(Restore)
<a name="2783"></a>    execAction(cmd)
<a name="2784"></a>    {
<a name="2785"></a>        /* ask for a file and restore it */
<a name="2786"></a>        askAndRestore();
<a name="2787"></a>
<a name="2788"></a>        /* 
<a name="2789"></a>         *   regardless of what happened, abandon any additional commands
<a name="2790"></a>         *   on the same command line 
<a name="2791"></a>         */
<a name="2792"></a>        throw new TerminateCommandException();
<a name="2793"></a>    }
<a name="2794"></a>
<a name="2795"></a>    /*
<a name="2796"></a>     *   Ask for a file and try to restore it.  Returns true on success,
<a name="2797"></a>     *   nil on failure.  (Failure could indicate that the user chose to
<a name="2798"></a>     *   cancel out of the file selector, that we couldn't find the file to
<a name="2799"></a>     *   restore, or that the file isn't a valid saved state file.  In any
<a name="2800"></a>     *   case, we show an appropriate message on failure.)  
<a name="2801"></a>     */
<a name="2802"></a>    askAndRestore()
<a name="2803"></a>    {
<a name="2804"></a>        local succ;        
<a name="2805"></a>        local result;
<a name="2806"></a>
<a name="2807"></a>
<a name="2808"></a>        /* presume failure */
<a name="2809"></a>        succ = nil;
<a name="2810"></a>
<a name="2811"></a>        /* ask for a file */
<a name="2812"></a>        result = getInputFile(BMsg(get restore prompt, 'Restore game from file'), 
<a name="2813"></a>                              InFileOpen, FileTypeT3Save, 0);
<a name="2814"></a>
<a name="2815"></a>        /* check the inputFile response */
<a name="2816"></a>        switch(result[1])
<a name="2817"></a>        {
<a name="2818"></a>        case InFileSuccess:
<a name="2819"></a>            /* 
<a name="2820"></a>             *   try restoring the file; use code 2 to indicate that the
<a name="2821"></a>             *   restoration was performed by an explicit RESTORE command 
<a name="2822"></a>             */
<a name="2823"></a>            if (performRestore(result[2], 2))
<a name="2824"></a>            {
<a name="2825"></a>                /* note that we succeeded */
<a name="2826"></a>                succ = true;
<a name="2827"></a>            }
<a name="2828"></a>           
<a name="2829"></a>            /* done */
<a name="2830"></a>            break;
<a name="2831"></a>
<a name="2832"></a>        case InFileFailure:
<a name="2833"></a>            /* advise of the failure of the prompt */
<a name="2834"></a>            if (result.length() &gt; 1)
<a name="2835"></a>                filePromptFailedMsg(result[2]);
<a name="2836"></a>            else
<a name="2837"></a>                filePromptFailed();
<a name="2838"></a>            break;
<a name="2839"></a>
<a name="2840"></a>        case InFileCancel:
<a name="2841"></a>            /* acknowledge the cancellation */
<a name="2842"></a>            DMsg(restore canceled, '&lt;.parser&gt;Canceled.&lt;./parser&gt; ');            
<a name="2843"></a>            break;
<a name="2844"></a>        }
<a name="2845"></a>
<a name="2846"></a>        /* 
<a name="2847"></a>         *   If we were successful, clear out the AGAIN memory.  This
<a name="2848"></a>         *   avoids any confusion about whether we're repeating the RESTORE
<a name="2849"></a>         *   command itself, the command just before RESTORE from the
<a name="2850"></a>         *   current session, or the last command before SAVE from the
<a name="2851"></a>         *   restored game. 
<a name="2852"></a>         */
<a name="2853"></a>        if (succ)
<a name="2854"></a>            Again.clearForAgain();
<a name="2855"></a>
<a name="2856"></a>        /* return the success/failure indication */
<a name="2857"></a>        return succ;
<a name="2858"></a>    }
<a name="2859"></a>
<a name="2860"></a>    /*
<a name="2861"></a>     *   Restore a game on startup.  This can be called from mainRestore()
<a name="2862"></a>     *   to restore a saved game directly as part of loading the game.
<a name="2863"></a>     *   (Most interpreters provide a way of starting the interpreter
<a name="2864"></a>     *   directly with a saved game to be restored, skipping the
<a name="2865"></a>     *   intermediate step of running the game and using a RESTORE
<a name="2866"></a>     *   command.)
<a name="2867"></a>     *   
<a name="2868"></a>     *   Returns true on success, nil on failure.  On failure, the caller
<a name="2869"></a>     *   should simply exit the program.  On success, the caller should
<a name="2870"></a>     *   start the game running, usually using runGame(), after showing any
<a name="2871"></a>     *   desired introductory messages.  
<a name="2872"></a>     */
<a name="2873"></a>    startupRestore(fname)
<a name="2874"></a>    {
<a name="2875"></a>        /* 
<a name="2876"></a>         *   try restoring the game, using code 1 to indicate that this is
<a name="2877"></a>         *   a direct startup restore 
<a name="2878"></a>         */
<a name="2879"></a>        if (performRestore(fname, 1))
<a name="2880"></a>        {
<a name="2881"></a>            /* success - tell the caller to proceed with the restored game */
<a name="2882"></a>            return true;
<a name="2883"></a>        }
<a name="2884"></a>        else
<a name="2885"></a>        {
<a name="2886"></a>            /* 
<a name="2887"></a>             *   Failure.  We've described the problem, so ask the user
<a name="2888"></a>             *   what they want to do about it. 
<a name="2889"></a>             */
<a name="2890"></a>            try
<a name="2891"></a>            {
<a name="2892"></a>                /* show options and read the response */
<a name="2893"></a>                failedRestoreOptions();
<a name="2894"></a>
<a name="2895"></a>                /* if we get here, proceed with the game */
<a name="2896"></a>                return true;
<a name="2897"></a>            }
<a name="2898"></a>            catch (QuittingException qe)
<a name="2899"></a>            {
<a name="2900"></a>                /* quitting - tell the caller to terminate */
<a name="2901"></a>                return nil;
<a name="2902"></a>            }
<a name="2903"></a>        }
<a name="2904"></a>    }
<a name="2905"></a>    
<a name="2906"></a>
<a name="2907"></a>    /*
<a name="2908"></a>     *   Restore a file.  'code' is the restoreCode value for the
<a name="2909"></a>     *   PostRestoreObject notifications.  Returns true on success, nil on
<a name="2910"></a>     *   failure.  
<a name="2911"></a>     */
<a name="2912"></a>    performRestore(fname, code)
<a name="2913"></a>    {
<a name="2914"></a>        try
<a name="2915"></a>        {
<a name="2916"></a>            /* restore the file */
<a name="2917"></a>            restoreGame(fname);
<a name="2918"></a>        }
<a name="2919"></a>        catch (StorageServerError sse)
<a name="2920"></a>        {
<a name="2921"></a>            /* failed due to a storage server error - explain the problem */
<a name="2922"></a>            DMsg(restore failed on server,'&lt;.parser&gt;Failed, because of a problem
<a name="2923"></a>                accessing the storage server:
<a name="2924"></a>                &lt;&lt;makeSentence(sse.errMsg)&gt;&gt;&lt;./parser&gt;');            
<a name="2925"></a>
<a name="2926"></a>            /* indicate failure */
<a name="2927"></a>            return nil;
<a name="2928"></a>        }
<a name="2929"></a>        catch (RuntimeError err)
<a name="2930"></a>        {
<a name="2931"></a>            /* failed - check the error to see what went wrong */
<a name="2932"></a>            switch(err.errno_)
<a name="2933"></a>            {
<a name="2934"></a>            case 1201:
<a name="2935"></a>                /* not a saved state file */
<a name="2936"></a>                DMsg(restore invalid file, '&lt;.parser&gt;Failed: this is not a valid
<a name="2937"></a>                    saved position file.&lt;./parser&gt; ');                
<a name="2938"></a>                break;
<a name="2939"></a>                
<a name="2940"></a>            case 1202:
<a name="2941"></a>                /* saved by different game or different version */
<a name="2942"></a>                DMsg(restore invalid match, '&lt;.parser&gt;Failed: the file was not
<a name="2943"></a>                    saved by this story (or was saved by an incompatible version
<a name="2944"></a>                    of the story).&lt;./parser&gt; ');               
<a name="2945"></a>                break;
<a name="2946"></a>                
<a name="2947"></a>            case 1207:
<a name="2948"></a>                /* corrupted saved state file */
<a name="2949"></a>                DMsg(restore corrupted file, '&lt;.parser&gt;Failed: this saved state
<a name="2950"></a>                    file appears to be corrupted.  This can occur if the file
<a name="2951"></a>                    was modified by another program, or the file was copied
<a name="2952"></a>                    between computers in a non-binary transfer mode, or the
<a name="2953"></a>                    physical media storing the file were damaged.&lt;./parser&gt; ');                
<a name="2954"></a>                break;
<a name="2955"></a>                
<a name="2956"></a>            default:
<a name="2957"></a>                /* some other failure */
<a name="2958"></a>                DMsg(restore failed, '&lt;.parser&gt;Failed: the position could not be
<a name="2959"></a>                    restored.&lt;./parser&gt;');                
<a name="2960"></a>                break;
<a name="2961"></a>            }
<a name="2962"></a>
<a name="2963"></a>            /* indicate failure */
<a name="2964"></a>            return nil;
<a name="2965"></a>        }
<a name="2966"></a>
<a name="2967"></a>        /* note that we've successfully restored the game */
<a name="2968"></a>        DMsg(restore okay, '&lt;.parser&gt;Restored.&lt;./parser&gt; ');
<a name="2969"></a>               
<a name="2970"></a>        /* set the appropriate restore-action code */
<a name="2971"></a>        PostRestoreObject.restoreCode = code;
<a name="2972"></a>
<a name="2973"></a>        /* notify all PostRestoreObject instances */
<a name="2974"></a>        PostRestoreObject.classExec();
<a name="2975"></a>
<a name="2976"></a>        /* 
<a name="2977"></a>         *   look around, to refresh the player's memory of the state the
<a name="2978"></a>         *   game was in when saved 
<a name="2979"></a>         */
<a name="2980"></a>        "\b";
<a name="2981"></a>        libGlobal.playerChar.outermostVisibleParent().lookAroundWithin();
<a name="2982"></a>
<a name="2983"></a>        /* indicate success */
<a name="2984"></a>        return true;
<a name="2985"></a>    }
<a name="2986"></a>    
<a name="2987"></a>    /* 
<a name="2988"></a>     *   There's no point in including this in undo.  If the command
<a name="2989"></a>     *   succeeds, it's not undoable itself, and there won't be any undo
<a name="2990"></a>     *   information in the newly restored state.  If the command fails, it
<a name="2991"></a>     *   won't make any changes to the game state, so there won't be
<a name="2992"></a>     *   anything to undo.  
<a name="2993"></a>     */
<a name="2994"></a>    includeInUndo = nil
<a name="2995"></a>    
<a name="2996"></a>    /* error showing the input file dialog (or character-mode equivalent) */
<a name="2997"></a>    filePromptFailed()
<a name="2998"></a>    {
<a name="2999"></a>        DMsg(file prompt failed, '&lt;.parser&gt;A system error occurred asking for a
<a name="3000"></a>            filename. Your computer might be running low on memory, or might
<a name="3001"></a>            have a configuration problem.&lt;./parser&gt; ');
<a name="3002"></a>    }
<a name="3003"></a>
<a name="3004"></a>    /* error showing the input file dialog, with a system error message */
<a name="3005"></a>    filePromptFailedMsg(msg)
<a name="3006"></a>    {
<a name="3007"></a>        DMsg(file prompt failed msg, '&lt;.parser&gt;Failed:
<a name="3008"></a>            &lt;&lt;makeSentence(msg)&gt;&gt;&lt;./parser&gt; ');
<a name="3009"></a>    }
<a name="3010"></a>;
<a name="3011"></a>
<a name="3012"></a>/*
<a name="3013"></a> *   Subclass of Restore action that takes a literal string as part of the
<a name="3014"></a> *   command.  The filename must be a literal enclosed in quotes, and the
<a name="3015"></a> *   string (with the quotes) must be stored in our fname_ property by
<a name="3016"></a> *   assignment of a quotedStringPhrase production in the grammar rule.  
<a name="3017"></a> */
<a name="3018"></a>DefineAction(RestoreString, Restore)
<a name="3019"></a>    execAction(cmd)
<a name="3020"></a>    {
<a name="3021"></a>        /* 
<a name="3022"></a>         *   Perform the restore, using the filename given in our fname_
<a name="3023"></a>         *   parameter, trimmed of quotes.  Use code 2, the same as any
<a name="3024"></a>         *   other explicit RESTORE command.  
<a name="3025"></a>         */
<a name="3026"></a>        performRestore(fname_.getStringText(), 2);
<a name="3027"></a>
<a name="3028"></a>        /* abandon any additional commands on the same command line */
<a name="3029"></a>        throw new TerminateCommandException();
<a name="3030"></a>    }
<a name="3031"></a>;
<a name="3032"></a>
<a name="3033"></a>
<a name="3034"></a>DefineSystemAction(Again)
<a name="3035"></a>    
<a name="3036"></a>    exec(cmd)
<a name="3037"></a>    {
<a name="3038"></a>        if((gameMain.againRepeatsParse &amp;&amp; libGlobal.lastCommandForAgain is in
<a name="3039"></a>           ('',nil)) || (!gameMain.againRepeatsParse &amp;&amp; libGlobal.lastCommand is
<a name="3040"></a>           in ('', nil)))
<a name="3041"></a>        {
<a name="3042"></a>            DMsg(no repeat, 'Sorry, there is no action available to repeat. ');
<a name="3043"></a>        }
<a name="3044"></a>        else if (gameMain.againRepeatsParse)
<a name="3045"></a>        {
<a name="3046"></a>            Parser.parse(libGlobal.lastCommandForAgain);
<a name="3047"></a>        }
<a name="3048"></a>        else
<a name="3049"></a>        {
<a name="3050"></a>            libGlobal.lastCommand.exec();
<a name="3051"></a>        }
<a name="3052"></a>    }
<a name="3053"></a>    
<a name="3054"></a>    clearForAgain()
<a name="3055"></a>    {
<a name="3056"></a>        libGlobal.lastAction = nil;
<a name="3057"></a>        libGlobal.lastCommand = nil;
<a name="3058"></a>    }
<a name="3059"></a>    
<a name="3060"></a>;
<a name="3061"></a>
<a name="3062"></a>/* Dummy action to provide an action context. */
<a name="3063"></a>
<a name="3064"></a>DefineTIAction(DoNothing)
<a name="3065"></a>    curDobj = gPlayerChar
<a name="3066"></a>    curIobj = gPlayerChar.location
<a name="3067"></a>    curObj = curDobj
<a name="3068"></a>    grammarTemplates = ['do nothing']
<a name="3069"></a>;
<a name="3070"></a>
<a name="3071"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/04/2024 from adv3Lite version 2.0</div>
</body>
</html>

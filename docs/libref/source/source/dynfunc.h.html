<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>dynfunc.h</title></head><body>
<table class=ban><tr><td><h1>dynfunc.h</h1><td align=right><a href="../file/dynfunc.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   The header defines the DynamicFunc intrinsic class.  This class is used
<a name="10"></a> *   for creating new functions from source code strings dynamically at
<a name="11"></a> *   run-time.
<a name="12"></a> *   
<a name="13"></a> *   Programs that use the DynamicFunc class should add the system library
<a name="14"></a> *   source file dynfunc.t to the build file list, since it contains some
<a name="15"></a> *   additional definitions that are useful with this class.  
<a name="16"></a> */
<a name="17"></a>
<a name="18"></a>
<a name="19"></a>/* include our base class definitions */
<a name="20"></a>#include "systype.h"
<a name="21"></a>
<a name="22"></a>/*
<a name="23"></a> *   The DynamicFunc class is used to create new functions from source code
<a name="24"></a> *   strings dynamically at run-time.  To create a new executable function,
<a name="25"></a> *   create a new DynamicFunc object:
<a name="26"></a> *   
<a name="27"></a> *.    local f = new DynamicFunc('function(x) { return x*2; }',
<a name="28"></a> *.                              globals, locals, macros);
<a name="29"></a> *   
<a name="30"></a> *   The first constructor argument is a string giving the source code to
<a name="31"></a> *   compile.
<a name="32"></a> *   
<a name="33"></a> *   The optional second argument is a LookupTable containing the global
<a name="34"></a> *   symbols for the compilation.  This can be the table returned from
<a name="35"></a> *   t3GetGlobalSymbols(), or it can be a custom table.  The compiler looks
<a name="36"></a> *   up string keys in the table to resolve global symbol names; the
<a name="37"></a> *   corresponding values can be objects, properties, enum values, or
<a name="38"></a> *   function pointers.
<a name="39"></a> *   
<a name="40"></a> *   The optional third argument is a StackFrameDesc object, or a list of
<a name="41"></a> *   StackFrameDesc objects, giving the stack frames to use for local
<a name="42"></a> *   variable access within the dynamic code.  The source code can refer to
<a name="43"></a> *   local variables in these frames, and can assign new values to them.
<a name="44"></a> *   This is analogous to the way anonymous functions can refer to local
<a name="45"></a> *   variables in their lexically enclosing scopes.  If you supply a list,
<a name="46"></a> *   the compiler searches the frames in order of their appearance in the
<a name="47"></a> *   list.  If a variable appears in more than one frame in the list, the
<a name="48"></a> *   compiler will use the first occurrence it finds. 
<a name="49"></a> *   
<a name="50"></a> *   The optional fourth argument is a LookupTable giving the preprocessor
<a name="51"></a> *   macros to use for the compilation.  This is a table in the format
<a name="52"></a> *   returned by t3GetGlobalsSymbols(T3PreprocMacros).
<a name="53"></a> *   
<a name="54"></a> *   If the 'symtab' or 'macros' arguments are omitted or nil, the
<a name="55"></a> *   compilation is done without global symbols or macros, respectively.
<a name="56"></a> *   Note that built-in functions and intrinsic classes are identified by
<a name="57"></a> *   global symbols, so you won't be able to call any built-ins if you don't
<a name="58"></a> *   provide a symbol table.
<a name="59"></a> *   
<a name="60"></a> *   The source code string can start with the keyword 'function', followed
<a name="61"></a> *   by a list of parameter names, followed by the executable statements in
<a name="62"></a> *   braces.  Or, it can simply be a list of statements, in which case it's a
<a name="63"></a> *   function with no arguments, as though it started with 'function()'.
<a name="64"></a> *   
<a name="65"></a> *   Creating a DynamicFunc compiles the source code.  If a compilation error
<a name="66"></a> *   occurs (such as a syntax error, or an unknown symbol reference), the
<a name="67"></a> *   'new' call will throw a CompilerException error.  The exception object
<a name="68"></a> *   contains information on the specific compiler error.
<a name="69"></a> *   
<a name="70"></a> *   To invoke the new function, simply use the standard function call syntax
<a name="71"></a> *   on the object value, as though it were a regular function pointer:
<a name="72"></a> *   
<a name="73"></a> *.     local y = f(7);
<a name="74"></a> */
<a name="75"></a>intrinsic class DynamicFunc 'dynamic-func/030000'
<a name="76"></a>{
<a name="77"></a>    /*
<a name="78"></a>     *   Get the original source code of the function.  This returns the
<a name="79"></a>     *   string that was used as the source string to create the function.  
<a name="80"></a>     */
<a name="81"></a>    getSource();
<a name="82"></a>}
<a name="83"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/04/2024 from adv3Lite version 2.0</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>score.t</title></head><body>
<table class=ban><tr><td><h1>score.t</h1><td align=right><a href="../file/score.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 by Michael J. Roberts.  All Rights Reserved. 
<a name="5"></a> *   Lightly adapted for adv3Lite by Eric Eve
<a name="6"></a> *   
<a name="7"></a> *   TADS 3 Library - scoring
<a name="8"></a> *   
<a name="9"></a> *   This module defines objects related to keeping track of the player's
<a name="10"></a> *   score, which indicates the player's progress through the game.  
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>/* include the library header */
<a name="14"></a>#include "advlite.h"
<a name="15"></a>
<a name="16"></a>
<a name="17"></a>
<a name="18"></a>/* ------------------------------------------------------------------------ */
<a name="19"></a>/*
<a name="20"></a> *   An Achievement is an object used to award points in the score.  For
<a name="21"></a> *   most purposes, an achievement can be described simply by a string,
<a name="22"></a> *   but the Achievement object provides more flexibility in describing
<a name="23"></a> *   combined scores when a set of similar achievements are to be grouped.
<a name="24"></a> *   
<a name="25"></a> *   There are two ways to use the scoring system.
<a name="26"></a> *   
<a name="27"></a> *   1.  You can use a mix of string names and Achievement objects for
<a name="28"></a> *   scoring items; each time you award a scoring item, you call the
<a name="29"></a> *   function addToScore() to specify the achievement (by name or by
<a name="30"></a> *   Achievement object) and the number of points to award.  You can also
<a name="31"></a> *   call the method addToScoreOnce() on an Achievement object to award
<a name="32"></a> *   the scoring item, ensuring that the item is only awarded once in the
<a name="33"></a> *   entire game (saving you the trouble of checking to see if the event
<a name="34"></a> *   that triggered the scoring item has happened before already in the
<a name="35"></a> *   same game).  If you do this, you MUST set the property
<a name="36"></a> *   gameMain.maxScore to reflect the maximum score possible in the game.
<a name="37"></a> *   
<a name="38"></a> *   2.  You can use EXCLUSIVELY Achievement objects to represents scoring
<a name="39"></a> *   items, and give each Achievement object a 'points' property
<a name="40"></a> *   indicating the number of points it's worth.  To award a scoring item,
<a name="41"></a> *   you call the method awardPoints() on an Achievement object.  If you
<a name="42"></a> *   use this style of scoring, the library AUTOMATICALLY computes the
<a name="43"></a> *   gameMain.maxScore value, by adding up the 'points' values of all of
<a name="44"></a> *   the Achievement objects in the game.  For this to work properly, you
<a name="45"></a> *   have to obey the following rules:
<a name="46"></a> *   
<a name="47"></a> *.    - use ONLY Achievement objects (never strings) to award points;
<a name="48"></a> *.    - set the 'points' property of each Achievement to its score;
<a name="49"></a> *.    - define Achievement objects statically only (never use 'new' to
<a name="50"></a> *.      create an Achievement dynamically)
<a name="51"></a> *.    - if an Achievement can be awarded more than once, you must override
<a name="52"></a> *.      its 'maxPoints' property to reflect the total number of points it
<a name="53"></a> *.      will be worth when it is awarded the maximum number of times;
<a name="54"></a> *.    - always award an Achievement through its awardPoints() or
<a name="55"></a> *.      awardPointsOnce() method;
<a name="56"></a> *.    - there exists at least one solution of the game in which every
<a name="57"></a> *.      Achievement object is awarded
<a name="58"></a> */
<a name="59"></a>class Achievement: object
<a name="60"></a>    /*
<a name="61"></a>     *   The number of points this Achievement scores individually.  By
<a name="62"></a>     *   default, we set this to nil.  If you use the awardPoints() or
<a name="63"></a>     *   awardPointsOnce() methods, you MUST set this to a non-nil value.
<a name="64"></a>     *   
<a name="65"></a>     *   If you set this to a non-nil value, the library will use it
<a name="66"></a>     *   pre-compute the maximum possible score in the game, saving you the
<a name="67"></a>     *   trouble of figuring out the maximum score by hand.  
<a name="68"></a>     */
<a name="69"></a>    points = nil
<a name="70"></a>
<a name="71"></a>    /*
<a name="72"></a>     *   The MAXIMUM number of points this Achievement can award.  This is
<a name="73"></a>     *   by default just our 'points' value, on the assumption that the
<a name="74"></a>     *   achievement is scored only once.  The library uses this value
<a name="75"></a>     *   during pre-initialization to compute the maximum possible score in
<a name="76"></a>     *   the game.  
<a name="77"></a>     */
<a name="78"></a>    maxPoints = (points)
<a name="79"></a>
<a name="80"></a>    /* 
<a name="81"></a>     *   Describe the achievement - this must display a string explaining
<a name="82"></a>     *   the reason the points associated with this achievement were
<a name="83"></a>     *   awarded.
<a name="84"></a>     *   
<a name="85"></a>     *   Note that this description can make use of the scoreCount
<a name="86"></a>     *   information to show different descriptions depending on how many
<a name="87"></a>     *   times the item has scored.  For example, an achievement for
<a name="88"></a>     *   finding various treasure items might want to display "finding a
<a name="89"></a>     *   treasure" if only one treasure was found and "finding five
<a name="90"></a>     *   treasures" if five were found.
<a name="91"></a>     *   
<a name="92"></a>     *   In some cases, it might be desirable to keep track of additional
<a name="93"></a>     *   custom information, and use that information in generating the
<a name="94"></a>     *   description.  For example, the game might keep a list of
<a name="95"></a>     *   treasures found with the achievement, adding to the list each
<a name="96"></a>     *   time the achievement is scored, and displaying the contents of
<a name="97"></a>     *   the list when the description is shown.
<a name="98"></a>     */
<a name="99"></a>    desc = ""
<a name="100"></a>
<a name="101"></a>    /* show myself in a full-score listing */
<a name="102"></a>    listFullScoreItem()
<a name="103"></a>    {
<a name="104"></a>        /* show the number of points I'm worth */
<a name="105"></a>        DMsg(full score item points, '\n &lt;&lt;totalPoints&gt;&gt; point&lt;&lt;totalPoints == 1
<a name="106"></a>              ?  '' : 's'&gt;&gt; for ');
<a name="107"></a>
<a name="108"></a>        /* show my description */
<a name="109"></a>        desc;
<a name="110"></a>        
<a name="111"></a>    }
<a name="112"></a>
<a name="113"></a>    /* 
<a name="114"></a>     *   The number of times the achievement has been awarded.  Each time
<a name="115"></a>     *   the achievement is passed to addToScore(), this is incremented.
<a name="116"></a>     *   Note that this is distinct from the number of points.  
<a name="117"></a>     */
<a name="118"></a>    scoreCount = 0
<a name="119"></a>
<a name="120"></a>    /* 
<a name="121"></a>     *   the number of points awarded for the achievement; if this
<a name="122"></a>     *   achievement has been accomplished multiple times, this reflects
<a name="123"></a>     *   the aggregate number of points awarded for all of the times it
<a name="124"></a>     *   has been accomplished 
<a name="125"></a>     */
<a name="126"></a>    totalPoints = 0
<a name="127"></a>
<a name="128"></a>    /*
<a name="129"></a>     *   Add this achievement to the score one time only, awarding the
<a name="130"></a>     *   given number of points.  This can be used to score an achievement
<a name="131"></a>     *   without separately tracking whether or not the achievement has
<a name="132"></a>     *   been accomplished previously.  If the achievement has already been
<a name="133"></a>     *   scored before, this will do nothing at all; otherwise, it'll score
<a name="134"></a>     *   the achievement with the given number of points.  Returns true if
<a name="135"></a>     *   we do award the points, nil if not (because we've awarded them
<a name="136"></a>     *   before).  
<a name="137"></a>     */
<a name="138"></a>    addToScoreOnce(points)
<a name="139"></a>    {
<a name="140"></a>        /* if I've never been scored before, score me now */
<a name="141"></a>        if (scoreCount == 0)
<a name="142"></a>        {
<a name="143"></a>            /* add the points to the score */
<a name="144"></a>            addToScore(points, self);
<a name="145"></a>
<a name="146"></a>            /* tell the caller we awarded the points as requested */
<a name="147"></a>            return true;
<a name="148"></a>        }
<a name="149"></a>        else
<a name="150"></a>        {
<a name="151"></a>            /* tell the caller we didn't do anything */
<a name="152"></a>            return nil;
<a name="153"></a>        }
<a name="154"></a>    }
<a name="155"></a>
<a name="156"></a>    /*
<a name="157"></a>     *   Award this Achievement's score, using the score value specified in
<a name="158"></a>     *   my 'points' property.  
<a name="159"></a>     */
<a name="160"></a>    awardPoints()
<a name="161"></a>    {
<a name="162"></a>        /* add me to the score, using my 'points' property */
<a name="163"></a>        addToScore(points, self);
<a name="164"></a>    }
<a name="165"></a>
<a name="166"></a>    /*
<a name="167"></a>     *   Award this Achievement's score, but ensure that we're never
<a name="168"></a>     *   awarded more than one time.  If this Achievement has already been
<a name="169"></a>     *   awarded, this does nothing at all.  Returns true if we do award
<a name="170"></a>     *   the points, nil if not (because we've awarded them before).  
<a name="171"></a>     */
<a name="172"></a>    awardPointsOnce()
<a name="173"></a>    {
<a name="174"></a>        /* award my 'points' value only if we haven't score before */
<a name="175"></a>        return addToScoreOnce(points);
<a name="176"></a>    }
<a name="177"></a>    
<a name="178"></a>    /* 
<a name="179"></a>     *   Has this achievement been achieved? By default it has if our scoreCount
<a name="180"></a>     *   is greater than 0 (i.e. if points have been awarded for this
<a name="181"></a>     *   achievement at least once.
<a name="182"></a>     */
<a name="183"></a>    achieved = (scoreCount &gt; 0)
<a name="184"></a>    
<a name="185"></a>    listOrder = 0
<a name="186"></a>    
<a name="187"></a>    lastListOrder = 0
<a name="188"></a>;
<a name="189"></a>
<a name="190"></a>/*
<a name="191"></a> *   Generic text achievement.  When we add an achievement to the full
<a name="192"></a> *   score list and the achievement is a simple string description, we'll
<a name="193"></a> *   create one of these to encapsulate the achievement.  
<a name="194"></a> */
<a name="195"></a>class SimpleAchievement: Achievement
<a name="196"></a>    /* create dynamically with a given string as our description */
<a name="197"></a>    construct(str) { desc_ = str; }
<a name="198"></a>
<a name="199"></a>    /* show my description */
<a name="200"></a>    desc { say(desc_); }
<a name="201"></a>
<a name="202"></a>    /* my description string */
<a name="203"></a>    desc_ = ''
<a name="204"></a>;
<a name="205"></a>
<a name="206"></a>/*
<a name="207"></a> *   List interface for showing the full score list 
<a name="208"></a> */
<a name="209"></a>fullScoreLister: Lister
<a name="210"></a>    showListPrefix(lst, pl, paraCnt)
<a name="211"></a>    {
<a name="212"></a>        /* show the full score list intro message */
<a name="213"></a>        DMsg(full score prefix, 'Your score consists of:');
<a name="214"></a>    }
<a name="215"></a>
<a name="216"></a>    /* every achievement is listed */
<a name="217"></a>    listed(obj) { return true; }
<a name="218"></a>
<a name="219"></a>    
<a name="220"></a>    showList(lst, pl, paraCnt)
<a name="221"></a>    {
<a name="222"></a>        foreach(local obj in lst)
<a name="223"></a>            obj.listFullScoreItem();
<a name="224"></a>    }
<a name="225"></a>    
<a name="226"></a>;
<a name="227"></a>    
<a name="228"></a>
<a name="229"></a>/*
<a name="230"></a> *   Score notification daemon handler.  We'll receive a
<a name="231"></a> *   checkNotification() call each turn; we'll display a notification
<a name="232"></a> *   message each time the score has changed since the last time we ran.  
<a name="233"></a> */
<a name="234"></a>scoreNotifier: object
<a name="235"></a>    /* the score as it was the last time we displayed a notification */
<a name="236"></a>    lastScore = static (libScore.totalScore)
<a name="237"></a>
<a name="238"></a>    /* we've never generated a notification about the score before */
<a name="239"></a>    everNotified = nil
<a name="240"></a>
<a name="241"></a>    /* daemon entrypoint */
<a name="242"></a>    checkNotification()
<a name="243"></a>    {
<a name="244"></a>        /* 
<a name="245"></a>         *   if the score has changed since the last time we checked,
<a name="246"></a>         *   possibly generate a notification 
<a name="247"></a>         */
<a name="248"></a>        if (libScore.totalScore != lastScore)
<a name="249"></a>        {
<a name="250"></a>            /* only show a message if we're allowed to */
<a name="251"></a>            if (libScore.scoreNotify.isOn)
<a name="252"></a>            {
<a name="253"></a>                local delta;
<a name="254"></a>            
<a name="255"></a>                /* calculate the change since the last notification */
<a name="256"></a>                delta = libScore.totalScore - lastScore;
<a name="257"></a>                
<a name="258"></a>                /* 
<a name="259"></a>                 *   generate the first or non-first notification, as
<a name="260"></a>                 *   appropriate 
<a name="261"></a>                 */
<a name="262"></a>                if (everNotified)
<a name="263"></a>                    scoreChange(delta);                    
<a name="264"></a>                else
<a name="265"></a>                    firstScoreChange(delta);
<a name="266"></a>            
<a name="267"></a>                /* 
<a name="268"></a>                 *   note that we've ever generated a score change
<a name="269"></a>                 *   notification, so that we don't generate the more
<a name="270"></a>                 *   verbose first-time message on subsequent
<a name="271"></a>                 *   notifications 
<a name="272"></a>                 */
<a name="273"></a>                everNotified = true;
<a name="274"></a>            }
<a name="275"></a>
<a name="276"></a>            /* 
<a name="277"></a>             *   Remember the current score, so that we don't generate
<a name="278"></a>             *   another notification until the score has changed again.
<a name="279"></a>             *   Note that we note the new score even if we aren't
<a name="280"></a>             *   displaying a message this time, because we don't want to
<a name="281"></a>             *   generate a message upon re-enabling notifications.  
<a name="282"></a>             */
<a name="283"></a>            lastScore = libScore.totalScore;
<a name="284"></a>        }
<a name="285"></a>        
<a name="286"></a>        
<a name="287"></a>    }
<a name="288"></a>    
<a name="289"></a>    /* score change - first notification */
<a name="290"></a>    firstScoreChange(delta)
<a name="291"></a>    {
<a name="292"></a>        scoreChange(delta);
<a name="293"></a>        DMsg(first score change, '&lt;.p&gt;&lt;.parser&gt;If you&lt;/sq&gt;d prefer not to be notified about score
<a name="294"></a>            changes in the future, type NOTIFY OFF.&lt;./parser&gt;');
<a name="295"></a>    }
<a name="296"></a>
<a name="297"></a>    /* score change - notification other than the first time */
<a name="298"></a>    scoreChange(delta)
<a name="299"></a>    {
<a name="300"></a>        "&lt;.p&gt;&lt;.notification&gt;&lt;&lt;
<a name="301"></a>        basicScoreChange(delta)&gt;&gt;&lt;./notification&gt; ";
<a name="302"></a>    }
<a name="303"></a>
<a name="304"></a>    /*
<a name="305"></a>     *   basic score change notification message - this is an internal
<a name="306"></a>     *   service routine for scoreChange and firstScoreChange 
<a name="307"></a>     */
<a name="308"></a>    basicScoreChange(delta)
<a name="309"></a>    {
<a name="310"></a>        cquoteOutputFilter.deactivate();
<a name="311"></a>        
<a name="312"></a>        DMsg(basic score change,         
<a name="313"></a>             '''Your &lt;&lt;aHref('full score', 'score', 
<a name="314"></a>                            'Show full score')&gt;&gt;
<a name="315"></a>        has just &lt;&lt;delta &gt; 0 ? 'in' : 'de'&gt;&gt;creased by
<a name="316"></a>        &lt;&lt;spellNumber(delta &gt; 0 ? delta : -delta)&gt;&gt;
<a name="317"></a>        point&lt;&lt;delta is in (1, -1) ? '' : 's'&gt;&gt;.''');
<a name="318"></a>        
<a name="319"></a>        cquoteOutputFilter.activate();
<a name="320"></a>    }
<a name="321"></a>
<a name="322"></a>    
<a name="323"></a>;
<a name="324"></a>
<a name="325"></a>/* 
<a name="326"></a> *   Add points to the total score.  This is a convenience function that
<a name="327"></a> *   simply calls libScore.addToScore_().
<a name="328"></a> */
<a name="329"></a>addToScore(points, desc)
<a name="330"></a>{
<a name="331"></a>    /* simply call the libScore method to handle it */
<a name="332"></a>    libScore.addToScore_(points, desc);
<a name="333"></a>}
<a name="334"></a>
<a name="335"></a>/*
<a name="336"></a> *   The main game score object.  
<a name="337"></a> */
<a name="338"></a>libScore: PreinitObject
<a name="339"></a>    /*
<a name="340"></a>     *   Add to the score.  'points' is the number of points to add to the
<a name="341"></a>     *   score, and 'desc' is a string describing the reason the points
<a name="342"></a>     *   are being awarded, or an Achievement object describing the points.
<a name="343"></a>     *   
<a name="344"></a>     *   We keep a list of each unique achievement.  If 'desc' is already
<a name="345"></a>     *   in this list, we'll simply add the given number of points to the
<a name="346"></a>     *   existing entry for the same description.
<a name="347"></a>     *   
<a name="348"></a>     *   Note that, if 'desc' is an Achievement object, it will match a
<a name="349"></a>     *   previous item only if it's exactly the same Achievement instance.
<a name="350"></a>     */
<a name="351"></a>    addToScore_(points, desc)
<a name="352"></a>    {
<a name="353"></a>        local idx;
<a name="354"></a>        
<a name="355"></a>        /* 
<a name="356"></a>         *   if the description is a string, encapsulate it in a
<a name="357"></a>         *   SimpleAchievement object 
<a name="358"></a>         */
<a name="359"></a>        if (dataType(desc) == TypeSString)
<a name="360"></a>        {
<a name="361"></a>            local newDesc;
<a name="362"></a>            
<a name="363"></a>            /* 
<a name="364"></a>             *   look for an existing SimpleAchievement in our list with
<a name="365"></a>             *   the same descriptive text - if we find one, reuse it,
<a name="366"></a>             *   since this is another instance of the same group of
<a name="367"></a>             *   achievements and thus can be combined into the same
<a name="368"></a>             *   achievement object 
<a name="369"></a>             */
<a name="370"></a>            newDesc = fullScoreList.valWhich(
<a name="371"></a>                { x: x.ofKind(SimpleAchievement) &amp;&amp; x.desc_ == desc });
<a name="372"></a>
<a name="373"></a>            /* 
<a name="374"></a>             *   if we didn't find it, create a new simple achievement to
<a name="375"></a>             *   wrap the descriptive text 
<a name="376"></a>             */
<a name="377"></a>            if (newDesc == nil)
<a name="378"></a>                newDesc = new SimpleAchievement(desc);
<a name="379"></a>
<a name="380"></a>            /* 
<a name="381"></a>             *   for the rest of our processing, use the wrapper simple
<a name="382"></a>             *   achievement object instead of the original text string 
<a name="383"></a>             */
<a name="384"></a>            desc = newDesc;
<a name="385"></a>        }
<a name="386"></a>
<a name="387"></a>        /* increase the use count for the achievement */
<a name="388"></a>        desc.scoreCount++;
<a name="389"></a>        
<a name="390"></a>        /* add the points to the total */
<a name="391"></a>        totalScore += points;
<a name="392"></a>        
<a name="393"></a>        /* try to find a match in our list of past achievements */
<a name="394"></a>        idx = fullScoreList.indexOf(desc);
<a name="395"></a>        
<a name="396"></a>        /* if we didn't find it, add it to the list */
<a name="397"></a>        if (idx == nil)
<a name="398"></a>        {
<a name="399"></a>            fullScoreList.append(desc);
<a name="400"></a>            desc.listOrder = ++Achievement.lastListOrder;
<a name="401"></a>        }
<a name="402"></a>
<a name="403"></a>        /* 
<a name="404"></a>         *   combine the points awarded this time into the total for this
<a name="405"></a>         *   achievement 
<a name="406"></a>         */
<a name="407"></a>        desc.totalPoints += points;
<a name="408"></a>    }
<a name="409"></a>
<a name="410"></a>    /*
<a name="411"></a>     *   Explicitly run the score notification daemon. 
<a name="412"></a>     */
<a name="413"></a>    runScoreNotifier()
<a name="414"></a>    {
<a name="415"></a>        /* explicitly run the notification */
<a name="416"></a>        scoreNotifier.checkNotification();
<a name="417"></a>    }
<a name="418"></a>
<a name="419"></a>    /*
<a name="420"></a>     *   Show the simple score 
<a name="421"></a>     */
<a name="422"></a>    showScore()
<a name="423"></a>    {
<a name="424"></a>        /* 
<a name="425"></a>         *   Show the basic score statistics.  Use the appropriate form of
<a name="426"></a>         *   the message, depending on whether or not there's a maximum
<a name="427"></a>         *   score value. 
<a name="428"></a>         */
<a name="429"></a>        if (gameMain.maxScore != nil)                
<a name="430"></a>            showScoreMessage(totalScore, gameMain.maxScore,
<a name="431"></a>                                          libGlobal.totalTurns);
<a name="432"></a>        else
<a name="433"></a>            showScoreNoMaxMessage(totalScore, libGlobal.totalTurns);
<a name="434"></a>
<a name="435"></a>        /* show the score ranking */
<a name="436"></a>        showScoreRank(totalScore);
<a name="437"></a>                
<a name="438"></a>
<a name="439"></a>    }
<a name="440"></a>
<a name="441"></a>    /* show the basic score message */
<a name="442"></a>    showScoreMessage(points, maxPoints, turns)
<a name="443"></a>    {
<a name="444"></a>        DMsg(show score, 'In {1} turn&lt;&lt;turns == 1 ? '' : 's'&gt;&gt; you have scored 
<a name="445"></a>            {2} of a total {3} point&lt;&lt;maxPoints == 1 ? '' : 's'&gt;&gt;. ',
<a name="446"></a>        turns, points, maxPoints);
<a name="447"></a>    }
<a name="448"></a>    
<a name="449"></a>    
<a name="450"></a>    /* show the basic score message with no maximum */
<a name="451"></a>    showScoreNoMaxMessage(points, turns)
<a name="452"></a>    {
<a name="453"></a>        DMsg(show score no max, 'In {1} turn&lt;&lt;turns == 1 ? '' : 's'&gt;&gt; you have
<a name="454"></a>            scored {2} point&lt;&lt;points == 1 ? '' : 's'&gt;&gt;. ', turns, points);
<a name="455"></a>        
<a name="456"></a>    }
<a name="457"></a>    
<a name="458"></a>    
<a name="459"></a>    /* 
<a name="460"></a>     *   show the score rank message 
<a name="461"></a>     */
<a name="462"></a>    showScoreRank(points)
<a name="463"></a>    {
<a name="464"></a>        local idx;
<a name="465"></a>        local tab = gameMain.scoreRankTable;
<a name="466"></a>        
<a name="467"></a>        /* if there's no rank table, skip the ranking */
<a name="468"></a>        if (tab == nil)
<a name="469"></a>            return;
<a name="470"></a>        
<a name="471"></a>        /*
<a name="472"></a>         *   find the last item for which our score is at least the
<a name="473"></a>         *   minimum - the table is in ascending order of minimum score,
<a name="474"></a>         *   so we want the last item for which our score is sufficient 
<a name="475"></a>         */
<a name="476"></a>        idx = tab.lastIndexWhich({x: points &gt;= x[1]});
<a name="477"></a>    
<a name="478"></a>        /* if we didn't find an item, use the first by default */
<a name="479"></a>        if (idx == nil)
<a name="480"></a>            idx = 1;
<a name="481"></a>    
<a name="482"></a>        /* show the description from the item we found */
<a name="483"></a>        showScoreRankMessage(tab[idx][2]);
<a name="484"></a>    }
<a name="485"></a>
<a name="486"></a>     /* show the full message for a given score rank string */
<a name="487"></a>    showScoreRankMessage(msg) 
<a name="488"></a>    { 
<a name="489"></a>        DMsg(show score rank, 'This makes you {1}. ', msg ); 
<a name="490"></a>    }
<a name="491"></a>    
<a name="492"></a>    
<a name="493"></a>    /*
<a name="494"></a>     *   Display the full score.  'explicit' is true if the player asked
<a name="495"></a>     *   for the full score explicitly, as with a FULL SCORE command; if
<a name="496"></a>     *   we're showing the full score automatically in the course of some
<a name="497"></a>     *   other action, 'explicit' should be nil.  
<a name="498"></a>     */
<a name="499"></a>    showFullScore()
<a name="500"></a>    {
<a name="501"></a>        /* show the basic score statistics */
<a name="502"></a>        showScore();
<a name="503"></a>        
<a name="504"></a>        /* list the achievements in 'tall' mode */
<a name="505"></a>        fullScoreLister.show(fullScoreList.toList(), 0);
<a name="506"></a>    }
<a name="507"></a>
<a name="508"></a>    /*
<a name="509"></a>     *   Vector for the full score achievement list.  This is a list of
<a name="510"></a>     *   all of the Achievement objects awarded for accomplishments so
<a name="511"></a>     *   far.  
<a name="512"></a>     */
<a name="513"></a>    fullScoreList = static new Vector(32)
<a name="514"></a>
<a name="515"></a>    /* the total number of points scored so far */
<a name="516"></a>    totalScore = 0
<a name="517"></a>
<a name="518"></a>    /* 
<a name="519"></a>     *   current score notification status - if on, we'll show a message at
<a name="520"></a>     *   the end of each turn where the score changes, otherwise we won't
<a name="521"></a>     *   mention anything 
<a name="522"></a>     */
<a name="523"></a>    scoreNotify = scoreNotifySettingsItem
<a name="524"></a>
<a name="525"></a>    /*
<a name="526"></a>     *   Compute the sum of the maximum point values of the Achievement
<a name="527"></a>     *   objects in the game.  Point values are optional in Achievement
<a name="528"></a>     *   objects; if there are no Achievement objects with non-nil point
<a name="529"></a>     *   values, this will simply return nil.  
<a name="530"></a>     */
<a name="531"></a>    calcMaxScore()
<a name="532"></a>    {
<a name="533"></a>        local sum;
<a name="534"></a>        local found;
<a name="535"></a>
<a name="536"></a>        /* start with a running total of zero */
<a name="537"></a>        sum = 0;
<a name="538"></a>
<a name="539"></a>        /* we haven't found any non-nil point values yet */
<a name="540"></a>        found = nil;
<a name="541"></a>
<a name="542"></a>        /*
<a name="543"></a>         *   Run through all of the Achievement objects to see if we can
<a name="544"></a>         *   derive a maximum score for the game. 
<a name="545"></a>         */
<a name="546"></a>        forEachInstance(Achievement, function(obj) {
<a name="547"></a>            local m;
<a name="548"></a>            
<a name="549"></a>            /*
<a name="550"></a>             *   If this object has a non-nil maxPoints value, add it to
<a name="551"></a>             *   the running total. 
<a name="552"></a>             */
<a name="553"></a>            if ((m = obj.maxPoints) != nil)
<a name="554"></a>            {
<a name="555"></a>                /* add this one to the sum */
<a name="556"></a>                sum += m;
<a name="557"></a>
<a name="558"></a>                /* note that we found one with a non-nil point value */
<a name="559"></a>                found = true;
<a name="560"></a>            }
<a name="561"></a>        });
<a name="562"></a>
<a name="563"></a>        /*
<a name="564"></a>         *   If we found any Achievements with point values, return the sum
<a name="565"></a>         *   of those point values; otherwise, return nil. 
<a name="566"></a>         */
<a name="567"></a>        return (found ? sum : nil);
<a name="568"></a>    }
<a name="569"></a>
<a name="570"></a>    /* execute pre-initialization */
<a name="571"></a>    execute()
<a name="572"></a>    {
<a name="573"></a>        /* register as the global score handler */
<a name="574"></a>        libGlobal.scoreObj = self;
<a name="575"></a>    }
<a name="576"></a>;
<a name="577"></a>
<a name="578"></a>/* settings item for score notification mode */
<a name="579"></a>scoreNotifySettingsItem: object 
<a name="580"></a>    /* the "factory setting" for NOTIFY is ON */
<a name="581"></a>    isOn = true
<a name="582"></a>
<a name="583"></a>    /* our configuration file variable ID */
<a name="584"></a>    settingID = 'adv3.notify'
<a name="585"></a>
<a name="586"></a>    /* show our description */
<a name="587"></a>    settingDesc() 
<a name="588"></a>    { 
<a name="589"></a>        DMsg(short notify status, 'NOTIFY &lt;&lt;isOn ? 'ON' : 'OFF'&gt;&gt;');
<a name="590"></a>    }    
<a name="591"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 08/12/2025 from adv3Lite version 2.2.2</div>
</body>
</html>

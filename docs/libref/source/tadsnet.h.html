<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>tadsnet.h</title></head><body>
<table class=ban><tr><td><h1>tadsnet.h</h1><td align=right><a href="../file/tadsnet.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 1999, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3
<a name="8"></a> *   
<a name="9"></a> *   This header defines the tads-net intrinsic function set.
<a name="10"></a> *   
<a name="11"></a> *   The tads-net function set provides network input/output.  In particular,
<a name="12"></a> *   this implements an HTTP server that can be used to implement a
<a name="13"></a> *   browser-based user interface.  The network layer could also be used for
<a name="14"></a> *   other purposes, such as implementing a multi-user game server.
<a name="15"></a> *   
<a name="16"></a> *   The first step in setting up a network server is to create a suitable
<a name="17"></a> *   server object, such as an HTTPServer.  The server opens a network port
<a name="18"></a> *   on the local machine and waits for incoming connection requests from
<a name="19"></a> *   clients, such as from Web browsers on remote machines.  When a client
<a name="20"></a> *   connects to the server's port, the server creates a separate thread to
<a name="21"></a> *   handle the new connection, then goes back to listening for additional
<a name="22"></a> *   connections.  The connection thread handles network communications with
<a name="23"></a> *   the client; when the client sends a request to the server, the thread
<a name="24"></a> *   posts an event message to the network message queue.
<a name="25"></a> *   
<a name="26"></a> *   The next step for the program, then, is simply to go into a loop reading
<a name="27"></a> *   and handling incoming network messages.  Once the server is set up, the
<a name="28"></a> *   program is basically driven by the network client.  Call netEvent() to
<a name="29"></a> *   read the next message, then interpret the contents, process the message,
<a name="30"></a> *   and send a reply.  Once that's done, go back to the start of the loop to
<a name="31"></a> *   handle the next request message.  The program continues running until a
<a name="32"></a> *   suitable network event occurs to terminate it, such as the user typing
<a name="33"></a> *   QUIT into the UI.  
<a name="34"></a> */
<a name="35"></a>
<a name="36"></a>
<a name="37"></a>/*
<a name="38"></a> *   tads-net - the TADS Network function set
<a name="39"></a> */
<a name="40"></a>intrinsic 'tads-net/030001'
<a name="41"></a>{
<a name="42"></a>    /*
<a name="43"></a>     *   Connect to the Web UI client.  This connects the Web browser client
<a name="44"></a>     *   to the game's HTTP server.  'server' is the HTTPServer object where
<a name="45"></a>     *   the Web UI is found, and 'path' is the URL path of the game's main
<a name="46"></a>     *   UI start page.  This will tell the client to navigate to the given
<a name="47"></a>     *   start path on the given server.
<a name="48"></a>     *   
<a name="49"></a>     *   Web-based games must call this after starting the HTTP server that
<a name="50"></a>     *   provides the game's Web UI.  This should be called as quickly as
<a name="51"></a>     *   possible after starting up, because clients might time out and miss
<a name="52"></a>     *   the connection data if it takes too long to get this back to them.  
<a name="53"></a>     */
<a name="54"></a>    connectWebUI(server, path);
<a name="55"></a>
<a name="56"></a>    /*
<a name="57"></a>     *   Read an event from the network message queue.  When a listener
<a name="58"></a>     *   receives a connection request from a client, it creates a network
<a name="59"></a>     *   server thread to handle the connection; then when the server thread
<a name="60"></a>     *   receives data from the client, it packages the data into an event
<a name="61"></a>     *   message and places it in the queue.  This function retrieves the
<a name="62"></a>     *   next message from the queue.
<a name="63"></a>     *   
<a name="64"></a>     *   If 'timeout' is omitted or nil, the function waits indefinitely; it
<a name="65"></a>     *   doesn't return until a network event occurs.  If a timeout is given,
<a name="66"></a>     *   it gives the maximum time in milliseconds that the function should
<a name="67"></a>     *   wait for an event; if the timeout expires before any events arrive,
<a name="68"></a>     *   the function returns a timeout event.
<a name="69"></a>     *   
<a name="70"></a>     *   The return value is a NetEvent instance describing the event.  
<a name="71"></a>     */
<a name="72"></a>    getNetEvent(timeout?);
<a name="73"></a>
<a name="74"></a>    /*
<a name="75"></a>     *   Get the local network host name.  This is the name (or a name) that
<a name="76"></a>     *   other computers can use to connect to this computer across the
<a name="77"></a>     *   network.
<a name="78"></a>     *   
<a name="79"></a>     *   Some computers have multiple host names, since a single machine can
<a name="80"></a>     *   have more than one network adapter.  If this is the case, this
<a name="81"></a>     *   function returns the default host name if there is such a concept,
<a name="82"></a>     *   otherwise it just picks one of the names arbitrarily.
<a name="83"></a>     *   
<a name="84"></a>     *   If there's no host name at all, this returns nil.
<a name="85"></a>     *   
<a name="86"></a>     *   The host name returned here isn't usually a "global" name for the
<a name="87"></a>     *   computer, but is a name that the local operating system recognizes
<a name="88"></a>     *   as itself for networking purposes.  In particular, this usually
<a name="89"></a>     *   won't be a full internet "x.y.com" domain name.  This name thus
<a name="90"></a>     *   isn't something you can advertise to arbitrary other machines across
<a name="91"></a>     *   the Internet and expect them to be able to connect.  Instead, this
<a name="92"></a>     *   name is primarily useful for telling the operating system which
<a name="93"></a>     *   network adapter to use when opening a listening port.  For example,
<a name="94"></a>     *   you can use this name in the HTTPServer constructor.  
<a name="95"></a>     */
<a name="96"></a>    getHostName();
<a name="97"></a>
<a name="98"></a>    /*
<a name="99"></a>     *   Get the local host's IP address.  This is the IP address (or an IP
<a name="100"></a>     *   address) that other computers can use to connect to this computer
<a name="101"></a>     *   via the network.  IP addresses are the basic addressing scheme of
<a name="102"></a>     *   the Internet.
<a name="103"></a>     *   
<a name="104"></a>     *   Some computers have multiple IP addresses, since a single machine
<a name="105"></a>     *   can have more than one network adapter.  If this is the case, this
<a name="106"></a>     *   function returns the default IP address if there is one, otherwise
<a name="107"></a>     *   it selects one of the machine's IP addresses arbitrarily.
<a name="108"></a>     *   
<a name="109"></a>     *   If the IP address can't be retrieved (for example, because the
<a name="110"></a>     *   machine has no network adapter installed), this returns nil.
<a name="111"></a>     */
<a name="112"></a>    getLocalIP();
<a name="113"></a>
<a name="114"></a>    /*
<a name="115"></a>     *   Get the URL to the storage server.  When running in Web mode, the
<a name="116"></a>     *   interpreter is generally configured to store files on a separate
<a name="117"></a>     *   "storage server" rather than on the game server.  This function
<a name="118"></a>     *   retrieves the interpreter's configuration data and returns the
<a name="119"></a>     *   storage server URL.
<a name="120"></a>     *   
<a name="121"></a>     *   'resource' is a string giving the resource (page) name on the server
<a name="122"></a>     *   that you wish to access.  This can contain query parameters
<a name="123"></a>     *   (introduced by a "?"  symbol), if desired.  The return value is the
<a name="124"></a>     *   full URL to the requested page on the server.
<a name="125"></a>     */
<a name="126"></a>    getNetStorageURL(resource);
<a name="127"></a>
<a name="128"></a>    /*
<a name="129"></a>     *   Get the host address that the user used to launch the game.  For
<a name="130"></a>     *   standard client/server TADS Web play, this is the network address
<a name="131"></a>     *   that you should specify as the listening address when setting up the
<a name="132"></a>     *   HTTPServer object.
<a name="133"></a>     *   
<a name="134"></a>     *   When we're operating in client/server mode, the interpreter is
<a name="135"></a>     *   launched by an external Web server, in response to an incoming
<a name="136"></a>     *   request from a client.  In order to establish our own connection
<a name="137"></a>     *   with the client, we need to know the address that the client used to
<a name="138"></a>     *   connect to the external Web server in the first place.  The Web
<a name="139"></a>     *   server passes this address to the interpreter as part of the launch
<a name="140"></a>     *   information, and the interpreter makes the address available to the
<a name="141"></a>     *   TADS program here.
<a name="142"></a>     *   
<a name="143"></a>     *   If there's no launch address, this returns nil.  This means that the
<a name="144"></a>     *   user launched the interpreter directly, from the local desktop or
<a name="145"></a>     *   command shell.  In this case, it means that the user wants to run
<a name="146"></a>     *   the game locally, rather than from a remote client machine.  Simply
<a name="147"></a>     *   use "localhost" as the networking binding address in this case.  
<a name="148"></a>     */
<a name="149"></a>    getLaunchHostAddr();
<a name="150"></a>
<a name="151"></a>    /*
<a name="152"></a>     *   Send a network request to a remote server.  This initiates
<a name="153"></a>     *   processing the request and immediately returns; the process of
<a name="154"></a>     *   setting up the network connection to the remote server, sending the
<a name="155"></a>     *   request data, and receiving the reply proceeds asynchronously while
<a name="156"></a>     *   the program continues running.  When the request completes (or fails
<a name="157"></a>     *   due to an error), a NetEvent of type NetEvReply is queued.
<a name="158"></a>     *   
<a name="159"></a>     *   'id' is a user-defined identifier for the request.  This can be any
<a name="160"></a>     *   value, but is typically an object that you create to keep track of
<a name="161"></a>     *   the request and process the reply.  TADS doesn't use this value
<a name="162"></a>     *   itself, but simply hangs onto it while the request is being
<a name="163"></a>     *   processed, and then stores it in the NetEvent object generated when
<a name="164"></a>     *   the request completes.  This lets you relate the reply event back to
<a name="165"></a>     *   the request, so that you know which request it applies to.
<a name="166"></a>     *   
<a name="167"></a>     *   'url' is a string giving the URL of the resource.  This starts with
<a name="168"></a>     *   a protocol name that specifies which protocol to use.  The possible
<a name="169"></a>     *   protocols are:
<a name="170"></a>     *   
<a name="171"></a>     *   - HTTP: the URL has the form 'http://server:port/resource'.  It can
<a name="172"></a>     *   also start with 'https://' for a secure HTTP connection.  The port
<a name="173"></a>     *   number is optional; if omitted, the default port is 80 for regular
<a name="174"></a>     *   HTTP, or 443 for HTTPS.
<a name="175"></a>     *   
<a name="176"></a>     *   Currently, the only protocol supported is HTTP.  An error occurs if
<a name="177"></a>     *   another protocol is specified.
<a name="178"></a>     *   
<a name="179"></a>     *   Additional parameters depend on the protocol.
<a name="180"></a>     *   
<a name="181"></a>     *   HTTP Additional Parameters:
<a name="182"></a>     *   
<a name="183"></a>     *   'verb' - a string giving the HTTP verb for the request (GET, POST,
<a name="184"></a>     *   HEAD, PUT, etc).
<a name="185"></a>     *   
<a name="186"></a>     *   'options' - optional; a bitwise combination of NetReqXXX option
<a name="187"></a>     *   flags specifying special settings.  Omit this argument or pass 0 to
<a name="188"></a>     *   use the default settings.
<a name="189"></a>     *   
<a name="190"></a>     *   'headers' - optional; a string giving any custom headers to include
<a name="191"></a>     *   with the request.  The system automatically generates any required
<a name="192"></a>     *   headers for the type of request, but you can add your own custom
<a name="193"></a>     *   headers with this parameter.  The headers must be specified using
<a name="194"></a>     *   the standard 'name: value' format.  Use '\r\n' to separate multiple
<a name="195"></a>     *   headers.  If you don't need to specify any custom headers, pass nil
<a name="196"></a>     *   or simply omit this argument.
<a name="197"></a>     *   
<a name="198"></a>     *   'body' - optional; a string or ByteArray giving the content body of
<a name="199"></a>     *   the request, if any.  This is suitable for verbs such as PUT and
<a name="200"></a>     *   POST.  For verbs that don't send any content with the request, pass
<a name="201"></a>     *   nil or simply omit the argument.
<a name="202"></a>     *   
<a name="203"></a>     *   'bodyType' - optional; a string giving the MIME type of the content
<a name="204"></a>     *   body.  If this is omitted, a default MIME type is assumed according
<a name="205"></a>     *   to the type of 'body': for a string, "text/plain; charset=utf-8";
<a name="206"></a>     *   for a ByteArray, "appliation/octet-stream".
<a name="207"></a>     *   
<a name="208"></a>     *   This routine has no return value, since the request is processed
<a name="209"></a>     *   asynchronously.  The result can't be determined until the
<a name="210"></a>     *   corresponding NetEvReqReply event occurs, at which point you can
<a name="211"></a>     *   inspect that NetEvent object to find out if the request was
<a name="212"></a>     *   successful, and if so retrieve the reply data.
<a name="213"></a>     */
<a name="214"></a>    sendNetRequest(id, url, ...);
<a name="215"></a>}
<a name="216"></a>
<a name="217"></a>/* ------------------------------------------------------------------------ */
<a name="218"></a>/*
<a name="219"></a> *   sendNetRequest option flags for HTTP requests.
<a name="220"></a> */
<a name="221"></a>
<a name="222"></a>/* 
<a name="223"></a> *   DO NOT follow "redirect" (301) results.  By default (i.e., without this
<a name="224"></a> *   option flag), if the server sends back a 301 HTTP status code
<a name="225"></a> *   ("permanently moved"), we'll automatically follow the link to the new
<a name="226"></a> *   location and return the result from that new request.  This is
<a name="227"></a> *   transparent to the caller; the caller just sees the final result from
<a name="228"></a> *   the final server we're redirected to.  If this flag is specified, we
<a name="229"></a> *   DON'T follow a redirection, but instead simply stop and return the 301
<a name="230"></a> *   result.  The caller can inspect the reply headers to get the redirection
<a name="231"></a> *   link.
<a name="232"></a> */
<a name="233"></a>#define NetReqNoRedirect    0x0001
<a name="234"></a>
<a name="235"></a>
<a name="236"></a>/* ------------------------------------------------------------------------ */
<a name="237"></a>/*
<a name="238"></a> *   Network event types.  This value is used in the evType property of
<a name="239"></a> *   NetEvent objects to indicate the type of the event. 
<a name="240"></a> */
<a name="241"></a>
<a name="242"></a>/* 
<a name="243"></a> *   Request event.  This type of event contains a request from the network
<a name="244"></a> *   client.  For example, for an HTTP client, the event contains an HTTP
<a name="245"></a> *   request, such as a GET.  The request is represented as an object; the
<a name="246"></a> *   class depends on the type of server and request.  
<a name="247"></a> */
<a name="248"></a>#define NetEvRequest     1
<a name="249"></a>
<a name="250"></a>/* 
<a name="251"></a> *   Timeout.  netEvent() returns this type of event when the interval
<a name="252"></a> *   expires before any actual network events occur.  
<a name="253"></a> */
<a name="254"></a>#define NetEvTimeout     2
<a name="255"></a>
<a name="256"></a>/*
<a name="257"></a> *   Debugger interrupt.  netEvent() returns this type of event when the user
<a name="258"></a> *   commands the debugger to interrupt the program and take control.  If the
<a name="259"></a> *   program is waiting for a network event, this causes the netEvent() call
<a name="260"></a> *   to return with this type of event.
<a name="261"></a> *   
<a name="262"></a> *   In a normal event-loop type of program, you can simply ignore this event
<a name="263"></a> *   and loop back for a new event immediately.  The purpose of this event
<a name="264"></a> *   type is to force netEvent() to stop waiting and return to the byte-code
<a name="265"></a> *   caller, so that the debugger can pause execution at a valid byte-code
<a name="266"></a> *   program location.  Once that's accomplished, there's nothing more to do
<a name="267"></a> *   with this event type; simply discard it and get the next event when the
<a name="268"></a> *   user resumes execution.  
<a name="269"></a> */
<a name="270"></a>#define NetEvDebugBreak  3
<a name="271"></a>
<a name="272"></a>/*
<a name="273"></a> *   UI Closed.  This type of event occurs when the user manually closes the
<a name="274"></a> *   Web UI, ONLY in a stand-alone local configuration.  This is the special
<a name="275"></a> *   configuration where the browser UI is integrated into the interpreter
<a name="276"></a> *   application, simulating the traditional TADS interpreter environment
<a name="277"></a> *   with the Web UI, and everything's running on a single machine.  When the
<a name="278"></a> *   user closes the Web UI in this environment, the game should usually just
<a name="279"></a> *   terminate, since the user has effectively dismissed the application.
<a name="280"></a> *   
<a name="281"></a> *   In the true client/server configuration, where the user is running an
<a name="282"></a> *   ordinary Web browser on a separate machine, we have no way of knowing
<a name="283"></a> *   that the user has closed the browser window.  The best we can detect is
<a name="284"></a> *   a dropped network connection, but we can't assume this is due to the
<a name="285"></a> *   window closing, because it could happen for other reasons (such as a
<a name="286"></a> *   temporary network interruption).  In the full client/server
<a name="287"></a> *   configuration, we have to be more subtle in determining that the user
<a name="288"></a> *   intends to quit the application, generally with inactivity timers.  
<a name="289"></a> */
<a name="290"></a>#define NetEvUIClose     4
<a name="291"></a>
<a name="292"></a>/*
<a name="293"></a> *   Network reply.  This type of event occurs when a network request
<a name="294"></a> *   initiated by sendNetRequest() completes, or fails with an error.  The
<a name="295"></a> *   event object contains the status of the request and, if successful, the
<a name="296"></a> *   result information sent back from the server.
<a name="297"></a> */
<a name="298"></a>#define NetEvReply   5
<a name="299"></a>
<a name="300"></a>/*
<a name="301"></a> *   Reply data transfer finished.  This type of event occurs when an
<a name="302"></a> *   asynchronous reply to a request is completed.  An asynchronous HTTP
<a name="303"></a> *   request reply can be sent with HTTPRequest.sendReplyAsync().  The event
<a name="304"></a> *   object contains information on whether or not the reply was successfully
<a name="305"></a> *   sent to the client.  For HTTP transactions, this is largely advisory,
<a name="306"></a> *   since there's no recovery action the server can take when an error
<a name="307"></a> *   occurs sending a reply; there's no provision in HTTP for a server to
<a name="308"></a> *   initiate contact with a client, so it's up to the client to handle it,
<a name="309"></a> *   such as by retrying the request.
<a name="310"></a> */
<a name="311"></a>#define NetEvReplyDone    6
<a name="312"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

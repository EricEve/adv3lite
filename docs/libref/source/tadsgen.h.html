<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>tadsgen.h</title></head><body>
<table class=ban><tr><td><h1>tadsgen.h</h1><td align=right><a href="../file/tadsgen.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 1999, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3
<a name="8"></a> *   
<a name="9"></a> *   This header defines the tads-gen intrinsic function set.  This function
<a name="10"></a> *   set provides some miscellaneous functions, including data conversions,
<a name="11"></a> *   object iteration, regular expressions, and state persistence operations.
<a name="12"></a> */
<a name="13"></a>
<a name="14"></a>
<a name="15"></a>/*
<a name="16"></a> *   The tads-gen function set.  This set contains basic data manipulation
<a name="17"></a> *   and miscellaneous utility functions.
<a name="18"></a> */
<a name="19"></a>intrinsic 'tads-gen/030008'
<a name="20"></a>{
<a name="21"></a>    /*
<a name="22"></a>     *   Get the type of the given value.  This returns a TypeXxx value.
<a name="23"></a>     */
<a name="24"></a>    dataType(val);
<a name="25"></a>
<a name="26"></a>    /*
<a name="27"></a>     *   Get the given parameter to the current function.  'idx' is 1 for the
<a name="28"></a>     *   first argument in left-to-right order, 2 for the second, and so on. 
<a name="29"></a>     */
<a name="30"></a>    getArg(idx);
<a name="31"></a>
<a name="32"></a>    /*
<a name="33"></a>     *   Get the first object in memory.  If 'cls' is provided, we return the
<a name="34"></a>     *   first object of the given class; otherwise we return the first
<a name="35"></a>     *   object of any kind.  'flags' is an optional bitwise combination of
<a name="36"></a>     *   ObjXxx values, specifying whether classes, instances, or both are
<a name="37"></a>     *   desired.  If this isn't specified, ObjAll is assumed.  This is used
<a name="38"></a>     *   in conjunction with nextObj() to iterate over all objects in memory,
<a name="39"></a>     *   or all objects of a given class.
<a name="40"></a>     *   
<a name="41"></a>     *   Note that firstObj-nextObj loops can retrieve objects that aren't
<a name="42"></a>     *   otherwise reachable, because unreachable objects are only removed
<a name="43"></a>     *   from memory when the garbage collector runs, which happens
<a name="44"></a>     *   intermittently.  If you want to ensure that any currently
<a name="45"></a>     *   unreachable objects are removed from memory just before a
<a name="46"></a>     *   firstObj-nextObj loop, you can do so by calling t3RunGC().
<a name="47"></a>     */
<a name="48"></a>    firstObj(cls?, flags?);
<a name="49"></a>
<a name="50"></a>    /*
<a name="51"></a>     *   Get the next object in memory after the given object, optionally of
<a name="52"></a>     *   the given class and optionally limiting to instances, classes, or
<a name="53"></a>     *   both.  This is used to continue an iteration started with
<a name="54"></a>     *   firstObj().  
<a name="55"></a>     */
<a name="56"></a>    nextObj(obj, cls?, flags?);
<a name="57"></a>
<a name="58"></a>    /*
<a name="59"></a>     *   Random number generator (RNG) initialization.  This selects and
<a name="60"></a>     *   initializes the random number generator algorithm used by rand().
<a name="61"></a>     *   TADS provides several different RNG algorithms; each RNG has
<a name="62"></a>     *   different properties, so some applications might have reasons to
<a name="63"></a>     *   prefer a particular algorithm.  For general purposes, any of them
<a name="64"></a>     *   should produce good results.
<a name="65"></a>     *   
<a name="66"></a>     *   The interpreter automatically makes a call to randomize() (the
<a name="67"></a>     *   no-arguments version) when it starts up, unless the user specifies
<a name="68"></a>     *   the "-norand" option when launching the interpreter.  For most
<a name="69"></a>     *   programs, this means that you'll never have to make your own call to
<a name="70"></a>     *   randomize() - you can just call rand() when you need random numbers.
<a name="71"></a>     *   
<a name="72"></a>     *   This function performs several tasks, depending on how you invoke
<a name="73"></a>     *   it:
<a name="74"></a>     *   
<a name="75"></a>     *.    randomize() - selects the default RNG algorithm (ISAAC), and seeds
<a name="76"></a>     *.          the RNG with truly random data from the operating system.
<a name="77"></a>     *   
<a name="78"></a>     *.    randomize(nil) - retrieves the current state of the RNG.  Returns
<a name="79"></a>     *.          a list: [id, state], where 'id' is the ID of the currently
<a name="80"></a>     *.          selected RNG algorithm, and 'state' is a value containing
<a name="81"></a>     *.          its internal state, which can be used in a later call to
<a name="82"></a>     *.          randomize([id, state]) to restore the RNG state.  The 'state'
<a name="83"></a>     *.          value is opaque, meaning that it's not meant to be used
<a name="84"></a>     *.          directly; the only thing you should do with it it save it
<a name="85"></a>     *.          for later if you should want to restore this state later.
<a name="86"></a>     *   
<a name="87"></a>     *.    randomize([id, state]) - if you pass in a list that obtained from
<a name="88"></a>     *.          an earlier call to randomize(nil), the RNG will be returned
<a name="89"></a>     *.          to its state at the time of the randomize(nil) call.  This
<a name="90"></a>     *.          selects the same RNG algorithm that was in effect then and
<a name="91"></a>     *.          restores the internal state of the generator.  After calling
<a name="92"></a>     *.          this, a series of calls to rand() will return the same
<a name="93"></a>     *.          sequence of numbers that were returned after the call to
<a name="94"></a>     *.          randomize(nil).
<a name="95"></a>     *   
<a name="96"></a>     *.    randomize(id) - selects the RNG algorithm identified by 'id'
<a name="97"></a>     *.          (an RNG_Xxx value).  This doesn't change the state of
<a name="98"></a>     *.          the generator; it simply selects the algorithm.
<a name="99"></a>     *   
<a name="100"></a>     *.    randomize(id, nil) - selects the RNG algorithm identified by
<a name="101"></a>     *.          'id' (an RNG_Xxx value), and seeds the generator with
<a name="102"></a>     *.          truly random data obtained from the operating system.
<a name="103"></a>     *   
<a name="104"></a>     *.    randomize(id, val) - selects the RNG algorithm identified by
<a name="105"></a>     *.          'id' (an RNG_Xxx value), and seeds the generator with
<a name="106"></a>     *.          the initial value 'val'.  This can be either an integer
<a name="107"></a>     *.          value or a string; the preferred format varies by
<a name="108"></a>     *.          algorithm, but they'll all accept either format.  After
<a name="109"></a>     *.          you set a given seed value, rand() will return a sequence
<a name="110"></a>     *.          of numbers that's repeatable every time you set the same
<a name="111"></a>     *.          seed value.  This can be useful for things like testing,
<a name="112"></a>     *.          where you want a sequence of numbers that's statistically
<a name="113"></a>     *.          random, but which can be reproduced on demand.
<a name="114"></a>     *   
<a name="115"></a>     *   Most programs that require random numbers want a truly unpredictable
<a name="116"></a>     *   series of numbers - that is, numbers that have a statistically
<a name="117"></a>     *   random distribution, with no discernible patterns, and which will be
<a name="118"></a>     *   different every time the program is run.  There are two separate
<a name="119"></a>     *   parts to this proposition, and they're handled by separate
<a name="120"></a>     *   functions.  rand() fulfills the first part: it uses a mathematical
<a name="121"></a>     *   formula to generate a series of numbers that are statistically
<a name="122"></a>     *   distributed in a random fashion (for example, so that "1" occurs as
<a name="123"></a>     *   often as "10" or any other number, any given sequence of 2, 3, or
<a name="124"></a>     *   more numbers is equally likely, and so on: mathematicians have many
<a name="125"></a>     *   formal tests that RNGs must satisfy to be considered random.)
<a name="126"></a>     *   randomize() fulfills the second part, which is making sure that the
<a name="127"></a>     *   sequence of numbers is different every time you run the program.
<a name="128"></a>     *   The reason this second part is important is that rand() is by its
<a name="129"></a>     *   nature deterministic: it's defined entirely in terms of a formula,
<a name="130"></a>     *   so given the same initial conditions, it'll always crank out the
<a name="131"></a>     *   same sequence of numbers.  The trick is to randomize its initial
<a name="132"></a>     *   conditions - and what makes it tricky is that we can't just turn to
<a name="133"></a>     *   rand(), since it's the thing we're trying to randomize!
<a name="134"></a>     *   
<a name="135"></a>     *   This is where the "seed" values come in.  randomize() and
<a name="136"></a>     *   randomize(id, nil) ask the operating system for truly random data to
<a name="137"></a>     *   use for the initial conditions.  The degree of entropy in this OS
<a name="138"></a>     *   seed data varies by system; some systems have better entropy sources
<a name="139"></a>     *   than others.  But whatever the source, the seed data should be
<a name="140"></a>     *   different each time you run the program.  randomize() feeds this
<a name="141"></a>     *   seed data into the RNG to set its initial conditions, so each time
<a name="142"></a>     *   you run, rand() will be starting from a different initial state.
<a name="143"></a>     *   This makes for a different series of numbers from rand() on each
<a name="144"></a>     *   run.
<a name="145"></a>     *   
<a name="146"></a>     *   Note that it's not necessary (or desirable) to call randomize()
<a name="147"></a>     *   every time you want a random number.  Once you seed the RNG, rand()
<a name="148"></a>     *   is all you need to call.  It can be slow to gather the true random
<a name="149"></a>     *   data that randomize() uses, since this sometimes requires
<a name="150"></a>     *   interacting with hardware devices or scanning large amounts of
<a name="151"></a>     *   system data.  rand() is quite fast, since it just calculates a
<a name="152"></a>     *   number using a formula.  Depending on the system, rand() might also
<a name="153"></a>     *   be more reliable at producing high volumes of statistically random
<a name="154"></a>     *   data than the OS sources.  The operating system sources of true
<a name="155"></a>     *   entropy don't always change quickly, so it's better to use them
<a name="156"></a>     *   infrequently, such as just once at the start of program execution,
<a name="157"></a>     *   than to use them as a routine source of random numbers.
<a name="158"></a>     *   
<a name="159"></a>     *   The fixed seed values, with randomize(id, val), do something a
<a name="160"></a>     *   little different.  Rather than making the RNG produce different
<a name="161"></a>     *   sequences on each run, a fixed seed makes rand() generate the same
<a name="162"></a>     *   series of numbers every time.  The numbers will still be
<a name="163"></a>     *   statistically random, but each time you run the program, you'll get
<a name="164"></a>     *   the same seaquence.  (The sequence is a function of the seed value.
<a name="165"></a>     *   You'll get a different sequence for each different seed value.)
<a name="166"></a>     *   
<a name="167"></a>     *   Why would you want a fixed series of rand() results?  One big reason
<a name="168"></a>     *   is testing.  One popular way to test software is regression testing,
<a name="169"></a>     *   where you run the program and compare its output to a reference
<a name="170"></a>     *   version that you know is correct.  If there are no differences, you
<a name="171"></a>     *   know that changes you've made to the program since haven't broken
<a name="172"></a>     *   anything in the test script.  Randomization interferes with this
<a name="173"></a>     *   kind of testing, because it makes the output different on each run -
<a name="174"></a>     *   it's useless to do a simple mechanical comparison of the new and old
<a name="175"></a>     *   output because they'll always differ.  Fixed seeds to the rescue.
<a name="176"></a>     *   Using a fixed seed, you can still exercise the program's random
<a name="177"></a>     *   behavior, but the sequence of random behavior will repeat on every
<a name="178"></a>     *   run, so you run those regression comparisons after all.  The really
<a name="179"></a>     *   great thing is that you don't have to make big changes to the
<a name="180"></a>     *   program if you want to switch between test mode and real randomness
<a name="181"></a>     *   - all you have to do is change the one call to randomize().
<a name="182"></a>     */
<a name="183"></a>    randomize(...);
<a name="184"></a>
<a name="185"></a>    /*
<a name="186"></a>     *   Select a random number or a random value.  This uses the current
<a name="187"></a>     *   random number algorithm as selected via randomize().
<a name="188"></a>     *   
<a name="189"></a>     *   If no arguments are supplied, the result is a random integer
<a name="190"></a>     *   distributed evenly over the full range of the 32-bit integer type.
<a name="191"></a>     *   The result can be positive or negative.
<a name="192"></a>     *   
<a name="193"></a>     *   If exactly one argument is supplied, the result depends on the type
<a name="194"></a>     *   of the argument:
<a name="195"></a>     *   
<a name="196"></a>     *   - Integer: the function returns an integer from 0 to one less than
<a name="197"></a>     *   the argument value.  For example, rand(10) returns a number from 0
<a name="198"></a>     *   to 9 inclusive.
<a name="199"></a>     *   
<a name="200"></a>     *   - List: the function randomly selects one of the values from the
<a name="201"></a>     *   list and returns it.
<a name="202"></a>     *   
<a name="203"></a>     *   - String: the function generates a random string by replacing each
<a name="204"></a>     *   character of the argument string with a randomly chosen character,
<a name="205"></a>     *   selected from a specific range specified by the argument character.
<a name="206"></a>     *   For example, each 'a' in the input string is replaced by a random
<a name="207"></a>     *   lower-case letter from a to z, each 'A' is replaced by a capital
<a name="208"></a>     *   letter, and each 'd' is replaced by a random digit 0 to 9.  See the
<a name="209"></a>     *   System Manual for the full list of the character codes.
<a name="210"></a>     *   
<a name="211"></a>     *   If more than one argument is supplied, the function randomly selects
<a name="212"></a>     *   one of the arguments and returns it.  Note that this is an ordinary
<a name="213"></a>     *   function call, so all of the arguments are evaluated, triggering any
<a name="214"></a>     *   side effects of those evaluations.
<a name="215"></a>     *   
<a name="216"></a>     *   In all cases, the random numbers are uniformly distributed, meaning
<a name="217"></a>     *   that each possible return value has equal probability.  
<a name="218"></a>     */
<a name="219"></a>    rand(...);
<a name="220"></a>
<a name="221"></a>    /*
<a name="222"></a>     *   Convert the given value to a string representation.  'val' can be an
<a name="223"></a>     *   integer, in which case it's converted to a string representation in
<a name="224"></a>     *   the numeric base given by 'radix' (which can be any value from 2 to
<a name="225"></a>     *   36), or base 10 (decimal) if 'radix' is omitted; nil or true, in
<a name="226"></a>     *   which case the string 'nil' or 'true' is returned; a string, which
<a name="227"></a>     *   is returned unchanged; or a BigNumber, in which case the number is
<a name="228"></a>     *   converted to a string representation in the given radix; a list or
<a name="229"></a>     *   vector, in which case the individual elements are converted
<a name="230"></a>     *   recursively, then the results concatenated together into a string
<a name="231"></a>     *   with commas separating elements; or any of the built-in object types
<a name="232"></a>     *   with default string conversions (ByteArray, StringBuffer, FileName,
<a name="233"></a>     *   Date, TimeZone, FileName, etc).
<a name="234"></a>     *   
<a name="235"></a>     *   Note that when working with BigNumber values, you might prefer to
<a name="236"></a>     *   use BigNumber.formatString(), as that gives you more control over
<a name="237"></a>     *   the formatting style.
<a name="238"></a>     *   
<a name="239"></a>     *   'radix' is only meaningful with numeric values (integers and
<a name="240"></a>     *   BigNumbers).  For BigNumbers, only whole integer values can be
<a name="241"></a>     *   displayed in a non-decimal radix; if the number has a fractional
<a name="242"></a>     *   part, the radix will be ignored and the number will be shown in
<a name="243"></a>     *   decimal.
<a name="244"></a>     *   
<a name="245"></a>     *   'isSigned' indicates whether or not the value should be treated as
<a name="246"></a>     *   "signed", meaning that negative values are represented with a "-"
<a name="247"></a>     *   sign followed by the absolute value.  If 'isSigned' is nil, a
<a name="248"></a>     *   negative value won't be converted to its absolute value before being
<a name="249"></a>     *   displayed, but will instead be re-interpreted within its type system
<a name="250"></a>     *   as an unsigned value.  For regular integers, this means that the
<a name="251"></a>     *   result depends on the native hardware storage format for negative
<a name="252"></a>     *   integers.  Most modern hardware uses two's complement notation,
<a name="253"></a>     *   which represents -1 as 0xFFFFFFFF, -2 as 0xFFFFFFFE, etc.  Most
<a name="254"></a>     *   types other than integer don't have distinct signed and unsigned
<a name="255"></a>     *   interpretations, so 'isSigned' isn't meaningful with most other
<a name="256"></a>     *   types.  With BigNumber in particular, the only effect is to omit the
<a name="257"></a>     *   "-" sign for negative values.  
<a name="258"></a>     */
<a name="259"></a>    toString(val, radix?, isSigned?);
<a name="260"></a>
<a name="261"></a>    /*
<a name="262"></a>     *   Convert the given value to an integer.
<a name="263"></a>     *   
<a name="264"></a>     *   If 'val' is a string, the function parses the string's contents as
<a name="265"></a>     *   an integer in the numeric base given by 'radix, which can be any
<a name="266"></a>     *   integer from 2 to 36.  If 'radix' is omitted or nil, the default is
<a name="267"></a>     *   base 10 (decimal).  The value is returned as an integer.  If the
<a name="268"></a>     *   number represented by the string is too large for a 32-bit integer,
<a name="269"></a>     *   a numeric overflow error occurs.
<a name="270"></a>     *   
<a name="271"></a>     *   If 'val' is true, or the string 'true', the return value is 1.  If
<a name="272"></a>     *   'val' is nil, or the string 'nil', the return value is 0.  Leading
<a name="273"></a>     *   and trailing spaces are ignored for these strings.
<a name="274"></a>     *   
<a name="275"></a>     *   If 'val' is a BigNumber value, the value is rounded to the whole
<a name="276"></a>     *   number, and returned as an integer value.  A numeric overflow error
<a name="277"></a>     *   occurs if the number is out of range for a 32-bit integer.  (If you
<a name="278"></a>     *   want to round a BigNumber to the nearest integer and get the result
<a name="279"></a>     *   as another BigNumber value, use the getWhole() method of the
<a name="280"></a>     *   BigNumber.)
<a name="281"></a>     *   
<a name="282"></a>     *   See also toNumber(), which can also parse floating point values and
<a name="283"></a>     *   whole numbers too large for the ordinary integer type.  
<a name="284"></a>     */
<a name="285"></a>    toInteger(val, radix?);
<a name="286"></a>
<a name="287"></a>    /* 
<a name="288"></a>     *   Get the current local time.
<a name="289"></a>     *   
<a name="290"></a>     *   If timeType is GetTimeDateAndTime (or is omitted), this returns the
<a name="291"></a>     *   calendar date and wall-clock time, as a list: [year, month,
<a name="292"></a>     *   dayOfMonth, dayOfWeek, dayOfYear, hour, minute, second, timer].
<a name="293"></a>     *   Year is the year AD (for example, 2006); month is the current month,
<a name="294"></a>     *   from 1 (January) to 12 (December); dayOfMonth is the calendar day of
<a name="295"></a>     *   the month, from 1 to 31; dayOfWeek is the day of the week, from 1
<a name="296"></a>     *   (Sunday) to 7 (Saturday); dayOfYear is the current day of the year,
<a name="297"></a>     *   from 1 (January 1) to 366 (December 31 in a leap year); hour is the
<a name="298"></a>     *   hour on a 24-hour clock, ranging from 0 (midnight) to 23 (11pm);
<a name="299"></a>     *   minute is the minute of the hour, from 0 to 59; second is the second
<a name="300"></a>     *   of the minute, from 0 to 59; and timer is the number of seconds
<a name="301"></a>     *   elapsed since the "Epoch," defined as midnight, January 1, 1970,
<a name="302"></a>     *   midnight UTC.  (This is the Epoch that Unix-like systems use, so it
<a name="303"></a>     *   appears frequently in computer timekeeping systems.)  See the Date
<a name="304"></a>     *   class for more comprehensive date/time handling.
<a name="305"></a>     *   
<a name="306"></a>     *   If timeType is GetTimeTicks, this return the number of milliseconds
<a name="307"></a>     *   since an arbitrary starting time.  The first call to get this
<a name="308"></a>     *   information sets the starting time, so it will return zero;
<a name="309"></a>     *   subsequent calls will return the amount of time elapsed from that
<a name="310"></a>     *   starting time.  Note that because a signed 32-bit integer can only
<a name="311"></a>     *   hold values up to about 2 billion, the maximum elapsed time that
<a name="312"></a>     *   this value can represent is about 24.8 days; so, if your program
<a name="313"></a>     *   runs continuously for more than this, the timer value will roll
<a name="314"></a>     *   around to zero at each 24.8 day multiple.  So, it's possible for
<a name="315"></a>     *   this function to return a smaller value than on a previous
<a name="316"></a>     *   invocation, if the two invocations straddle a 24.8-day boundary.  
<a name="317"></a>     */
<a name="318"></a>    getTime(timeType?);
<a name="319"></a>
<a name="320"></a>    /*
<a name="321"></a>     *   Match a string to a regular expression pattern.  'pat' can be either
<a name="322"></a>     *   a string giving the regular expression, or can be a RexPattern
<a name="323"></a>     *   object.  'str' is the string to match, and 'index' is the starting
<a name="324"></a>     *   character index (the first character is at index 1) at which to
<a name="325"></a>     *   start matching.  Returns the length in characters of the match, or
<a name="326"></a>     *   nil if the string doesn't match the pattern.  (Note that a return
<a name="327"></a>     *   value of zero doesn't indicate failure - rather, it indicates a
<a name="328"></a>     *   successful match of the pattern to zero characters.  This is
<a name="329"></a>     *   possible for a pattern with a zero-or-more closure, such as 'x*' or
<a name="330"></a>     *   'x?'.)  
<a name="331"></a>     */
<a name="332"></a>    rexMatch(pat, str, index?);
<a name="333"></a>
<a name="334"></a>    /*
<a name="335"></a>     *   Search the given string for the given regular expression pattern.
<a name="336"></a>     *   'pat' is a string giving the regular expression to find, or a
<a name="337"></a>     *   RexPattern object.  'str' is the string to search, and 'index' is
<a name="338"></a>     *   the optional starting index (the first character is at index 1;
<a name="339"></a>     *   negative indices are from the end of the string, so -1 is the last
<a name="340"></a>     *   character, -2 is the second to last, and so on).  If a match to the
<a name="341"></a>     *   pattern isn't found, returns nil.  If a match is found, the return
<a name="342"></a>     *   value is a list: [index, length, string], where index is the
<a name="343"></a>     *   starting character index of the match, length is the length in
<a name="344"></a>     *   characters of the match, and string is the text of the match.  
<a name="345"></a>     */
<a name="346"></a>    rexSearch(pat, str, index?);
<a name="347"></a>
<a name="348"></a>    /*
<a name="349"></a>     *   Get the given regular expression group.  This can be called after a
<a name="350"></a>     *   successful rexMatch() or rexSearch() call to retrieve information on
<a name="351"></a>     *   the substring that matched the given "group" within the regular
<a name="352"></a>     *   expression.  A group is a parenthesized sub-pattern within the
<a name="353"></a>     *   regular expression; groups are numbered left to right by the open
<a name="354"></a>     *   parenthesis, starting at group 1.  If there is no such group in the
<a name="355"></a>     *   last regular expression searched or matched, or the group wasn't
<a name="356"></a>     *   part of the match (for example, because it was part of an
<a name="357"></a>     *   alternation that wasn't matched), the return value is nil.  If the
<a name="358"></a>     *   group is valid and was part of the match, the return value is a
<a name="359"></a>     *   list: [index, length, string], where index is the character index
<a name="360"></a>     *   within the matched or searched string of the start of the group
<a name="361"></a>     *   match, length is the character length of the group match, and string
<a name="362"></a>     *   is the text of the group match.  
<a name="363"></a>     */
<a name="364"></a>    rexGroup(groupNum);
<a name="365"></a>
<a name="366"></a>    /*
<a name="367"></a>     *   Search for the given regular expression pattern (which can be given
<a name="368"></a>     *   as a regular expression string or as a RexPattern object) within the
<a name="369"></a>     *   given string, and replace one or more occurrences of the pattern
<a name="370"></a>     *   with the given replacement text.
<a name="371"></a>     *   
<a name="372"></a>     *   The search pattern can also be given as a *list* of search patterns.
<a name="373"></a>     *   In this case, we'll search for each of the patterns and replace each
<a name="374"></a>     *   one with the corresponding replacement text.  If the replacement is
<a name="375"></a>     *   itself given a list in this case, each element of the pattern list
<a name="376"></a>     *   is replaced by the corresponding element of the replacement list.
<a name="377"></a>     *   If there are more patterns than replacements, the extra patterns are
<a name="378"></a>     *   replaced by empty strings; any extra replacements are simply
<a name="379"></a>     *   ignored.  If the replacement is a single value rather than a list,
<a name="380"></a>     *   each pattern is replaced by that single replacement value.
<a name="381"></a>     *   
<a name="382"></a>     *   'flags' is a combination of the ReplaceXxx bit flags, using '|'.  If
<a name="383"></a>     *   the flags include ReplaceAll, all occurrences of the pattern are
<a name="384"></a>     *   replaced; otherwise only the first occurrence is replaced.
<a name="385"></a>     *   
<a name="386"></a>     *   ReplaceOnce and ReplaceAll are mutually exclusive; they mean,
<a name="387"></a>     *   respectively, that only the first occurrence of the match should be
<a name="388"></a>     *   replaced, or that every occurrence should be replaced.  ReplaceOnce
<a name="389"></a>     *   and ReplaceAll are ignored if a 'limit' value is specified (this is
<a name="390"></a>     *   true even if 'limit' is nil, which means that all occurrences are
<a name="391"></a>     *   replaced).
<a name="392"></a>     *   
<a name="393"></a>     *   If ReplaceIgnoreCase is included, the capitalization of the match
<a name="394"></a>     *   pattern is ignored, so letters in the pattern match both their
<a name="395"></a>     *   upper- and lower-case equivalents.  Otherwise the case will be
<a name="396"></a>     *   matched exactly. If ReplaceFollowCase AND ReplaceIgnoreCase are
<a name="397"></a>     *   included, lower-case letters in the replacement text are capitalized
<a name="398"></a>     *   as needed to follow the capitalization pattern of the actual text
<a name="399"></a>     *   matched: if all the letters in the match are lower-case, the
<a name="400"></a>     *   replacement is lower case; if all are upper-case, the replacement is
<a name="401"></a>     *   changed to all upper-case; if there's a mix of cases in the match,
<a name="402"></a>     *   the first letter of the replacement is capitalized and the rest are
<a name="403"></a>     *   left in lower-case.
<a name="404"></a>     *   
<a name="405"></a>     *   The ReplaceSerial flag controls how the search proceeds when
<a name="406"></a>     *   multiple patterns are specified.  By default, we search for each one
<a name="407"></a>     *   of the patterns, and replace the leftmost match.  If ReplaceOnce is
<a name="408"></a>     *   specified, we're done; otherwise we continue by searching again for
<a name="409"></a>     *   all of the patterns, this time in the remainder of the string (after
<a name="410"></a>     *   that first replacement), and again we replace the leftmost match.
<a name="411"></a>     *   This proceeds until we can't find any more matches for any of the
<a name="412"></a>     *   patterns.  If ReplaceSerial is included in the flags, we start by
<a name="413"></a>     *   searching only for the first pattern, replacing one or all
<a name="414"></a>     *   occurrences depending on the ReplaceOnce or ReplaceAll flag.  Next,
<a name="415"></a>     *   if ReplaceAll is specified OR we didn't find any matches for the
<a name="416"></a>     *   first pattern, we start over with the result and search for the
<a name="417"></a>     *   second pattern, replacing one or all occurrences of it.  We repeat
<a name="418"></a>     *   this for each pattern.
<a name="419"></a>     *   
<a name="420"></a>     *   If the flags are omitted entirely, the default is ReplaceAll (which
<a name="421"></a>     *   means replace all occurrences, exact case matches only, parallel
<a name="422"></a>     *   searching).
<a name="423"></a>     *   
<a name="424"></a>     *   'index', if provided, is the starting character index of the search;
<a name="425"></a>     *   instances of the pattern before this index will be ignored.  Returns
<a name="426"></a>     *   the result string with all of the desired replacements.  When an
<a name="427"></a>     *   instance of the pattern is found and then replaced, the replacement
<a name="428"></a>     *   string is not rescanned for further occurrences of the text, so
<a name="429"></a>     *   there's no danger of infinite recursion; instead, scanning proceeds
<a name="430"></a>     *   from the next character after the replacement text.
<a name="431"></a>     *   
<a name="432"></a>     *   'limit', if specified, is an integer indicating the maximum number
<a name="433"></a>     *   of matches to replace, or nil to replace all matches.  If the limit
<a name="434"></a>     *   is reached before all matches have been replaced, no further
<a name="435"></a>     *   replacements are performed.  If this parameter is specified, it
<a name="436"></a>     *   overrides any ReplaceOnce or ReplaceAll flag.
<a name="437"></a>     *   
<a name="438"></a>     *   The replacement text can use "%n" sequences to substitute group
<a name="439"></a>     *   matches from the input into the output.  %1 is replaced by the match
<a name="440"></a>     *   to the first group, %2 the second, and so on.  %* is replaced by the
<a name="441"></a>     *   entire matched input.  (Because of the special meaning of "%", you
<a name="442"></a>     *   must use "%%" to include a percent sign in the replacement text.)  
<a name="443"></a>     */
<a name="444"></a>    rexReplace(pat, str, replacement, flags?, index?, limit?);
<a name="445"></a>
<a name="446"></a>    /*
<a name="447"></a>     *   Create an UNDO savepoint.  This adds a marker to the VM's internal
<a name="448"></a>     *   UNDO log, establishing a point in time for a future UNDO operation.
<a name="449"></a>     */
<a name="450"></a>    savepoint();
<a name="451"></a>
<a name="452"></a>    /*
<a name="453"></a>     *   UNDO to the most recent savepoint.  This uses the VM's internal UNDO
<a name="454"></a>     *   log to undo all changes to persistent objects, up to the most recent
<a name="455"></a>     *   savepoint.  Returns true if the operation succeeded, nil if not.  A
<a name="456"></a>     *   nil return means that there's no further UNDO information recorded,
<a name="457"></a>     *   which could be because the program has already undone everything
<a name="458"></a>     *   back to the start of the session, or because the UNDO log was
<a name="459"></a>     *   truncated due to memory size such that no savepoints are recorded.
<a name="460"></a>     *   (The system automatically limits the UNDO log's total memory
<a name="461"></a>     *   consumption, according to local system parameters.  This function
<a name="462"></a>     *   requires at least one savepoint to be present, because otherwise it
<a name="463"></a>     *   could create an inconsistent state.)  
<a name="464"></a>     */
<a name="465"></a>    undo();
<a name="466"></a>
<a name="467"></a>    /*
<a name="468"></a>     *   Save the current system state into the given file.  This uses the
<a name="469"></a>     *   VM's internal state-save mechanism to store the current state of all
<a name="470"></a>     *   persistent objects in the given file.  Any existing file is
<a name="471"></a>     *   overwritten.
<a name="472"></a>     *   
<a name="473"></a>     *   'metatab' is an optional LookupTable containing string key/value
<a name="474"></a>     *   pairs to be saved with the file as descriptive metadata.  The
<a name="475"></a>     *   interpreter and other tools can display this information to the user
<a name="476"></a>     *   when browsing a collection of saved game files, to help the user
<a name="477"></a>     *   remember the details of each saved position.  It's up to the game to
<a name="478"></a>     *   determine what to include; the list can include any information
<a name="479"></a>     *   relevant to the game that would be helpful when reviewing saved
<a name="480"></a>     *   position files, such as the room name, score, turn count, chapter
<a name="481"></a>     *   name, etc.  
<a name="482"></a>     */
<a name="483"></a>    saveGame(filename, metatab?);
<a name="484"></a>
<a name="485"></a>    /*
<a name="486"></a>     *   Restore a previously saved state file.  This loads the states of all
<a name="487"></a>     *   persistent objects stored in the given file.  The file must have
<a name="488"></a>     *   been saved by the current version of the current running program; if
<a name="489"></a>     *   not, an exception is thrown.  
<a name="490"></a>     */
<a name="491"></a>    restoreGame(filename);
<a name="492"></a>
<a name="493"></a>    /*
<a name="494"></a>     *   Restart the program from the beginning.  This resets all persistent
<a name="495"></a>     *   objects to their initial state, as they were when the program was
<a name="496"></a>     *   first started.  
<a name="497"></a>     */
<a name="498"></a>    restartGame();
<a name="499"></a>
<a name="500"></a>    /*
<a name="501"></a>     *   Get the maximum of the given arguments.  The values must be
<a name="502"></a>     *   comparable with the ordinary "&lt;" and "&gt;" operators.  Note that
<a name="503"></a>     *   because this is an ordinary function call, all of the arguments are
<a name="504"></a>     *   evaluated (which means any side effects of these evaluations will be
<a name="505"></a>     *   triggered).  
<a name="506"></a>     */
<a name="507"></a>    max(val1, ...);
<a name="508"></a>
<a name="509"></a>    /*
<a name="510"></a>     *   Get the minimum of the given arguments.  The values must be
<a name="511"></a>     *   comparable with the ordinary "&lt;" and "&gt;" operators.  Note that
<a name="512"></a>     *   because this is an ordinary function call, all of the arguments are
<a name="513"></a>     *   evaluated (which means any side effects of these evaluations will be
<a name="514"></a>     *   triggered).  
<a name="515"></a>     */
<a name="516"></a>    min(val1, ...);
<a name="517"></a>
<a name="518"></a>    /*
<a name="519"></a>     *   Create a string by repeating the given value the given number of
<a name="520"></a>     *   times.  If the repeat count isn't specified, the default is 1; a
<a name="521"></a>     *   repeat count less than zero throws an error.  'val' can be a string,
<a name="522"></a>     *   in which case the string is simply repeated the given number of
<a name="523"></a>     *   times; an integer, in which case the given Unicode character is
<a name="524"></a>     *   repeated; or a list of integers, in which case the given Unicode
<a name="525"></a>     *   characters are repeated, in the order of the list.  The list format
<a name="526"></a>     *   can be used to create a string from a list of Unicode characters
<a name="527"></a>     *   that you've been manipulating as a character array, which is
<a name="528"></a>     *   sometimes a more convenient or efficient way to do certain types of
<a name="529"></a>     *   string handling than using the actual string type.  
<a name="530"></a>     */
<a name="531"></a>    makeString(val, repeatCount?);
<a name="532"></a>
<a name="533"></a>    /*
<a name="534"></a>     *   Get a description of the parameters to the given function.  'func'
<a name="535"></a>     *   is a function pointer.  This function returns a list: [minArgs,
<a name="536"></a>     *   optionalArgs, isVarargs], where minArgs is the minimum number of
<a name="537"></a>     *   arguments required by the function, optionalArgs is the additional
<a name="538"></a>     *   number of arguments that can be optionally provided to the function,
<a name="539"></a>     *   and isVarargs is true if the function takes any number of additional
<a name="540"></a>     *   ("varying") arguments, nil if not.  
<a name="541"></a>     */
<a name="542"></a>    getFuncParams(func);
<a name="543"></a>
<a name="544"></a>    /*
<a name="545"></a>     *   Convert the given value to a number.  This is similar to
<a name="546"></a>     *   toInteger(), but can parse strings containing floating point numbers
<a name="547"></a>     *   and whole numbers too large for ordinary integers.
<a name="548"></a>     *   
<a name="549"></a>     *   If 'val' is an integer or BigNumber value, the return value is
<a name="550"></a>     *   simply 'val'.
<a name="551"></a>     *   
<a name="552"></a>     *   If 'val' is a string, the function parses the string's contents as a
<a name="553"></a>     *   number in the given 'radix', which can be any integer from 2 to 36.
<a name="554"></a>     *   If 'radix' is omitted, the default is 10 for decimal.  If the radix
<a name="555"></a>     *   is decimal, and the number contains a decimal point (a period, '.')
<a name="556"></a>     *   or an exponent (which consists of the letter 'e' or 'E', an optional
<a name="557"></a>     *   '+' or '-' sign, and one or more digits), the value is parsed as a
<a name="558"></a>     *   floating point number, and a BigNumber value is returned.  For any
<a name="559"></a>     *   other radix, decimal points and exponents are considered non-number
<a name="560"></a>     *   characters.  For an integral value, the result will be an integer if
<a name="561"></a>     *   the number is within the range that fits in an integer, otherwise
<a name="562"></a>     *   the result is a BigNumber.  The routine will simply stop parsing at
<a name="563"></a>     *   the first non-number character it encounters, so no error will occur
<a name="564"></a>     *   if the string contains text following the number.  If the text
<a name="565"></a>     *   doesn't contain any number characters at all, the result is zero.
<a name="566"></a>     *   
<a name="567"></a>     *   If val is true or the string 'true', return 1; if nil or the string
<a name="568"></a>     *   'nil', returns 0.  Leading and trailing spaces are ignored in the
<a name="569"></a>     *   string versions of these values.  
<a name="570"></a>     */
<a name="571"></a>    toNumber(val, radix?);
<a name="572"></a>
<a name="573"></a>    /*
<a name="574"></a>     *   Format values into a string.  This is similar to the traditional C
<a name="575"></a>     *   language "printf" family of functions: it takes a "format string"
<a name="576"></a>     *   containing a mix of plain text and substitution parameters, and a
<a name="577"></a>     *   set of values to plug in to the substitution parameters, and returns
<a name="578"></a>     *   a new string containing the formatted result.
<a name="579"></a>     *   
<a name="580"></a>     *   'format' is the format string.  Most characters of the format string
<a name="581"></a>     *   are simply copied verbatim to the result.  However, each '%' in the
<a name="582"></a>     *   format string begins a substitution parameter; the '%' is followed
<a name="583"></a>     *   by one or more optional qualifiers, then by a type code letter.  The
<a name="584"></a>     *   corresponding value from the argument list is formatted into a
<a name="585"></a>     *   string according to the type code, and then replaces the entire '%'
<a name="586"></a>     *   sequence in the result string.  By default, the first '%' parameter
<a name="587"></a>     *   corresponds to the first additional argument after 'format', the
<a name="588"></a>     *   second '%' corresponds to the second additional argument, and so on.
<a name="589"></a>     *   You can override the default argument position of a '%' using the
<a name="590"></a>     *   '$' qualifier - see below.
<a name="591"></a>     *   
<a name="592"></a>     *   The arguments following 'format' are the values to be substituted
<a name="593"></a>     *   for the '%' parameters in the format string.
<a name="594"></a>     *   
<a name="595"></a>     *   The return value is a string containing the formatted result.
<a name="596"></a>     *   
<a name="597"></a>     *   See the System Manual for the list of '%' codes.  
<a name="598"></a>     */
<a name="599"></a>    sprintf(format, ...);
<a name="600"></a>
<a name="601"></a>    /*
<a name="602"></a>     *   Create a list by repeating the given value the given number of
<a name="603"></a>     *   times.  If the repeat count isn't specified, the default is 1; a
<a name="604"></a>     *   repeat count less than zero throws an error.  'val' can be any
<a name="605"></a>     *   value; it's simply repeated in each element of the list.
<a name="606"></a>     */
<a name="607"></a>    makeList(val, repeatCount?);
<a name="608"></a>
<a name="609"></a>    /*
<a name="610"></a>     *   Get the absolute value of a number.  The argument can be an integer
<a name="611"></a>     *   or a BigNumber; the return value is the absolute value of the
<a name="612"></a>     *   argument, and has the same type as the argument.  (The absolute
<a name="613"></a>     *   value of a positive number X (or zero) is X; the absolute value of a
<a name="614"></a>     *   negative number X is -X.) 
<a name="615"></a>     */
<a name="616"></a>    abs(num);
<a name="617"></a>
<a name="618"></a>    /*
<a name="619"></a>     *   Get the sign of a number.  The argument can be an integer or a
<a name="620"></a>     *   BigNumber.  The return value is an integer: 1 if the argument is
<a name="621"></a>     *   positive, 0 if the argument is zero, -1 if the argument is negative.
<a name="622"></a>     */
<a name="623"></a>    sgn(num);
<a name="624"></a>
<a name="625"></a>    /*
<a name="626"></a>     *   Concatenate the arguments together into a single string.  The
<a name="627"></a>     *   arguments can be strings or any types that can be automatically
<a name="628"></a>     *   converted to string for the regular "+" operator; non-strings are
<a name="629"></a>     *   first converted to strings using the same rules that "+" uses when
<a name="630"></a>     *   combining a string with a non-string.  If there are no arguments,
<a name="631"></a>     *   the result is an empty string.
<a name="632"></a>     *   
<a name="633"></a>     *   This function is essentially the same as concatenating a series of
<a name="634"></a>     *   values with the "+" operator, but it's more efficient with three or
<a name="635"></a>     *   more values, since the "+" operator has to be applied successively
<a name="636"></a>     *   in pairs; that creates and copies an extra intermediate result
<a name="637"></a>     *   string at each step.  This function only creates one result string
<a name="638"></a>     *   and only has to copy each input string once.
<a name="639"></a>     */
<a name="640"></a>    concat(...);
<a name="641"></a>
<a name="642"></a>    /*
<a name="643"></a>     *   Search backwards in the given string for the given regular
<a name="644"></a>     *   expression pattern.  'pat' is a string giving the regular expression
<a name="645"></a>     *   to find, or a RexPattern object.  'str' is the string to search, and
<a name="646"></a>     *   'index' is the optional starting index (the first character is at
<a name="647"></a>     *   index 1; negative indices are from the end of the string, so -1 is
<a name="648"></a>     *   the last character, -2 is the second to last, and so on; 0 means the
<a name="649"></a>     *   position just after the last character of the string).  If 'index'
<a name="650"></a>     *   is omitted, the default is to search the entire string from the end,
<a name="651"></a>     *   which is equivalent to passing 0 or str.length()+1 for 'index'.
<a name="652"></a>     *   
<a name="653"></a>     *   If a match is found, the return value is a list: [index, length,
<a name="654"></a>     *   string], where index is the starting character index of the match,
<a name="655"></a>     *   length is the length in characters of the match, and string is the
<a name="656"></a>     *   text of the match.
<a name="657"></a>     *   
<a name="658"></a>     *   This does the same work as rexSearch(), but searches the string
<a name="659"></a>     *   backwards, from the end to the start.  The match must end before the
<a name="660"></a>     *   starting index, which allows for repeated searches: simply pass the
<a name="661"></a>     *   match index from the previous search as the 'index' value for the
<a name="662"></a>     *   next search to find the next earlier match that doesn't overlap the
<a name="663"></a>     *   previous match.
<a name="664"></a>     *   
<a name="665"></a>     *   The meanings of the &lt;FirstBegin&gt; and &lt;FirstEnd&gt; flags for a reverse
<a name="666"></a>     *   search are essentially the mirror image of their meanings in a
<a name="667"></a>     *   regular forward search.  This is easiest to understand by thinking
<a name="668"></a>     *   about the flags in the abstract.  &lt;FirstBegin&gt; means that the
<a name="669"></a>     *   winning match is the one whose "near" endpoint is closest to the
<a name="670"></a>     *   starting index; &lt;FirstEnd&gt; means that the winner is the match whose
<a name="671"></a>     *   "far" endpoint is closest to the starting index.  The near endpoint
<a name="672"></a>     *   in a forward search is the start of the match, whereas it's the end
<a name="673"></a>     *   of the match in a reverse search.  Similarly, the far endpoint is
<a name="674"></a>     *   the end of the match in a forward search and the start of the match
<a name="675"></a>     *   in a reverse search.  So in a reverse search, &lt;FirstBegin&gt; means
<a name="676"></a>     *   that the winner is the match whose ending index is highest, and
<a name="677"></a>     *   &lt;FirstEnd&gt; means that the winner is the one whose starting index is
<a name="678"></a>     *   highest.
<a name="679"></a>     */
<a name="680"></a>    rexSearchLast(pat, str, index?);
<a name="681"></a>}
<a name="682"></a>
<a name="683"></a>/*
<a name="684"></a> *   flags for firstObj() and nextObj()
<a name="685"></a> */
<a name="686"></a>#define ObjInstances  0x0001
<a name="687"></a>#define ObjClasses    0x0002
<a name="688"></a>#define ObjAll        (ObjInstances | ObjClasses)
<a name="689"></a>
<a name="690"></a>/*
<a name="691"></a> *   rexReplace() flags 
<a name="692"></a> */
<a name="693"></a>#define ReplaceAll         0x0001
<a name="694"></a>#define ReplaceIgnoreCase  0x0002
<a name="695"></a>#define ReplaceFollowCase  0x0004
<a name="696"></a>#define ReplaceSerial      0x0008
<a name="697"></a>#define ReplaceOnce        0x0010
<a name="698"></a>
<a name="699"></a>/*
<a name="700"></a> *   getTime() flags 
<a name="701"></a> */
<a name="702"></a>#define GetTimeDateAndTime  1
<a name="703"></a>#define GetTimeTicks        2
<a name="704"></a>
<a name="705"></a>/*
<a name="706"></a> *   Random number generator IDs for randomize().
<a name="707"></a> */
<a name="708"></a>
<a name="709"></a>/*
<a name="710"></a> *   
<a name="711"></a> *   RNG_ISAAC - ISAAC is the default generator.  It's designed for both
<a name="712"></a> *   cryptographic application and more mainstream uses.  Crypto applications
<a name="713"></a> *   generally have more stringent requirements for an RNG than ordinary
<a name="714"></a> *   applications.  ISAAC does well with the usual statistical tests for RNGs
<a name="715"></a> *   and is reasonably fast.
<a name="716"></a> *   
<a name="717"></a> *   ISAAC's preferred format for a fixed seed is a string value.
<a name="718"></a> */
<a name="719"></a>#define RNG_ISAAC    1
<a name="720"></a>
<a name="721"></a>
<a name="722"></a>/*   
<a name="723"></a> *   RNG_LCG - LCG stands for Linear Congruential Generator, which generates
<a name="724"></a> *   numbers using a simple linear formula.  This is the old standby of
<a name="725"></a> *   computer RNGs; it's the sort that comes standard with C compilers.
<a name="726"></a> *   These generators have been extensively studied and have reasonably good
<a name="727"></a> *   statistical properties and a number of known weaknesses.  The TADS LCG
<a name="728"></a> *   uses the method described in Knuth, The Art of Computer Programming,
<a name="729"></a> *   volume 2, p170.
<a name="730"></a> *   
<a name="731"></a> *   The LCG's preferred format for a fixed seed is an integer value.
<a name="732"></a> */
<a name="733"></a>#define RNG_LCG      2
<a name="734"></a>
<a name="735"></a>/*
<a name="736"></a> *   RNG_MT19937 - Mersenne Twister MT19937 algorithm.  This is a widely used
<a name="737"></a> *   RNG algorithm that's become especially popular for scientific
<a name="738"></a> *   simulations.  It's relatively new, dating from 1997, and was designed to
<a name="739"></a> *   remedy most of the known shortcomings of linear congruential generators
<a name="740"></a> *   and other earlier RNGs.  It's fast and does well on standard statistical
<a name="741"></a> *   tests.
<a name="742"></a> *   
<a name="743"></a> *   MT's preferred format for a fixed seed is a string value.
<a name="744"></a> */
<a name="745"></a>#define RNG_MT19937  3
<a name="746"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>parser.t</title></head><body>
<table class=ban><tr><td><h1>parser.t</h1><td align=right><a href="../file/parser.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/* ------------------------------------------------------------------------ */
<a name="5"></a>/*
<a name="6"></a> *   Temporary scaffolding for the game world.  This gives us information
<a name="7"></a> *   on scope, pronoun antecedents, and other information the parser needs
<a name="8"></a> *   from the game world.  
<a name="9"></a> */
<a name="10"></a>World: PreinitObject
<a name="11"></a>    /*
<a name="12"></a>     *   Get the list of objects in scope 
<a name="13"></a>     */
<a name="14"></a>    scope()
<a name="15"></a>    {
<a name="16"></a>        local s = scope_;
<a name="17"></a>
<a name="18"></a>        if (s == nil)
<a name="19"></a>            scope_ = s = Q.scopeList(gPlayerChar);
<a name="20"></a>
<a name="21"></a>        return s;
<a name="22"></a>    }
<a name="23"></a>
<a name="24"></a>    /* cached scope list */
<a name="25"></a>    scope_ = nil
<a name="26"></a>
<a name="27"></a>    /* 
<a name="28"></a>     *   A list of all Mentionables in the game, useful for building scope lists
<a name="29"></a>     *   for resolving Topics.
<a name="30"></a>     */
<a name="31"></a>    universalScope = nil
<a name="32"></a>    
<a name="33"></a>    buildUniversalScope()
<a name="34"></a>    {
<a name="35"></a>        local vec = new Vector(100);
<a name="36"></a>        forEachInstance(Mentionable, {o: vec.append(o) });
<a name="37"></a>        universalScope = vec.toList;
<a name="38"></a>    }
<a name="39"></a>    
<a name="40"></a>    execute()
<a name="41"></a>    {
<a name="42"></a>        buildUniversalScope();
<a name="43"></a>    }
<a name="44"></a>    
<a name="45"></a>    
<a name="46"></a>;
<a name="47"></a>
<a name="48"></a>
<a name="49"></a>/* ------------------------------------------------------------------------ */
<a name="50"></a>/*
<a name="51"></a> *   Parser is the class that implements the main parsing procedure, namely
<a name="52"></a> *   taking a line of text from the player, figuring out what it means, and
<a name="53"></a> *   executing it.
<a name="54"></a> *   
<a name="55"></a> *   The conventional IF parsing loop simply consists of reading a line of
<a name="56"></a> *   text from the player, calling Parser.parse() on the string, and
<a name="57"></a> *   repeating.
<a name="58"></a> *   
<a name="59"></a> *   In most cases you'll just need a single Parser instance.  The Parser
<a name="60"></a> *   object keeps track of unfinished commands, such as when we need to ask
<a name="61"></a> *   for disambiguation help or for a missing object.  If for some reason
<a name="62"></a> *   you want to keep multiple sets of this kind of state (reading input
<a name="63"></a> *   from more than one player, for example), you can create as many Parser
<a name="64"></a> *   instances as needed.  
<a name="65"></a> */
<a name="66"></a>class Parser: object
<a name="67"></a>    /*
<a name="68"></a>     *   Auto-Look: Should we treat an empty command line (i.e., the user
<a name="69"></a>     *   just presses Return) as a LOOK AROUND command?
<a name="70"></a>     *   
<a name="71"></a>     *   The traditional handling since the Infocom era has always been to
<a name="72"></a>     *   treat an empty command line as a parsing error, and display an
<a name="73"></a>     *   error message along the lines of "I beg your pardon?".  Given that
<a name="74"></a>     *   an empty command line has no conflicting meaning, though, we
<a name="75"></a>     *   *could* assign it a meaning.
<a name="76"></a>     *   
<a name="77"></a>     *   But what meaning should that be?  A blank line is the simplest
<a name="78"></a>     *   possible command for a player to enter, so it would make sense to
<a name="79"></a>     *   define it as some very commonly used command.  It's also fairly
<a name="80"></a>     *   easy to enter a blank line accidentally (which is partly why the
<a name="81"></a>     *   traditional reply is an error message), so the command should be
<a name="82"></a>     *   benign - it shouldn't be a problem to enter it unintentionally.
<a name="83"></a>     *   It can't be anything with parallel verbs, like NORTH, since then
<a name="84"></a>     *   there'd be no good reason to pick NORTH instead of, say, SOUTH.
<a name="85"></a>     *   Finally, it has to be intransitive, since it obviously won't
<a name="86"></a>     *   involve an object name.  The obvious candidates that fit all of
<a name="87"></a>     *   these criteria are LOOK and INVENTORY.  LOOK is probably the more
<a name="88"></a>     *   useful and the more frequently used of the two, so it's the one we
<a name="89"></a>     *   choose by default.
<a name="90"></a>     *   
<a name="91"></a>     *   If this property is set to true, we'll perform a LOOK AROUND
<a name="92"></a>     *   command when the player enters a blank command line.  If nil,
<a name="93"></a>     *   we'll show an error message.  
<a name="94"></a>     */
<a name="95"></a>    autoLook = true
<a name="96"></a>
<a name="97"></a>    /*
<a name="98"></a>     *   Default Actions: Should we treat a command line that consists entirely
<a name="99"></a>     *   of a single noun phrase to be a "Default Action" on the named object?
<a name="100"></a>     *   The precise meaning of the default action varies by object.  For most
<a name="101"></a>     *   objects, it's EXAMINE.  For locations, it's GO TO.
<a name="102"></a>     *
<a name="103"></a>     *   We make the default value nil since setting it to true can result in
<a name="104"></a>     *   some rather odd parser behaviour.
<a name="105"></a>     */
<a name="106"></a>    
<a name="107"></a>    defaultActions = true
<a name="108"></a>
<a name="109"></a>    /*
<a name="110"></a>     *   Should we attempt automatic spelling correction?  If this is true, whenever a command
<a name="111"></a>     *   fails, we'll check for a word that we don't recognize; if we find one, we'll try applying
<a name="112"></a>     *   spelling correction to see if we can come up with a working command.
<a name="113"></a>     *
<a name="114"></a>     *   Our spelling correction algorithm is designed to be quite conservative.  In particular, we
<a name="115"></a>     *   generally limit candidates for "correct" words to the vocabulary for objects that are
<a name="116"></a>     *   actually in scope, which avoids revealing the existence of objects that haven't been seen
<a name="117"></a>     *   yet; and we only apply a correction when it yields a command that parses and resolves
<a name="118"></a>     *   correctly.  When we can't correct a command and get something resolvable, we don't even
<a name="119"></a>     *   mention that we tried.  This avoids the bizarre, random guesses at "corrections" that often
<a name="120"></a>     *   show up in other applications, and more importantly avoids giving away information that the
<a name="121"></a>     *   player shouldn't know yet.
<a name="122"></a>     *
<a name="123"></a>     *   We set this to true by default, in an attempt to reduce the player's typing workload by
<a name="124"></a>     *   automatically correcting simple typos when possible.  If for some reason the spelling
<a name="125"></a>     *   corrector is problematic in a particular game, you can disable it by setting this property
<a name="126"></a>     *   to nil.
<a name="127"></a>     *
<a name="128"></a>     *   As an experiment, change the default value to be nil when we're in a conversation and true
<a name="129"></a>     *   otherwise, since over-zealous spelling corrections can be particularly troublesome in a
<a name="130"></a>     *   conversational context.
<a name="131"></a>     */
<a name="132"></a>    autoSpell = (gPlayerChar.currentInterlocutor == nil)
<a name="133"></a>
<a name="134"></a>    /*
<a name="135"></a>     *   Maximum spelling correction time, in milliseconds.  The spelling
<a name="136"></a>     *   correction process is iterative, and each iteration involves a new
<a name="137"></a>     *   parsing attempt.  On a fast machine this doesn't tend to be
<a name="138"></a>     *   noticeable, but it's conceivable that a pathological case could
<a name="139"></a>     *   involve a large number of attempts that could be noticeably slow
<a name="140"></a>     *   on an older machine.  To avoid stalling the game while we
<a name="141"></a>     *   overanalyze the spelling possibilities, we set an upper bound to
<a name="142"></a>     *   the actual elapsed time for spelling correction.  Each time we
<a name="143"></a>     *   consider a new correction candidate, we'll check the elapsed time,
<a name="144"></a>     *   and abort the process if it exceeds this limit.  Note that this
<a name="145"></a>     *   limit doesn't limit the parsing time itself - we'll never
<a name="146"></a>     *   interrupt that mid-stream.  
<a name="147"></a>     */
<a name="148"></a>    spellTimeLimit = 250
<a name="149"></a>
<a name="150"></a>    /*
<a name="151"></a>     *   When the parser doesn't recognize a word, should it say so?  If
<a name="152"></a>     *   this property is set to true, when parsing fails, we'll scan the
<a name="153"></a>     *   command line for a word that's not in the dictionary and show a
<a name="154"></a>     *   message such as "I don't know the word &lt;foo&gt;."  If this property
<a name="155"></a>     *   is nil, the parser will instead simply say that it doesn't
<a name="156"></a>     *   recognize the syntax, or that the object in question isn't
<a name="157"></a>     *   present, without saying specifically which word wasn't recognized,
<a name="158"></a>     *   or indeed even admitting that there was such a thing.
<a name="159"></a>     *   
<a name="160"></a>     *   There are two schools of thought on this, both concerned with
<a name="161"></a>     *   optimizing the user experience.
<a name="162"></a>     *   
<a name="163"></a>     *   The first school holds that the parser's job is to be as helpful
<a name="164"></a>     *   as possible.  First and foremost, that means we should understand
<a name="165"></a>     *   the user's input as often as possible.  But when we can't, it
<a name="166"></a>     *   means that we should be do our best to explain what we didn't
<a name="167"></a>     *   understand, to help the user formulate a working command next
<a name="168"></a>     *   time.  In the case of a word the parser doesn't recognize, we can
<a name="169"></a>     *   be pretty sure that the unknown word is the reason we can't
<a name="170"></a>     *   understand the input.  The best way to help the user correct the
<a name="171"></a>     *   problem is to let them know exactly which word we didn't know,
<a name="172"></a>     *   rather than make them guess at what we didn't understand.  This is
<a name="173"></a>     *   the way the classic Infocom games worked, and it's the traditional
<a name="174"></a>     *   TADS default as well.
<a name="175"></a>     *   
<a name="176"></a>     *   The second school holds that the user's overriding interest is
<a name="177"></a>     *   maintaining suspension of disbelief, and that the parser should do
<a name="178"></a>     *   its best not to interfere with that.  A major aspect of this in IF
<a name="179"></a>     *   the illusion that the game world is as boundless as the real
<a name="180"></a>     *   world.  Missing dictionary words tend to break this illusion: if
<a name="181"></a>     *   the user types EXAMINE ZEBRA, and the parser replies that it
<a name="182"></a>     *   doesn't know the word "zebra", we've suddenly exposed a limit of
<a name="183"></a>     *   the game world.  If we instead play coy and simply say that
<a name="184"></a>     *   there's no zebra currently present, we allow the player to imagine
<a name="185"></a>     *   that a zebra might yet turn up.  This is the way Inform games
<a name="186"></a>     *   typically work.
<a name="187"></a>     *   
<a name="188"></a>     *   Each approach has its advantages and disadvantages, adherents and
<a name="189"></a>     *   detractors, and it seems that neither one is objectively "right".
<a name="190"></a>     *   It comes down to taste.  But there seems to be a clear preference
<a name="191"></a>     *   among the majority of players in the modern era for the second
<a name="192"></a>     *   approach.  The key factor is probably that typical IF commands are
<a name="193"></a>     *   so short that it's easy enough to spot a typo without help from
<a name="194"></a>     *   the parser, so the clarity benefits of "unknown word" messages
<a name="195"></a>     *   seem considerably outweighed by the harm they do to the illusion
<a name="196"></a>     *   of boundlessness.  So, our default is the second option, playing
<a name="197"></a>     *   coy.  
<a name="198"></a>     */
<a name="199"></a>    showUnknownWords = nil
<a name="200"></a>
<a name="201"></a>    /*
<a name="202"></a>     *   Parse and execute a command line.  This is the main parsing
<a name="203"></a>     *   routine.  We take the text of a command line, parse it against the
<a name="204"></a>     *   grammar defined in the language module, resolve the noun phrases
<a name="205"></a>     *   to game-world objects, and execute the action.  If the command
<a name="206"></a>     *   line has more than one verb phrase, we repeat the process for each
<a name="207"></a>     *   one.
<a name="208"></a>     *   
<a name="209"></a>     *   'str' is the text of the command line, as entered by the player.
<a name="210"></a>     */
<a name="211"></a>    parse(str)
<a name="212"></a>    {
<a name="213"></a>        /* Make sure our current SpecialVerb is set to nil before we start parsing a new command. */
<a name="214"></a>        specialVerbMgr.currentSV = nil;
<a name="215"></a>        
<a name="216"></a>        /* tokenize the input */
<a name="217"></a>        local toks;
<a name="218"></a>        try
<a name="219"></a>        {
<a name="220"></a>            /* run the command tokenizer over the input string */
<a name="221"></a>            toks = cmdTokenizer.tokenize(str);
<a name="222"></a>            
<a name="223"></a>            /* Dispose of any unwanted terminal punctuation */
<a name="224"></a>            while(toks.length &gt; 0 &amp;&amp; getTokType(toks[toks.length]) == tokPunct)
<a name="225"></a>                toks = toks.removeElementAt(toks.length);
<a name="226"></a>            
<a name="227"></a>        }
<a name="228"></a>        catch (TokErrorNoMatch err)
<a name="229"></a>        {
<a name="230"></a>            /* 
<a name="231"></a>             *   The tokenizer found a character (usually a punctuation
<a name="232"></a>             *   mark) that doesn't fit any of the token rules.  
<a name="233"></a>             */
<a name="234"></a>            DMsg(token error, 'I don\'t understand the punctuation {1}',
<a name="235"></a>                 err.curChar_);
<a name="236"></a>
<a name="237"></a>           
<a name="238"></a>            
<a name="239"></a>            
<a name="240"></a>            /* give up on the parse */
<a name="241"></a>            return;
<a name="242"></a>        }
<a name="243"></a>
<a name="244"></a>        /* 
<a name="245"></a>         *   Assume initially that the actor is the player character, but only
<a name="246"></a>         *   if we don't have a question, since if the player is replying to a
<a name="247"></a>         *   question the actor may already have been resolved.
<a name="248"></a>         */
<a name="249"></a>        if(question == nil)
<a name="250"></a>            gActor = gPlayerChar;        
<a name="251"></a>        
<a name="252"></a>        /* no spelling corrections have been attempted yet */
<a name="253"></a>        local history = new transient SpellingHistory(self);
<a name="254"></a>
<a name="255"></a>        /* we're starting with the first command in the string */
<a name="256"></a>        local firstCmd = true;
<a name="257"></a>
<a name="258"></a>        /* parse the tokens */
<a name="259"></a>        try
<a name="260"></a>        {
<a name="261"></a>            /* if there are no tokens, simply perform the empty command */
<a name="262"></a>            if (toks.length() == 0)
<a name="263"></a>            {
<a name="264"></a>                /* 
<a name="265"></a>                 *   this counts as a new command, so forget any previous
<a name="266"></a>                 *   question or typo information 
<a name="267"></a>                 */
<a name="268"></a>                question = nil;
<a name="269"></a>                lastTokens = nil;
<a name="270"></a>
<a name="271"></a>                /* process an empty command */
<a name="272"></a>                emptyCommand();
<a name="273"></a>
<a name="274"></a>                /* we're done */
<a name="275"></a>                return;
<a name="276"></a>            }
<a name="277"></a>
<a name="278"></a>            /* check for an OOPS command */
<a name="279"></a>            local lst = oopsCommand.parseTokens(toks, cmdDict);
<a name="280"></a>            if (lst.length() != 0)
<a name="281"></a>            {
<a name="282"></a>                /* this only works if we have an error to correct */
<a name="283"></a>                local ui;
<a name="284"></a>                if (lastTokens == nil
<a name="285"></a>                    || (ui = spellingCorrector.findUnknownWord(lastTokens))
<a name="286"></a>                        == nil)
<a name="287"></a>                {
<a name="288"></a>                    /* OOPS isn't available - throw an error */
<a name="289"></a>                    throw new CantOopsError();
<a name="290"></a>                }
<a name="291"></a>                
<a name="292"></a>                /* apply the correction, and proceed to parse the result */
<a name="293"></a>                toks = OopsProduction.applyCorrection(lst[1], lastTokens, ui);
<a name="294"></a>            }
<a name="295"></a>            
<a name="296"></a>             /* Update the vocabulary of any game objects with alternating/changing vocab. */
<a name="297"></a>            updateVocab();
<a name="298"></a>            
<a name="299"></a>             /* Allow the specialVerb Manager to adjust our toks */            
<a name="300"></a>            toks = specialVerbMgr.matchSV(toks);  
<a name="301"></a>            
<a name="302"></a>            /*   
<a name="303"></a>             *   Parse each predicate in the command line, until we run out
<a name="304"></a>             *   of tokens.  The beginning of a whole new command line is
<a name="305"></a>             *   definitely the beginning of a sentence, so start parsing
<a name="306"></a>             *   with firstCommandPhrase.  
<a name="307"></a>             */
<a name="308"></a>            for (local root = firstCommandPhrase ; toks.length() != 0 ; )
<a name="309"></a>            {
<a name="310"></a>                /* we don't have a parse list yet */
<a name="311"></a>                local cmdLst = nil;
<a name="312"></a>
<a name="313"></a>                /* 
<a name="314"></a>                 *   we haven't found a resolution error in a non-command
<a name="315"></a>                 *   parsing yet 
<a name="316"></a>                 */
<a name="317"></a>                local qErr = nil, defErr = nil;
<a name="318"></a>
<a name="319"></a>                /* 
<a name="320"></a>                 *   If we have an outstanding question, and it takes
<a name="321"></a>                 *   priority over interpreting input as a new command, try
<a name="322"></a>                 *   parsing the input against the question.  Only do this
<a name="323"></a>                 *   on the first command on the line - a question answer
<a name="324"></a>                 *   has to be the entire input, so if we've already parsed
<a name="325"></a>                 *   earlier commands on the same line, this definitely
<a name="326"></a>                 *   isn't an answer to a past question.  
<a name="327"></a>                 */
<a name="328"></a>                if (firstCmd &amp;&amp; question != nil &amp;&amp; question.priority)
<a name="329"></a>                {
<a name="330"></a>                    /* try parsing against the Question */
<a name="331"></a>                    local l = question.parseAnswer(toks, cmdDict);
<a name="332"></a>
<a name="333"></a>                    /* if it parsed and resolved, this is our command */
<a name="334"></a>                    if (l != nil &amp;&amp; l.cmd != nil)
<a name="335"></a>                        cmdLst = l;
<a name="336"></a>
<a name="337"></a>                    /* if it parsed but didn't resolved, note the error */
<a name="338"></a>                    if (l != nil)
<a name="339"></a>                        qErr = l.getResErr();
<a name="340"></a>                }
<a name="341"></a>
<a name="342"></a>                /* 
<a name="343"></a>                 *   if the question didn't grab it, try parsing as a whole
<a name="344"></a>                 *   new command against the ordinary command grammar
<a name="345"></a>                 */
<a name="346"></a>                if (cmdLst == nil || cmdLst.cmd == nil)
<a name="347"></a>                {
<a name="348"></a>                    cmdLst = new CommandList(
<a name="349"></a>                        root, toks, cmdDict, { p: new Command(p) });
<a name="350"></a>                }
<a name="351"></a>
<a name="352"></a>                /* 
<a name="353"></a>                 *   If we didn't find any resolvable commands, and this is
<a name="354"></a>                 *   the first command, check to see if it's an answer to
<a name="355"></a>                 *   an outstanding query.  We only check this if the
<a name="356"></a>                 *   regular grammar parsing fails, because anything that
<a name="357"></a>                 *   looks like a valid new command overrides a past query.
<a name="358"></a>                 *   This is important because some of the short, common
<a name="359"></a>                 *   commands sometimes can look like noun phrases, so we
<a name="360"></a>                 *   explicitly give preference to interpreting these as
<a name="361"></a>                 *   brand new commands.  
<a name="362"></a>                 */
<a name="363"></a>                if (cmdLst.cmd == nil
<a name="364"></a>                    &amp;&amp; firstCmd
<a name="365"></a>                    &amp;&amp; question != nil
<a name="366"></a>                    &amp;&amp; !question.priority)
<a name="367"></a>                {
<a name="368"></a>                    /* try parsing against the Question */
<a name="369"></a>                    local l = question.parseAnswer(toks, cmdDict);
<a name="370"></a>
<a name="371"></a>                    /* if it parsed and resolved, this is our command */
<a name="372"></a>                    if (l != nil &amp;&amp; l.cmd != nil)
<a name="373"></a>                        cmdLst = l;
<a name="374"></a>
<a name="375"></a>                    /* if it parsed but didn't resolved, note the error */
<a name="376"></a>                    if (l != nil)
<a name="377"></a>                        qErr = l.getResErr();
<a name="378"></a>                }
<a name="379"></a>
<a name="380"></a>                /*
<a name="381"></a>                 *   If we don't have a command yet, and this is the first
<a name="382"></a>                 *   command on the line, handle it as a conversational command
<a name="383"></a>                 *   if conversation is in progress; otherwise if default
<a name="384"></a>                 *   actions are enabled, check to see if the command looks like
<a name="385"></a>                 *   a single noun phrase.  If so, handle it as the default
<a name="386"></a>                 *   action on the noun.
<a name="387"></a>                 */
<a name="388"></a>                if (cmdLst.cmd == nil
<a name="389"></a>                    &amp;&amp; firstCmd)
<a name="390"></a>                {
<a name="391"></a>                    local l;                   
<a name="392"></a>                    
<a name="393"></a>                    
<a name="394"></a>                    /* 
<a name="395"></a>                     *   If a conversation is in progress parse the command line
<a name="396"></a>                     *   as the single topic object phrase of a Say command,
<a name="397"></a>                     *   provided that the first word on the command line
<a name="398"></a>                     *   doesn't match a possible action.
<a name="399"></a>                     */
<a name="400"></a>                    
<a name="401"></a>                    if(gPlayerChar.currentInterlocutor != nil
<a name="402"></a>                       &amp;&amp; cmdLst.length == 0 
<a name="403"></a>                       &amp;&amp; Q.canTalkTo(gPlayerChar,
<a name="404"></a>                                      gPlayerChar.currentInterlocutor)
<a name="405"></a>                       &amp;&amp; str.find(',') == nil
<a name="406"></a>                       &amp;&amp; gPlayerChar.currentInterlocutor.allowImplicitSay())
<a name="407"></a>                    {
<a name="408"></a>                         l = new CommandList(
<a name="409"></a>                            topicPhrase, toks, cmdDict,
<a name="410"></a>                            { p: new Command(SayAction, p) });
<a name="411"></a>                        
<a name="412"></a>                        libGlobal.lastCommandForUndo = str;
<a name="413"></a>                        savepoint();
<a name="414"></a>                    }
<a name="415"></a>                    /* 
<a name="416"></a>                     *   If the player char is not in conversation with anyone,
<a name="417"></a>                     *   or the first word of the command matches a possible
<a name="418"></a>                     *   command verb, then try parsing the command line as a
<a name="419"></a>                     *   single direct object phrase for the DefaultAction verb,
<a name="420"></a>                     *   provided defaultActions are enabled (which they aren't
<a name="421"></a>                     *   by default).
<a name="422"></a>                     */
<a name="423"></a>                    else if(defaultActions)                                                
<a name="424"></a>                        l = new CommandList(
<a name="425"></a>                            defaultCommandPhrase, toks, cmdDict,
<a name="426"></a>                            { p: new Command(p) });                       
<a name="427"></a>                    
<a name="428"></a>                    
<a name="429"></a>                       
<a name="430"></a>                    /* accept a curable reply */
<a name="431"></a>                    if (l != nil &amp;&amp; l.acceptCurable() != nil)
<a name="432"></a>                    {
<a name="433"></a>                        cmdLst = l;
<a name="434"></a>                        
<a name="435"></a>                        /* note any resolution error */
<a name="436"></a>                        defErr = l.getResErr();
<a name="437"></a>                    }
<a name="438"></a>                }
<a name="439"></a>                
<a name="440"></a>                /*
<a name="441"></a>                 *   If we've applied a spelling correction, and the
<a name="442"></a>                 *   command match didn't consume the entire input, make
<a name="443"></a>                 *   sure what's left of the input has a valid parsing as
<a name="444"></a>                 *   another command.  This ensures that we don't get a
<a name="445"></a>                 *   false positive by excessively shortening a command,
<a name="446"></a>                 *   which we can sometimes do by substituting a word like
<a name="447"></a>                 *   "then" for another word.  
<a name="448"></a>                 */
<a name="449"></a>                if (cmdLst.length() != nil
<a name="450"></a>                    &amp;&amp; history.hasCorrections())
<a name="451"></a>                {
<a name="452"></a>                    /* get the best available parsing */
<a name="453"></a>                    local c = cmdLst.getBestCmd();
<a name="454"></a>
<a name="455"></a>                    /* if it doesn't use all the tokens, check what's left */
<a name="456"></a>                    if (c != nil &amp;&amp; c.tokenLen &lt; toks.length())
<a name="457"></a>                    {
<a name="458"></a>                        /* try parsing the next command */
<a name="459"></a>                        local l = commandPhrase.parseTokens(
<a name="460"></a>                            c.nextTokens, cmdDict);
<a name="461"></a>
<a name="462"></a>                        /* 
<a name="463"></a>                         *   if that didn't work, invalidate the command by
<a name="464"></a>                         *   substituting an empty command list 
<a name="465"></a>                         */
<a name="466"></a>                        if (l.length() == 0)
<a name="467"></a>                            cmdLst = new CommandList();
<a name="468"></a>                    }
<a name="469"></a>                }
<a name="470"></a>                
<a name="471"></a>                /* 
<a name="472"></a>                 *   If we didn't find a parsing at all, it's a generic "I
<a name="473"></a>                 *   don't understand" error.  If we found a parsing, but
<a name="474"></a>                 *   not a resolution, reject it if it's a spelling
<a name="475"></a>                 *   correction.  We only want completely clean spelling
<a name="476"></a>                 *   corrections, without any errors.
<a name="477"></a>                 */
<a name="478"></a>                if (cmdLst.length() == 0
<a name="479"></a>                    || (history.hasCorrections()
<a name="480"></a>                        &amp;&amp; cmdLst.getResErr() != nil
<a name="481"></a>                        &amp;&amp; !cmdLst.getResErr().allowOnRespell))
<a name="482"></a>                {
<a name="483"></a>                    /* 
<a name="484"></a>                     *   If we were able to parse the input using one of
<a name="485"></a>                     *   the non-command interpretations, use the
<a name="486"></a>                     *   resolution error from that parsing.  Otherwise, we
<a name="487"></a>                     *   simply can't make any sense of this input, so use
<a name="488"></a>                     *   the generic "I don't understand" error. 
<a name="489"></a>                     */
<a name="490"></a>                    local err = (qErr != nil ? qErr :
<a name="491"></a>                                 defErr != nil ? defErr :
<a name="492"></a>                                 new NotUnderstoodError());
<a name="493"></a>                    
<a name="494"></a>                    /* look for a spelling correction */
<a name="495"></a>                    local newToks = history.checkSpelling(toks, err);
<a name="496"></a>                    if (newToks != nil)
<a name="497"></a>                    {
<a name="498"></a>                        /* parse again with the new tokens */
<a name="499"></a>                        toks = newToks;
<a name="500"></a>                        continue;
<a name="501"></a>                    }
<a name="502"></a>
<a name="503"></a>                    /* 
<a name="504"></a>                     *   There's no spelling correction available.  If we've 
<a name="505"></a>                     *   settled on an auto-examine or question error, skip 
<a name="506"></a>                     *   that and go back to "I don't understand" after 
<a name="507"></a>                     *   all.  We don't want to assume Auto-Examine unless we
<a name="508"></a>                     *   actually have something to examine, since we can 
<a name="509"></a>                     *   parse noun phrase grammar out of practically any 
<a name="510"></a>                     *   input.  
<a name="511"></a>                     */
<a name="512"></a>                    if (err is in (defErr, qErr))
<a name="513"></a>                    {
<a name="514"></a>                        /* return to the not-understood error */
<a name="515"></a>                        err = new NotUnderstoodError();
<a name="516"></a>                        
<a name="517"></a>                        /* check spelling again with this error */
<a name="518"></a>                        newToks = history.checkSpelling(toks, err);
<a name="519"></a>                        if (newToks != nil)
<a name="520"></a>                        {
<a name="521"></a>                            /* parse again with the new tokens */
<a name="522"></a>                            toks = newToks;
<a name="523"></a>                            continue;
<a name="524"></a>                        }
<a name="525"></a>                    
<a name="526"></a>                        
<a name="527"></a>                        /* 
<a name="528"></a>                         *   We didn't find any spelling corrections this time
<a name="529"></a>                         *   through.  Since we're rolling back to the
<a name="530"></a>                         *   not-understood error, discard any spelling
<a name="531"></a>                         *   corrections we attempted with other
<a name="532"></a>                         *   interpretations.
<a name="533"></a>                         */
<a name="534"></a>                        history.clear();                   
<a name="535"></a>                    }
<a name="536"></a>                
<a name="537"></a>                    /* fail with the error */
<a name="538"></a>                    throw err;
<a name="539"></a>                }
<a name="540"></a>
<a name="541"></a>                /* if we found a resolvable command, execute it */
<a name="542"></a>                if (cmdLst.cmd != nil)
<a name="543"></a>                {
<a name="544"></a>                    /* get the winning Command */
<a name="545"></a>                    local cmd = cmdLst.cmd;
<a name="546"></a>                    
<a name="547"></a>                    /* 
<a name="548"></a>                     *   We next have to ensure that the player hasn't entered
<a name="549"></a>                     *   multiple nouns in a slot that only allows a single noun
<a name="550"></a>                     *   in the grammar. If the player has entered two objects
<a name="551"></a>                     *   like "the bat and the ball" in such a case, the
<a name="552"></a>                     *   badMulti flag will be set on the command object, so we
<a name="553"></a>                     *   first test for that and abort the command with a
<a name="554"></a>                     *   suitable error message if badMulti is not nil (by
<a name="555"></a>                     *   throwing a BadMultiError
<a name="556"></a>                     *
<a name="557"></a>                     *   Unfortunately the badMulti flag doesn't get set if the
<a name="558"></a>                     *   player enters a multiple object as a plural (e.g.
<a name="559"></a>                     *   "bats"), so we need to trap this case too. We do that
<a name="560"></a>                     *   by checking whether there's multiple objects in the
<a name="561"></a>                     *   direct, indirect and accessory object slots at the same
<a name="562"></a>                     *   time as the grammar tag matching the slot in question
<a name="563"></a>                     *   is 'normal', which it is only for a single noun match.
<a name="564"></a>                     */
<a name="565"></a>                     
<a name="566"></a>                    if(cmd &amp;&amp; cmd.verbProd != nil &amp;&amp;                        
<a name="567"></a>                        (cmd.badMulti != nil 
<a name="568"></a>                       || (cmd.verbProd.dobjMatch != nil &amp;&amp;
<a name="569"></a>                           cmd.verbProd.dobjMatch.grammarTag == 'normal'
<a name="570"></a>                           &amp;&amp; cmd.dobjs.length &gt; 1)
<a name="571"></a>                       ||
<a name="572"></a>                       (cmd.verbProd.iobjMatch != nil &amp;&amp;
<a name="573"></a>                           cmd.verbProd.iobjMatch.grammarTag == 'normal'
<a name="574"></a>                           &amp;&amp; cmd.iobjs.length &gt; 1)                          
<a name="575"></a>                        ||
<a name="576"></a>                       (cmd.verbProd.accMatch != nil &amp;&amp;
<a name="577"></a>                           cmd.verbProd.accMatch.grammarTag == 'normal'
<a name="578"></a>                           &amp;&amp; cmd.accs.length &gt; 1)
<a name="579"></a>                           ))
<a name="580"></a>                        cmd.cmdErr = new BadMultiError(cmd.np);
<a name="581"></a>                    
<a name="582"></a>                    /* if this command has a pending error, throw it */
<a name="583"></a>                    if (cmd.cmdErr != nil)
<a name="584"></a>                        throw cmd.cmdErr;
<a name="585"></a>
<a name="586"></a>                    /* 
<a name="587"></a>                     *   Forget any past question and typo information.
<a name="588"></a>                     *   The new command is either an answer to this
<a name="589"></a>                     *   question, or it's simply ignoring the question; in
<a name="590"></a>                     *   either case, the question is no longer in play for
<a name="591"></a>                     *   future input.  
<a name="592"></a>                     */
<a name="593"></a>                    question = nil;
<a name="594"></a>                    lastTokens = nil;
<a name="595"></a>                    
<a name="596"></a>                    /* note any spelling changes */
<a name="597"></a>                    history.noteSpelling(toks);
<a name="598"></a>                    
<a name="599"></a>                    /* execute the command */
<a name="600"></a>                    cmd.exec();
<a name="601"></a>                    
<a name="602"></a>                    /* start over with a new spelling correction history */
<a name="603"></a>                    history = new transient SpellingHistory(self);
<a name="604"></a>                    
<a name="605"></a>                    /* 
<a name="606"></a>                     *   Set the root grammar production for the next
<a name="607"></a>                     *   predicate.  If the previous command ended the
<a name="608"></a>                     *   sentence, start a new sentence; otherwise, use the
<a name="609"></a>                     *   additional clause syntax. 
<a name="610"></a>                     */
<a name="611"></a>                    root = cmd.endOfSentence
<a name="612"></a>                        ? firstCommandPhrase : commandPhrase;
<a name="613"></a>                    
<a name="614"></a>                    /* we're no longer on the first command in the string */
<a name="615"></a>                    firstCmd = nil;
<a name="616"></a>                    
<a name="617"></a>                    /* go back and parse the remainder of the command line */
<a name="618"></a>                    toks = cmd.nextTokens;
<a name="619"></a>                    continue;
<a name="620"></a>                }
<a name="621"></a>
<a name="622"></a>                /*
<a name="623"></a>                 *   We weren't able to resolve any of the parse trees.  If
<a name="624"></a>                 *   one of the errors is "curable", meaning that the
<a name="625"></a>                 *   player can fix it by answering a question, pick the
<a name="626"></a>                 *   first of those, in predicate priority order.
<a name="627"></a>                 *   Otherwise, just pick the first command overall in
<a name="628"></a>                 *   predicate priority order.  In either case, since we
<a name="629"></a>                 *   didn't find any working alternatives, it's time to
<a name="630"></a>                 *   actually show the error and fail the command.  
<a name="631"></a>                 */
<a name="632"></a>                local c = cmdLst.acceptAny();
<a name="633"></a>
<a name="634"></a>                /* 
<a name="635"></a>                 *   If the error isn't curable, check for spelling errors,
<a name="636"></a>                 *   time permitting.  Don't bother doing this with a
<a name="637"></a>                 *   curable error, since that will have its own way of
<a name="638"></a>                 *   solving the problem that reflects a better
<a name="639"></a>                 *   understanding of the input than considering it a
<a name="640"></a>                 *   simple typo.  
<a name="641"></a>                 */
<a name="642"></a>                if (!c.cmdErr.curable)
<a name="643"></a>                {
<a name="644"></a>                    /*
<a name="645"></a>                     *   For spelling correction purposes, if this is an
<a name="646"></a>                     *   unmatched noun error, but the command has a misc
<a name="647"></a>                     *   word list and an empty noun phrase, treat this as
<a name="648"></a>                     *   a "not understood" error.  The combination of noun
<a name="649"></a>                     *   phrase errors suggests that we took a word that
<a name="650"></a>                     *   was meant to be part of the verb, and incorrectly
<a name="651"></a>                     *   parsed it as part of a noun phrase, leaving the
<a name="652"></a>                     *   verb structure and other noun phrase incomplete.
<a name="653"></a>                     *   This is really a verb syntax error, not a noun
<a name="654"></a>                     *   phrase error.  
<a name="655"></a>                     */
<a name="656"></a>                    local spellErr = c.cmdErr;
<a name="657"></a>                    if (c.cmdErr.ofKind(UnmatchedNounError)
<a name="658"></a>                        &amp;&amp; c.miscWordLists.length() &gt; 0
<a name="659"></a>                        &amp;&amp; c.missingNouns &gt; 0)
<a name="660"></a>                        spellErr = new NotUnderstoodError();
<a name="661"></a>
<a name="662"></a>                    /* try spelling correction */
<a name="663"></a>                    local newToks = history.checkSpelling(toks, spellErr);
<a name="664"></a>
<a name="665"></a>                    /* if that worked, try the corrected command */
<a name="666"></a>                    if (newToks != nil)
<a name="667"></a>                    {
<a name="668"></a>                        /* parse again with the new tokens */
<a name="669"></a>                        toks = newToks;
<a name="670"></a>                        continue;
<a name="671"></a>                    }
<a name="672"></a>                }
<a name="673"></a>
<a name="674"></a>                /* re-throw the error that caused the resolution to fail */
<a name="675"></a>                throw c.cmdErr;
<a name="676"></a>            }
<a name="677"></a>        }
<a name="678"></a>        catch (ParseError err)
<a name="679"></a>        {
<a name="680"></a>            /* 
<a name="681"></a>             *   roll back any spelling changes to the last one that
<a name="682"></a>             *   improved matters 
<a name="683"></a>             */
<a name="684"></a>            local h = history.rollback(toks, err);
<a name="685"></a>            toks = h.oldToks;
<a name="686"></a>            err = h.parseError;
<a name="687"></a>
<a name="688"></a>            /* 
<a name="689"></a>             *   if this is a curable error, it poses a question, which the
<a name="690"></a>             *   player can answer on the next input 
<a name="691"></a>             */
<a name="692"></a>            if (err.curable)
<a name="693"></a>                question = new ParseErrorQuestion(err);
<a name="694"></a>            
<a name="695"></a>            /* 
<a name="696"></a>             *   If the current error isn't curable, and unknown word
<a name="697"></a>             *   disclosure is enabled, and there's a word in the command
<a name="698"></a>             *   that's not in the dictionary, replace the parsing error
<a name="699"></a>             *   with an unknown word error.  
<a name="700"></a>             */
<a name="701"></a>            local ui;
<a name="702"></a>            if (!err.curable
<a name="703"></a>                &amp;&amp; showUnknownWords
<a name="704"></a>                &amp;&amp; (ui = spellingCorrector.findUnknownWord(toks)) != nil)
<a name="705"></a>            {
<a name="706"></a>                /* find the misspelled word in the original tokens */
<a name="707"></a>                err = new UnknownWordError(getTokOrig(toks[ui]));
<a name="708"></a>            }
<a name="709"></a>            
<a name="710"></a>            /* 
<a name="711"></a>             *   If the new error isn't an error in an OOPS command, save
<a name="712"></a>             *   the token list for an OOPS command next time out. 
<a name="713"></a>             */
<a name="714"></a>            if (!err.ofKind(OopsError))
<a name="715"></a>                lastTokens = toks;
<a name="716"></a>            
<a name="717"></a>            /* log any spelling changes we kept */
<a name="718"></a>            history.noteSpelling(toks);
<a name="719"></a>
<a name="720"></a>            /* display the error we finally decided upon */
<a name="721"></a>            err.display();
<a name="722"></a>        }
<a name="723"></a>        catch (CommandSignal sig)
<a name="724"></a>        {
<a name="725"></a>            /* 
<a name="726"></a>             *   On any command signal we haven't caught so far, simply
<a name="727"></a>             *   stop processing this command line.  
<a name="728"></a>             */
<a name="729"></a>        }
<a name="730"></a>    }
<a name="731"></a>
<a name="732"></a>    /*
<a name="733"></a>     *   The token list from the last command, if an error occurred.  This
<a name="734"></a>     *   is the token list that we'll retry if the player enters an OOPS
<a name="735"></a>     *   command.  
<a name="736"></a>     */
<a name="737"></a>    lastTokens = nil
<a name="738"></a>
<a name="739"></a>    /*
<a name="740"></a>     *   The outstanding Question object.  When we ask an interactive
<a name="741"></a>     *   question (such as a disambiguation query, a missing noun phrase
<a name="742"></a>     *   query, or a custom question from the game), this is set to the
<a name="743"></a>     *   Question waiting to be answered.  We parse the next command
<a name="744"></a>     *   against the Question to see if it's a reply, and if so we execute
<a name="745"></a>     *   the reply.  
<a name="746"></a>     */
<a name="747"></a>    question = nil
<a name="748"></a>
<a name="749"></a>    /*
<a name="750"></a>     *   Execute an empty command line.  The parse() routine calls this
<a name="751"></a>     *   when given a blank command line (i.e., the user simply pressed the
<a name="752"></a>     *   Return key).  By default, we execute a Look Around command if
<a name="753"></a>     *   autoLook is enabled, otherwise we show the "I beg your pardon"
<a name="754"></a>     *   error.
<a name="755"></a>     */
<a name="756"></a>    emptyCommand()
<a name="757"></a>    {
<a name="758"></a>        if (autoLook)
<a name="759"></a>            new Command(Look).exec();
<a name="760"></a>        else
<a name="761"></a>        {
<a name="762"></a>            /* 
<a name="763"></a>             *   The player entered an empty command line (i.e., pressed
<a name="764"></a>             *   Return at the command prompt, without typing anything else
<a name="765"></a>             *   first).  Note that this error can only occur if Auto-Look
<a name="766"></a>             *   is disabled, since otherwise an empty command implicitly
<a name="767"></a>             *   means LOOK AROUND.  
<a name="768"></a>             */
<a name="769"></a>            DMsg(empty command line, 'I beg your pardon?');
<a name="770"></a>
<a name="771"></a>        }
<a name="772"></a>    }
<a name="773"></a>    
<a name="774"></a>    /* 
<a name="775"></a>     *   The action to be tried if the parser can't find a verb in the command
<a name="776"></a>     *   line and tries to parse the command line as the single object of a
<a name="777"></a>     *   DefaultAction command instead.
<a name="778"></a>     */
<a name="779"></a>    
<a name="780"></a>    DefaultAction = ExamineOrGoTo
<a name="781"></a>    
<a name="782"></a>    /*  Return an rmcXXXX enum code depending on the state of Parser.question */
<a name="783"></a>    rmcType()
<a name="784"></a>    {
<a name="785"></a>        if(Parser.question != nil &amp;&amp; Parser.question.err != nil)
<a name="786"></a>        {
<a name="787"></a>            /* 
<a name="788"></a>             *   If the Parser error is an EmptyNounError then we're asking for
<a name="789"></a>             *   an object.
<a name="790"></a>             */
<a name="791"></a>            if(Parser.question.err.ofKind(EmptyNounError))
<a name="792"></a>                return rmcAskObject;
<a name="793"></a>            
<a name="794"></a>            /* 
<a name="795"></a>             *   If the Parser error is an AmbiguousError then we're requesting
<a name="796"></a>             *   disambiguation.
<a name="797"></a>             */
<a name="798"></a>            if(Parser.question.err.ofKind(AmbiguousError))
<a name="799"></a>                return rmcDisambig;            
<a name="800"></a>        }
<a name="801"></a>        
<a name="802"></a>        /* 
<a name="803"></a>         *   If there's no special situation, assume we're reading a standard
<a name="804"></a>         *   command.
<a name="805"></a>         */
<a name="806"></a>        return rmcCommand;
<a name="807"></a>    }
<a name="808"></a>    
<a name="809"></a>    /* 
<a name="810"></a>     *   Update the vocabulary of items in the game for which it might vary; specifically those with
<a name="811"></a>     *   an altVocab defined.
<a name="812"></a>     */
<a name="813"></a>    updateVocab()
<a name="814"></a>    {
<a name="815"></a>        /* Retrieve the list of items that have alternating vocabulary. */
<a name="816"></a>        local lst = libGlobal.altVocabLst;
<a name="817"></a>        
<a name="818"></a>        /* 
<a name="819"></a>         *   If the list is longer than a certain amount, it may become more efficient to iterate
<a name="820"></a>         *   over only those items in the list that are already in scope.
<a name="821"></a>         */
<a name="822"></a>        if(lst.length &gt; 30)
<a name="823"></a>        {
<a name="824"></a>            /* Get a list of items in scope. */
<a name="825"></a>            local scope = Q.scopeList(gPlayerChar).toList();
<a name="826"></a>            
<a name="827"></a>            /* Reduce our list of variable vocab items to include only those in scope. */
<a name="828"></a>            lst = lst.intersect(scope);
<a name="829"></a>            
<a name="830"></a>        }
<a name="831"></a>        
<a name="832"></a>        /* Call updateVocab() on every item in our list. */
<a name="833"></a>        lst.forEach({ x: x.updateVocab() });
<a name="834"></a>    }
<a name="835"></a>;
<a name="836"></a>
<a name="837"></a>/* ------------------------------------------------------------------------ */
<a name="838"></a>/*
<a name="839"></a> *   Base class for command execution signals.  These allow execution
<a name="840"></a> *   handlers to terminate execution for the current command line or
<a name="841"></a> *   portion of the command line.  
<a name="842"></a> */
<a name="843"></a>class CommandSignal: Exception
<a name="844"></a>;
<a name="845"></a>
<a name="846"></a>
<a name="847"></a>/* 
<a name="848"></a> *   Terminate the entire command line.
<a name="849"></a> */
<a name="850"></a>class ExitCommandLineSignal: CommandSignal
<a name="851"></a>;
<a name="852"></a>    
<a name="853"></a>
<a name="854"></a>/* ------------------------------------------------------------------------ */
<a name="855"></a>/*
<a name="856"></a> *   A CommandList is a set of potential parsings for a given input with a
<a name="857"></a> *   given grammar.  
<a name="858"></a> */
<a name="859"></a>class CommandList: object
<a name="860"></a>    /*
<a name="861"></a>     *   new CommandList(prod, toks, dict, wrapper) - construct a new
<a name="862"></a>     *   CommandList object by parsing an input token list.  'prod' is the
<a name="863"></a>     *   GrammarProd to parse against; 'toks' is the token list; 'dict' is
<a name="864"></a>     *   the main parser dictionary; 'wrapper' is a callback function that
<a name="865"></a>     *   maps a parse tree to a Command object.
<a name="866"></a>     *   
<a name="867"></a>     *   new CommandList(Command) - construct a CommandList containing a
<a name="868"></a>     *   single pre-resolved Command object.  
<a name="869"></a>     */
<a name="870"></a>    construct([args])
<a name="871"></a>    {
<a name="872"></a>        /* check which argument list we have */        
<a name="873"></a>        if (args.matchProto([GrammarProd, Collection, Dictionary, TypeFuncPtr]))
<a name="874"></a>        {
<a name="875"></a>            /* retrieve the arguments */
<a name="876"></a>            local prod = args[1], toks = args[2], dict = args[3],
<a name="877"></a>                wrapper = args[4];
<a name="878"></a>
<a name="879"></a>            /* parse the token list, and map the list to Command objects  */
<a name="880"></a>            cmdLst = prod.parseTokens(toks, dict).mapAll(wrapper);
<a name="881"></a>            
<a name="882"></a>            /* sort in priority order */
<a name="883"></a>            cmdLst = Command.sortList(cmdLst);
<a name="884"></a>            
<a name="885"></a>            /* 
<a name="886"></a>             *   Go through the list, looking for an item with noun phrases we
<a name="887"></a>             *   can resolve.  Take the first item that we can properly
<a name="888"></a>             *   resolve.  
<a name="889"></a>             */
<a name="890"></a>            foreach (local c in cmdLst)
<a name="891"></a>            {
<a name="892"></a>                try
<a name="893"></a>                {                    
<a name="894"></a>                    /* resolve this phrase */
<a name="895"></a>                    c.resolveNouns();
<a name="896"></a>                    
<a name="897"></a>                    /* success - take this as the result; look no further */
<a name="898"></a>                    /* 
<a name="899"></a>                     *   But only if we haven't yet got a command or the new
<a name="900"></a>                     *   command didn't have to create a new Topic object.
<a name="901"></a>                     */
<a name="902"></a>                    if(cmd == nil || !c.madeTopic)
<a name="903"></a>                        cmd = c;
<a name="904"></a>                    
<a name="905"></a>                    /* 
<a name="906"></a>                     *   But if this command had to create a new Topic object,
<a name="907"></a>                     *   let's go on to see if we can find a better match.
<a name="908"></a>                     */
<a name="909"></a>                    if(!cmd.madeTopic)
<a name="910"></a>                       break;
<a name="911"></a>                }
<a name="912"></a>                catch(InsufficientNounsError err)
<a name="913"></a>                {
<a name="914"></a>                    c.cmdErr = err;
<a name="915"></a>                    throw err;
<a name="916"></a>                }
<a name="917"></a>                catch(NoneInOwnerError err)
<a name="918"></a>                {
<a name="919"></a>                    c.cmdErr = err;
<a name="920"></a>                    throw err;
<a name="921"></a>                }
<a name="922"></a>                
<a name="923"></a>                catch (ParseError err)
<a name="924"></a>                {
<a name="925"></a>                    /* save the error with the command */
<a name="926"></a>                    c.cmdErr = err;
<a name="927"></a>                    
<a name="928"></a>                    /* 
<a name="929"></a>                     *   That didn't resolve correctly.  But don't actually
<a name="930"></a>                     *   show the error message yet; instead, continue through
<a name="931"></a>                     *   the list to see if we can find another alternative
<a name="932"></a>                     *   that we can resolve.
<a name="933"></a>                     *   
<a name="934"></a>                     *   If it's the first curable error we've seen, note it. 
<a name="935"></a>                     */
<a name="936"></a>                    if (err.curable &amp;&amp; curable == nil)
<a name="937"></a>                        curable = c;
<a name="938"></a>                }
<a name="939"></a>            }
<a name="940"></a>        }
<a name="941"></a>        else if (args.matchProto([Command]))
<a name="942"></a>        {
<a name="943"></a>            /* get the command - it's the single list entry */
<a name="944"></a>            cmd = args[1];
<a name="945"></a>            cmdLst = [cmd];
<a name="946"></a>        }
<a name="947"></a>        else if (args.matchProto([]))
<a name="948"></a>        {
<a name="949"></a>            /* empty command list */
<a name="950"></a>            cmd = nil;
<a name="951"></a>            cmdLst = [];
<a name="952"></a>        }
<a name="953"></a>        else
<a name="954"></a>            throw new ArgumentMismatchError();
<a name="955"></a>    }
<a name="956"></a>
<a name="957"></a>    /* number of parsings in the list */
<a name="958"></a>    length() { return cmdLst.length(); }
<a name="959"></a>
<a name="960"></a>    /*
<a name="961"></a>     *   Accept a curable resolution as the actual resolution.  If we don't
<a name="962"></a>     *   have an error-free resolution, we'll set 'cmd' to the curable
<a name="963"></a>     *   resolution.  Returns true if we have any resolution, nil if not.  
<a name="964"></a>     */
<a name="965"></a>    acceptCurable()
<a name="966"></a>    {
<a name="967"></a>        /* if we don't have an error-free resolution, accept a curable one */
<a name="968"></a>        if (cmd == nil)
<a name="969"></a>            cmd = curable;
<a name="970"></a>
<a name="971"></a>        /* indicate whether we have a resolution now */
<a name="972"></a>        return cmd;
<a name="973"></a>    }
<a name="974"></a>
<a name="975"></a>    /*
<a name="976"></a>     *   Accept ANY command, with or without a resolution error, curable or
<a name="977"></a>     *   not.  We'll take the error-free resolution if we have one,
<a name="978"></a>     *   otherwise the resolution with a curable error, otherwise just the
<a name="979"></a>     *   first parsing in priority order. 
<a name="980"></a>     */
<a name="981"></a>    acceptAny()
<a name="982"></a>    {
<a name="983"></a>        /* accept the best command, and return it */
<a name="984"></a>        return cmd = getBestCmd();
<a name="985"></a>    }
<a name="986"></a>
<a name="987"></a>    /*
<a name="988"></a>     *   Get the most promising command from the available parsings.  This
<a name="989"></a>     *   returns the first successfully resolved command in priority order,
<a name="990"></a>     *   if any; otherwise the first command with a curable error, if any;
<a name="991"></a>     *   otherwise the first command in priority order.  
<a name="992"></a>     */
<a name="993"></a>    getBestCmd()
<a name="994"></a>    {
<a name="995"></a>        /* if we have a parsed and resolved command, return it */
<a name="996"></a>        if (cmd != nil)
<a name="997"></a>            return cmd;
<a name="998"></a>
<a name="999"></a>        /* if we have a curable command, return it */
<a name="1000"></a>        if (curable != nil)
<a name="1001"></a>            return curable;
<a name="1002"></a>
<a name="1003"></a>        /* if we have any parsing at all, return the first one */
<a name="1004"></a>        if (cmdLst.length() &gt; 0)
<a name="1005"></a>            return cmdLst[1];
<a name="1006"></a>
<a name="1007"></a>        /* we don't have any parsing */
<a name="1008"></a>        return nil;
<a name="1009"></a>    }
<a name="1010"></a>
<a name="1011"></a>    /*
<a name="1012"></a>     *   Get the resolution error, if any.  If we parsed but didn't
<a name="1013"></a>     *   resolve, this returns the error from the first parsing in priority
<a name="1014"></a>     *   order.  
<a name="1015"></a>     */
<a name="1016"></a>    getResErr()
<a name="1017"></a>    {
<a name="1018"></a>        /* if we resolved a command, return any error from it */
<a name="1019"></a>        if (cmd != nil)
<a name="1020"></a>            return cmd.cmdErr;
<a name="1021"></a>
<a name="1022"></a>        /* if we have a curable error, return it */
<a name="1023"></a>        if (curable != nil)
<a name="1024"></a>            return curable.cmdErr;
<a name="1025"></a>
<a name="1026"></a>        /* otherwise, return the first item with a cmdErr */
<a name="1027"></a>        local c = cmdLst.valWhich({ c: c.cmdErr != nil });
<a name="1028"></a>        return (c != nil ? c.cmdErr : nil);
<a name="1029"></a>    }
<a name="1030"></a>
<a name="1031"></a>    /* our list of Command objects */
<a name="1032"></a>    cmdLst = []
<a name="1033"></a>
<a name="1034"></a>    /* 
<a name="1035"></a>     *   Our resolved Command.  This is the first parsing in our list that
<a name="1036"></a>     *   (in priority order) we were able to resolve with no errors.  
<a name="1037"></a>     */
<a name="1038"></a>    cmd = nil
<a name="1039"></a>
<a name="1040"></a>    /* 
<a name="1041"></a>     *   Our semi-resolved Command.  When we can't find a command that
<a name="1042"></a>     *   resolves without errors, we'll set this to the first one (in
<a name="1043"></a>     *   priority order) that resolves with a curable error.  
<a name="1044"></a>     */
<a name="1045"></a>    curable = nil
<a name="1046"></a>;
<a name="1047"></a>
<a name="1048"></a>
<a name="1049"></a>/* ------------------------------------------------------------------------ */
<a name="1050"></a>/*
<a name="1051"></a> *   A Question is an interactive question we ask the player via the
<a name="1052"></a> *   regular command line.  The player then has the option to answer the
<a name="1053"></a> *   question, or to ignore the question and enter a new command.
<a name="1054"></a> *   
<a name="1055"></a> *   The parser uses Question objects internally to handle certain errors
<a name="1056"></a> *   that the player can fix by entering additional information, such as
<a name="1057"></a> *   disambiguation queries and missing noun phrase queries.  Games can use
<a name="1058"></a> *   Question objects for other, custom interactions.
<a name="1059"></a> *   
<a name="1060"></a> *   The basic Question object is incomplete - you have to subclass it to
<a name="1061"></a> *   get a functional question handler.  In particular, you must provide a
<a name="1062"></a> *   parseAnswer() routine that parses the reply and creates a Command to
<a name="1063"></a> *   carry out the action of answering the question.  
<a name="1064"></a> */
<a name="1065"></a>class Question: object
<a name="1066"></a>    /*
<a name="1067"></a>     *   Priority: Should the answer be parsed before checking for a
<a name="1068"></a>     *   regular command entry?  If this is true, the parser will try
<a name="1069"></a>     *   parsing the player's input as an answer to this question BEFORE it
<a name="1070"></a>     *   tries parsing the input as a regular command.  If the answer
<a name="1071"></a>     *   parses, we'll assume it really is an answer to the question, and
<a name="1072"></a>     *   we won't even try parsing it as a new command.
<a name="1073"></a>     *   
<a name="1074"></a>     *   For disambiguation and missing noun queries, the parser only
<a name="1075"></a>     *   parses question replies AFTER parsing regular commands.  Replies
<a name="1076"></a>     *   to these questions are frequently very short, abbreviated noun
<a name="1077"></a>     *   phrases - maybe just a single adjective or noun.  It's fairly
<a name="1078"></a>     *   common for there be at least a few nouns that are the same as
<a name="1079"></a>     *   verbs in the game, so the input after a disambiguation or missing
<a name="1080"></a>     *   noun reply can often be interpreted equally well as a new verb or
<a name="1081"></a>     *   as a reply to the question.  There's probably no theoretical basis
<a name="1082"></a>     *   for choosing one over the other when this happens, but in practice
<a name="1083"></a>     *   it seems that it's usually better to treat the reply as a new
<a name="1084"></a>     *   command.  So, by default we set this property to nil, to give
<a name="1085"></a>     *   priority to a new command.
<a name="1086"></a>     *   
<a name="1087"></a>     *   Custom questions posed by the game might want to give higher
<a name="1088"></a>     *   priority to the answer interpretation, though.  Yes/No questions
<a name="1089"></a>     *   in particular will probably want to do this, because otherwise the
<a name="1090"></a>     *   parser would take the answer as a conversational overture to any
<a name="1091"></a>     *   nearby NPC.  
<a name="1092"></a>     */
<a name="1093"></a>    priority = nil
<a name="1094"></a>    
<a name="1095"></a>    /*
<a name="1096"></a>     *   Parse the answer.  'toks' is the token list of the user's input,
<a name="1097"></a>     *   and 'dict' is the main parser Dictionary object.
<a name="1098"></a>     *   
<a name="1099"></a>     *   If the input does look like a valid answer to the question,
<a name="1100"></a>     *   returns a CommandList with the parsed reply.  If not, returns nil,
<a name="1101"></a>     *   in which case the parser will continue trying to parse the input
<a name="1102"></a>     *   as a whole new command.
<a name="1103"></a>     *   
<a name="1104"></a>     *   By default, we simply return nil.  Subclasses/instances must
<a name="1105"></a>     *   override this to provide the custom answer parsing.  
<a name="1106"></a>     */
<a name="1107"></a>    parseAnswer(toks, dict) { return nil; }
<a name="1108"></a>
<a name="1109"></a>    /* the answer template */
<a name="1110"></a>    answerTemplate = nil
<a name="1111"></a>;
<a name="1112"></a>
<a name="1113"></a>/*
<a name="1114"></a> *   A GramQuestion is a question handler that parses an answer using a
<a name="1115"></a> *   grammar rule.
<a name="1116"></a> */
<a name="1117"></a>class GramQuestion: Question
<a name="1118"></a>    /*
<a name="1119"></a>     *   Create a simple question.  'prod' is the root GrammarProd to use
<a name="1120"></a>     *   for parsing the reply.  'func' is a callback function that carries
<a name="1121"></a>     *   out the action of the answering the question.  'func' is invoked
<a name="1122"></a>     *   with a single argument giving the Command object representing the
<a name="1123"></a>     *   answer; you can get the match tree from the Command if you need
<a name="1124"></a>     *   the parsed form of the answer input.  
<a name="1125"></a>     */
<a name="1126"></a>    construct(prod, func)
<a name="1127"></a>    {
<a name="1128"></a>        answerProd = prod;
<a name="1129"></a>        answerFunc = func;
<a name="1130"></a>    }
<a name="1131"></a>
<a name="1132"></a>    /*
<a name="1133"></a>     *   Parse the answer.  We'll match the token list against the grammar
<a name="1134"></a>     *   rule.  If we find a match, we'll call makeCommand() to create the
<a name="1135"></a>     *   command to carry out the action of answering the question.  
<a name="1136"></a>     */
<a name="1137"></a>    parseAnswer(toks, dict)
<a name="1138"></a>    {
<a name="1139"></a>        /* try parsing against our grammar rule */
<a name="1140"></a>        return new CommandList(
<a name="1141"></a>            answerProd, toks, dict, { p: makeCommand(p) });
<a name="1142"></a>    }
<a name="1143"></a>
<a name="1144"></a>    /*
<a name="1145"></a>     *   Create a Command object for a successful grammar match.  'prod' is
<a name="1146"></a>     *   the root match object of the grammar match.  This returns a
<a name="1147"></a>     *   suitable Command that carries out the action of answering the
<a name="1148"></a>     *   question.  
<a name="1149"></a>     */
<a name="1150"></a>    makeCommand(prod) { return new FuncCommand(prod, answerFunc); }
<a name="1151"></a>
<a name="1152"></a>    /* the GrammarProd rule that we use to parse the answer */
<a name="1153"></a>    answerProd = nil
<a name="1154"></a>
<a name="1155"></a>    /* the callback function that carries out the reply action */
<a name="1156"></a>    answerFunc = nil
<a name="1157"></a>;
<a name="1158"></a>
<a name="1159"></a>/*
<a name="1160"></a> *   A YesNoQuestion is a simple subclass of Question for asking
<a name="1161"></a> *   interactive questions with Yes or No answers. 
<a name="1162"></a> */
<a name="1163"></a>class YesNoQuestion: GramQuestion
<a name="1164"></a>    /*
<a name="1165"></a>     *   Create - 'func' is the callback function to invoke on answering
<a name="1166"></a>     *   the question.  This is invoked with one argument, true if the
<a name="1167"></a>     *   answer was Yes, nil if the answer was No.  
<a name="1168"></a>     */
<a name="1169"></a>    construct(func)
<a name="1170"></a>    {
<a name="1171"></a>        /* 
<a name="1172"></a>         *   Parse our answer against the simple yes-or-no grammar.  To
<a name="1173"></a>         *   execute the answer, call the user's callback, providing the
<a name="1174"></a>         *   yes/no result from the Command.  The yes-or-no production sets
<a name="1175"></a>         *   the yesOrNoAnswer property in the Command during the build
<a name="1176"></a>         *   process.  
<a name="1177"></a>         */
<a name="1178"></a>        inherited(yesOrNoPhrase, { cmd: func(cmd.yesOrNoAnswer) });
<a name="1179"></a>    }
<a name="1180"></a>
<a name="1181"></a>    /* 
<a name="1182"></a>     *   parse Yes/No replies ahead of new commands, since we'd otherwise
<a name="1183"></a>     *   never get an answer - the parser would always match the reply to a
<a name="1184"></a>     *   conversational verb instead 
<a name="1185"></a>     */
<a name="1186"></a>    priority = true
<a name="1187"></a>;
<a name="1188"></a>
<a name="1189"></a>/*
<a name="1190"></a> *   A RexQuestion is a simple subclass of Question for parsing answers
<a name="1191"></a> *   with regular expressions. 
<a name="1192"></a> */
<a name="1193"></a>class RexQuestion: Question
<a name="1194"></a>    /*
<a name="1195"></a>     *   Create - 'pat' is the regular expression pattern, as either a
<a name="1196"></a>     *   string or a RexPattern object.  We'll parse an answer simply by
<a name="1197"></a>     *   matching it against the regular expression; if we match, we'll
<a name="1198"></a>     *   take it as an answer.  'func' is a callback function that we'll
<a name="1199"></a>     *   call to carry out the action of answering the question.  We'll
<a name="1200"></a>     *   invoke this with one argument giving the literal text of the
<a name="1201"></a>     *   input.  
<a name="1202"></a>     */
<a name="1203"></a>    construct(pat, func)
<a name="1204"></a>    {
<a name="1205"></a>        answerPat = pat;
<a name="1206"></a>        answerFunc = func;
<a name="1207"></a>    }
<a name="1208"></a>
<a name="1209"></a>    parseAnswer(toks, dict)
<a name="1210"></a>    {
<a name="1211"></a>        /* reconstruct the string input */
<a name="1212"></a>        local str = cmdTokenizer.buildOrigText(toks);
<a name="1213"></a>
<a name="1214"></a>        /* check for a match to our pattern */
<a name="1215"></a>        if (rexMatch(answerPat, str,) != nil)
<a name="1216"></a>        {
<a name="1217"></a>            /* set up a single-entry command list for the answer */
<a name="1218"></a>            return new CommandList(new FuncCommand(
<a name="1219"></a>                nil, { cmd: answerFunc(str) }));
<a name="1220"></a>        }
<a name="1221"></a>        else
<a name="1222"></a>        {
<a name="1223"></a>            /* no match */
<a name="1224"></a>            return nil;
<a name="1225"></a>        }
<a name="1226"></a>    }
<a name="1227"></a>
<a name="1228"></a>    /* the regular expression pattern to match */
<a name="1229"></a>    answerPat = nil
<a name="1230"></a>
<a name="1231"></a>    /* the callback to invoke on answering */
<a name="1232"></a>    answerFunc = nil
<a name="1233"></a>;
<a name="1234"></a>
<a name="1235"></a>/*
<a name="1236"></a> *   An ErrorQuestion is a subclass of Question for curable parsing errors.
<a name="1237"></a> */
<a name="1238"></a>class ParseErrorQuestion: Question
<a name="1239"></a>    construct(err)
<a name="1240"></a>    {
<a name="1241"></a>        /* remember the ParseError object */
<a name="1242"></a>        self.err = err;
<a name="1243"></a>    }
<a name="1244"></a>
<a name="1245"></a>    parseAnswer(toks, dict)
<a name="1246"></a>    {
<a name="1247"></a>        /* ask the error to parse the response */
<a name="1248"></a>        return err.tryCuring(toks, dict);
<a name="1249"></a>    }
<a name="1250"></a>
<a name="1251"></a>    /* the curable ParseError that posed the question */
<a name="1252"></a>    err = nil
<a name="1253"></a>    
<a name="1254"></a>    /* 
<a name="1255"></a>     *   Should we prioritize interpreting player input to a parser query as a response to that
<a name="1256"></a>     *   query over interpreting it as a nea command (where the latter is possible)? By default we
<a name="1257"></a>     *   do (since this seems more likely to reflect player intention in this case), although game
<a name="1258"></a>     *   code can override if desired.
<a name="1259"></a>     */
<a name="1260"></a>    priority = true
<a name="1261"></a>;
<a name="1262"></a>
<a name="1263"></a>
<a name="1264"></a>/* ------------------------------------------------------------------------ */
<a name="1265"></a>/*
<a name="1266"></a> *   A Distinguisher is an abstract parser object that represents one way
<a name="1267"></a> *   that we can tell two objects apart, both in the name we display and in
<a name="1268"></a> *   command input.
<a name="1269"></a> *   
<a name="1270"></a> *   Note that this class is designed primarily for the parser's internal
<a name="1271"></a> *   use, to facilitate some bookkeeping that we have to do during
<a name="1272"></a> *   disambiguation.  It's not really designed as an extensibility
<a name="1273"></a> *   mechanism, because it's not usually enough to just add a new instance:
<a name="1274"></a> *   you usually also have to add grammar for whatever new phrasing the new
<a name="1275"></a> *   distinguisher represents, plus object resolution code to handle the
<a name="1276"></a> *   new form of qualification.  
<a name="1277"></a> */
<a name="1278"></a>class Distinguisher: object
<a name="1279"></a>    /* 
<a name="1280"></a>     *   Sorting order.  The parser sorts the master list of distinguishers
<a name="1281"></a>     *   in ascending order of this value to determine the order of
<a name="1282"></a>     *   application.  
<a name="1283"></a>     */
<a name="1284"></a>    sortOrder = 0
<a name="1285"></a>
<a name="1286"></a>    /*
<a name="1287"></a>     *   Compare two objects for equivalence under this distinguisher.
<a name="1288"></a>     *   Returns true if the objects are equivalent, nil others. 
<a name="1289"></a>     */
<a name="1290"></a>    equal(a, b) { return nil; }
<a name="1291"></a>
<a name="1292"></a>    /* 
<a name="1293"></a>     *   Is this distinguisher applicable to the given object?  Some
<a name="1294"></a>     *   distinguishers can only apply to certain objects.  For example, a
<a name="1295"></a>     *   Lit/Unlit distinguisher can only be applied to objects with that
<a name="1296"></a>     *   state variable, because there's no vocabulary that we can add to
<a name="1297"></a>     *   an object without the variable.  (We can talk about "lit" and
<a name="1298"></a>     *   "unlit" matches, but we don't have any standard vocabulary to talk
<a name="1299"></a>     *   about "unlightable" matches.)  
<a name="1300"></a>     */
<a name="1301"></a>    appliesTo(obj) { return true; }
<a name="1302"></a>
<a name="1303"></a>    /*
<a name="1304"></a>     *   Apply the distinguisher.  Returns a DistResult object with the
<a name="1305"></a>     *   results.  
<a name="1306"></a>     */
<a name="1307"></a>    apply(lst)
<a name="1308"></a>    {
<a name="1309"></a>        /* create the results object */
<a name="1310"></a>        local r = new DistResult(self);
<a name="1311"></a>
<a name="1312"></a>        /* set up the list of applicable objects */
<a name="1313"></a>        r.appliesTo = lst.subset({ obj: appliesTo(obj) });
<a name="1314"></a>
<a name="1315"></a>        /* make a to-do vector, starting with all applicable items */
<a name="1316"></a>        local toDo = new Vector(10, r.appliesTo);
<a name="1317"></a>
<a name="1318"></a>        /* process each item in the to-do list */
<a name="1319"></a>        while (toDo.length() &gt; 0)
<a name="1320"></a>        {
<a name="1321"></a>            /* pop the last item */
<a name="1322"></a>            local obj = toDo.pop();
<a name="1323"></a>
<a name="1324"></a>            /* start a partition list for this item and its equivalents */
<a name="1325"></a>            local sv = new Vector(10);
<a name="1326"></a>
<a name="1327"></a>            /* start the partition with the current object */
<a name="1328"></a>            sv.append(obj);
<a name="1329"></a>
<a name="1330"></a>            /* add the new partition to the partition list */
<a name="1331"></a>            r.partitioned.append(sv);
<a name="1332"></a>
<a name="1333"></a>            /* scan the to-do list for items equivalent to obj */
<a name="1334"></a>            for (local i = toDo.length() ; i &gt; 0 ; --i)
<a name="1335"></a>            {
<a name="1336"></a>                /* get this item and check for equivalence to obj */
<a name="1337"></a>                local obj2 = toDo[i];
<a name="1338"></a>                if (equal(obj, obj2))
<a name="1339"></a>                {
<a name="1340"></a>                    /* it's equivalent to obj, so add it to obj's partition */
<a name="1341"></a>                    sv.append(obj2);
<a name="1342"></a>
<a name="1343"></a>                    /* it's been processed; remove it from the to-do list */
<a name="1344"></a>                    toDo.removeElementAt(i);
<a name="1345"></a>                }
<a name="1346"></a>            }
<a name="1347"></a>        }
<a name="1348"></a>
<a name="1349"></a>        /* return the result object */
<a name="1350"></a>        return r;
<a name="1351"></a>    }
<a name="1352"></a>
<a name="1353"></a>    /* class property: master list of all distinguishers */
<a name="1354"></a>    all = []
<a name="1355"></a>
<a name="1356"></a>    /* during initialization, build the master list */
<a name="1357"></a>    classInit()
<a name="1358"></a>    {
<a name="1359"></a>        /* add each instance to the master list */
<a name="1360"></a>        forEachInstance(Distinguisher, {d: all += d});
<a name="1361"></a>
<a name="1362"></a>        /* arrange by sortOrder */
<a name="1363"></a>        all = all.sort(SortAsc, {a, b: a.sortOrder - b.sortOrder});
<a name="1364"></a>    }
<a name="1365"></a>
<a name="1366"></a>    /* make sure the StateDistinguisher instances are constructed first */
<a name="1367"></a>    classInitFirst = [StateDistinguisher]
<a name="1368"></a>
<a name="1369"></a>    /*
<a name="1370"></a>     *   Class method: generate distinguishing names for a list of objects.
<a name="1371"></a>     *   This generates names that distinguish the objects from one
<a name="1372"></a>     *   another, by applying as many Distinguishers as needed to come up
<a name="1373"></a>     *   with unique names.
<a name="1374"></a>     *   
<a name="1375"></a>     *   If 'article' is true, we'll use a definite or indefinite article,
<a name="1376"></a>     *   as appropriate: definite if the name we settle upon uniquely
<a name="1377"></a>     *   identifies the object within the list, indefinite if not.  If
<a name="1378"></a>     *   'article' is nil, the names don't have articles at all.
<a name="1379"></a>     *   
<a name="1380"></a>     *   Returns a list of [name, [objects]] sublists.  The name is a
<a name="1381"></a>     *   string giving the distinguished name; the [objects] sub-sublist is
<a name="1382"></a>     *   a list of the objects known under that name.  
<a name="1383"></a>     */
<a name="1384"></a>    getNames(objs, article)
<a name="1385"></a>    {
<a name="1386"></a>        /* start with an empty result list */
<a name="1387"></a>        local names = new Vector(objs.length());
<a name="1388"></a>
<a name="1389"></a>        /* start with an empty list of distinguisher results */
<a name="1390"></a>        local dres = new Vector(Distinguisher.all.length());
<a name="1391"></a>
<a name="1392"></a>        /* apply each distinguisher to our objects, saving the results */
<a name="1393"></a>        foreach (local d in Distinguisher.all)
<a name="1394"></a>            dres.append(d.apply(objs));
<a name="1395"></a>
<a name="1396"></a>        /* find the distinguishing characteristics for each object */
<a name="1397"></a>        while (objs.length() != 0)
<a name="1398"></a>        {
<a name="1399"></a>            /* treat the to-do list as a stack: pop an object */
<a name="1400"></a>            local obj = objs.pop();
<a name="1401"></a>
<a name="1402"></a>            /* get the subset of dist results that apply to this object */
<a name="1403"></a>            local ores = dres.subset({ r: r.appliesTo.indexOf(obj) != nil });
<a name="1404"></a>
<a name="1405"></a>            /*
<a name="1406"></a>             *   What we're after is the minimum set of distinguishers that
<a name="1407"></a>             *   can tell this object apart from as many of the others as
<a name="1408"></a>             *   possible.
<a name="1409"></a>             *   
<a name="1410"></a>             *   In the best case, there's a single distinguisher that can
<a name="1411"></a>             *   pick out this object uniquely.  For example, if this is
<a name="1412"></a>             *   the lit match, and all the other matches are unlit, the
<a name="1413"></a>             *   Lit/Unlit State distinguisher is all we need: 'lit'
<a name="1414"></a>             *   uniquely identifies this object among our set.  If that's
<a name="1415"></a>             *   the case, obj will appear in the Lit/Unlit list in its own
<a name="1416"></a>             *   partition, with no other objects.
<a name="1417"></a>             *   
<a name="1418"></a>             *   It might be that there's no one distinguisher that can
<a name="1419"></a>             *   tell obj apart from all of the others.  But perhaps a
<a name="1420"></a>             *   combination of two distinguishers can: perhaps obj is one
<a name="1421"></a>             *   of two lit matches, and one of two matches belonging to
<a name="1422"></a>             *   Bob, but it's the only lit match belonging to Bob.  We'd
<a name="1423"></a>             *   thus find obj in two partitions of two objects each;
<a name="1424"></a>             *   intersecting the two will yield a list with just one
<a name="1425"></a>             *   element, so we'd get down to a unique object again.
<a name="1426"></a>             *   
<a name="1427"></a>             *   We might not ever get down to a single-object partition,
<a name="1428"></a>             *   even after combining several distinguishers, since we
<a name="1429"></a>             *   might be truly indistinguishable from one or more other
<a name="1430"></a>             *   objects.  In such a case, we'll have to group the objects
<a name="1431"></a>             *   and ask if the player means "*a* lit match of Bob's", say.
<a name="1432"></a>             *   
<a name="1433"></a>             *   In any case, our fastest route to the smallest set is to
<a name="1434"></a>             *   start with the smallest set, and intersect against larger
<a name="1435"></a>             *   sets until we get down to one object or run out of other
<a name="1436"></a>             *   sets to intersect.  So start by sorting the results by the
<a name="1437"></a>             *   size of the partition in which obj appears, smallest to
<a name="1438"></a>             *   largest.  
<a name="1439"></a>             */
<a name="1440"></a>            ores.sort(SortAsc, new function(a, b)
<a name="1441"></a>            {
<a name="1442"></a>                /* sort by partition size */
<a name="1443"></a>                local asiz = a.partSize(obj);
<a name="1444"></a>                local bsiz = b.partSize(obj);
<a name="1445"></a>
<a name="1446"></a>                /* if they differ, sort according to the relative sizes */
<a name="1447"></a>                if (asiz != bsiz)
<a name="1448"></a>                    return asiz - bsiz;
<a name="1449"></a>
<a name="1450"></a>                /* same size partitions; sort by Distinguisher order */
<a name="1451"></a>                return a.distinguisher.sortOrder - b.distinguisher.sortOrder;
<a name="1452"></a>            });
<a name="1453"></a>
<a name="1454"></a>            /* we haven't used any distinguishers yet */
<a name="1455"></a>            local used = new Vector(10);
<a name="1456"></a>
<a name="1457"></a>            /* 
<a name="1458"></a>             *   Start with the first distinguisher in the list, and its
<a name="1459"></a>             *   initial set.  Note that we're guaranteed to have at least
<a name="1460"></a>             *   one result in the list, since the basic name distinguisher
<a name="1461"></a>             *   applies to everything.  
<a name="1462"></a>             */
<a name="1463"></a>            used.append(ores[1].distinguisher);
<a name="1464"></a>            local rem = ores[1].partition(obj).toList();
<a name="1465"></a>
<a name="1466"></a>            /* 
<a name="1467"></a>             *   now apply additional distinguishers until we get the set
<a name="1468"></a>             *   down to one object, or run out of distinguishers 
<a name="1469"></a>             */
<a name="1470"></a>            for (local i = 2, local olen = ores.length() ;
<a name="1471"></a>                 rem.length() &gt; 1 &amp;&amp; i &lt;= olen ; ++i)
<a name="1472"></a>            {
<a name="1473"></a>                /* 
<a name="1474"></a>                 *   figure the intersection of this distinguisher
<a name="1475"></a>                 *   partition with the remaining set 
<a name="1476"></a>                 */
<a name="1477"></a>                local rcur = ores[i];
<a name="1478"></a>                local isect = rem.intersect(rcur.partition(obj).toList());
<a name="1479"></a>
<a name="1480"></a>                /* 
<a name="1481"></a>                 *   If that reduced the set size, keep the result.  Ignore
<a name="1482"></a>                 *   distinguishers that don't reduce the set size, because
<a name="1483"></a>                 *   they don't help - they'd just add words to the
<a name="1484"></a>                 *   generated name without helping to tell things apart.  
<a name="1485"></a>                 */
<a name="1486"></a>                if (isect.length() &lt; rem.length())
<a name="1487"></a>                {
<a name="1488"></a>                    /* keep the reduced list */
<a name="1489"></a>                    rem = isect;
<a name="1490"></a>
<a name="1491"></a>                    /* note that we used this distinguisher */
<a name="1492"></a>                    used.append(rcur.distinguisher);
<a name="1493"></a>                }
<a name="1494"></a>            }
<a name="1495"></a>
<a name="1496"></a>            /* 
<a name="1497"></a>             *   We've thrown out as many distinguishable items as
<a name="1498"></a>             *   possible, and in the process we've built a list of the
<a name="1499"></a>             *   distinguishing characteristics that we needed in order to
<a name="1500"></a>             *   tell this object apart from the others.  Generate the
<a name="1501"></a>             *   name, based on that list of characteristics.  If we
<a name="1502"></a>             *   whittled the set size down to a single object, use a
<a name="1503"></a>             *   definite article; otherwise, we have a group of
<a name="1504"></a>             *   indistinguishable objects, so use an indefinite article to
<a name="1505"></a>             *   refer to an arbitrary one of these.  
<a name="1506"></a>             */
<a name="1507"></a>            local rlen = rem.length();
<a name="1508"></a>            local nm = obj.distinguishedName(
<a name="1509"></a>                article ? (rlen == 1 ? Definite : Indefinite) : Unqualified,
<a name="1510"></a>                used);
<a name="1511"></a>
<a name="1512"></a>            /* 
<a name="1513"></a>             *   This name covers the whole group, so remove all of the of
<a name="1514"></a>             *   additional objects from the to-do list.  (We've already
<a name="1515"></a>             *   removed the first one, so don't waste time looking for it
<a name="1516"></a>             *   again.)  
<a name="1517"></a>             */
<a name="1518"></a>            for (local i = 2 ; i &lt;= rlen ; ++i)
<a name="1519"></a>                objs.removeElement(rem[i]);
<a name="1520"></a>
<a name="1521"></a>            /* append this name result */
<a name="1522"></a>            names.append([nm, rem]);
<a name="1523"></a>        }
<a name="1524"></a>
<a name="1525"></a>        /* return the name list */
<a name="1526"></a>        return names;
<a name="1527"></a>    }
<a name="1528"></a>;
<a name="1529"></a>
<a name="1530"></a>/*
<a name="1531"></a> *   Result object from applying a Distinguisher to a set of objects. 
<a name="1532"></a> */
<a name="1533"></a>class DistResult: object
<a name="1534"></a>    construct(dist)
<a name="1535"></a>    {
<a name="1536"></a>        /* remember the distinguisher */
<a name="1537"></a>        distinguisher = dist;
<a name="1538"></a>
<a name="1539"></a>        /* set up a vector for the partition list */
<a name="1540"></a>        partitioned = new Vector(10);
<a name="1541"></a>    }
<a name="1542"></a>
<a name="1543"></a>    /* get the partition in which 'obj' appears */
<a name="1544"></a>    partition(obj)
<a name="1545"></a>    {
<a name="1546"></a>        return partitioned.valWhich({ p: p.indexOf(obj) != nil });
<a name="1547"></a>    }
<a name="1548"></a>
<a name="1549"></a>    /* get the size of the partition in which 'obj' appears */
<a name="1550"></a>    partSize(obj)
<a name="1551"></a>    {
<a name="1552"></a>        return partition(obj).length();
<a name="1553"></a>    }
<a name="1554"></a>
<a name="1555"></a>    /* the objects that the distinguisher applies to */
<a name="1556"></a>    appliesTo = []
<a name="1557"></a>
<a name="1558"></a>    /* 
<a name="1559"></a>     *   The partitioned list of objects.  This is a list of lists.  Each
<a name="1560"></a>     *   sublist is a group of objects we can't distinguish from one
<a name="1561"></a>     *   another.  Each object in appliesTo appears once in a sublist, and
<a name="1562"></a>     *   each object in a sublist appears in appliesTo.  
<a name="1563"></a>     */
<a name="1564"></a>    partitioned = []
<a name="1565"></a>
<a name="1566"></a>    /* the Distinguisher that these results come from */
<a name="1567"></a>    distinguisher = nil
<a name="1568"></a>;
<a name="1569"></a>
<a name="1570"></a>/*
<a name="1571"></a> *   The basic name distinguisher distinguishes objects by their base names.
<a name="1572"></a> *   This is the first distinguisher we apply, since the name is always the
<a name="1573"></a> *   easiest way to tell objects apart in parsing. However since one name could
<a name="1574"></a> *   be entirely contained within another (e.g. 'ball' and 'red ball') we
<a name="1575"></a> *   consider the names as equal for this purpose if one of them is part of the
<a name="1576"></a> *   other.
<a name="1577"></a> */
<a name="1578"></a>nameDistinguisher: Distinguisher
<a name="1579"></a>    sortOrder = 100
<a name="1580"></a>    equal(a, b) { return a.name.find(b.name) || b.name.find(a.name); }
<a name="1581"></a>;
<a name="1582"></a>
<a name="1583"></a>/*
<a name="1584"></a> *   The disambiguation name distinguisher.  This distinguishes objects by
<a name="1585"></a> *   their disambiguation names.  We apply this immediately after the basic
<a name="1586"></a> *   name distinguisher, since the disambiguation name is a custom name
<a name="1587"></a> *   provided by the author for the express purpose of distinguishing the
<a name="1588"></a> *   object in parsing.  
<a name="1589"></a> */
<a name="1590"></a>disambigNameDistinguisher: Distinguisher
<a name="1591"></a>    sortOrder = 200
<a name="1592"></a>    equal(a, b) { return a.disambigName == b.disambigName; }
<a name="1593"></a>;
<a name="1594"></a>
<a name="1595"></a>/*
<a name="1596"></a> *   The class for state distinguishers.  A state distinguisher tells
<a name="1597"></a> *   objects apart based on their having distinct current values for a
<a name="1598"></a> *   given state.  During preinit, we create a separate instance of this
<a name="1599"></a> *   for each State object in the game.  
<a name="1600"></a> */
<a name="1601"></a>class StateDistinguisher: Distinguisher
<a name="1602"></a>    sortOrder = 300
<a name="1603"></a>
<a name="1604"></a>    /* we distinguish based on each object's current value for the state */
<a name="1605"></a>    equal(a, b) { return a.(state.stateProp) == b.(state.stateProp); }
<a name="1606"></a>
<a name="1607"></a>    /* we only apply to objects that have our state variable */
<a name="1608"></a>    appliesTo(obj) { return state.appliesTo(obj); }
<a name="1609"></a>    
<a name="1610"></a>    /* build from a State */
<a name="1611"></a>    construct(st)
<a name="1612"></a>    {
<a name="1613"></a>        /* remember the state object */
<a name="1614"></a>        state = st;
<a name="1615"></a>    }
<a name="1616"></a>
<a name="1617"></a>    /* during preinit, build an instance for each State */
<a name="1618"></a>    classInit()
<a name="1619"></a>    {
<a name="1620"></a>        forEachInstance(State, {st: stateList += new StateDistinguisher(st)});
<a name="1621"></a>    }
<a name="1622"></a>
<a name="1623"></a>    /* the State this distinguisher tests */
<a name="1624"></a>    state = nil
<a name="1625"></a>
<a name="1626"></a>    /* class property: the list of state distinguisher instances */
<a name="1627"></a>    stateList = []
<a name="1628"></a>;
<a name="1629"></a>
<a name="1630"></a>
<a name="1631"></a>/*
<a name="1632"></a> *   Owner distinguisher.  This tells objects apart based on their nominal
<a name="1633"></a> *   owners (and only applies to objects with nominal owners at all).  
<a name="1634"></a> */
<a name="1635"></a>ownerDistinguisher: Distinguisher
<a name="1636"></a>    sortOrder = 400
<a name="1637"></a>    appliesTo(obj) { return obj.nominalOwner() != nil; }
<a name="1638"></a>    equal(a, b) { return a.nominalOwner() == b.nominalOwner(); }
<a name="1639"></a>;
<a name="1640"></a>
<a name="1641"></a>/*
<a name="1642"></a> *   Location distinguisher.  This tells objects apart based on their
<a name="1643"></a> *   immediate containers. 
<a name="1644"></a> */
<a name="1645"></a>locationDistinguisher: Distinguisher
<a name="1646"></a>    sortOrder = 500
<a name="1647"></a>    equal(a, b) { return a.location == b.location; }
<a name="1648"></a>;
<a name="1649"></a>
<a name="1650"></a>/*
<a name="1651"></a> *   Contents distinguisher.  This tells objects apart based on their
<a name="1652"></a> *   nominal contents (and only applies to objects with nominal contents at
<a name="1653"></a> *   all).  Note that we're interested in the *names* of the contents, so
<a name="1654"></a> *   even if two objects have different contents objects, they're still
<a name="1655"></a> *   considered equal if the contents' names match.  (E.g., two "buckets of
<a name="1656"></a> *   water" are indistinguishable, even if the contents are two distinct
<a name="1657"></a> *   "water" objects.  But "bucket of water" and "bucket of fish" are
<a name="1658"></a> *   distinguishable.)  
<a name="1659"></a> */
<a name="1660"></a>contentsDistinguisher: Distinguisher
<a name="1661"></a>    sortOrder = 600
<a name="1662"></a>    appliesTo(obj) { return obj.distinguishByContents != nil; }
<a name="1663"></a>    equal(a, b)
<a name="1664"></a>    {
<a name="1665"></a>        local ac = a.nominalContents(), bc = b.nominalContents();
<a name="1666"></a>        return (ac != nil ? ac.name : nil) == (bc != nil ? bc.name : nil);
<a name="1667"></a>    }
<a name="1668"></a>;
<a name="1669"></a>    
<a name="1670"></a>
<a name="1671"></a>/* ------------------------------------------------------------------------ */
<a name="1672"></a>/*
<a name="1673"></a> *   A NounPhrase object represents a noun phrase within a command line.
<a name="1674"></a> *   This class handles the mapping from the text of the noun phrase in the
<a name="1675"></a> *   input to the game-world objects that the noun phrase refers to.
<a name="1676"></a> *   
<a name="1677"></a> *   This object encompasses a core noun phrase plus all of its qualifiers.
<a name="1678"></a> *   Qualifiers can themselves be noun phrases: possessives, locationals,
<a name="1679"></a> *   and contents phrases contain subsidiary noun phrases, so we represent
<a name="1680"></a> *   these qualifiers with subsidiary NounPhrase objects.  
<a name="1681"></a> */
<a name="1682"></a>class NounPhrase: object
<a name="1683"></a>    /* create */
<a name="1684"></a>    construct(parent, prod)
<a name="1685"></a>    {
<a name="1686"></a>        /* 
<a name="1687"></a>         *   remember the parent NounPhrase and the grammar production
<a name="1688"></a>         *   match object that's the source of the noun phrase
<a name="1689"></a>         */
<a name="1690"></a>        self.parent = parent;
<a name="1691"></a>        self.prod = self.coreProd = prod;
<a name="1692"></a>    }
<a name="1693"></a>
<a name="1694"></a>    /* clone - create a modifiable copy based on this original noun phrase */
<a name="1695"></a>    clone()
<a name="1696"></a>    {
<a name="1697"></a>        /* create a new object with my same property values */
<a name="1698"></a>        local cl = createClone();
<a name="1699"></a>
<a name="1700"></a>        /* make safe copies of any vectors */
<a name="1701"></a>        foreach (local p in cl.getPropList())
<a name="1702"></a>        {
<a name="1703"></a>            local v;
<a name="1704"></a>            if (cl.propType(p) == TypeObject &amp;&amp; (v = cl.(p)).ofKind(Vector))
<a name="1705"></a>                cl.(p) = new Vector(v.length(), v);
<a name="1706"></a>        }
<a name="1707"></a>
<a name="1708"></a>        /* return the clone */
<a name="1709"></a>        return cl;
<a name="1710"></a>    }
<a name="1711"></a>
<a name="1712"></a>    /* 
<a name="1713"></a>     *   By default, use the original input text of my "core" production as
<a name="1714"></a>     *   the name we show for this noun phrase in error messages.  The core
<a name="1715"></a>     *   production is the noun phrase minus any qualifiers (articles,
<a name="1716"></a>     *   possessives, locational phrases, etc).
<a name="1717"></a>     *   
<a name="1718"></a>     *   As we successfully resolve qualifiers, we'll expand this to
<a name="1719"></a>     *   include the qualifying phrases.  Any error we find after resolving
<a name="1720"></a>     *   a qualifier will necessary apply to the qualified form, so we want
<a name="1721"></a>     *   to include the qualifier in any error message.
<a name="1722"></a>     *   
<a name="1723"></a>     *   For example, if the original phrase is BUCKET OF FISH ON TABLE,
<a name="1724"></a>     *   we'll start out with the core phrase of BUCKET.  We'll next
<a name="1725"></a>     *   resolve the contents qualifier, OF FISH.  Assuming that we find a
<a name="1726"></a>     *   BUCKET OF FISH, that becomes the new error name.  If we then fail
<a name="1727"></a>     *   to find such an object ON TABLE, we'll be able to report that
<a name="1728"></a>     *   there's no BUCKET OF FISH on the table.  This is better than
<a name="1729"></a>     *   reporting that we don't see any BUCKET on the table, because there
<a name="1730"></a>     *   could in fact be a different bucket on the table.  
<a name="1731"></a>     */
<a name="1732"></a>    errName = (errNameProd.getText())
<a name="1733"></a>
<a name="1734"></a>    /* the source of the error name is initially the core production */
<a name="1735"></a>    errNameProd = (coreProd)
<a name="1736"></a>
<a name="1737"></a>    /*
<a name="1738"></a>     *   Expand the error-message name to include the given qualifier.
<a name="1739"></a>     *   We'll find the common parent of the core production and the given
<a name="1740"></a>     *   qualifier's production, and use its text as the new error name. 
<a name="1741"></a>     */
<a name="1742"></a>    expandErrName(np)
<a name="1743"></a>    {
<a name="1744"></a>        /* 
<a name="1745"></a>         *   look for the common parent of 'np' and the current error name
<a name="1746"></a>         *   source 
<a name="1747"></a>         */
<a name="1748"></a>        for (local prod = np.prod ; prod != nil ; prod = prod.parent)
<a name="1749"></a>        {
<a name="1750"></a>            /* 
<a name="1751"></a>             *   if this is also a parent of errNameProd, we've found the
<a name="1752"></a>             *   common parent 
<a name="1753"></a>             */
<a name="1754"></a>            if (prod == errNameProd || errNameProd.isChildOf(prod))
<a name="1755"></a>            {
<a name="1756"></a>                /* establish this as the new error name source */
<a name="1757"></a>                errNameProd = prod;
<a name="1758"></a>
<a name="1759"></a>                /* no need to keep looking */
<a name="1760"></a>                break;
<a name="1761"></a>            }
<a name="1762"></a>        }
<a name="1763"></a>    }
<a name="1764"></a>
<a name="1765"></a>    /*
<a name="1766"></a>     *   Does this NounPhrase contain the given NounPhrase?  Returns true
<a name="1767"></a>     *   if NounPhrase is self, or one of our qualifier noun phrases
<a name="1768"></a>     *   contains it. 
<a name="1769"></a>     */
<a name="1770"></a>    contains(np)
<a name="1771"></a>    {
<a name="1772"></a>        return (np == self
<a name="1773"></a>                || (possQual != nil &amp;&amp; possQual.contains(np))
<a name="1774"></a>                || (locQual != nil &amp;&amp; locQual.contains(np))
<a name="1775"></a>                || (exclusions != nil
<a name="1776"></a>                    &amp;&amp; exclusions.indexWhich({ x: x.contains(np) }) != nil));
<a name="1777"></a>    }
<a name="1778"></a>    
<a name="1779"></a>    /*
<a name="1780"></a>     *   Get the list of objects matching the vocabulary words in our noun
<a name="1781"></a>     *   phrase.  Populates our 'matches' property with a vector of matching
<a name="1782"></a>     *   objects.  This doesn't look at any of our qualifiers, or attempt
<a name="1783"></a>     *   to disambiguate contextually; it simply finds everything in scope
<a name="1784"></a>     *   that the noun phrase could refer to.  
<a name="1785"></a>     */
<a name="1786"></a>    matchVocab(cmd)
<a name="1787"></a>    {
<a name="1788"></a>        /* start with an empty vector */
<a name="1789"></a>        local v = new Vector(32);
<a name="1790"></a>
<a name="1791"></a>        /* get the current scope list */        
<a name="1792"></a>        cmd.action.buildScopeList();
<a name="1793"></a>        local scope = cmd.action.scopeList;
<a name="1794"></a>
<a name="1795"></a>        /* check what kind of phrase we have */
<a name="1796"></a>        if (pronoun != nil)
<a name="1797"></a>        {
<a name="1798"></a>            /* it's a pronoun - resolved based on the antecedent */
<a name="1799"></a>            addMatches(v, pronoun.resolve(), 0);
<a name="1800"></a>
<a name="1801"></a>            /* if there are no antecedents, flag the error */
<a name="1802"></a>            if (v.length() == 0)
<a name="1803"></a>                throw new NoAntecedentError(self, pronoun);
<a name="1804"></a>
<a name="1805"></a>            /* filter for in-scope objects (or reflexive placeholders) */
<a name="1806"></a>            v = v.subset(
<a name="1807"></a>                { m: m.obj.ofKind(Pronoun) || scope.find(m.obj) });
<a name="1808"></a>
<a name="1809"></a>            /* if that leaves nothing, flag the error */
<a name="1810"></a>            if (v.length() == 0)
<a name="1811"></a>                throw new AntecedentScopeError(cmd, self, pronoun);
<a name="1812"></a>
<a name="1813"></a>        }
<a name="1814"></a>        else if (determiner == All &amp;&amp; tokens == [])
<a name="1815"></a>        {
<a name="1816"></a>            /* ALL - use everything in scope applicable to the verb */
<a name="1817"></a>            addMatches(v, cmd.action.getAllUnhidden(cmd, role), 0);
<a name="1818"></a>            cmd.matchedAll = true;
<a name="1819"></a>        }
<a name="1820"></a>        else
<a name="1821"></a>        {
<a name="1822"></a>            /* 
<a name="1823"></a>             *   It's a named object.  Our 'tokens' property is a list of
<a name="1824"></a>             *   the words in the noun phrase in the user input.  Match it
<a name="1825"></a>             *   against the objects in physical scope.
<a name="1826"></a>             */
<a name="1827"></a>            v.appendAll(matchNameScope(cmd, scope));
<a name="1828"></a>        }
<a name="1829"></a>
<a name="1830"></a>        /* save the match list so far */
<a name="1831"></a>        matches = v;
<a name="1832"></a>
<a name="1833"></a>        /* if we have a contents qualifier, match its vocabulary */
<a name="1834"></a>        if (contQual != nil)
<a name="1835"></a>        {
<a name="1836"></a>            /* match vocabulary */
<a name="1837"></a>            contQual.matchVocab(cmd);
<a name="1838"></a>
<a name="1839"></a>            /* apply the qualifier to keep only matching items */
<a name="1840"></a>            contQual.applyContQual();
<a name="1841"></a>
<a name="1842"></a>            /* if that empties our list, flag it */
<a name="1843"></a>            if (matches.length() == 0)
<a name="1844"></a>                throw new NoneWithContentsError(cmd, self, contQual);
<a name="1845"></a>
<a name="1846"></a>            /* 
<a name="1847"></a>             *   Expand the error text name to include the contents
<a name="1848"></a>             *   qualifier, since any subsequent failure to match will be
<a name="1849"></a>             *   against the result of this qualification.  For example, if
<a name="1850"></a>             *   the phrase is BUCKET OF FISH ON TABLE, we've now limited
<a name="1851"></a>             *   the scope to just BUCKET OF FISH, so if we fail to find
<a name="1852"></a>             *   such an object on the table it'll be because there's no
<a name="1853"></a>             *   BUCKET OF FISH on the table, not because there's simply no
<a name="1854"></a>             *   BUCKET.  
<a name="1855"></a>             */
<a name="1856"></a>            expandErrName(contQual);
<a name="1857"></a>        }
<a name="1858"></a>
<a name="1859"></a>        /* if we have a possessive qualifier, apply it */
<a name="1860"></a>        if (possQual != nil)
<a name="1861"></a>        {
<a name="1862"></a>            /* match vocabulary for the possessive phrase */
<a name="1863"></a>            possQual.matchVocabPoss(cmd);
<a name="1864"></a>
<a name="1865"></a>            /* 
<a name="1866"></a>             *   apply the qualifier, filtering out things not owned by the
<a name="1867"></a>             *   object named in the qualifier 
<a name="1868"></a>             */
<a name="1869"></a>            possQual.applyPossessive();
<a name="1870"></a>
<a name="1871"></a>            /* if that empties our list, flag it */
<a name="1872"></a>            if (matches.length() == 0)
<a name="1873"></a>                throw new NoneInOwnerError(cmd, self, possQual);
<a name="1874"></a>
<a name="1875"></a>            /* expand the error text to include the possessive qualifier */
<a name="1876"></a>            expandErrName(possQual);
<a name="1877"></a>        }
<a name="1878"></a>
<a name="1879"></a>        /* if we have a locational qualifier, match its vocabulary */
<a name="1880"></a>        if (locQual != nil)
<a name="1881"></a>        {
<a name="1882"></a>            /* match vocabulary */
<a name="1883"></a>            locQual.matchVocab(cmd);
<a name="1884"></a>
<a name="1885"></a>            /* apply the qualifier to keep only properly located items */
<a name="1886"></a>            locQual.applyLocational();
<a name="1887"></a>
<a name="1888"></a>            /* if that empties our list, flag it */
<a name="1889"></a>            if (matches.length() == 0)
<a name="1890"></a>                throw new NoneInLocationError(cmd, self, locQual);
<a name="1891"></a>
<a name="1892"></a>            /* expand the error name to include the locational */
<a name="1893"></a>            expandErrName(locQual);
<a name="1894"></a>        }
<a name="1895"></a>
<a name="1896"></a>        /* if there's an exclusion list, apply it */
<a name="1897"></a>        if (exclusions != nil)
<a name="1898"></a>            exclusions.forEach({ x: x.applyExclusion(cmd) });
<a name="1899"></a>    }
<a name="1900"></a>
<a name="1901"></a>    /*
<a name="1902"></a>     *   Add matching objects to a match vector.  'lst' can be a list or
<a name="1903"></a>     *   vector of objects, or a single object.  'match' is the MatchXxx
<a name="1904"></a>     *   flag value returned from the object name match, if applicable.  
<a name="1905"></a>     */
<a name="1906"></a>    addMatches(vec, lst, match)
<a name="1907"></a>    {
<a name="1908"></a>        /* ignore nil */
<a name="1909"></a>        if (lst == nil)
<a name="1910"></a>            return;
<a name="1911"></a>
<a name="1912"></a>        /* wrap each item in an NPMatch object and add it to the vector */
<a name="1913"></a>        vec.appendAll(valToList(lst).mapAll({ obj: new NPMatch(self, obj, match) }));
<a name="1914"></a>    }
<a name="1915"></a>
<a name="1916"></a>    /*
<a name="1917"></a>     *   Find the vocabulary matches for a given noun phrase within a given
<a name="1918"></a>     *   scope list.  Add all of the matches to the given vector.  
<a name="1919"></a>     */
<a name="1920"></a>    matchNameScope(cmd, scope)
<a name="1921"></a>    {
<a name="1922"></a>        /* set up a vector for the results */
<a name="1923"></a>        local v = new Vector(32);
<a name="1924"></a>        
<a name="1925"></a>        /*
<a name="1926"></a>         *   Run through the scope list and ask each object if it matches
<a name="1927"></a>         *   the noun phrase.  Keep the ones that match.  
<a name="1928"></a>         */
<a name="1929"></a>        foreach (local obj in scope)
<a name="1930"></a>        {
<a name="1931"></a>            /* ask this object if it matches */
<a name="1932"></a>            local match = obj.matchName(tokens);
<a name="1933"></a>            
<a name="1934"></a>            /* if it matches, include it in the results */
<a name="1935"></a>            if (match)
<a name="1936"></a>                v.append(new NPMatch(self, obj, match));
<a name="1937"></a>        }
<a name="1938"></a>
<a name="1939"></a>        /*
<a name="1940"></a>         *   Now narrow the list according to the match strength.  Only
<a name="1941"></a>         *   keep the matches that have the maximum strength of the list.
<a name="1942"></a>         */
<a name="1943"></a>        if (v.length() &gt; 0)
<a name="1944"></a>        {
<a name="1945"></a>            /* sort in descending order of strength */
<a name="1946"></a>            v.sort(SortDesc, { a, b: a.strength - b.strength });
<a name="1947"></a>
<a name="1948"></a>            /* 
<a name="1949"></a>             *   discard everything that doesn't match the highest strength
<a name="1950"></a>             *   (which is the first element's strength, since we've sorted
<a name="1951"></a>             *   in descending order) 
<a name="1952"></a>             */
<a name="1953"></a>            v = v.subset({ a: a.strength == v[1].strength });
<a name="1954"></a>        }
<a name="1955"></a>        else
<a name="1956"></a>        {
<a name="1957"></a>            /* the list is empty - complain about it */
<a name="1958"></a>            throw new UnmatchedNounError(cmd, self);
<a name="1959"></a>        }
<a name="1960"></a>
<a name="1961"></a>        /* return the list */
<a name="1962"></a>        return v;
<a name="1963"></a>    }
<a name="1964"></a>
<a name="1965"></a>    /*
<a name="1966"></a>     *   Match vocabulary for a possessive qualifier phrase.
<a name="1967"></a>     *   
<a name="1968"></a>     *   Possessive matching has somewhat different rules than for ordinary
<a name="1969"></a>     *   noun phrases.
<a name="1970"></a>     *   
<a name="1971"></a>     *   First, possessive pronouns (HIS, HER, ITS, THEIR) *can* act like
<a name="1972"></a>     *   reflexives, in that they can refer back to earlier clauses in the
<a name="1973"></a>     *   same predicate: ASK BOB ABOUT HIS MOTHER.  However, they can also
<a name="1974"></a>     *   refer to previous commands: SEARCH BOB; TAKE HIS WALLET.  The
<a name="1975"></a>     *   deciding factor is whether or not there's an earlier noun phrase
<a name="1976"></a>     *   in the command that matches in gender and number; if so, we use
<a name="1977"></a>     *   the reflexive meaning, otherwise we use the external referent.
<a name="1978"></a>     *   
<a name="1979"></a>     *   Second, the scope for ordinary noun phrases has to be expanded to
<a name="1980"></a>     *   include the owners of the objects in scope.  If we have a wallet
<a name="1981"></a>     *   that we know belongs to Bob, we should be able to refer to it as
<a name="1982"></a>     *   "Bob's wallet" whether or not Bob himself is in scope.  So, for
<a name="1983"></a>     *   the purposes of the possessive, Bob is in scope even if he
<a name="1984"></a>     *   wouldn't be for an ordinary noun phrase.  
<a name="1985"></a>     */
<a name="1986"></a>    matchVocabPoss(cmd)
<a name="1987"></a>    {
<a name="1988"></a>        /* start with an empty vector */
<a name="1989"></a>        local v = matches = new Vector(32);
<a name="1990"></a>
<a name="1991"></a>        /* check what kind of phrase we have */
<a name="1992"></a>        if (pronoun != nil)
<a name="1993"></a>        {
<a name="1994"></a>            /* 
<a name="1995"></a>             *   It's a possessive pronoun (HIS, HER, ITS, etc).
<a name="1996"></a>             *   Possessive pronouns can refer back to something in the
<a name="1997"></a>             *   same sentence (ASK BOB ABOUT HIS WALLET) or to earlier
<a name="1998"></a>             *   commands (SEARCH BOB; TAKE HIS WALLET).
<a name="1999"></a>             *   
<a name="2000"></a>             *   If it's a second-person possessive (YOUR), and there's an
<a name="2001"></a>             *   addressee actor, it refers to the actor.  For example,
<a name="2002"></a>             *   "Bob, give me your wallet".
<a name="2003"></a>             *   
<a name="2004"></a>             *   Look at the preceding noun phrases in the predicate to see
<a name="2005"></a>             *   if we can find an object that matches this pronoun.  If
<a name="2006"></a>             *   so, use it as the antecedent.  If not, use the regular
<a name="2007"></a>             *   antecedent.  
<a name="2008"></a>             */
<a name="2009"></a>            local done = nil;
<a name="2010"></a>            cmd.forEachNP(new function(np)
<a name="2011"></a>            {
<a name="2012"></a>                /* if we've already finished, ignore this noun phrase */
<a name="2013"></a>                if (done)
<a name="2014"></a>                    return;
<a name="2015"></a>
<a name="2016"></a>                /* 
<a name="2017"></a>                 *   if this is our parent, stop looking - pronoun
<a name="2018"></a>                 *   references of this sort are always back references 
<a name="2019"></a>                 */
<a name="2020"></a>                if (np == parent)
<a name="2021"></a>                {
<a name="2022"></a>                    done = true;
<a name="2023"></a>                    return;
<a name="2024"></a>                }
<a name="2025"></a>
<a name="2026"></a>                /* 
<a name="2027"></a>                 *   If this is the addressee actor, and we have a
<a name="2028"></a>                 *   second-person possessive pronoun (YOUR), the pronoun
<a name="2029"></a>                 *   refers to the actor. 
<a name="2030"></a>                 */
<a name="2031"></a>                if (np.role == ActorRole &amp;&amp; pronoun.person == 2)
<a name="2032"></a>                {
<a name="2033"></a>                    v.appendAll(np.matches);
<a name="2034"></a>                    done = true;
<a name="2035"></a>                    return;
<a name="2036"></a>                }
<a name="2037"></a>
<a name="2038"></a>                /* check for matches to this pronoun in this match list */
<a name="2039"></a>                local s = np.matches.subset(
<a name="2040"></a>                    { o: pronoun.matchObj(o.obj) });
<a name="2041"></a>
<a name="2042"></a>                /* 
<a name="2043"></a>                 *   if we found any matches, use them, and stop looking -
<a name="2044"></a>                 *   we only want to use the nearest match 
<a name="2045"></a>                 */
<a name="2046"></a>                if (s.length() != 0)
<a name="2047"></a>                {
<a name="2048"></a>                    v.appendAll(s);
<a name="2049"></a>                    done = true;
<a name="2050"></a>                }
<a name="2051"></a>            });
<a name="2052"></a>
<a name="2053"></a>            /* 
<a name="2054"></a>             *   if we didn't find any matches, use the antecedent from a
<a name="2055"></a>             *   previous command, if available 
<a name="2056"></a>             */
<a name="2057"></a>            if (v.length() == 0)
<a name="2058"></a>                v.appendAll(pronoun.resolve().mapAll({
<a name="2059"></a>                    x: new NPMatch(self, x, 0) }));
<a name="2060"></a>        }
<a name="2061"></a>        else
<a name="2062"></a>        {
<a name="2063"></a>            /* 
<a name="2064"></a>             *   It's a named object.  We need an expanded scope list that
<a name="2065"></a>             *   includes the owners of the objects referred to by the
<a name="2066"></a>             *   underlying noun phrase that we qualify.  
<a name="2067"></a>             */
<a name="2068"></a>            local expScope = new Vector(32);
<a name="2069"></a>            foreach (local obj in parent.matches)
<a name="2070"></a>            {
<a name="2071"></a>                /* 
<a name="2072"></a>                 *   if this object has an owner or owners, add it/them to
<a name="2073"></a>                 *   the expanded scope list 
<a name="2074"></a>                 */
<a name="2075"></a>                local owner = obj.obj.owner;
<a name="2076"></a>                if (owner != nil)
<a name="2077"></a>                    expScope.appendAll(owner);
<a name="2078"></a>            }
<a name="2079"></a>
<a name="2080"></a>            /* add the objects in scope, filtering out duplicates */
<a name="2081"></a>            expScope.appendUnique(World.scope.toList());
<a name="2082"></a>
<a name="2083"></a>            /* now build the match list using the expanded scope */
<a name="2084"></a>            v.appendAll(matchNameScope(cmd, expScope));
<a name="2085"></a>        }
<a name="2086"></a>
<a name="2087"></a>        /* 
<a name="2088"></a>         *   a possessive qualifier can itself have a possessive qualifier
<a name="2089"></a>         *   (BOB'S MOTHER'S HAT), so go resolve that as well 
<a name="2090"></a>         */
<a name="2091"></a>        if (possQual != nil)
<a name="2092"></a>            possQual.matchVocabPoss(cmd);
<a name="2093"></a>    }
<a name="2094"></a>
<a name="2095"></a>    /*
<a name="2096"></a>     *   Apply this possessive phrase's qualification.  This filters the
<a name="2097"></a>     *   underlying (parent) noun list to keep only objects owned by the
<a name="2098"></a>     *   object(s) named in this noun phrase.  
<a name="2099"></a>     */
<a name="2100"></a>    applyPossessive()
<a name="2101"></a>    {
<a name="2102"></a>        /* 
<a name="2103"></a>         *   First, do "reverse" filtering: consider only owners who own
<a name="2104"></a>         *   something that's in the underlying noun list.  For example, if
<a name="2105"></a>         *   there are two guards present, but only one of them is carrying
<a name="2106"></a>         *   a sword, GUARD'S SWORD must refer to the guard who's carrying
<a name="2107"></a>         *   a sword.
<a name="2108"></a>         *   
<a name="2109"></a>         *   (Take a subset of our own objects, keeping each object 'o'
<a name="2110"></a>         *   where there's something in the parent list owned by 'o'.  That
<a name="2111"></a>         *   is, there's an object 'p' in the parent list where 'p' is
<a name="2112"></a>         *   owned by 'o'.)  
<a name="2113"></a>         */
<a name="2114"></a>        local m = matches.subset(
<a name="2115"></a>            { o: parent.matches.indexWhich(
<a name="2116"></a>                { p: p.obj.ownedBy(o.obj) }) != nil });
<a name="2117"></a>
<a name="2118"></a>        /* if the reverse filter didn't rule everything out, apply it */
<a name="2119"></a>        if (m.length() &gt; 0)
<a name="2120"></a>            matches = m;
<a name="2121"></a>        
<a name="2122"></a>        /* next, apply any possessive qualifier of my own */
<a name="2123"></a>        if (possQual != nil)
<a name="2124"></a>            possQual.applyPossessive();
<a name="2125"></a>
<a name="2126"></a>        /* filter parent objects not owned by anything in my list */
<a name="2127"></a>        parent.matches = parent.matches.subset(
<a name="2128"></a>            { p: matches.indexWhich(
<a name="2129"></a>                { o: p.obj.ownedBy(o.obj) }) != nil });
<a name="2130"></a>    }
<a name="2131"></a>
<a name="2132"></a>    /*
<a name="2133"></a>     *   Apply this contents qualifier phrase's qualification.  This
<a name="2134"></a>     *   filters the underlying (parent) noun list to keep only objects
<a name="2135"></a>     *   that contain the object(s) named in this noun list.  
<a name="2136"></a>     */
<a name="2137"></a>    applyContQual()
<a name="2138"></a>    {
<a name="2139"></a>        /* 
<a name="2140"></a>         *   First, do the reverse filtering, to keep only objects that
<a name="2141"></a>         *   could be inside objects in the underlying list.  
<a name="2142"></a>         */
<a name="2143"></a>        local m = matches.subset(
<a name="2144"></a>            { o: parent.matches.indexWhich(
<a name="2145"></a>                { p: o.obj.isChild(p.obj, nil) }) != nil });
<a name="2146"></a>
<a name="2147"></a>        /* if that didn't rule everything out, apply the filter */
<a name="2148"></a>        if (m.length() &gt; 0)
<a name="2149"></a>            matches = m;
<a name="2150"></a>
<a name="2151"></a>        /* next, apply any locational qualifier of my own */
<a name="2152"></a>        if (contQual != nil)
<a name="2153"></a>            contQual.applyContQual();
<a name="2154"></a>
<a name="2155"></a>        /* filter parent objects not containing anything in my list */
<a name="2156"></a>        parent.matches = parent.matches.subset(
<a name="2157"></a>            { p: matches.indexWhich(
<a name="2158"></a>                { o: o.obj.isChild(p.obj, nil) }) != nil });
<a name="2159"></a>    }
<a name="2160"></a>    
<a name="2161"></a>    /*
<a name="2162"></a>     *   Apply this locational phrase's qualification.  This filters the
<a name="2163"></a>     *   underlying (parent) noun list to keep only objects located within
<a name="2164"></a>     *   the object(s) named in this noun phrase.  
<a name="2165"></a>     */
<a name="2166"></a>    applyLocational()
<a name="2167"></a>    {
<a name="2168"></a>        /* 
<a name="2169"></a>         *   First, do the reverse filtering, to keep only objects that
<a name="2170"></a>         *   could contain objects in the underlying list. 
<a name="2171"></a>         */
<a name="2172"></a>        local m = matches.subset(
<a name="2173"></a>            { o: parent.matches.indexWhich(
<a name="2174"></a>                { p: p.obj.isChild(o.obj, locType) }) != nil });
<a name="2175"></a>
<a name="2176"></a>        /* if that didn't rule everything out, apply the filter */
<a name="2177"></a>        if (m.length() &gt; 0)
<a name="2178"></a>            matches = m;
<a name="2179"></a>
<a name="2180"></a>        /* next, apply any locational qualifier of my own */
<a name="2181"></a>        if (locQual != nil)
<a name="2182"></a>            locQual.applyLocational();
<a name="2183"></a>
<a name="2184"></a>        /* first, try limiting to items DIRECTLY in the location */
<a name="2185"></a>        m = parent.matches.subset(
<a name="2186"></a>            { p: matches.indexWhich(
<a name="2187"></a>                { o: p.obj.isDirectChild(o.obj, locType) }) != nil });
<a name="2188"></a>
<a name="2189"></a>        /* if there weren't any, try items indirectly in the location */
<a name="2190"></a>        if (m.length() == 0)
<a name="2191"></a>            m = parent.matches.subset(
<a name="2192"></a>                { p: matches.indexWhich(
<a name="2193"></a>                    { o: p.obj.isChild(o.obj, locType) }) != nil });
<a name="2194"></a>
<a name="2195"></a>        /* save the filtered list in the parent */
<a name="2196"></a>        parent.matches = m;
<a name="2197"></a>    }
<a name="2198"></a>    
<a name="2199"></a>    /*
<a name="2200"></a>     *   Apply an exclusion item.  This resolves the vocabulary for the
<a name="2201"></a>     *   exclusion phrase and filters the matching item(s) noun phrase out
<a name="2202"></a>     *   of the parent list.  
<a name="2203"></a>     */
<a name="2204"></a>    applyExclusion(cmd)
<a name="2205"></a>    {
<a name="2206"></a>        /* do our vocabulary matching */
<a name="2207"></a>        matchVocab(cmd);
<a name="2208"></a>
<a name="2209"></a>        /* filter the parent list to exclude everything we matched */
<a name="2210"></a>        parent.matches = parent.matches.subset(
<a name="2211"></a>            { p: matches.indexWhich(
<a name="2212"></a>                { o: o.obj == p.obj }) == nil });
<a name="2213"></a>    }
<a name="2214"></a>
<a name="2215"></a>    /*
<a name="2216"></a>     *   Select the objects from among the vocabulary matches.  This
<a name="2217"></a>     *   narrows the list of possible vocabulary matches for our noun
<a name="2218"></a>     *   phrase to find the actual object or objects the player is
<a name="2219"></a>     *   referencing.
<a name="2220"></a>     *   
<a name="2221"></a>     *   When this is called, we've already filled in the match list with
<a name="2222"></a>     *   all objects in scope that match the vocabulary of the core noun
<a name="2223"></a>     *   phrase (including non-reflexive pronouns and ALL), and we've
<a name="2224"></a>     *   applied any possessive, locational, and exclusion qualifiers.
<a name="2225"></a>     *   What we're left with is the list of in-scope objects that meet all
<a name="2226"></a>     *   of the specifications contained in the entire noun phrase.  In
<a name="2227"></a>     *   other words, we've squeezed all available information out of the
<a name="2228"></a>     *   noun phrase itself.  If the result is ambiguous, then, we'll have
<a name="2229"></a>     *   to look beyond the noun phrase, to the broader semantic content of
<a name="2230"></a>     *   the overall command.  
<a name="2231"></a>     *   
<a name="2232"></a>     *   There are three possible "goals" for what our final object list
<a name="2233"></a>     *   should look like after disambiguation.  Only one goal applies to
<a name="2234"></a>     *   each particular noun phrase; which it is depends on the grammar of
<a name="2235"></a>     *   the phrase:
<a name="2236"></a>     *   
<a name="2237"></a>     *   1.  Definite mode: TAKE BOOK, TAKE THE BOOK, TAKE BOTH BOOKS, TAKE
<a name="2238"></a>     *   THE THREE BOOKS.  The goal in definite mode is to choose the given
<a name="2239"></a>     *   number of objects, *and* to make sure that the player could *only*
<a name="2240"></a>     *   have meant those precise objects.  In other words, we're not
<a name="2241"></a>     *   allowed to make an arbitrary choice: in natural language, the
<a name="2242"></a>     *   definite mode says that the speaker believes the listener knows
<a name="2243"></a>     *   which *particular* object or objects the speaker is referring to.
<a name="2244"></a>     *   If we're not absolutely sure which objects the player is talking
<a name="2245"></a>     *   about, we have a disagreement with the player's apparent
<a name="2246"></a>     *   expectations and must ask for clarification.
<a name="2247"></a>     *   
<a name="2248"></a>     *   2.  Indefinite mode: TAKE A BOOK, TAKE ANY BOOK, TAKE TWO BOOKS.
<a name="2249"></a>     *   The goal is to choose the given number of objects from the
<a name="2250"></a>     *   possible matches, arbitrarily choosing from the available objects.
<a name="2251"></a>     *   
<a name="2252"></a>     *   3. Plural mode: TAKE BOOKS, TAKE THE BOOKS, TAKE ALL BOOKS.  The
<a name="2253"></a>     *   goal here is to choose all of the matching objects.  
<a name="2254"></a>     */
<a name="2255"></a>    selectObjects(cmd)
<a name="2256"></a>    {
<a name="2257"></a>        /* take the mode from the determiner */
<a name="2258"></a>        local mode = determiner;
<a name="2259"></a>        
<a name="2260"></a>        /* 
<a name="2261"></a>         *   If the player typed ALL or ANY or some such response in response to
<a name="2262"></a>         *   a disambiguation respose, that response will have set a determiner
<a name="2263"></a>         *   we need to use instead.
<a name="2264"></a>         */
<a name="2265"></a>        if(cmd.disambig.length &gt; 0)
<a name="2266"></a>            mode = cmd.disambig[1][1].determiner;
<a name="2267"></a>        
<a name="2268"></a>
<a name="2269"></a>        /* 
<a name="2270"></a>         *   Sort the matches by listing order.  If we have a plural, this
<a name="2271"></a>         *   will make the order of processing more logical when there's
<a name="2272"></a>         *   some kind of natural order (such as alphabetized or numbered
<a name="2273"></a>         *   items).  
<a name="2274"></a>         */
<a name="2275"></a>        matches.groupSort(
<a name="2276"></a>            { ent, idx: [ent.obj.disambigGroup, ent.obj.disambigOrder] });
<a name="2277"></a>
<a name="2278"></a>        /* if there's no determiner, assume definite */
<a name="2279"></a>        if (mode == nil)
<a name="2280"></a>            mode = Definite;
<a name="2281"></a>
<a name="2282"></a>        /*
<a name="2283"></a>         *   If we're in Definite mode and we don't have a quantifier,
<a name="2284"></a>         *   check for a plural noun phrase.  A plural without a specific
<a name="2285"></a>         *   number puts us in Plural mode.  Consider the noun phrase to be
<a name="2286"></a>         *   plural if it matched any of our objects with plural usage.
<a name="2287"></a>         *   Even if some objects were singular in usage, one plural is
<a name="2288"></a>         *   enough to suggest that the name has plural usage. 
<a name="2289"></a>         */
<a name="2290"></a>        if (mode == Definite
<a name="2291"></a>            &amp;&amp; quantifier == nil
<a name="2292"></a>            &amp;&amp; matches.indexWhich({ m: m.match &amp; MatchPlural }) != nil)
<a name="2293"></a>            mode = All;
<a name="2294"></a>
<a name="2295"></a>        /* 
<a name="2296"></a>         *   Figure the target quantity.  If there's a quantifier, it's the
<a name="2297"></a>         *   quantifier value; otherwise we implicitly want a singleton.
<a name="2298"></a>         *   Note that the quantifier is ignored in Plural mode, since we
<a name="2299"></a>         *   simply want to match all of the objects in this case.  
<a name="2300"></a>         */
<a name="2301"></a>        local num = (quantifier != nil ? quantifier : 1);
<a name="2302"></a>
<a name="2303"></a>        /*
<a name="2304"></a>         *   If we don't have enough objects to satisfy the request,
<a name="2305"></a>         *   complain about it. 
<a name="2306"></a>         */
<a name="2307"></a>        if (num &gt; matches.length() 
<a name="2308"></a>            &amp;&amp; objs.indexWhich({o: o.canSupply}) == nil)
<a name="2309"></a>            throw new InsufficientNounsError(cmd, self);
<a name="2310"></a>        
<a name="2311"></a>        if (mode == Definite &amp;&amp; isAllEquivalent(matches) &amp;&amp; matches.length &gt; 1)
<a name="2312"></a>            mode = Indefinite;
<a name="2313"></a>
<a name="2314"></a>        
<a name="2315"></a>        for(local cur in objs)
<a name="2316"></a>            cur.filterResolveList(self, cmd, mode);
<a name="2317"></a>        
<a name="2318"></a>        /* select the goal based on the mode */
<a name="2319"></a>        switch (mode)
<a name="2320"></a>        {
<a name="2321"></a>        case Definite:        
<a name="2322"></a>            /* 
<a name="2323"></a>             *   Definite mode.  If we have more than the desired number,
<a name="2324"></a>             *   we must disambiguate.  
<a name="2325"></a>             */
<a name="2326"></a>            if (matches.length() &gt; num)
<a name="2327"></a>                disambiguate(cmd, num, cmd.action);
<a name="2328"></a>            else
<a name="2329"></a>                /* 
<a name="2330"></a>                 *   If we don't disambiguate we don't run the verify routine
<a name="2331"></a>                 *   that stores a reference to the object selected for this
<a name="2332"></a>                 *   role so that it can be available to the verify routine for
<a name="2333"></a>                 *   the other role; so we store a reference now.
<a name="2334"></a>                 */
<a name="2335"></a>                cmd.action.(role.objProp) = cmd.(role.objListProp)[1].obj;
<a name="2336"></a>            break;
<a name="2337"></a>
<a name="2338"></a>        case Indefinite:
<a name="2339"></a>            /*
<a name="2340"></a>             *   Indefinite mode - we must select the desired number, but
<a name="2341"></a>             *   we can do so arbitrarily.  Simply select the first 'num'
<a name="2342"></a>             *   in the list.
<a name="2343"></a>             */
<a name="2344"></a>            
<a name="2345"></a>            /* start by getting object rankings from the verb */
<a name="2346"></a>            cmd.action.scoreObjects(cmd, role, matches);
<a name="2347"></a>            
<a name="2348"></a>            /* sort by score (highest to lowest), except for the ActorRole */
<a name="2349"></a>            matches.sort(SortDesc, { a, b: a.score - b.score });
<a name="2350"></a>            
<a name="2351"></a>            if (matches.length() &gt; num)
<a name="2352"></a>                matches.removeRange(num + 1, matches.length());
<a name="2353"></a>
<a name="2354"></a>            /* flag the objects as arbitrarily chosen */
<a name="2355"></a>            matches.forEach({ m: m.flags |= SelArbitrary });
<a name="2356"></a>            break;
<a name="2357"></a>
<a name="2358"></a>        case All:
<a name="2359"></a>            /* 
<a name="2360"></a>             *   Plural mode - select all of the objects.  Simply use the
<a name="2361"></a>             *   set we've already built.  Flag the selections as plural.  
<a name="2362"></a>             */
<a name="2363"></a>            matches.forEach({ m: m.flags |= SelPlural });
<a name="2364"></a>            cmd.matchedMulti = true;
<a name="2365"></a>            break;
<a name="2366"></a>        }
<a name="2367"></a>    }
<a name="2368"></a>
<a name="2369"></a>    /* 
<a name="2370"></a>     *   Determine whether all matches in the matchList are impossible to
<a name="2371"></a>     *   disambiguate.
<a name="2372"></a>     */
<a name="2373"></a>    isAllEquivalent(matchList){
<a name="2374"></a>        local names = Distinguisher.getNames(
<a name="2375"></a>            matchList.mapAll({ x: x.obj }), nil);
<a name="2376"></a>        return (names.length() == 1);
<a name="2377"></a>    }
<a name="2378"></a>    
<a name="2379"></a>    /*
<a name="2380"></a>     *   Disambiguate the match list to select the given target number of
<a name="2381"></a>     *   objects.  
<a name="2382"></a>     */
<a name="2383"></a>    disambiguate(cmd, num, action)
<a name="2384"></a>    {
<a name="2385"></a>        /* start by getting object rankings from the verb */
<a name="2386"></a>        action.scoreObjects(cmd, role, matches);
<a name="2387"></a>
<a name="2388"></a>        /* sort by score (highest to lowest) */
<a name="2389"></a>        matches.sort(SortDesc, { a, b: a.score - b.score });
<a name="2390"></a>
<a name="2391"></a>        /* 
<a name="2392"></a>         *   To pick automatically, we need exactly 'num' objects at the
<a name="2393"></a>         *   highest score.  The sort put the object with the highest score
<a name="2394"></a>         *   at the start of the list, so the high-scoring subset is the
<a name="2395"></a>         *   subset that matches the first object's score.
<a name="2396"></a>         *   
<a name="2397"></a>         *   We only disambiguate in definite mode, and definite mode in
<a name="2398"></a>         *   input is the player's way of telling us that they think there
<a name="2399"></a>         *   are exactly this many objects that obviously apply to their
<a name="2400"></a>         *   command.  The score tells us which objects *we* think are the
<a name="2401"></a>         *   obvious choices for the command.  If we come up with the same
<a name="2402"></a>         *   set size that the player expressed, then we presumably
<a name="2403"></a>         *   understand what the player is saying.  If our set size differs
<a name="2404"></a>         *   from theirs, we're not thinking alike, so we need to ask for
<a name="2405"></a>         *   clarification.  
<a name="2406"></a>         */
<a name="2407"></a>        local sub = matches.subset({x: x.score == matches[1].score});
<a name="2408"></a>        
<a name="2409"></a>        if (isAllEquivalent(sub))
<a name="2410"></a>            sub.setLength(num);
<a name="2411"></a>        
<a name="2412"></a>        if (sub.length() == num)
<a name="2413"></a>        {
<a name="2414"></a>            /* 
<a name="2415"></a>             *   We have the desired number of most obvious matches, so
<a name="2416"></a>             *   we've successfully disambiguated it.  We might want to
<a name="2417"></a>             *   announce the selection, since we're making a guess, so
<a name="2418"></a>             *   generate a name for each that distinguishes it from the
<a name="2419"></a>             *   other items we could have matched.  
<a name="2420"></a>             */
<a name="2421"></a>            local names = Distinguisher.getNames(
<a name="2422"></a>                matches.mapAll({ x: x.obj }), nil);            
<a name="2423"></a>
<a name="2424"></a>            /* save the disambiguated subset */
<a name="2425"></a>            matches = sub;
<a name="2426"></a>
<a name="2427"></a>            /* mark each as disambiguated, and save the distinctive name */
<a name="2428"></a>            foreach (local m in matches)
<a name="2429"></a>            {
<a name="2430"></a>                m.flags |= SelDisambig;
<a name="2431"></a>                m.name = names.valWhich({ n: n[2].indexOf(m.obj) != nil })[1];
<a name="2432"></a>            }
<a name="2433"></a>            
<a name="2434"></a>            /* we've successfully disambiguated the phrase */
<a name="2435"></a>            return;
<a name="2436"></a>        }        
<a name="2437"></a>        else if (sub.length() &gt; num &amp;&amp; num &gt; 1)                    
<a name="2438"></a>        {
<a name="2439"></a>            /*            
<a name="2440"></a>             *   We've asked for a definite number of 2 or more items, but there
<a name="2441"></a>             *   are different options among the best matches.  This poses a
<a name="2442"></a>             *   problem because there's no good disambiguation we can possibly
<a name="2443"></a>             *   ask here. So we just give up and ask them to be more specific.
<a name="2444"></a>             *   I can imagine someone responding to this message by just
<a name="2445"></a>             *   retyping a more specific form of the noun phrase. For example,
<a name="2446"></a>             *   after GET THE TWO MATCHES doesn't work, they might just want to
<a name="2447"></a>             *   type THE LIT MATCH AND AN UNLIT MATCH, but currently the parser
<a name="2448"></a>             *   does not do this.  Probably the DMsg should also refer to the
<a name="2449"></a>             *   specific noun phrase that is ambiguous in its message.
<a name="2450"></a>             */
<a name="2451"></a>            throw new AmbiguousMultiDefiniteError(cmd,self);
<a name="2452"></a>        }
<a name="2453"></a>    
<a name="2454"></a>        /*
<a name="2455"></a>         *   We have more than what we need in the highest scoring section,
<a name="2456"></a>         *   so make this the matches and proceed with disambiguation.
<a name="2457"></a>         *   This line makes it so that when you say something like "drop match"
<a name="2458"></a>         *   it will only try to disambiguate among the things you are holding.
<a name="2459"></a>         *   I think this behavior is more desirable, but am not certain.
<a name="2460"></a>         */
<a name="2461"></a>        matches = sub;
<a name="2462"></a>        
<a name="2463"></a>
<a name="2464"></a>        /* it's still ambiguous, so throw an error to ask for help */
<a name="2465"></a>        ambigError(cmd);
<a name="2466"></a>        matches.setLength(num);
<a name="2467"></a>    }
<a name="2468"></a>
<a name="2469"></a>    /*
<a name="2470"></a>     *   Throw an ambiguous noun phrase error for the current match list. 
<a name="2471"></a>     */
<a name="2472"></a>    ambigError(cmd)
<a name="2473"></a>    {
<a name="2474"></a>        /* if we have a reply to a past disambiguation question, apply it */
<a name="2475"></a>        local disambig = cmd.fetchDisambigReply();
<a name="2476"></a>        if (disambig != nil)
<a name="2477"></a>        {
<a name="2478"></a>            /* start a list for the result */
<a name="2479"></a>            local dmatches = new Vector(matches.length());
<a name="2480"></a>
<a name="2481"></a>            /* add the object(s) selected by each noun phrase in the reply */
<a name="2482"></a>            foreach (local dnp in disambig)
<a name="2483"></a>            {
<a name="2484"></a>                /* 
<a name="2485"></a>                 *   resolve this noun phrase of the reply and add its
<a name="2486"></a>                 *   selections to the master list 
<a name="2487"></a>                 */
<a name="2488"></a>                dmatches.appendAll(
<a name="2489"></a>                    dnp.applyDisambig(cmd, matches, disambigNameList));
<a name="2490"></a>            }
<a name="2491"></a>
<a name="2492"></a>            /* 
<a name="2493"></a>             *   If we get this far, we have a valid result set now, even
<a name="2494"></a>             *   if it's not of the original size.  The reply can select a
<a name="2495"></a>             *   different number of objects than originally implied, since
<a name="2496"></a>             *   the reply can say something like "the red one and the blue
<a name="2497"></a>             *   one" to pick more than one of the offered objects.  
<a name="2498"></a>             */
<a name="2499"></a>            matches = dmatches;
<a name="2500"></a>            return;
<a name="2501"></a>        }
<a name="2502"></a>
<a name="2503"></a>        /* 
<a name="2504"></a>         *   Still ambiguous, so we need to ask for clarification, with a
<a name="2505"></a>         *   question like "Which do you mean, the red book, or the blue
<a name="2506"></a>         *   book?"  Generate the list of names.  
<a name="2507"></a>         */
<a name="2508"></a>        local nameList = Distinguisher.getNames(
<a name="2509"></a>            matches.mapAll({ x: x.obj }), true);
<a name="2510"></a>
<a name="2511"></a>        /* 
<a name="2512"></a>         *   Sort by disambigGroup and disambigOrder.  Note that it's
<a name="2513"></a>         *   possible for a set to have more than one item with a
<a name="2514"></a>         *   disambigGroup, and these might not match.  We can't break up a
<a name="2515"></a>         *   set, though, so we'll just have to pick one group arbitrarily
<a name="2516"></a>         *   for the whole set. 
<a name="2517"></a>         */
<a name="2518"></a>        nameList.groupSort(new function(entry, idx)
<a name="2519"></a>        {
<a name="2520"></a>            /* find an arbitrary entry in the set with a disambigGroup */
<a name="2521"></a>            local gobj = entry[2].valWhich({ x: x.disambigGroup != nil });
<a name="2522"></a>            
<a name="2523"></a>            /* if we found one, use its group and order; otherwise use nil */
<a name="2524"></a>            return gobj != nil
<a name="2525"></a>                ? [gobj.disambigGroup, gobj.disambigOrder]
<a name="2526"></a>                : [nil, idx];
<a name="2527"></a>        });
<a name="2528"></a>
<a name="2529"></a>        /* 
<a name="2530"></a>         *   remember this list, since it determines the meanings of
<a name="2531"></a>         *   ordinals ("the second one") in the reply 
<a name="2532"></a>         */
<a name="2533"></a>        disambigNameList = nameList;       
<a name="2534"></a>        
<a name="2535"></a>        /* throw the still-ambiguous error */
<a name="2536"></a>        throw new AmbiguousError(cmd, self, nameList);
<a name="2537"></a>        
<a name="2538"></a>        
<a name="2539"></a>    }
<a name="2540"></a>
<a name="2541"></a>    /*
<a name="2542"></a>     *   Apply this noun phrase as a disambiguation reply to the given
<a name="2543"></a>     *   original list of matches to an ambiguous noun phrase.  
<a name="2544"></a>     */
<a name="2545"></a>    applyDisambig(cmd, ambigMatches, nameList)
<a name="2546"></a>    {
<a name="2547"></a>        /* 
<a name="2548"></a>         *   Start with the ambiguous list.  Our goal is to narrow the list
<a name="2549"></a>         *   that the original noun phrase matched, so start with the list
<a name="2550"></a>         *   and remove items that don't match the additional vocabulary
<a name="2551"></a>         *   and/or qualifiers in the reply.  
<a name="2552"></a>         */
<a name="2553"></a>        matches = ambigMatches;
<a name="2554"></a>
<a name="2555"></a>        /* if there's an ordinal, pick out the selected item */
<a name="2556"></a>        if (ordinal != nil)
<a name="2557"></a>        {
<a name="2558"></a>            /* pick the name list entry based on the list position */
<a name="2559"></a>            local n;
<a name="2560"></a>            if (ordinal == -1 &amp;&amp; nameList.length() &gt; 0)
<a name="2561"></a>                n = nameList[nameList.length()];
<a name="2562"></a>            else if (ordinal &gt;= 1 &amp;&amp; ordinal &lt;= nameList.length())
<a name="2563"></a>                n = nameList[ordinal];
<a name="2564"></a>            else
<a name="2565"></a>                throw new OrdinalRangeError(self, ordinal);
<a name="2566"></a>
<a name="2567"></a>            /* 
<a name="2568"></a>             *   take the first object from the group, and build a resolved
<a name="2569"></a>             *   object list with this object 
<a name="2570"></a>             */
<a name="2571"></a>            n = n[2][1];
<a name="2572"></a>            matches = matches.subset({ m: m.obj == n });
<a name="2573"></a>        }
<a name="2574"></a>
<a name="2575"></a>        /* if there's a locational qualifier, apply it */
<a name="2576"></a>        if (locQual != nil)
<a name="2577"></a>        {
<a name="2578"></a>            /* apply the locational qualifier */
<a name="2579"></a>            locQual.matchVocab(cmd);
<a name="2580"></a>            locQual.applyLocational();
<a name="2581"></a>
<a name="2582"></a>            /* if that empties our list, flag it */
<a name="2583"></a>            if (matches.length() == 0)
<a name="2584"></a>                throw new NoneInLocationError(cmd, parent, locQual);
<a name="2585"></a>        }
<a name="2586"></a>                
<a name="2587"></a>        /* if there's a possessive qualifier, apply it */
<a name="2588"></a>        if (possQual != nil)
<a name="2589"></a>        {
<a name="2590"></a>            /* apply the possessive qualifier */
<a name="2591"></a>            possQual.matchVocabPoss(cmd);
<a name="2592"></a>            possQual.applyPossessive();
<a name="2593"></a>
<a name="2594"></a>            /* if that empties our list, flag it */
<a name="2595"></a>            if (matches.length() == 0)
<a name="2596"></a>                throw new NoneInOwnerError(cmd, parent, possQual);
<a name="2597"></a>        }
<a name="2598"></a>
<a name="2599"></a>        /* if there's a contents qualifier, apply it */
<a name="2600"></a>        if (contQual != nil)
<a name="2601"></a>        {
<a name="2602"></a>            /* apply the qualifier */
<a name="2603"></a>            contQual.matchVocab(cmd);
<a name="2604"></a>            contQual.applyContQual();
<a name="2605"></a>
<a name="2606"></a>            /* if that empties our list, flag it */
<a name="2607"></a>            if (matches.length() == 0)
<a name="2608"></a>                throw new NoneWithContentsError(cmd, parent, contQual);
<a name="2609"></a>        }
<a name="2610"></a>
<a name="2611"></a>        /* if there's vocabulary, apply it */
<a name="2612"></a>        if (tokens.length() &gt; 0)
<a name="2613"></a>        {
<a name="2614"></a>            /*
<a name="2615"></a>             *   The basic vocabulary of the reply isn't as simple to
<a name="2616"></a>             *   handle as it might seem, since the words could refer to
<a name="2617"></a>             *   the object itself, a container, an owner, or the nominal
<a name="2618"></a>             *   contents.  Consider:
<a name="2619"></a>             *   
<a name="2620"></a>             *   Which bucket do you mean, the empty bucket, the bucket on
<a name="2621"></a>             *   the shelf, the tall fisherman's bucket, or the bucket of
<a name="2622"></a>             *   water?
<a name="2623"></a>             *   
<a name="2624"></a>             *   Players are accustomed to being able to answer these
<a name="2625"></a>             *   questions by entering just a word or two from the prompt,
<a name="2626"></a>             *   so we'd want to accept EMPTY, SHELF, TALL, and WATER for
<a name="2627"></a>             *   the respective choices.
<a name="2628"></a>             *   
<a name="2629"></a>             *   So: first assume that the reply refers to the object
<a name="2630"></a>             *   itself.  If we don't find any matches, try the other
<a name="2631"></a>             *   possibilities: containers, owners, and nominal contents.  
<a name="2632"></a>             */
<a name="2633"></a>            if (tokens.length() &gt; 0 &amp;&amp; matches.length() &gt; 0)
<a name="2634"></a>            {
<a name="2635"></a>                /* first try applying the words to the object itself */
<a name="2636"></a>                local m = matches.subset(
<a name="2637"></a>                    { o: o.obj.matchNameDisambig(tokens) != 0 });
<a name="2638"></a>                
<a name="2639"></a>                /* if that didn't match anything, try containers */
<a name="2640"></a>                if (m.length() == 0)
<a name="2641"></a>                {
<a name="2642"></a>                    /* get the list of in-scope objects matching the tokens */
<a name="2643"></a>                    local locs = World.scope.subset(
<a name="2644"></a>                        { o: o.matchNameDisambig(tokens) != 0 });
<a name="2645"></a>
<a name="2646"></a>                    /* get the subset of 'matches' that are in 'locs' */
<a name="2647"></a>                    m = matches.subset(
<a name="2648"></a>                        { o: locs.indexWhich(
<a name="2649"></a>                            { l: o.obj.isChild(l, nil) }) != nil });
<a name="2650"></a>                }
<a name="2651"></a>                
<a name="2652"></a>                /* if we still don't have any matches, try owners */
<a name="2653"></a>                if (m.length() == 0)
<a name="2654"></a>                {
<a name="2655"></a>                    /* get the list of scope objects plus potential owners */
<a name="2656"></a>                    local owners = new Vector(50, World.scope.toList());
<a name="2657"></a>                    foreach (local obj in matches)
<a name="2658"></a>                    {
<a name="2659"></a>                        local owner = obj.obj.owner;
<a name="2660"></a>                        if (owner != nil)
<a name="2661"></a>                            owners.appendAll(owner);
<a name="2662"></a>                    }
<a name="2663"></a>
<a name="2664"></a>                    /* get the subset matching the tokens */
<a name="2665"></a>                    owners = owners.subset(
<a name="2666"></a>                        { o: o.matchNameDisambig(tokens) != 0 });
<a name="2667"></a>
<a name="2668"></a>                    /* get the subset of 'matches' with owners in 'owners' */
<a name="2669"></a>                    m = matches.subset(
<a name="2670"></a>                        { o: owners.indexWhich(
<a name="2671"></a>                            { l: o.obj.ownedBy(l) }) != nil });
<a name="2672"></a>                }
<a name="2673"></a>                
<a name="2674"></a>                /* if we still don't have any matches, try nominal contents */
<a name="2675"></a>                if (m.length() == 0)
<a name="2676"></a>                {
<a name="2677"></a>                    /* get the list of in-scope objects matching the tokens */
<a name="2678"></a>                    local conts = World.scope.subset(
<a name="2679"></a>                        { c: c.matchNameDisambig(tokens) != 0 });
<a name="2680"></a>
<a name="2681"></a>                    /* get the subset of 'matches' with contents in 'conts' */
<a name="2682"></a>                    m = matches.subset(
<a name="2683"></a>                        { o: conts.indexOf(o.obj.nominalContents) != nil });
<a name="2684"></a>                }
<a name="2685"></a>                
<a name="2686"></a>                /* if we've eliminated everything, it's an error */
<a name="2687"></a>                if (m.length() == 0)
<a name="2688"></a>                    throw new UnmatchedNounError(cmd, self);
<a name="2689"></a>
<a name="2690"></a>                /* we're out of things to try, so take what we have */
<a name="2691"></a>                matches = m;
<a name="2692"></a>            }
<a name="2693"></a>        }
<a name="2694"></a>
<a name="2695"></a>        /* determine how many the reply *wants* to select */
<a name="2696"></a>        local num = (quantifier != nil ? quantifier : 1);
<a name="2697"></a>
<a name="2698"></a>        /* if we don't have enough, it's an error */
<a name="2699"></a>        if (matches.length() &lt; num)
<a name="2700"></a>            throw new InsufficientNounsError(cmd, self);
<a name="2701"></a>        
<a name="2702"></a>        if (determiner == Definite &amp;&amp; isAllEquivalent(matches))
<a name="2703"></a>            determiner = Indefinite;
<a name="2704"></a>        
<a name="2705"></a>        /* determine the actual number available */
<a name="2706"></a>        switch (determiner)
<a name="2707"></a>        {
<a name="2708"></a>        case Definite:
<a name="2709"></a>            /* 
<a name="2710"></a>             *   They want exactly the number indicated.  If we still have
<a name="2711"></a>             *   more than this, it's *still* ambiguous, so throw another
<a name="2712"></a>             *   ambiguity error to further disambiguate the new list.
<a name="2713"></a>             *   Otherwise, we're set.  
<a name="2714"></a>             */
<a name="2715"></a>            if (num &lt; matches.length())
<a name="2716"></a>                ambigError(cmd);
<a name="2717"></a>            break;
<a name="2718"></a>            
<a name="2719"></a>        case Indefinite:
<a name="2720"></a>            /* indefinite - arbitrarily select any 'num' of the items */
<a name="2721"></a>            if (matches.length() &gt; num)
<a name="2722"></a>                matches.removeRange(num + 1, matches.length());
<a name="2723"></a>
<a name="2724"></a>            /* mark them as arbitrary */
<a name="2725"></a>            matches.forEach({ m: m.flags |= SelArbitrary });
<a name="2726"></a>            break;
<a name="2727"></a>            
<a name="2728"></a>        case All:
<a name="2729"></a>            /* all - keep all of the items */
<a name="2730"></a>            break;
<a name="2731"></a>        }
<a name="2732"></a>
<a name="2733"></a>        /* return our final match list */
<a name="2734"></a>        return matches;
<a name="2735"></a>    }
<a name="2736"></a>
<a name="2737"></a>    /*
<a name="2738"></a>     *   Resolve ALL.  This is called on a separate pass after
<a name="2739"></a>     *   selectObjects(), because two-object verbs sometimes resolve ALL in
<a name="2740"></a>     *   one slot according to the selection in the other slot.  
<a name="2741"></a>     */
<a name="2742"></a>    resolveAll(cmd)
<a name="2743"></a>    {
<a name="2744"></a>        /* if this is a simple ALL phrase, re-resolve it */
<a name="2745"></a>        if (determiner == All)
<a name="2746"></a>        {
<a name="2747"></a>            /* 
<a name="2748"></a>             *   If it's just ALL, re-match the vocabulary to pick up the
<a name="2749"></a>             *   final ALL list.  Otherwise, take the subset of the ALL
<a name="2750"></a>             *   list that matches the vocabulary. 
<a name="2751"></a>             */
<a name="2752"></a>            if (tokens == [])
<a name="2753"></a>            {
<a name="2754"></a>                /* it's just ALL - start over with the final ALL list */
<a name="2755"></a>                matchVocab(cmd);
<a name="2756"></a>            }
<a name="2757"></a>            else
<a name="2758"></a>            {
<a name="2759"></a>                /* 
<a name="2760"></a>                 *   it's ALL &lt;somethings&gt; - take the subset that's in the
<a name="2761"></a>                 *   final ALL list 
<a name="2762"></a>                 */
<a name="2763"></a>                local all = cmd.action.getAll(cmd, role);
<a name="2764"></a>                local sub = matches.subset({ m: all.indexOf(m.obj) != nil });
<a name="2765"></a>
<a name="2766"></a>                /* 
<a name="2767"></a>                 *   If we found any objects in the intersection, keep only
<a name="2768"></a>                 *   the subset, since this is the set that actually makes
<a name="2769"></a>                 *   sense for this command.  If the subset is empty,
<a name="2770"></a>                 *   though, ignore it and stick with the objects we've
<a name="2771"></a>                 *   already selected based on the vocabulary; these will
<a name="2772"></a>                 *   probably fail the command, but that'll make more sense
<a name="2773"></a>                 *   to the player than claiming there's nothing matching
<a name="2774"></a>                 *   the description they gave.  
<a name="2775"></a>                 */
<a name="2776"></a>                if (sub.length() != 0)
<a name="2777"></a>                    matches = sub;
<a name="2778"></a>            }
<a name="2779"></a>        }
<a name="2780"></a>    }
<a name="2781"></a>    
<a name="2782"></a>    /*
<a name="2783"></a>     *   Resolve reflexive pronouns.  Our Command calls this AFTER
<a name="2784"></a>     *   resolving all of the regular noun phrases, because reflexives
<a name="2785"></a>     *   refer back to other nouns in the same command.  
<a name="2786"></a>     */
<a name="2787"></a>    resolveReflexives(cmd)
<a name="2788"></a>    {
<a name="2789"></a>        /* if we have a reflexive pronoun object in the list, resolve it */
<a name="2790"></a>        if (matches.length() == 1 &amp;&amp; matches[1].obj.ofKind(Pronoun))
<a name="2791"></a>        {
<a name="2792"></a>            /* 
<a name="2793"></a>             *   We have a reflexive pronoun pending.  Ask the command for
<a name="2794"></a>             *   the current meaning of the reflexive.  
<a name="2795"></a>             */
<a name="2796"></a>            matches = cmd.resolveReflexive(matches[1].obj).mapAll(
<a name="2797"></a>                { x: new NPMatch(self, x, 0) });
<a name="2798"></a>
<a name="2799"></a>            /* it's an error if that didn't yield anything */
<a name="2800"></a>            if (matches.length() == 0)
<a name="2801"></a>                throw new NoAntecedentError(self, pronoun);
<a name="2802"></a>        }
<a name="2803"></a>        else
<a name="2804"></a>        {
<a name="2805"></a>            /*
<a name="2806"></a>             *   This isn't a reflexive, so it's a candidate to be an
<a name="2807"></a>             *   antecedent of a reflexive later in the phrase.  Pass it
<a name="2808"></a>             *   along to the command to note for future use.  Since we
<a name="2809"></a>             *   visit the noun phrases in their order of appearance in the
<a name="2810"></a>             *   command, we'll naturally have the latest one before the
<a name="2811"></a>             *   pronoun when we encounter a pronoun, which is exactly what
<a name="2812"></a>             *   we want: a reflexive pronoun binds to the nearest
<a name="2813"></a>             *   preceding noun that matches in gender, number, etc.  
<a name="2814"></a>             */
<a name="2815"></a>            matches.forEach({ match: cmd.saveReflexiveAnte(match.obj) });
<a name="2816"></a>
<a name="2817"></a>            /* also save the entire list, for THEMSELVES */
<a name="2818"></a>            cmd.saveReflexiveAnte(matches.mapAll({ x: x.obj }));
<a name="2819"></a>        }
<a name="2820"></a>    }
<a name="2821"></a>
<a name="2822"></a>    /* Build the 'objs' list from the match list */
<a name="2823"></a>    buildObjList()
<a name="2824"></a>    {
<a name="2825"></a>        objs = matches.mapAll({x: x.obj});
<a name="2826"></a>    }
<a name="2827"></a>
<a name="2828"></a>    /* 
<a name="2829"></a>     *   List of NPMatch objects.  This is populated during the matchName
<a name="2830"></a>     *   phase with the list of possible vocabulary matches, and then
<a name="2831"></a>     *   reduced during disambiguation to the final set.  
<a name="2832"></a>     */
<a name="2833"></a>    matches = []
<a name="2834"></a>
<a name="2835"></a>    /* 
<a name="2836"></a>     *   List of resolved objects.  This is populated after disambiguation
<a name="2837"></a>     *   from the 'matches' set - it contains the same objects, but simply
<a name="2838"></a>     *   the objects rather than the NPMatch wrappers. 
<a name="2839"></a>     */
<a name="2840"></a>    objs = []
<a name="2841"></a>
<a name="2842"></a>    /* add a literal to this phrase */
<a name="2843"></a>    addLiteral(tok) { tokens += tok; }
<a name="2844"></a>
<a name="2845"></a>    /* add a possessive qualifier, returning the new noun phrase */
<a name="2846"></a>    addPossessive(prod)
<a name="2847"></a>    {
<a name="2848"></a>        /* create, store, and return a new noun phrase for the possessor */
<a name="2849"></a>        return possQual = new NounPhrase(self, prod);
<a name="2850"></a>    }
<a name="2851"></a>
<a name="2852"></a>    /* add a contents qualifier, returning the new noun phrase */
<a name="2853"></a>    addContents(prep, prod)
<a name="2854"></a>    {
<a name="2855"></a>        /* remember the contents preposition */
<a name="2856"></a>        contPrep = prep;
<a name="2857"></a>
<a name="2858"></a>        /* create, store, and return a new noun phrase for the contents */
<a name="2859"></a>        return contQual = new NounPhrase(self, prod);
<a name="2860"></a>    }
<a name="2861"></a>
<a name="2862"></a>    /* add a locational qualifier, returning the new noun phrase */
<a name="2863"></a>    addLocation(locType, prod)
<a name="2864"></a>    {
<a name="2865"></a>        /* create a new noun phrase for the location */
<a name="2866"></a>        locQual = new NounPhrase(self, prod);
<a name="2867"></a>
<a name="2868"></a>        /* set its location type */
<a name="2869"></a>        locQual.locType = locType;
<a name="2870"></a>
<a name="2871"></a>        /* return the new phrase */
<a name="2872"></a>        return locQual;
<a name="2873"></a>    }
<a name="2874"></a>
<a name="2875"></a>    /* add a quantifier, given as an integer value */
<a name="2876"></a>    addQuantifier(num)
<a name="2877"></a>    {
<a name="2878"></a>        quantifier = num;
<a name="2879"></a>    }
<a name="2880"></a>
<a name="2881"></a>    /* add an ordinal, given as an integer value */
<a name="2882"></a>    addOrdinal(num)
<a name="2883"></a>    {
<a name="2884"></a>        ordinal = num;
<a name="2885"></a>    }
<a name="2886"></a>
<a name="2887"></a>    /* add an exclusion list item */
<a name="2888"></a>    addExclusionItem(prod)
<a name="2889"></a>    {
<a name="2890"></a>        /* if we don't already have an exclusion list, create one */
<a name="2891"></a>        if (exclusions == nil)
<a name="2892"></a>            exclusions = [];
<a name="2893"></a>
<a name="2894"></a>        /* create a new NounPhrase */
<a name="2895"></a>        local np = new NounPhrase(self, prod);
<a name="2896"></a>
<a name="2897"></a>        /* add it to the exclusion list */
<a name="2898"></a>        exclusions += np;
<a name="2899"></a>
<a name="2900"></a>        /* return the new noun phrase */
<a name="2901"></a>        return np;
<a name="2902"></a>    }
<a name="2903"></a>
<a name="2904"></a>    /*
<a name="2905"></a>     *   Does this noun phrase refer to multiple objects structurally?
<a name="2906"></a>     *   This is true if any the matches used plural words, or the
<a name="2907"></a>     *   determiner is All, or we have a quantifier greater than 1.  
<a name="2908"></a>     */
<a name="2909"></a>    isMultiple()
<a name="2910"></a>    {
<a name="2911"></a>        return determiner == All
<a name="2912"></a>            || (quantifier != nil &amp;&amp; quantifier &gt; 1)
<a name="2913"></a>            || matches.indexWhich({ m: m.match &amp; MatchPlural }) != nil;
<a name="2914"></a>    }
<a name="2915"></a>
<a name="2916"></a>    /* 
<a name="2917"></a>     *   the Command list we're a part of (&amp;dobjNPs, &amp;iobjNPs, etc: the
<a name="2918"></a>     *   Command overrides this to the actual list property for a primary
<a name="2919"></a>     *   noun phrase, and for qualifiers such as possessives, this
<a name="2920"></a>     *   inherited version looks it up via the parent) 
<a name="2921"></a>     */
<a name="2922"></a>    role = (parent.role)
<a name="2923"></a>
<a name="2924"></a>    /* the NounPhrase we qualify, if we're a possessive or locational */
<a name="2925"></a>    parent = nil
<a name="2926"></a>
<a name="2927"></a>    /* the grammar production match object for this noun phrase */
<a name="2928"></a>    prod = nil
<a name="2929"></a>
<a name="2930"></a>    /* 
<a name="2931"></a>     *   the grammar match for the core noun phrase; this is the part that
<a name="2932"></a>     *   names a single object, stripped of all qualifiers (such as
<a name="2933"></a>     *   possessives, articles, quantifiers, and locational phrases) 
<a name="2934"></a>     */
<a name="2935"></a>    coreProd = nil
<a name="2936"></a>
<a name="2937"></a>    /* the literal tokens making up the noun phrase */
<a name="2938"></a>    tokens = []
<a name="2939"></a>
<a name="2940"></a>    /* the pronoun, if any, as a Pronoun object */
<a name="2941"></a>    pronoun = nil
<a name="2942"></a>
<a name="2943"></a>    /* the possessive qualifier, if any ("BOB'S box") */
<a name="2944"></a>    possQual = nil
<a name="2945"></a>
<a name="2946"></a>    /* the locational qualifier phrase, if any ("the box ON THE SHELF") */
<a name="2947"></a>    locQual = nil
<a name="2948"></a>
<a name="2949"></a>    /* 
<a name="2950"></a>     *   The locational qualifier relationship, as a LocType object.  (This
<a name="2951"></a>     *   is stored on the locational qualifier noun phrase itself, not on
<a name="2952"></a>     *   the underlying noun phrase it qualifies.)  
<a name="2953"></a>     */
<a name="2954"></a>    locType = nil
<a name="2955"></a>
<a name="2956"></a>    /* the contents qualifier phrase, if any ("the bucket OF WATER") */
<a name="2957"></a>    contQual = nil
<a name="2958"></a>
<a name="2959"></a>    /* the preposition of the contents qualifier */
<a name="2960"></a>    contPrep = nil
<a name="2961"></a>
<a name="2962"></a>    /* the quantifier, if any, as a number: for "five books", this is 5 */
<a name="2963"></a>    quantifier = nil
<a name="2964"></a>
<a name="2965"></a>    /* 
<a name="2966"></a>     *   The ordinal value, if any, as a number: for "the third one", this
<a name="2967"></a>     *   is 3.  This is intended for use in disambiguation replies, to let
<a name="2968"></a>     *   the user pick out an item by its position in the offered list.  
<a name="2969"></a>     */
<a name="2970"></a>    ordinal = nil
<a name="2971"></a>
<a name="2972"></a>    /* the determiner, if any, as a Determiner object */
<a name="2973"></a>    determiner = nil
<a name="2974"></a>
<a name="2975"></a>    /* 
<a name="2976"></a>     *   the exclusion list, if any (this is the list following EXCEPT or
<a name="2977"></a>     *   BUT in a phrase like ALL EXCEPT THE RED ONES) 
<a name="2978"></a>     */
<a name="2979"></a>    exclusions = nil
<a name="2980"></a>
<a name="2981"></a>    /* the name list from the disambiguation query */
<a name="2982"></a>    disambigNameList = nil
<a name="2983"></a>;
<a name="2984"></a>
<a name="2985"></a>/*
<a name="2986"></a> *   TopicPhrase is a special kind of NounPhrase for topics (ASK ABOUT,
<a name="2987"></a> *   TELL ABOUT, TALK ABOUT, LOOK UP, etc).  These phrases aren't resolved
<a name="2988"></a> *   to game-world objects the way ordinary noun phrases are, but instead
<a name="2989"></a> *   are resolved to conversation topic objects.  
<a name="2990"></a> */
<a name="2991"></a>class TopicPhrase: NounPhrase
<a name="2992"></a>     /*
<a name="2993"></a>     *   Get the list of objects matching the vocabulary words in our noun
<a name="2994"></a>     *   phrase.  Populates our 'matches' property with a vector of matching
<a name="2995"></a>     *   objects.  This doesn't look at any of our qualifiers, or attempt
<a name="2996"></a>     *   to disambiguate contextually; it simply finds everything in scope
<a name="2997"></a>     *   that the noun phrase could refer to.  
<a name="2998"></a>     */
<a name="2999"></a>    matchVocab(cmd)
<a name="3000"></a>    {
<a name="3001"></a>        /* start with an empty vector */
<a name="3002"></a>        local v = new Vector(32);
<a name="3003"></a>        
<a name="3004"></a>        /* get the current scope list */
<a name="3005"></a>        //        local scope = World.scope;
<a name="3006"></a>        
<a name="3007"></a>        
<a name="3008"></a>        local scope = Q.topicScopeList;
<a name="3009"></a>        
<a name="3010"></a>        /* check what kind of phrase we have */
<a name="3011"></a>        if (pronoun != nil)
<a name="3012"></a>        {
<a name="3013"></a>            /* it's a pronoun - resolved based on the antecedent */
<a name="3014"></a>            addMatches(v, pronoun.resolve(), 0);
<a name="3015"></a>            
<a name="3016"></a>            /* if there are no antecedents, flag the error */
<a name="3017"></a>            if (v.length() == 0)
<a name="3018"></a>                throw new NoAntecedentError(self, pronoun);
<a name="3019"></a>            
<a name="3020"></a>            /* filter for in-scope objects (or reflexive placeholders) */
<a name="3021"></a>            v = v.subset(
<a name="3022"></a>                { m: m.obj.ofKind(Pronoun) || scope.find(m.obj) });
<a name="3023"></a>            
<a name="3024"></a>            /* if that leaves nothing, flag the error */
<a name="3025"></a>            if (v.length() == 0)
<a name="3026"></a>                throw new AntecedentScopeError(cmd, self, pronoun);
<a name="3027"></a>            
<a name="3028"></a>        }
<a name="3029"></a>        
<a name="3030"></a>        else
<a name="3031"></a>        {
<a name="3032"></a>            /* 
<a name="3033"></a>             *   It's a named object.  Our 'tokens' property is a list of the
<a name="3034"></a>             *   words in the noun phrase in the user input.  Match it against
<a name="3035"></a>             *   the objects in physical scope.
<a name="3036"></a>             */
<a name="3037"></a>             v.appendAll(matchNameScope(cmd, scope));
<a name="3038"></a>            
<a name="3039"></a>            /* 
<a name="3040"></a>             *   Create a dummy object to represent the literal text; we may
<a name="3041"></a>             *   need this even if there are other matches to ensure that a
<a name="3042"></a>             *   regular expression is matched on a TopicEntry.
<a name="3043"></a>             */
<a name="3044"></a>            local obj = new Topic(tokens.join(' ').trim());
<a name="3045"></a>            
<a name="3046"></a>            /* 
<a name="3047"></a>             *   Note that the dummy object has been newly created so it can defer to any
<a name="3048"></a>             *   user-defined topics when it comes to selecting the best match.
<a name="3049"></a>             */
<a name="3050"></a>            obj.newlyCreated = true;
<a name="3051"></a>            
<a name="3052"></a>            /* Wrap the dummy object in am NPMatch object */
<a name="3053"></a>            local lst = [obj];
<a name="3054"></a>
<a name="3055"></a>            addMatches(v, lst, 1);
<a name="3056"></a>            
<a name="3057"></a>            matches = v;  
<a name="3058"></a>            
<a name="3059"></a>            cmd.madeTopic = true;
<a name="3060"></a>            
<a name="3061"></a>
<a name="3062"></a>        }
<a name="3063"></a>        
<a name="3064"></a>        /* save the match list so far */
<a name="3065"></a>        matches = v;
<a name="3066"></a>        
<a name="3067"></a>        
<a name="3068"></a>        
<a name="3069"></a>        /* 
<a name="3070"></a>         *   if we have a possessive qualifier, apply it, but only if it is to be applied to a Thing
<a name="3071"></a>         *   (rather than a Topic)
<a name="3072"></a>         */
<a name="3073"></a>        if (possQual != nil &amp;&amp; matches.indexWhich({x: x.obj.ofKind(Thing)}))
<a name="3074"></a>        {
<a name="3075"></a>            /* match vocabulary for the possessive phrase */
<a name="3076"></a>            possQual.matchVocabPoss(cmd);
<a name="3077"></a>            
<a name="3078"></a>            /* 
<a name="3079"></a>             *   apply the qualifier, filtering out things not owned by the
<a name="3080"></a>             *   object named in the qualifier
<a name="3081"></a>             */
<a name="3082"></a>            possQual.applyPossessive();
<a name="3083"></a>            
<a name="3084"></a>            /* if that empties our list, flag it */
<a name="3085"></a>            if (matches.length() == 0)
<a name="3086"></a>                throw new NoneInOwnerError(cmd, self, possQual);
<a name="3087"></a>            
<a name="3088"></a>            /* expand the error text to include the possessive qualifier */
<a name="3089"></a>            expandErrName(possQual);
<a name="3090"></a>        }
<a name="3091"></a>        
<a name="3092"></a>      
<a name="3093"></a>        
<a name="3094"></a>//        if(matches.length == 0)
<a name="3095"></a>        {        
<a name="3096"></a>           
<a name="3097"></a>        }
<a name="3098"></a>        
<a name="3099"></a>        
<a name="3100"></a>        local res = new ResolvedTopic(matches.mapAll({o: o.obj}).toList, tokens);
<a name="3101"></a>        
<a name="3102"></a>        res = new NPMatch(v[1].np, res, v[1].match);
<a name="3103"></a>        
<a name="3104"></a>        matches = new Vector([res]);
<a name="3105"></a>        
<a name="3106"></a>        
<a name="3107"></a>    }
<a name="3108"></a>    
<a name="3109"></a>    matchNameScope(cmd, scope)
<a name="3110"></a>    {
<a name="3111"></a>        /* set up a vector for the results */
<a name="3112"></a>        local v = new Vector(32);
<a name="3113"></a>        
<a name="3114"></a>        /*
<a name="3115"></a>         *   Run through the scope list and ask each object if it matches
<a name="3116"></a>         *   the noun phrase.  Keep the ones that match.  
<a name="3117"></a>         */
<a name="3118"></a>        foreach (local obj in scope)
<a name="3119"></a>        {
<a name="3120"></a>            /* ask this object if it matches */
<a name="3121"></a>            local match = obj.matchName(tokens);
<a name="3122"></a>            
<a name="3123"></a>            /* if it matches, include it in the results */
<a name="3124"></a>            if (match)
<a name="3125"></a>                v.append(new NPMatch(self, obj, match));
<a name="3126"></a>        }
<a name="3127"></a>
<a name="3128"></a>
<a name="3129"></a>        /* return the list */
<a name="3130"></a>        return v;
<a name="3131"></a>    }
<a name="3132"></a>    
<a name="3133"></a>    selectObjects(cmd)
<a name="3134"></a>    {
<a name="3135"></a>        filterResolveList(self, cmd, All);
<a name="3136"></a>    }
<a name="3137"></a>;
<a name="3138"></a>
<a name="3139"></a>class ResolvedTopic: object
<a name="3140"></a>    construct(lst, toks)
<a name="3141"></a>    {
<a name="3142"></a>        /* 
<a name="3143"></a>         *   if our list of topics has more than one entry, sort it in ascending
<a name="3144"></a>         *   order of length of name. That's because the shorter the name, the
<a name="3145"></a>         *   closer it may be to what the player actually typed.
<a name="3146"></a>         */
<a name="3147"></a>        if(lst != nil &amp;&amp; lst.length &gt; 1)
<a name="3148"></a>            topicList = lst.sort(SortAsc, {a, b: a.name.length - b.name.length});
<a name="3149"></a>        else       
<a name="3150"></a>            topicList = lst;    
<a name="3151"></a>        tokens = toks;
<a name="3152"></a>    }    
<a name="3153"></a>    
<a name="3154"></a>    topicList = nil
<a name="3155"></a>    tokens = nil
<a name="3156"></a>    
<a name="3157"></a>    /* Get the object representing this ResolvedTopic's best match. */
<a name="3158"></a>    getBestMatch()
<a name="3159"></a>    {
<a name="3160"></a>        if(topicList == nil)
<a name="3161"></a>            return nil;
<a name="3162"></a>        
<a name="3163"></a>        /* 
<a name="3164"></a>         *   If possible, find an object that hasn't just been newly created by the parser as a
<a name="3165"></a>         *   fallback wrapper (because we'd prefer to use Thing or Topic defined by the user).
<a name="3166"></a>         */
<a name="3167"></a>        local top = topicList.valWhich({t:!t.newlyCreated});
<a name="3168"></a>        
<a name="3169"></a>        /*   
<a name="3170"></a>         *   If we find a user-defined topic, return that; otherwise simply return the first item in
<a name="3171"></a>         *   the list.
<a name="3172"></a>         */
<a name="3173"></a>        return top ?? topicList[1];
<a name="3174"></a>    }    
<a name="3175"></a>    
<a name="3176"></a>    getTopicText = tokens.join(' ').trim()
<a name="3177"></a>    theName = (topicList != nil ? topicList[1].theName : getTopicText)
<a name="3178"></a>    aName = (topicList != nil ? topicList[1].aName : getTopicText)
<a name="3179"></a>    name = (topicList != nil ? topicList[1].name : getTopicText)
<a name="3180"></a>    person = 3
<a name="3181"></a>;
<a name="3182"></a>
<a name="3183"></a>/*
<a name="3184"></a>     *   LiteralPhrase is a special kind of NounPhrase for literals (TYPE,
<a name="3185"></a>     *   WRITE, SET TO, etc).  These phrases aren't resolved to game-world
<a name="3186"></a>     *   objects, but instead are just treated as literal text.  
<a name="3187"></a> */
<a name="3188"></a>class LiteralPhrase: NounPhrase
<a name="3189"></a>    matchVocab(cmd)
<a name="3190"></a>    {
<a name="3191"></a>        local v = new Vector(2);
<a name="3192"></a>        
<a name="3193"></a>        /* Recreate the literal text */
<a name="3194"></a>        local litName = tokens.join(' ');
<a name="3195"></a>               
<a name="3196"></a>        /* Create a dummy object to represent the literal text */
<a name="3197"></a>        local obj = new LiteralObject(litName.trim());
<a name="3198"></a>        
<a name="3199"></a>        /* Wrap the dummy object in am NPMatch object */
<a name="3200"></a>        local lst = [obj];
<a name="3201"></a>        addMatches(v, lst, MatchNoApprox);
<a name="3202"></a>        
<a name="3203"></a>        matches = v;   
<a name="3204"></a>    }
<a name="3205"></a>    
<a name="3206"></a>    selectObjects(cmd)
<a name="3207"></a>    {
<a name="3208"></a>        /* do nothing; there's only one object */
<a name="3209"></a>    }
<a name="3210"></a>;
<a name="3211"></a>
<a name="3212"></a>/* object to hold the result of a literal input */
<a name="3213"></a>
<a name="3214"></a>class LiteralObject: object
<a name="3215"></a>    construct(name_)
<a name="3216"></a>    {
<a name="3217"></a>        name = name_;
<a name="3218"></a>    }
<a name="3219"></a>    
<a name="3220"></a>    name = nil
<a name="3221"></a>    theName = (name)
<a name="3222"></a>    person = 3
<a name="3223"></a>;
<a name="3224"></a>    
<a name="3225"></a>/*
<a name="3226"></a> *   NumberPhrase is a special kind of NounPhrase for numeric literals
<a name="3227"></a> *   (e.g., FOOTNOTE n).  These phrases aren't resolved to game-world
<a name="3228"></a> *   objects, but are simply taken as numeric values. 
<a name="3229"></a> */
<a name="3230"></a>class NumberPhrase: NounPhrase
<a name="3231"></a>     matchVocab(cmd)
<a name="3232"></a>    {
<a name="3233"></a>        local v = new Vector(2);
<a name="3234"></a>        
<a name="3235"></a>        /* Get the number just entered*/        
<a name="3236"></a>        local val = prod.numval;
<a name="3237"></a>               
<a name="3238"></a>        /* Create a dummy object to represent the literal text */
<a name="3239"></a>        local obj = new NumericObject(tokens, val);
<a name="3240"></a>        
<a name="3241"></a>        /* Wrap the dummy object in am NPMatch object */
<a name="3242"></a>        local lst = [obj];
<a name="3243"></a>        addMatches(v, lst, MatchNoApprox);
<a name="3244"></a>        
<a name="3245"></a>        matches = v;   
<a name="3246"></a>    }
<a name="3247"></a>    
<a name="3248"></a>    selectObjects(cmd)
<a name="3249"></a>    {
<a name="3250"></a>        /* do nothing; there's only one object */
<a name="3251"></a>    }
<a name="3252"></a>;
<a name="3253"></a>
<a name="3254"></a>/* An object to hold a numerical value. */
<a name="3255"></a>class NumericObject: object
<a name="3256"></a>    construct(toks, val)
<a name="3257"></a>    {   
<a name="3258"></a>        numToks = toks;
<a name="3259"></a>        numVal = val;
<a name="3260"></a>    }
<a name="3261"></a>    
<a name="3262"></a>    numToks = nil
<a name="3263"></a>    numVal = nil
<a name="3264"></a>    numStr = (numToks.join(' '))
<a name="3265"></a>;
<a name="3266"></a>    
<a name="3267"></a>
<a name="3268"></a>/* ------------------------------------------------------------------------ */
<a name="3269"></a>/*
<a name="3270"></a> *   NPMatch is an object that describes one object matching a noun phrase.
<a name="3271"></a> */
<a name="3272"></a>class NPMatch: object
<a name="3273"></a>    construct(np, obj, match)
<a name="3274"></a>    {
<a name="3275"></a>        /* save the NounPhrase, the object we matched, and the match flags */
<a name="3276"></a>        self.np = np;
<a name="3277"></a>        self.obj = obj;
<a name="3278"></a>        self.match = match;
<a name="3279"></a>
<a name="3280"></a>        /* 
<a name="3281"></a>         *   set the name initially to the object name; the Command will
<a name="3282"></a>         *   replace this before execution with a name from the
<a name="3283"></a>         *   Distinguishers that's unique relative to the other objects in
<a name="3284"></a>         *   the list 
<a name="3285"></a>         */
<a name="3286"></a>        self.name = obj.name;
<a name="3287"></a>
<a name="3288"></a>        /*
<a name="3289"></a>         *   Calculate the match strength for sorting purposes.
<a name="3290"></a>         *   
<a name="3291"></a>         *   The strength tells us how well the vocabulary matched the
<a name="3292"></a>         *   object.  Matches without truncation are stronger than those
<a name="3293"></a>         *   that include truncated words; likewise character
<a name="3294"></a>         *   approximation.  Matches that consist of entirely adjectives
<a name="3295"></a>         *   are weaker than those that contain nouns or plurals (for
<a name="3296"></a>         *   example, if we have a TOY CAR and a TOY CAR REMOTE CONTROL in
<a name="3297"></a>         *   scope, we'd consider CAR to be an unambiguous match to the TOY
<a name="3298"></a>         *   CAR, since the match to the REMOTE is weak by virtue of being
<a name="3299"></a>         *   all adjectives).
<a name="3300"></a>         *   
<a name="3301"></a>         *   The MatchXxx bit flags are arranged in arithmetic order of
<a name="3302"></a>         *   match strength, so the 'match' value basically equals the
<a name="3303"></a>         *   strength.  However, for the strength calculation, plurals and
<a name="3304"></a>         *   nouns are equivalent.  So the strength value is the match
<a name="3305"></a>         *   value with any plural flag replaced by the noun flag. 
<a name="3306"></a>         */
<a name="3307"></a>        self.strength = (match &amp; ~MatchPlural)
<a name="3308"></a>            | (match &amp; MatchPlural ? MatchNoun : 0);
<a name="3309"></a>    }
<a name="3310"></a>
<a name="3311"></a>    /* the NounPhrase we matched */
<a name="3312"></a>    np = nil
<a name="3313"></a>
<a name="3314"></a>    /* the matching object */
<a name="3315"></a>    obj = nil
<a name="3316"></a>
<a name="3317"></a>    /* 
<a name="3318"></a>     *   the match flags - this is a combination of MatchXxx flags as
<a name="3319"></a>     *   returned from Mentionable.matchName()
<a name="3320"></a>     */
<a name="3321"></a>    match = 0
<a name="3322"></a>
<a name="3323"></a>    /* the match strength, for sorting the match list */
<a name="3324"></a>    strength = 0
<a name="3325"></a>
<a name="3326"></a>    /* the selection/disambiguation flags (SelXxx) */
<a name="3327"></a>    flags = 0
<a name="3328"></a>
<a name="3329"></a>    /*
<a name="3330"></a>     *   Disambiguation score.  This is a number assigned by the action in
<a name="3331"></a>     *   scoreObjects().
<a name="3332"></a>     */
<a name="3333"></a>    score = 0
<a name="3334"></a>
<a name="3335"></a>    /*
<a name="3336"></a>     *   The name, for announcement purposes.  This is filled in by the
<a name="3337"></a>     *   Command during execution.  The Command figures the name so that
<a name="3338"></a>     *   it's distinguished from all of the other objects in the same noun
<a name="3339"></a>     *   role in the command.  
<a name="3340"></a>     */
<a name="3341"></a>    name = ''
<a name="3342"></a>;
<a name="3343"></a>
<a name="3344"></a>
<a name="3345"></a>/* ------------------------------------------------------------------------ */
<a name="3346"></a>/*
<a name="3347"></a> *   Our root class for grammar productions.  (A "production" represents a
<a name="3348"></a> *   match to a syntax rule, as defined with a 'grammar' template.)
<a name="3349"></a> *   
<a name="3350"></a> *   The language module's grammar rules can define certain special
<a name="3351"></a> *   properties on any production match object, and we'll find them in the
<a name="3352"></a> *   course of building the command from the match tree:
<a name="3353"></a> *   
<a name="3354"></a> *   endOfSentence=true - define this on a production for a sentence-ending
<a name="3355"></a> *   verb conjunction.  In English (and most Western languages), this can
<a name="3356"></a> *   be used with rules that match punctuation marks like periods,
<a name="3357"></a> *   exclamation points, and question marks, since these marks typically
<a name="3358"></a> *   end a sentence.  The parser distinguishes between the grammar rules
<a name="3359"></a> *   for the first clause in a sentence vs subsequent clauses.  It starts a
<a name="3360"></a> *   new input line with the first-in-sentence rule, then uses the
<a name="3361"></a> *   additional clause rule for each subsequent clause.  When a clause ends
<a name="3362"></a> *   with a sentence-ending mark, though, we'll treat the next clause as a
<a name="3363"></a> *   sentence opener again.  
<a name="3364"></a> */
<a name="3365"></a>class Production: object
<a name="3366"></a>    /* get the original text of the command for this match */
<a name="3367"></a>    getText()
<a name="3368"></a>    {
<a name="3369"></a>        /* if we have no token list, return an empty string */
<a name="3370"></a>        if (tokenList == nil)
<a name="3371"></a>            return '';
<a name="3372"></a>        
<a name="3373"></a>        /* build the string based on my original token list */
<a name="3374"></a>        return cmdTokenizer.buildOrigText(getTokens());
<a name="3375"></a>    }
<a name="3376"></a>
<a name="3377"></a>    /* get my original token list, in canonical tokenizer format */
<a name="3378"></a>    getTokens()
<a name="3379"></a>    {
<a name="3380"></a>        /* 
<a name="3381"></a>         *   return the subset of the full token list from my first token
<a name="3382"></a>         *   to my last token
<a name="3383"></a>         */
<a name="3384"></a>        return nilToList(tokenList).sublist(
<a name="3385"></a>            firstTokenIndex, lastTokenIndex - firstTokenIndex + 1);
<a name="3386"></a>    }
<a name="3387"></a>
<a name="3388"></a>    /*
<a name="3389"></a>     *   Build the command for this production and its children.  By
<a name="3390"></a>     *   default, we'll simply traverse into our children.  
<a name="3391"></a>     */
<a name="3392"></a>    build(cmd, np)
<a name="3393"></a>    {
<a name="3394"></a>        /* if this is a sentence-ending mark, note it */
<a name="3395"></a>        if (endOfSentence)
<a name="3396"></a>            noteEndOfSentence(cmd, self);
<a name="3397"></a>
<a name="3398"></a>        /* run through our list of matches */
<a name="3399"></a>        local info = grammarInfoForBuild();
<a name="3400"></a>        for (local i = 2, local len = info.length() ; i &lt;= len ; ++i)
<a name="3401"></a>        {
<a name="3402"></a>            /* get the current match */
<a name="3403"></a>            local cur = info[i];
<a name="3404"></a>
<a name="3405"></a>            /* process it based on its type */
<a name="3406"></a>            switch (dataType(cur))
<a name="3407"></a>            {
<a name="3408"></a>            case TypeSString:
<a name="3409"></a>                /* it's a literal token match item */
<a name="3410"></a>                visitLiteral(cmd, np, cur);
<a name="3411"></a>                break;
<a name="3412"></a>
<a name="3413"></a>            case TypeObject:
<a name="3414"></a>                /* 
<a name="3415"></a>                 *   An object is a production sub-tree.  Set its parent
<a name="3416"></a>                 *   pointer to point back at us. 
<a name="3417"></a>                 */
<a name="3418"></a>                cur.parent = self;
<a name="3419"></a>
<a name="3420"></a>                /* visit the production */
<a name="3421"></a>                visitProd(cmd, np, cur);
<a name="3422"></a>                break;
<a name="3423"></a>            }
<a name="3424"></a>        }
<a name="3425"></a>
<a name="3426"></a>        /* 
<a name="3427"></a>         *   If there's a determiner, apply it the noun phrase.  Apply the
<a name="3428"></a>         *   determiner after building out the subtree, so that the parent
<a name="3429"></a>         *   determiner overrides any found in the subtree. 
<a name="3430"></a>         */
<a name="3431"></a>        if (determiner != nil)
<a name="3432"></a>            np.determiner = determiner;
<a name="3433"></a>    }
<a name="3434"></a>
<a name="3435"></a>    /*
<a name="3436"></a>     *   Get the grammar match list for build() purposes.  By default, this
<a name="3437"></a>     *   simply returns the grammarInfo() results, which are automatically
<a name="3438"></a>     *   generated by the compiler to return a list of the "-&gt;prop" values from
<a name="3439"></a>     *   the matched grammar rule.  Some rules might want to modify that default
<a name="3440"></a>     *   value list, so we provide this routine as an override hook.
<a name="3441"></a>     */
<a name="3442"></a>    grammarInfoForBuild()
<a name="3443"></a>    {
<a name="3444"></a>        return grammarInfo();
<a name="3445"></a>    }
<a name="3446"></a>    
<a name="3447"></a>    
<a name="3448"></a>    /*
<a name="3449"></a>     *   Add a new NounPhrase item to the list under construction.  Certain
<a name="3450"></a>     *   productions are associated with specific functional slots in the
<a name="3451"></a>     *   abstract command - direct object, indirect object, EXCEPT list,
<a name="3452"></a>     *   etc.  This routine is for such production subclasses to override,
<a name="3453"></a>     *   to direct new noun phrases into the appropriate slot lists.  In a
<a name="3454"></a>     *   grammar, the functional role is typically at a higher level in the
<a name="3455"></a>     *   tree, with ordinary noun phrases plugged in underneath.
<a name="3456"></a>     *   
<a name="3457"></a>     *   Our default handling is to first check our nounPhraseRole
<a name="3458"></a>     *   property; if it's set, it tells us the role that this sub-tree
<a name="3459"></a>     *   plays in the predicate (direct object, indirect object,
<a name="3460"></a>     *   accessory).  We use that information to add the new NounPhrase to
<a name="3461"></a>     *   the Command list that we're building for our assigned role.
<a name="3462"></a>     *   
<a name="3463"></a>     *   If nounPhraseRole is nil, then we simply pass the request up to
<a name="3464"></a>     *   our parent.  Eventually we should reach a node encoding the
<a name="3465"></a>     *   function slot.  
<a name="3466"></a>     */
<a name="3467"></a>    addNounListItem(cmd, prod)
<a name="3468"></a>    {
<a name="3469"></a>        if (nounPhraseRole != nil)
<a name="3470"></a>            return cmd.addNounListItem(nounPhraseRole, prod);
<a name="3471"></a>        else
<a name="3472"></a>            return parent.addNounListItem(cmd, prod);
<a name="3473"></a>    }
<a name="3474"></a>
<a name="3475"></a>    /* 
<a name="3476"></a>     *   Note an end-of-sentence marker.  We'll simply notify our parent by
<a name="3477"></a>     *   default. 
<a name="3478"></a>     */
<a name="3479"></a>    noteEndOfSentence(cmd, prod)
<a name="3480"></a>    {
<a name="3481"></a>        if (parent != nil)
<a name="3482"></a>            parent.noteEndOfSentence(cmd, prod);
<a name="3483"></a>    }
<a name="3484"></a>
<a name="3485"></a>    /*
<a name="3486"></a>     *   The NounPhrase subclass to use for noun phrases within this
<a name="3487"></a>     *   sub-tree.  By default, we look to our parent; if we don't have a
<a name="3488"></a>     *   parent, we use the base NounPhrase class.
<a name="3489"></a>     *   
<a name="3490"></a>     *   Special phrase types (topics, literals, and numbers) have their
<a name="3491"></a>     *   own NounPhrase subclasses.  This is important because the
<a name="3492"></a>     *   resolution rules for these phrase types differ from the regular
<a name="3493"></a>     *   object resolution rules.  
<a name="3494"></a>     */
<a name="3495"></a>    npClass = (parent != nil ? parent.npClass : NounPhrase)
<a name="3496"></a>
<a name="3497"></a>    /*
<a name="3498"></a>     *   My assigned noun phrase role, as a NounRole object.  This must be
<a name="3499"></a>     *   explicitly set for the top node in a noun slot (which can be a
<a name="3500"></a>     *   noun list production, a single noun production, a topic, etc).
<a name="3501"></a>     *   
<a name="3502"></a>     *   In a positional language grammar, the predicate production will
<a name="3503"></a>     *   mark its immediate child in each noun phrase slot by setting this
<a name="3504"></a>     *   according to the role that the sub-tree plays in the predicate
<a name="3505"></a>     *   grammar.  Non-positional languages that use grammatical case or
<a name="3506"></a>     *   other ways of encoding the role information must set this some
<a name="3507"></a>     *   other way.  
<a name="3508"></a>     */
<a name="3509"></a>    nounPhraseRole = nil
<a name="3510"></a>
<a name="3511"></a>    /*
<a name="3512"></a>     *   Get our noun phrase role.  If we don't have a role defined
<a name="3513"></a>     *   directly, we'll inherit the role from our parent node. 
<a name="3514"></a>     */
<a name="3515"></a>    getNounPhraseRole()
<a name="3516"></a>    {
<a name="3517"></a>        return nounPhraseRole != nil
<a name="3518"></a>            ? nounPhraseRole : parent.nounPhraseRole;
<a name="3519"></a>    }
<a name="3520"></a>
<a name="3521"></a>    /* 
<a name="3522"></a>     *   Visit a literal token child in our sub-tree.  This is called
<a name="3523"></a>     *   during the build process for each literal token in our child list.
<a name="3524"></a>     *   By default, we add the token to the command's current noun phrase.
<a name="3525"></a>     */
<a name="3526"></a>    visitLiteral(cmd, np, tok)
<a name="3527"></a>    {
<a name="3528"></a>        /* add the literal to the current noun phrase */
<a name="3529"></a>        if(np != nil)
<a name="3530"></a>           np.addLiteral(tok);
<a name="3531"></a>    }
<a name="3532"></a>
<a name="3533"></a>    /* 
<a name="3534"></a>     *   Visit a production object in our list.  This is called during the
<a name="3535"></a>     *   build process for each production object in our child list.  By
<a name="3536"></a>     *   default, we simply build the child production recursively.  
<a name="3537"></a>     */
<a name="3538"></a>    visitProd(cmd, np, prod)
<a name="3539"></a>    {
<a name="3540"></a>        /* build out this production recursively */
<a name="3541"></a>        prod.build(cmd, np);
<a name="3542"></a>    }
<a name="3543"></a>
<a name="3544"></a>    /*
<a name="3545"></a>     *   The determiner that this production applies to the noun phrase
<a name="3546"></a>     *   it's part of, as a Determiner object.  If this is non-nil, this
<a name="3547"></a>     *   Determiner will be set in the current NounPhrase when we visit
<a name="3548"></a>     *   this production in the build process.  
<a name="3549"></a>     */
<a name="3550"></a>    determiner = nil
<a name="3551"></a>
<a name="3552"></a>    /* 
<a name="3553"></a>     *   My parent production.  The low-level GrammarProd mechanism doesn't
<a name="3554"></a>     *   set this up, so we set it up ourselves in the course of building
<a name="3555"></a>     *   out the tree.  In build(), just before we visit each
<a name="3556"></a>     *   sub-production, we set the sub-production's 'parent' property to
<a name="3557"></a>     *   point back to the parent production.  This property is therefore
<a name="3558"></a>     *   always set while we're traversing the child's tree, but won't
<a name="3559"></a>     *   necessarily be set yet if we're not currently working somewhere
<a name="3560"></a>     *   within the child's tree.  That means that you can always look at
<a name="3561"></a>     *   'parent' within your own build() routine or a child build()
<a name="3562"></a>     *   routine, but you can't necessarily look at it across the tree or
<a name="3563"></a>     *   within your own children.  
<a name="3564"></a>     */
<a name="3565"></a>    parent = nil
<a name="3566"></a>
<a name="3567"></a>    /* 
<a name="3568"></a>     *   Find a parent matching a given test.  We'll scan up the parent
<a name="3569"></a>     *   tree, looking for the nearest parent p for which func(p) returns
<a name="3570"></a>     *   true, returning p.  If we can't find one, we return nil.  
<a name="3571"></a>     */
<a name="3572"></a>    findParent(func)
<a name="3573"></a>    {
<a name="3574"></a>        /* find the nearest parent that passes the callback test */
<a name="3575"></a>        local par;
<a name="3576"></a>        for (par = parent ; par != nil &amp;&amp; !func(par) ; par = par.parent) ;
<a name="3577"></a>
<a name="3578"></a>        /* return what we found */
<a name="3579"></a>        return par;
<a name="3580"></a>    }
<a name="3581"></a>
<a name="3582"></a>    /* Is this production a child of the given production? */
<a name="3583"></a>    isChildOf(prod)
<a name="3584"></a>    {
<a name="3585"></a>        /* look up my parent tree for the given parent */
<a name="3586"></a>        for (local par = parent ; par != nil ; par = par.parent)
<a name="3587"></a>        {
<a name="3588"></a>            /* if this is the one we're looking for, we're a child */
<a name="3589"></a>            if (par == prod)
<a name="3590"></a>                return true;
<a name="3591"></a>        }
<a name="3592"></a>
<a name="3593"></a>        /* didn't find it */
<a name="3594"></a>        return nil;
<a name="3595"></a>    }
<a name="3596"></a>
<a name="3597"></a>    /*
<a name="3598"></a>     *   Find the action.  This finds the child of type VerbProduction,
<a name="3599"></a>     *   then retrieves the action from the verb production.  
<a name="3600"></a>     */
<a name="3601"></a>    findAction()
<a name="3602"></a>    {
<a name="3603"></a>        /* find the VerbProduction among our children */
<a name="3604"></a>        local vp = findChild(VerbProduction);
<a name="3605"></a>
<a name="3606"></a>        /* return the action from the VerbProduction, if we found it */
<a name="3607"></a>        return (vp != nil ? vp.action : nil);
<a name="3608"></a>    }
<a name="3609"></a>
<a name="3610"></a>    /*
<a name="3611"></a>     *   Find a child of a given class. 
<a name="3612"></a>     */
<a name="3613"></a>    findChild(cls)
<a name="3614"></a>    {
<a name="3615"></a>        /* if I'm of the desired class, we're done */
<a name="3616"></a>        if (ofKind(cls))
<a name="3617"></a>            return self;
<a name="3618"></a>
<a name="3619"></a>        /* recursively scan my children */
<a name="3620"></a>        for (local gi = grammarInfo(), local i = 2, local len = gi.length() ;
<a name="3621"></a>             i &lt;= len ; ++i)
<a name="3622"></a>        {
<a name="3623"></a>            /* try this child */
<a name="3624"></a>            local chi = gi[i].findChild(cls);
<a name="3625"></a>            if (chi != nil)
<a name="3626"></a>                return chi;
<a name="3627"></a>        }
<a name="3628"></a>
<a name="3629"></a>        /* didn't find it */
<a name="3630"></a>        return nil;
<a name="3631"></a>    }
<a name="3632"></a>;
<a name="3633"></a>
<a name="3634"></a>/*
<a name="3635"></a> *   CommandProduction is a special Production subclass for the top-level
<a name="3636"></a> *   grammar rule for the overall command. 
<a name="3637"></a> *   
<a name="3638"></a> *   Each instance of this type of production must define the following
<a name="3639"></a> *   '-&gt;' properties in its syntax template:
<a name="3640"></a> *   
<a name="3641"></a> *   actor_ is the noun phrase giving the addressee of the command, if any.
<a name="3642"></a> *   A command such as TELL ACTOR TO DO X or (using the long-standing IF
<a name="3643"></a> *   convention) ACTOR, DO X addresses a command to an actor; i.e., it
<a name="3644"></a> *   tells the actor to carry out the command, rather than the player's
<a name="3645"></a> *   avatar.  A command that isn't addressed to an actor can leave actor_
<a name="3646"></a> *   as nil.  
<a name="3647"></a> *   
<a name="3648"></a> *   cmd_ is the *first* predicate phrase (see below), in the desired order
<a name="3649"></a> *   of execution.  For example, for "open the door and go north", cmd_
<a name="3650"></a> *   should be set to the match tree for the "open the door" predicate.
<a name="3651"></a> *   
<a name="3652"></a> *   conj_ is any conjunction or punctuation ending the first predicate
<a name="3653"></a> *   phrase.  This might be a period at the end of the sentence, or a word
<a name="3654"></a> *   like 'and' or 'then' that can separate multiple commands.  This can be
<a name="3655"></a> *   nil if there's no conjunction at all (such as when the whole command
<a name="3656"></a> *   is just the first predicate).  The reason we need conj_ is that it
<a name="3657"></a> *   tells us where any subsequent command on the same command line starts.
<a name="3658"></a> *   If cmd2_ is not nil, we'll ignore conj_ and use cmd2_ instead for this
<a name="3659"></a> *   purpose.
<a name="3660"></a> *   
<a name="3661"></a> *   cmd2_ is optional: it's the *second* predicate phrase.  If this is not
<a name="3662"></a> *   nil, it tells the parser where to start parsing the next predicate on
<a name="3663"></a> *   the same command line after finishing with the first one.  This is
<a name="3664"></a> *   optional, even if the command line really does have more than one
<a name="3665"></a> *   predicate, because the parser can use conj_ instead to infer where the
<a name="3666"></a> *   second predicate must start.
<a name="3667"></a> *   
<a name="3668"></a> *   (It's probably intuitively obvious what "first predicate" means, but
<a name="3669"></a> *   for the sake of translators, here's a more thorough analysis.  Some
<a name="3670"></a> *   command productions can match more than one predicate phrase, but this
<a name="3671"></a> *   is only for the sake of determining where the first one ends,
<a name="3672"></a> *   syntactically.  The execution engine actually only carries out the
<a name="3673"></a> *   first predicate matched for a given parse tree - it simply ignores any
<a name="3674"></a> *   others in the same tree.  After we finish executing the first
<a name="3675"></a> *   predicate from the match, we go back and re-parse the remaining text
<a name="3676"></a> *   from scratch, as raw text; at that point, the next predicate in the
<a name="3677"></a> *   text becomes the first predicate in the new parse tree and gets
<a name="3678"></a> *   executed.  We repeat this until we run out of text.  So we do
<a name="3679"></a> *   eventually execute everything the player types in - but not on the
<a name="3680"></a> *   first parse; we have to do one parse per predicate.  We have to repeat
<a name="3681"></a> *   the parsing because carrying out the first action could change the
<a name="3682"></a> *   game state in such a way that we'll find a different match to the next
<a name="3683"></a> *   predicate than we would have if we'd parsed everything up front.  By
<a name="3684"></a> *   "first predicate phrase", then, we mean the one that gets executed
<a name="3685"></a> *   first.  The point is to carry out the user's wishes as expressed in
<a name="3686"></a> *   the command, so we want the first predicate we execute to be the one
<a name="3687"></a> *   that the player *intends* to be carried out first; so by "first" we
<a name="3688"></a> *   really mean the one that a speaker of the natural language would
<a name="3689"></a> *   expect to be performed first, given the structure of the sentence and
<a name="3690"></a> *   the rules of the language.  In English, this is easy: X THEN Y or X,Y
<a name="3691"></a> *   or X AND Y all mean "first do X, then do Y" - the reading order is the
<a name="3692"></a> *   same as the execution order.)  
<a name="3693"></a> */
<a name="3694"></a>class CommandProduction: Production
<a name="3695"></a>    /* -&gt; property: the match tree for the addressee, if any */
<a name="3696"></a>    actor_ = nil
<a name="3697"></a>
<a name="3698"></a>    /*
<a name="3699"></a>     *   The grammatical person of the actor to whom we're giving orders.
<a name="3700"></a>     *   This is 2 for second person and 3 for third person.  (It's not
<a name="3701"></a>     *   meaningful to give orders in the first person.)
<a name="3702"></a>     *   
<a name="3703"></a>     *   In English (and probably most languages), commands of the form
<a name="3704"></a>     *   ACTOR, DO SOMETHING address ACTOR in the second person.  In
<a name="3705"></a>     *   contrast, TELL ACTOR TO DO SOMETHING gives orders to ACTOR, but in
<a name="3706"></a>     *   the third person.
<a name="3707"></a>     *   
<a name="3708"></a>     *   In the second-person form of giving orders, second-person pronouns
<a name="3709"></a>     *   (YOU, YOURSELF) within the command will refer back to the actor
<a name="3710"></a>     *   being addressed: BOB, EXAMINE YOURSELF tells Bob to look at Bob.
<a name="3711"></a>     *   In the indirect form, YOU refers to the player character: TELL BOB
<a name="3712"></a>     *   TO EXAMINE YOU tells Bob to look at the PC.
<a name="3713"></a>     *   
<a name="3714"></a>     *   The default is 2, since the long-standing IF convention is the
<a name="3715"></a>     *   ACTOR, DO SOMETHING format.  Override this (to 3) for TELL TO
<a name="3716"></a>     *   grammar rules.  
<a name="3717"></a>     */
<a name="3718"></a>    actorPerson = 2
<a name="3719"></a>    
<a name="3720"></a>    /* build the tree */
<a name="3721"></a>    build(cmd, np)
<a name="3722"></a>    {
<a name="3723"></a>        /* if we're giving orders, tell the command which person they're in */
<a name="3724"></a>        if (actor_ != nil)
<a name="3725"></a>            cmd.actorPerson = actorPerson;
<a name="3726"></a>
<a name="3727"></a>        /* 
<a name="3728"></a>         *   if we have a second predicate or a conjunction, note where the
<a name="3729"></a>         *   second predicate starts 
<a name="3730"></a>         */
<a name="3731"></a>        if (cmd2_ != nil)
<a name="3732"></a>        {
<a name="3733"></a>            /* 
<a name="3734"></a>             *   we have a second predicate production, so the second
<a name="3735"></a>             *   predicate starts with the first token of that production 
<a name="3736"></a>             */
<a name="3737"></a>            cmd.nextTokens = tokenList.sublist(cmd2_.firstTokenIndex);
<a name="3738"></a>        }
<a name="3739"></a>        else if (conj_ != nil)
<a name="3740"></a>        {
<a name="3741"></a>            /* 
<a name="3742"></a>             *   we don't have an explicit second predicate production, but
<a name="3743"></a>             *   we do have a conjunction, so the second predicate must
<a name="3744"></a>             *   start at the next token after the conjunction 
<a name="3745"></a>             */
<a name="3746"></a>            cmd.nextTokens = tokenList.sublist(conj_.lastTokenIndex + 1);
<a name="3747"></a>        }
<a name="3748"></a>
<a name="3749"></a>        /* do the normal work */
<a name="3750"></a>        inherited(cmd, np);
<a name="3751"></a>    }
<a name="3752"></a>
<a name="3753"></a>    /* visit a production */
<a name="3754"></a>    visitProd(cmd, np, prod)
<a name="3755"></a>    {
<a name="3756"></a>        /* if this is the actor, create a NounPhrase for the actor role */
<a name="3757"></a>        if (prod == actor_)
<a name="3758"></a>            np = cmd.addNounListItem(ActorRole, prod);
<a name="3759"></a>
<a name="3760"></a>        /*
<a name="3761"></a>         *   If this is the first predicate, actor, or conjunction, build
<a name="3762"></a>         *   it out as usual; otherwise ignore it.  We specifically don't
<a name="3763"></a>         *   want to build out any command processing for a second or
<a name="3764"></a>         *   subsequent predicate, because we only execute the first
<a name="3765"></a>         *   predicate in a parse tree.  
<a name="3766"></a>         */
<a name="3767"></a>        if (prod is in (cmd_, actor_, conj_))
<a name="3768"></a>        {
<a name="3769"></a>            /* expand the token extent to include this phrase */
<a name="3770"></a>            if (prod.lastTokenIndex &gt; cmd.tokenLen)
<a name="3771"></a>                cmd.tokenLen = prod.lastTokenIndex;
<a name="3772"></a>
<a name="3773"></a>            /* do the normal work */
<a name="3774"></a>            inherited(cmd, np, prod);
<a name="3775"></a>        }
<a name="3776"></a>    }
<a name="3777"></a>
<a name="3778"></a>    /* note the end of the sentence */
<a name="3779"></a>    noteEndOfSentence(cmd, prod)
<a name="3780"></a>    {
<a name="3781"></a>        /* 
<a name="3782"></a>         *   if the production is within the conjunction, the command ends
<a name="3783"></a>         *   the sentence 
<a name="3784"></a>         */
<a name="3785"></a>        if (prod == conj_ || prod.isChildOf(conj_))
<a name="3786"></a>            cmd.endOfSentence = true;
<a name="3787"></a>    }
<a name="3788"></a>;
<a name="3789"></a>
<a name="3790"></a>/*
<a name="3791"></a> *   A NounRole is a internal parser object that provides information on a
<a name="3792"></a> *   given noun role in a predicate.
<a name="3793"></a> *   
<a name="3794"></a> *   A noun role is one of the standard semantic roles that a noun phrase
<a name="3795"></a> *   can play in a natural language predicate.  A predicate is a
<a name="3796"></a> *   combination of an action and the objects that it applies to.  Any
<a name="3797"></a> *   given verb has a set of assigned roles that need to be filled to make
<a name="3798"></a> *   a complete thought.  (Sometimes the same verb word has multiple senses
<a name="3799"></a> *   with different numbers of slots to fill, but you can think of the
<a name="3800"></a> *   different senses as actually being different actions at some abstract
<a name="3801"></a> *   level, which all happen to share the same verb word.)  For example,
<a name="3802"></a> *   TAKE requires a noun phrase telling us which object is to be taken;
<a name="3803"></a> *   this is called the direct object of the verb.  PUT X IN Y has a direct
<a name="3804"></a> *   object (the thing to be put somewhere) and an indirect object (the
<a name="3805"></a> *   place to put it).
<a name="3806"></a> *   
<a name="3807"></a> *   Natural languages use a fairly small number of these noun roles.  Most
<a name="3808"></a> *   predicates in most languages have just one role: TAKE, DROP, OPEN,
<a name="3809"></a> *   CLOSE.  We call this first-and-only noun role the direct object.  A
<a name="3810"></a> *   few predicates have two roles: PUT IN, GIVE TO, UNLOCK WITH.  We call
<a name="3811"></a> *   the second role the indirect object.  A very few predicates have three
<a name="3812"></a> *   roles: TRADE BOB AN APPLE FOR AN ORANGE, PUT PLUTONIUM IN REACTOR WITH
<a name="3813"></a> *   TONGS.  We call the third role the "accessory" object (which is
<a name="3814"></a> *   something we made up - there doesn't seem to be an agreed-upon word
<a name="3815"></a> *   among linguists for this role).  And it appears that there's simply no
<a name="3816"></a> *   such thing as a "tetratransitive" verb in any natural human language,
<a name="3817"></a> *   so we don't bother defining a fourth slot.
<a name="3818"></a> *   
<a name="3819"></a> *   (It would be easy for a game to add an object defining a fourth slot,
<a name="3820"></a> *   analogous with these others, and use it to include a fourth noun
<a name="3821"></a> *   phrase in the grammar for applicable verbs.  The rest of the parser
<a name="3822"></a> *   will pick it up automatically if you do.  However, the practical
<a name="3823"></a> *   utility of this seems minimal.  *Three*-noun verbs are incredibly rare
<a name="3824"></a> *   in IF, in part because situations requiring them are rare, and in part
<a name="3825"></a> *   because they're almost guaranteed to vex players and be panned as
<a name="3826"></a> *   guess-the-syntax puzzles.  One can only imagine how a *four*-noun
<a name="3827"></a> *   command would be received.)  
<a name="3828"></a> */
<a name="3829"></a>class NounRole: object
<a name="3830"></a>    /* 
<a name="3831"></a>     *   The -&gt; property slot in the predicate grammar that's assigned to
<a name="3832"></a>     *   this role.  This is the property that predicate grammar rules
<a name="3833"></a>     *   assign for the match tree for a noun phrase taking this role.
<a name="3834"></a>     */
<a name="3835"></a>    matchProp = nil
<a name="3836"></a>
<a name="3837"></a>    /* the NounPhrase list property in the Command object for this role */
<a name="3838"></a>    npListProp = nil
<a name="3839"></a>
<a name="3840"></a>    /* the object match list property in the Command object for this role */
<a name="3841"></a>    objListProp = nil
<a name="3842"></a>
<a name="3843"></a>    /* the property in the Command for the *current* item being executed */
<a name="3844"></a>    objProp = nil
<a name="3845"></a>
<a name="3846"></a>    /* the property in the Command for the current item's NPMatch */
<a name="3847"></a>    objMatchProp = nil
<a name="3848"></a>
<a name="3849"></a>    /*
<a name="3850"></a>     *   Is this a predicate noun phrase role?  This is true for roles that
<a name="3851"></a>     *   serve as objects of a verb: direct object, indirect object,
<a name="3852"></a>     *   accessory.  This is nil for non-predicate roles, such as the
<a name="3853"></a>     *   addressee actor. 
<a name="3854"></a>     */
<a name="3855"></a>    isPredicate = true
<a name="3856"></a>
<a name="3857"></a>    /* 
<a name="3858"></a>     *   the predicate match object property that gives the grammar rule
<a name="3859"></a>     *   for parsing a reply to a missing noun question for this role 
<a name="3860"></a>     */
<a name="3861"></a>    missingReplyProp = nil
<a name="3862"></a>
<a name="3863"></a>    /* 
<a name="3864"></a>     *   name - this is an ID string that we use internally for embedding
<a name="3865"></a>     *   the role in things like verb template strings 
<a name="3866"></a>     */
<a name="3867"></a>    name = ''
<a name="3868"></a>
<a name="3869"></a>    /*
<a name="3870"></a>     *   Internal sequence number.  This tells us the order in which this
<a name="3871"></a>     *   role appears in lists (including argument lists) when we store
<a name="3872"></a>     *   lists of roles.  
<a name="3873"></a>     */
<a name="3874"></a>    order = 1000
<a name="3875"></a>
<a name="3876"></a>    /* class property: master list of all roles */
<a name="3877"></a>    all = []
<a name="3878"></a>
<a name="3879"></a>    /* class property: master list of all predicate roles */
<a name="3880"></a>    allPredicate = []
<a name="3881"></a>
<a name="3882"></a>    /* on construction, populate the various maps */
<a name="3883"></a>    construct()
<a name="3884"></a>    {
<a name="3885"></a>        /* add it to our master list of roles */
<a name="3886"></a>        NounRole.all += self;
<a name="3887"></a>
<a name="3888"></a>        /* add it to the master list of predicate roles, if applicable */
<a name="3889"></a>        if (isPredicate)
<a name="3890"></a>            NounRole.allPredicate += self;
<a name="3891"></a>        
<a name="3892"></a>        /* keep the lists in sorted order */
<a name="3893"></a>        NounRole.all = NounRole.all.sort(SortAsc, { a, b: a.order - b.order });
<a name="3894"></a>        NounRole.allPredicate = NounRole.allPredicate.sort(
<a name="3895"></a>            SortAsc, { a, b: a.order - b.order });
<a name="3896"></a>    }
<a name="3897"></a>;
<a name="3898"></a>
<a name="3899"></a>/*
<a name="3900"></a> *   The DirectObject role is the role of the object being most directly
<a name="3901"></a> *   acted upon in the command.  The is the only role in a verb that has
<a name="3902"></a> *   only one object.  In a verb with two objects, this is the object most
<a name="3903"></a> *   directly affected.  For example, UNLOCK DOOR WITH KEY directly acts
<a name="3904"></a> *   upon the door, so the door is the direct object; the key isn't the
<a name="3905"></a> *   direct object because it's merely a tool used to effect the change on
<a name="3906"></a> *   the door.  
<a name="3907"></a> */
<a name="3908"></a>DirectObject: NounRole
<a name="3909"></a>    matchProp = &amp;dobjMatch
<a name="3910"></a>    npListProp = &amp;dobjNPs
<a name="3911"></a>    objListProp = &amp;dobjs
<a name="3912"></a>    objProp = &amp;dobj
<a name="3913"></a>    objMatchProp = &amp;dobjInfo
<a name="3914"></a>    missingReplyProp = &amp;dobjReply
<a name="3915"></a>    curObjProp = &amp;curDobj
<a name="3916"></a>    name = 'dobj'
<a name="3917"></a>    order = 1
<a name="3918"></a>;
<a name="3919"></a>
<a name="3920"></a>/*
<a name="3921"></a> *   The IndirectObject role is the role of a secondary object that is used
<a name="3922"></a> *   in the command, but isn't the primary object being acted upon.  This
<a name="3923"></a> *   is usually a tool (UNLOCK dobj WITH iobj), a destination (PUT dobj IN
<a name="3924"></a> *   iobj), or a topic (ASK dobj ABOUT iobj). 
<a name="3925"></a> */
<a name="3926"></a>IndirectObject: NounRole
<a name="3927"></a>    matchProp = &amp;iobjMatch
<a name="3928"></a>    npListProp = &amp;iobjNPs
<a name="3929"></a>    objListProp = &amp;iobjs
<a name="3930"></a>    objProp = &amp;iobj
<a name="3931"></a>    objMatchProp = &amp;iobjInfo
<a name="3932"></a>    missingReplyProp = &amp;iobjReply
<a name="3933"></a>    curObjProp = &amp;curIobj
<a name="3934"></a>    name = 'iobj'
<a name="3935"></a>    order = 2
<a name="3936"></a>;
<a name="3937"></a>
<a name="3938"></a>/*
<a name="3939"></a> *   The AccessoryObject role is for a *third* object, beyond the direct
<a name="3940"></a> *   and indirect objects, involved in the command.  This might be a peer
<a name="3941"></a> *   to the indirect object in an exchange (TRADE dobj AN iobj FOR AN
<a name="3942"></a> *   accessory), but the canonical IF use is as a tool in a two-object
<a name="3943"></a> *   operation (PUT dobj IN iobj WITH accessory, WRITE dobj ON iobj WITH
<a name="3944"></a> *   accessory).  
<a name="3945"></a> */
<a name="3946"></a>AccessoryObject: NounRole
<a name="3947"></a>    matchProp = &amp;accMatch
<a name="3948"></a>    npListProp = &amp;accNPs
<a name="3949"></a>    objListProp = &amp;accs
<a name="3950"></a>    objProp = &amp;acc
<a name="3951"></a>    objMatchProp = &amp;accInfo
<a name="3952"></a>    missingReplyProp = &amp;accReply
<a name="3953"></a>    curObjProp = &amp;curAobj
<a name="3954"></a>    name = 'acc'
<a name="3955"></a>    order = 3
<a name="3956"></a>;
<a name="3957"></a>
<a name="3958"></a>/*
<a name="3959"></a> *   ActorRole is a special role for the addressee of a command (BOB, GO
<a name="3960"></a> *   NORTH, or TELL BOB TO GO NORTH).  This doesn't appear as part of a
<a name="3961"></a> *   predicate structure, so there's no matchProp, but it is used within
<a name="3962"></a> *   the Command.  
<a name="3963"></a> */
<a name="3964"></a>ActorRole: NounRole
<a name="3965"></a>    npListProp = &amp;actorNPs
<a name="3966"></a>    objListProp = &amp;actors
<a name="3967"></a>    objProp = &amp;actor
<a name="3968"></a>    isPredicate = nil
<a name="3969"></a>;
<a name="3970"></a>
<a name="3971"></a>
<a name="3972"></a>/*
<a name="3973"></a> *   VerbProduction is a special Production subclass for verb (predicate)
<a name="3974"></a> *   rules.  This production has special processing for building out the
<a name="3975"></a> *   object phrases making up the verb.
<a name="3976"></a> *   
<a name="3977"></a> *   Each instance should have an 'action' property giving the Action
<a name="3978"></a> *   object associated with the verb rule.  This is the Action that will be
<a name="3979"></a> *   performed when the parser matches the command input to the rule.
<a name="3980"></a> *   
<a name="3981"></a> *   Some languages, such as English, have "positional" predicate grammars.
<a name="3982"></a> *   This means that the position of a noun phrase in the sentence
<a name="3983"></a> *   determines its role (direct object, indirect object, etc).  In the
<a name="3984"></a> *   grammar for a positional language, each predicate rule simply needs to
<a name="3985"></a> *   plug in a singleNoun or nounList production (as appropriate) in each
<a name="3986"></a> *   noun phrase position, with its '-&gt;' property set to correspond to the
<a name="3987"></a> *   role: -&gt;dobjMatch for a direct object, -&gt;iobjMatch for an indirect
<a name="3988"></a> *   object, and -&gt;accMatch for an accessory object.
<a name="3989"></a> *   
<a name="3990"></a> *   Some languages, such as German and Latin, identify the role of a noun
<a name="3991"></a> *   phrase using grammatical case.  This means that the articles change
<a name="3992"></a> *   form in the different roles, or that the nouns themselves are
<a name="3993"></a> *   inflected (they have different forms, such as added suffixes)
<a name="3994"></a> *   according to role.  Case languages tend to have flexible predicate
<a name="3995"></a> *   word order, because the case markers tell you the role of each noun
<a name="3996"></a> *   even if the nouns are rearranged.  For this reason, it can be tedious
<a name="3997"></a> *   to write a grammar for a case language the way we do for English,
<a name="3998"></a> *   where the word ordering for a given verb is so rigid that we can
<a name="3999"></a> *   easily just write out each possible phrasing manually.  For a case
<a name="4000"></a> *   language, you'll probably instead want to write a set of generic verb
<a name="4001"></a> *   rules that cover *all* verbs (i.e., you leave the verb word itself as
<a name="4002"></a> *   a sub-production) in all of the different word orders, and use the
<a name="4003"></a> *   case tagging in the language to determine the role of each noun
<a name="4004"></a> *   phrase.  For this style of grammar, the grammar must set the property
<a name="4005"></a> *   nounPhraseRole in the top-level rule for each noun phrase case; set
<a name="4006"></a> *   this to DirectObject, IndirectObject, AccessoryObject, etc., according
<a name="4007"></a> *   to the role denoted by the case.
<a name="4008"></a> *   
<a name="4009"></a> *   Still other languages, such as Japanese, use particles (grammar
<a name="4010"></a> *   function words) to denote the role of each noun phrase in the
<a name="4011"></a> *   sentence.  This is similar to grammatical case, but the role
<a name="4012"></a> *   information is encoded in separate words (the particles) rather than
<a name="4013"></a> *   in noun affixes, so the nouns themselves aren't inflected.  You can
<a name="4014"></a> *   handle this type of language roughly the same way you'd handle a case
<a name="4015"></a> *   language.  Create generic rules that cover all verbs, then create a
<a name="4016"></a> *   grammar rule for each particle-plus-noun structure.  In each
<a name="4017"></a> *   particle-plus-noun phrase's top-level rule, set the nounPhraseRole
<a name="4018"></a> *   property to the appropriate role object (DirectObject, etc).  
<a name="4019"></a> */
<a name="4020"></a>class VerbProduction: Production
<a name="4021"></a>    /*
<a name="4022"></a>     *   The "priority" of this grammar rule.  This is a contributor to the
<a name="4023"></a>     *   Command priority - see Command.priority for an explanation of how
<a name="4024"></a>     *   that's used.
<a name="4025"></a>     *   
<a name="4026"></a>     *   The predicate priority is a small number, 0-99.  The default is
<a name="4027"></a>     *   50, which should apply to most normal, complete verb phrases.  For
<a name="4028"></a>     *   incomplete phrases (with a missing object, which will force the
<a name="4029"></a>     *   parser to assume a default or ask the player for the missing
<a name="4030"></a>     *   information), use 25.  Other values are for fine-tuning as needed
<a name="4031"></a>     *   in the individual grammar rules.  A higher value means higher
<a name="4032"></a>     *   priority.  
<a name="4033"></a>     */
<a name="4034"></a>    priority = 50
<a name="4035"></a>
<a name="4036"></a>    /* 
<a name="4037"></a>     *   Do we want to consider this production to be active; we may want some
<a name="4038"></a>     *   VerbRules to be active only under certain circumstanes.
<a name="4039"></a>     */
<a name="4040"></a>    isActive = true
<a name="4041"></a>    
<a name="4042"></a>    /* build the command */
<a name="4043"></a>    build(cmd, np)
<a name="4044"></a>    {
<a name="4045"></a>        /* set the action and the predicate phrase priority in the command */
<a name="4046"></a>        cmd.action = action;
<a name="4047"></a>        cmd.verbProd = self;
<a name="4048"></a>        cmd.predPriority = priority;
<a name="4049"></a>        cmd.predActive = isActive;;
<a name="4050"></a>
<a name="4051"></a>        /* do the standard work */
<a name="4052"></a>        inherited(cmd, np);
<a name="4053"></a>
<a name="4054"></a>        /* if we have a structurally empty slot, note it in the command */
<a name="4055"></a>        if (missingRole != nil)
<a name="4056"></a>            cmd.emptyNounRole(missingRole);
<a name="4057"></a>    }
<a name="4058"></a>
<a name="4059"></a>    /*
<a name="4060"></a>     *   Visit a production during the build process.  If this is one of
<a name="4061"></a>     *   our noun phrase slots, we tell the command to add a new noun
<a name="4062"></a>     *   phrase of this type, and make it the current phrase; then we
<a name="4063"></a>     *   recursively build out this child to populate the new noun phrase.
<a name="4064"></a>     */
<a name="4065"></a>    visitProd(cmd, np, prod)
<a name="4066"></a>    {
<a name="4067"></a>        /* 
<a name="4068"></a>         *   If this is a special phrase slot, mark the child with its
<a name="4069"></a>         *   role.  This is necessary for positional languages, where the
<a name="4070"></a>         *   role of a noun phrase is determined by its position in the
<a name="4071"></a>         *   predicate.  Grammars for these languages use generic rules
<a name="4072"></a>         *   that apply to any noun phrases, so the match objects don't
<a name="4073"></a>         *   know what role they have until they find out their position in
<a name="4074"></a>         *   the parent grammar.  We're the parent grammar, so when we see
<a name="4075"></a>         *   one of these special positional markers, we need to pass the
<a name="4076"></a>         *   information down to the sub-tree here.  
<a name="4077"></a>         */
<a name="4078"></a>        local r;
<a name="4079"></a>        if ((r = NounRole.all.valWhich(
<a name="4080"></a>            {x: x.matchProp != nil &amp;&amp; self.(x.matchProp) == prod})) != nil)
<a name="4081"></a>        {
<a name="4082"></a>            /* set the role in the sub-tree */
<a name="4083"></a>            prod.nounPhraseRole = r;
<a name="4084"></a>
<a name="4085"></a>            /* start a new noun phrase for the role */
<a name="4086"></a>            np = prod.addNounListItem(cmd, prod);
<a name="4087"></a>        }
<a name="4088"></a>
<a name="4089"></a>        /* 
<a name="4090"></a>         *   build out the child, in the context of the noun phrase we
<a name="4091"></a>         *   decided upon 
<a name="4092"></a>         */
<a name="4093"></a>        prod.build(cmd, np);
<a name="4094"></a>    }
<a name="4095"></a>
<a name="4096"></a>    /*
<a name="4097"></a>     *   The parser calls answerMissing() when the player answers a query
<a name="4098"></a>     *   for a missing noun phrase in the last command.  There's nothing
<a name="4099"></a>     *   that needs to happen here, and by default we do nothing; this is
<a name="4100"></a>     *   purely advisory.  This routine gives the language module a chance
<a name="4101"></a>     *   to alter the command according to the reply, if necessary.  
<a name="4102"></a>     */
<a name="4103"></a>    answerMissing(cmd, np) { }
<a name="4104"></a>;
<a name="4105"></a>
<a name="4106"></a>/*
<a name="4107"></a> *   NounListProduction is a special Production subclass for lists
<a name="4108"></a> *   including more than one noun.
<a name="4109"></a> *   
<a name="4110"></a> *   Each instance should have two '-&gt;' properties: np1_ and np2_.  These
<a name="4111"></a> *   should be set to the match sub-tree for the first and second elements
<a name="4112"></a> *   of the noun list (respectively).  Note that we assume there are only
<a name="4113"></a> *   two elements in each list grammar item - this isn't because we want to
<a name="4114"></a> *   limit noun lists to two elements, but rather because we assume that
<a name="4115"></a> *   the grammars for longer lists will be constructed recursively out of
<a name="4116"></a> *   two-element nodes: A, B, C, D becomes something along the lines of
<a name="4117"></a> *   List(a, List(b, List(c, List(d)))).  
<a name="4118"></a> */
<a name="4119"></a>class NounListProduction: Production
<a name="4120"></a>    /*
<a name="4121"></a>     *   Visit a production during the build process.  When parsing the
<a name="4122"></a>     *   second element, we'll add a new NounPhrase to the current slot's
<a name="4123"></a>     *   list.  
<a name="4124"></a>     */
<a name="4125"></a>    visitProd(cmd, np, prod)
<a name="4126"></a>    {
<a name="4127"></a>        /* if this is the second list item, add a new NounPhrase for it */
<a name="4128"></a>        if (prod == np2_)
<a name="4129"></a>            np = prod.addNounListItem(cmd, prod);
<a name="4130"></a>
<a name="4131"></a>        /* for noun phrases, tell the noun phrase about the production */
<a name="4132"></a>        if (prod is in (np1_, np2_))
<a name="4133"></a>            np.prod = prod;
<a name="4134"></a>
<a name="4135"></a>        /* do the normal work */
<a name="4136"></a>        inherited(cmd, np, prod);
<a name="4137"></a>    }
<a name="4138"></a>;
<a name="4139"></a>
<a name="4140"></a>/*
<a name="4141"></a> *   A BadListProduction is a Production subclass for a noun list written
<a name="4142"></a> *   in a slot intended for a single noun only.  This isn't really a
<a name="4143"></a> *   grammatical error, so the language grammar will probably want to
<a name="4144"></a> *   include a rule for this.  However, it *is* a semantic error; rules
<a name="4145"></a> *   that are written for single objects are written that way because we
<a name="4146"></a> *   can't make sense of a list there.  For example, PUT BOOK IN BOX AND
<a name="4147"></a> *   BAG would be nonsensical to us, because we can't put something in two
<a name="4148"></a> *   places at once.  This class can be used for a grammar rule that parses
<a name="4149"></a> *   a list where a single noun is required; we'll flag it with an
<a name="4150"></a> *   explanatory error message for the user.  
<a name="4151"></a> */
<a name="4152"></a>class BadListProduction: Production
<a name="4153"></a>    build(cmd, np)
<a name="4154"></a>    {
<a name="4155"></a>        /* mark the command with the list-in-single-slot error */
<a name="4156"></a>        cmd.badMulti = getNounPhraseRole();
<a name="4157"></a>
<a name="4158"></a>        /* do the normal work */
<a name="4159"></a>        inherited(cmd, np);
<a name="4160"></a>    }
<a name="4161"></a>;
<a name="4162"></a>
<a name="4163"></a>/*
<a name="4164"></a> *   ExceptListProduction is a Production subclass for EXCEPT lists.  This
<a name="4165"></a> *   is a slot in the grammar that holds a list of objects excepted from
<a name="4166"></a> *   some set, as in ALL BUT THE RED BOOK or THE COINS EXCEPT THE PENNIES.
<a name="4167"></a> */
<a name="4168"></a>class ExceptListProduction: Production
<a name="4169"></a>    /*
<a name="4170"></a>     *   Build this phrase.  Our sub-tree is a noun list that's to be
<a name="4171"></a>     *   excluded from the current noun phrase under construction, 'np';
<a name="4172"></a>     *   this exclusion list is a type of qualifier.  So, we (a) start an
<a name="4173"></a>     *   exception qualifier for 'np', (b) make that list the current noun
<a name="4174"></a>     *   phrase within our sub-tree, then (c) do the normal work to build
<a name="4175"></a>     *   out our sub-tree, but using the new context.  
<a name="4176"></a>     */
<a name="4177"></a>    build(cmd, np)
<a name="4178"></a>    {
<a name="4179"></a>        /* 
<a name="4180"></a>         *   remember the noun phrase that we qualify - this is simply the
<a name="4181"></a>         *   parent noun phrase, np 
<a name="4182"></a>         */
<a name="4183"></a>        qualifiedNP = np;
<a name="4184"></a>
<a name="4185"></a>        /* 
<a name="4186"></a>         *   start an exclusion list for the noun phrase; make the first
<a name="4187"></a>         *   element of the new list the active noun phrase for our
<a name="4188"></a>         *   sub-tree 
<a name="4189"></a>         */
<a name="4190"></a>        np = np.addExclusionItem(self);
<a name="4191"></a>
<a name="4192"></a>        /* do the normal work */
<a name="4193"></a>        inherited(cmd, np);
<a name="4194"></a>    }
<a name="4195"></a>
<a name="4196"></a>    /*
<a name="4197"></a>     *   Add a noun list item.  List items within our sub-tree go into the
<a name="4198"></a>     *   exclusion list for the parent noun phrase that we qualify.  
<a name="4199"></a>     */
<a name="4200"></a>    addNounListItem(cmd, prod)
<a name="4201"></a>    {
<a name="4202"></a>        /* add a new noun phrase to the qualified NP's exclusion list */
<a name="4203"></a>        return qualifiedNP.addExclusionItem(prod);
<a name="4204"></a>    }
<a name="4205"></a>
<a name="4206"></a>    /* the noun phrase we qualify */
<a name="4207"></a>    qualifiedNP = nil
<a name="4208"></a>;
<a name="4209"></a>
<a name="4210"></a>/*
<a name="4211"></a> *   CoreNounPhraseProduction is a Production subclass for the "core" noun
<a name="4212"></a> *   phrase grammar for noun phrases with object vocabulary.  This is the
<a name="4213"></a> *   part of the grammar that matches the basic name of an object, after
<a name="4214"></a> *   all qualifiers (such as articles, possessives, and quantifiers) have
<a name="4215"></a> *   already been dealt with.  This is the part of the phrase that contains
<a name="4216"></a> *   the vocabulary words for game-world objects.
<a name="4217"></a> *   
<a name="4218"></a> *   This class is only needed for noun phrases with object vocabulary
<a name="4219"></a> *   words.  It captures the unqualified core of the phrase as entered by
<a name="4220"></a> *   the user, mostly for reiteration in error messages from the parser.
<a name="4221"></a> *   It's not necessary to define rules of this class for noun phrases that
<a name="4222"></a> *   don't have object vocabulary words (e.g., pronouns, ALL).  
<a name="4223"></a> */
<a name="4224"></a>class CoreNounPhraseProduction: Production
<a name="4225"></a>    build(cmd, np)
<a name="4226"></a>    {
<a name="4227"></a>        /* note in the NounPhrase that this is the core noun phrase */
<a name="4228"></a>        np.coreProd = self;
<a name="4229"></a>
<a name="4230"></a>        /* do the normal work */
<a name="4231"></a>        inherited(cmd, np);
<a name="4232"></a>    }
<a name="4233"></a>;
<a name="4234"></a>
<a name="4235"></a>/*
<a name="4236"></a> *   EmptyNounProduction is a Production subclass for a grammar rule that
<a name="4237"></a> *   matches no tokens where a noun phrase would ordinarily go.  
<a name="4238"></a> */
<a name="4239"></a>class EmptyNounProduction: Production
<a name="4240"></a>    build(cmd, np)
<a name="4241"></a>    {
<a name="4242"></a>        /* mark the noun phrase role as empty in the command */
<a name="4243"></a>        cmd.emptyNounRole(np.role);
<a name="4244"></a>    }
<a name="4245"></a>;
<a name="4246"></a>
<a name="4247"></a>/*
<a name="4248"></a> *   NumberNounProduction is a Production subclass for a number that serves
<a name="4249"></a> *   as a direct, indirect, or accessory object.  
<a name="4250"></a> */
<a name="4251"></a>class NumberNounProduction: Production
<a name="4252"></a>    /* we use the NumberPhrase subclass for a noun phrase entries */
<a name="4253"></a>    npClass = NumberPhrase
<a name="4254"></a>;
<a name="4255"></a>
<a name="4256"></a>/*
<a name="4257"></a> *   TopicNounProduction is a Production subclass for a topic that serves
<a name="4258"></a> *   as a direct, indirect, or accessory object.  
<a name="4259"></a> */
<a name="4260"></a>class TopicNounProduction: Production
<a name="4261"></a>    /* we use the TopicPhrase subclass for a topic phrase entry */
<a name="4262"></a>    npClass = TopicPhrase
<a name="4263"></a>;
<a name="4264"></a>
<a name="4265"></a>/*
<a name="4266"></a> *   LiteralNounProduction is a Production subclass for a literal phrase
<a name="4267"></a> *   that serves as a direct, indirect, or accessory object. 
<a name="4268"></a> */
<a name="4269"></a>class LiteralNounProduction: Production
<a name="4270"></a>    /* we use the LiteralPhrase subclass for a noun phrase entries */
<a name="4271"></a>    npClass = LiteralPhrase
<a name="4272"></a>;
<a name="4273"></a>
<a name="4274"></a>/*
<a name="4275"></a> *   PronounProduction is a Production subclass for pronoun phrases.
<a name="4276"></a> *   Each instance should set the property 'pronoun' to a Pronoun object
<a name="4277"></a> *   giving the pronoun role for the phrase.  
<a name="4278"></a> */
<a name="4279"></a>class PronounProduction: Production
<a name="4280"></a>    /*
<a name="4281"></a>     *   Build the phrase.  We'll add our pronoun association to the
<a name="4282"></a>     *   current noun phrase.  (We'll also build out any sub-tree, although
<a name="4283"></a>     *   in nearly all cases a pronoun phrase is just a literal and won't
<a name="4284"></a>     *   have a sub-tree.) 
<a name="4285"></a>     */
<a name="4286"></a>    build(cmd, np)
<a name="4287"></a>    {
<a name="4288"></a>        /* set the pronoun association in the noun phrase */
<a name="4289"></a>        np.pronoun = pronoun;
<a name="4290"></a>
<a name="4291"></a>        /* do the normal work */
<a name="4292"></a>        inherited(cmd, np);
<a name="4293"></a>    }
<a name="4294"></a>;
<a name="4295"></a>
<a name="4296"></a>/*
<a name="4297"></a> *   A PossessiveProduction is a production subclass for possessive
<a name="4298"></a> *   qualifier phrases ("John's", "my").  When we build out this
<a name="4299"></a> *   production's contribution to the command, we add a separate NounPhrase
<a name="4300"></a> *   object for it, as a possessive qualifier to the current noun phrase.  
<a name="4301"></a> */
<a name="4302"></a>class PossessiveProduction: Production
<a name="4303"></a>    /*
<a name="4304"></a>     *   Build the phrase.  We'll build out our sub-tree as normal, except
<a name="4305"></a>     *   that we'll assign its output to a new NounPhrase, which we attach
<a name="4306"></a>     *   as a possessive qualifier to the encompassing noun phrase under
<a name="4307"></a>     *   construction.  
<a name="4308"></a>     */
<a name="4309"></a>    build(cmd, np)
<a name="4310"></a>    {
<a name="4311"></a>        /* 
<a name="4312"></a>         *   create a new noun phrase to serve as a possessive qualifier to
<a name="4313"></a>         *   the current noun phrase 
<a name="4314"></a>         */
<a name="4315"></a>        np = np.addPossessive(self);
<a name="4316"></a>
<a name="4317"></a>        /* if I have a pronoun, set it in the noun phrase */
<a name="4318"></a>        np.pronoun = pronoun;
<a name="4319"></a>
<a name="4320"></a>        /* do the normal work in the context of the possessive qualifier */
<a name="4321"></a>        inherited(cmd, np);
<a name="4322"></a>    }
<a name="4323"></a>;
<a name="4324"></a>
<a name="4325"></a>/*
<a name="4326"></a> *   ContentsQualifierProduction is a subclass of Production for phrases
<a name="4327"></a> *   that involve contents qualifiers, as in "the bucket of water".
<a name="4328"></a> *   
<a name="4329"></a> *   Each grammar rule of this type needs to define two special '-&gt;'
<a name="4330"></a> *   associations in its template:
<a name="4331"></a> *   
<a name="4332"></a> *   cont_ is the contents qualifier.  This is also just an ordinary noun
<a name="4333"></a> *   phrase.  This is the "water" part in "bucket of water".
<a name="4334"></a> *   
<a name="4335"></a> *   prep_ is the preposition giving the relationship. 
<a name="4336"></a> */
<a name="4337"></a>class ContentsQualifierProduction: Production
<a name="4338"></a>    /*
<a name="4339"></a>     *   Visit a production.  When we process the contents qualifier
<a name="4340"></a>     *   phrase, we'll build out the sub-tree in the context of a new
<a name="4341"></a>     *   NounPhrase, which we attach as a contents qualifier to the
<a name="4342"></a>     *   encompassing noun phrase under construction.  
<a name="4343"></a>     */
<a name="4344"></a>    visitProd(cmd, np, prod)
<a name="4345"></a>    {
<a name="4346"></a>        /* 
<a name="4347"></a>         *   if this sub-production is the contents qualifier phrase,
<a name="4348"></a>         *   create a new locational qualifier for it 
<a name="4349"></a>         */
<a name="4350"></a>        if (prod == cont_)
<a name="4351"></a>            np = np.addContents(prep_.getText(), prod);
<a name="4352"></a>
<a name="4353"></a>        /* do the normal work in the context of the noun phrase we set up */
<a name="4354"></a>        inherited(cmd, np, prod);
<a name="4355"></a>    }
<a name="4356"></a>;
<a name="4357"></a>    
<a name="4358"></a>
<a name="4359"></a>/*
<a name="4360"></a> *   LocationalProduction is a subclass of Production for phrases that
<a name="4361"></a> *   involve locational qualifiers, as in "the book on the table".
<a name="4362"></a> *   
<a name="4363"></a> *   Each grammar rule of this type needs to define two special '-&gt;'
<a name="4364"></a> *   associations in its template:
<a name="4365"></a> *   
<a name="4366"></a> *   cont_ is the locational qualifier.  This is also just an ordinary noun
<a name="4367"></a> *   phrase.  This is the "the table" part in "the book on the table".
<a name="4368"></a> *   
<a name="4369"></a> *   prep_ is the preposition production.  This should be *or* contain a
<a name="4370"></a> *   LocationTypeProduction match, which tells us the type of containment
<a name="4371"></a> *   relationship specified by the grammar.  *Alternatively*, you can
<a name="4372"></a> *   define locType directly on this production.  This specifies a LocType
<a name="4373"></a> *   object giving the containment relationship.  
<a name="4374"></a> */
<a name="4375"></a>class LocationalProduction: Production
<a name="4376"></a>    /*
<a name="4377"></a>     *   Visit a production.  When we process the locational qualifier
<a name="4378"></a>     *   phrase, we'll build out the sub-tree in the context of a new
<a name="4379"></a>     *   NounPhrase, which we attach as a locational qualifier to the
<a name="4380"></a>     *   encompassing noun phrase under construction.  
<a name="4381"></a>     */
<a name="4382"></a>    visitProd(cmd, np, prod)
<a name="4383"></a>    {
<a name="4384"></a>        /* 
<a name="4385"></a>         *   if this sub-production is the locational qualifier phrase,
<a name="4386"></a>         *   create a new locational qualifier for it 
<a name="4387"></a>         */
<a name="4388"></a>        if (prod == cont_)
<a name="4389"></a>        {
<a name="4390"></a>            /* add the location to the noun phrase */
<a name="4391"></a>            np = np.addLocation(locType, prod);
<a name="4392"></a>
<a name="4393"></a>            /* 
<a name="4394"></a>             *   explicitly build out the preposition sub-tree in the
<a name="4395"></a>             *   context of the locational noun phrase - this ensures that
<a name="4396"></a>             *   the locType gets set for the locational rather than the
<a name="4397"></a>             *   base noun phrase 
<a name="4398"></a>             */
<a name="4399"></a>            if (prep_ != nil)
<a name="4400"></a>                prep_.build(cmd, np);
<a name="4401"></a>        }            
<a name="4402"></a>
<a name="4403"></a>        /* 
<a name="4404"></a>         *   we already built the prep_ subtree explicitly in build(), so
<a name="4405"></a>         *   we can ignore it if we're hitting it again here 
<a name="4406"></a>         */
<a name="4407"></a>        if (prod == prep_)
<a name="4408"></a>            return;
<a name="4409"></a>
<a name="4410"></a>        /* do the normal work in the context of the noun phrase we set up */
<a name="4411"></a>        inherited(cmd, np, prod);
<a name="4412"></a>    }
<a name="4413"></a>
<a name="4414"></a>    /*
<a name="4415"></a>     *   Our location type.  This is a LocType object giving the location
<a name="4416"></a>     *   relationship specified by this locational phrase.  For languages
<a name="4417"></a>     *   that special locational phrases prepositionally, this will be set
<a name="4418"></a>     *   by the LocationPrepProduction in our sub-tree.  For languages that
<a name="4419"></a>     *   use case inflection to specify the type of relationship, this must
<a name="4420"></a>     *   be set by the noun phrase sub-tree instead.  
<a name="4421"></a>     */
<a name="4422"></a>    locType = nil
<a name="4423"></a>;
<a name="4424"></a>
<a name="4425"></a>/*
<a name="4426"></a> *   A LocationPrepProduction is a special Production type for phrases that
<a name="4427"></a> *   encode the preposition of a locational phrase.  This is only needed in
<a name="4428"></a> *   languages that use prepositional grammar to express location
<a name="4429"></a> *   relationships.  For languages that use noun case inflection, the
<a name="4430"></a> *   relationship will have to be inferred from the case grammar of the
<a name="4431"></a> *   noun phrase (such as noun affixes or articles), and the noun phrase
<a name="4432"></a> *   production will have to set the locType in the LocationalProduction.
<a name="4433"></a> *   
<a name="4434"></a> *   Set the locType property to the LocType object corresponding to the
<a name="4435"></a> *   location relationship of the preposition.  
<a name="4436"></a> */
<a name="4437"></a>class LocationPrepProduction: Production
<a name="4438"></a>    /* our location relationship type, as a LocType object */
<a name="4439"></a>    locType = nil
<a name="4440"></a>
<a name="4441"></a>    /* 
<a name="4442"></a>     *   on building the production, set the locType in our
<a name="4443"></a>     *   LocationalProduction parent 
<a name="4444"></a>     */
<a name="4445"></a>    build(cmd, np)
<a name="4446"></a>    {
<a name="4447"></a>        /* set the location type on the noun phrase */
<a name="4448"></a>        np.locType = locType;
<a name="4449"></a>        
<a name="4450"></a>        /* do the normal work */
<a name="4451"></a>        inherited(cmd, np);
<a name="4452"></a>    }
<a name="4453"></a>;    
<a name="4454"></a>
<a name="4455"></a>/*
<a name="4456"></a> *   QuantifierProduction is a subclass of Production for phrases that add
<a name="4457"></a> *   a number qualifier, as in "five books".
<a name="4458"></a> *   
<a name="4459"></a> *   Each grammar rule of this type needs to define a special '-&gt;quant_'
<a name="4460"></a> *   association in its template, giving the quantity phrase production.
<a name="4461"></a> *   This phrase must in turn provide a 'numval' property giving its
<a name="4462"></a> *   numeric value. 
<a name="4463"></a> *   
<a name="4464"></a> *   Alternatively, this production can itself simply provide a 'numval'
<a name="4465"></a> *   property with the correct number.  This is convenient for
<a name="4466"></a> *   adjective-like qualifier phrases that imply a number without stating
<a name="4467"></a> *   one directly, such as BOTH BOOKS.  
<a name="4468"></a> */
<a name="4469"></a>class QuantifierProduction: Production
<a name="4470"></a>    /*
<a name="4471"></a>     *   Build out the subtree.  If we have a numval embedded in this
<a name="4472"></a>     *   production, we'll use it as the quantifier.  Otherwise, we'll
<a name="4473"></a>     *   expect to find a separate quant_ sub-production among our
<a name="4474"></a>     *   children, and that it provides the quantity.  
<a name="4475"></a>     */
<a name="4476"></a>    build(cmd, np)
<a name="4477"></a>    {
<a name="4478"></a>        /* if we have our own numval value, apply it as the quantifier */
<a name="4479"></a>        if (numval != nil)
<a name="4480"></a>            np.addQuantifier(numval);
<a name="4481"></a>
<a name="4482"></a>        /* do the normal work */
<a name="4483"></a>        inherited(cmd, np);
<a name="4484"></a>    }
<a name="4485"></a>
<a name="4486"></a>    /*
<a name="4487"></a>     *   Visit a production.  When we visit the quantifier phrase, we'll
<a name="4488"></a>     *   handle it specially: we'll add the quantifier value to the main
<a name="4489"></a>     *   noun phrase, and then we *won't* parse into the subtree.  There's
<a name="4490"></a>     *   no need to parse the quantifier subtree, as its entire meaning is
<a name="4491"></a>     *   captured in its numeric value.  Parsing into it is undesirable
<a name="4492"></a>     *   because that would add the numeric tokens to the noun phrase -
<a name="4493"></a>     *   they don't belong there, since their qualification is captured in
<a name="4494"></a>     *   the quantifier and shouldn't also be added as adjectives.  
<a name="4495"></a>     */
<a name="4496"></a>    visitProd(cmd, np, prod)
<a name="4497"></a>    {
<a name="4498"></a>        /* if this is the quantifier, handle it specially */
<a name="4499"></a>        if (prod == quant_)
<a name="4500"></a>        {
<a name="4501"></a>            /* add the quantifier to the noun phrase */
<a name="4502"></a>            np.addQuantifier(prod.numval);
<a name="4503"></a>
<a name="4504"></a>            /* note that we explicitly DON'T parse into the subtree */
<a name="4505"></a>        }
<a name="4506"></a>        else
<a name="4507"></a>        {
<a name="4508"></a>            /* do the inherited work */
<a name="4509"></a>            inherited(cmd, np, prod);
<a name="4510"></a>        }
<a name="4511"></a>    }
<a name="4512"></a>;
<a name="4513"></a>
<a name="4514"></a>/*
<a name="4515"></a> *   OrdinalProduction is a subclass of Production for ordinal phrases
<a name="4516"></a> *   ("first", "second", etc).  The match object must define a method
<a name="4517"></a> *   ordval() that returns the integer value of the ordinal (1 for "first",
<a name="4518"></a> *   2 for "second", etc).  
<a name="4519"></a> */
<a name="4520"></a>class OrdinalProduction: Production
<a name="4521"></a>    build(cmd, np)
<a name="4522"></a>    {
<a name="4523"></a>        /* apply the ordinal value to the noun phrase */
<a name="4524"></a>        np.addOrdinal(ordval);
<a name="4525"></a>
<a name="4526"></a>        /* 
<a name="4527"></a>         *   we don't want to build out the subtree, since we don't want to
<a name="4528"></a>         *   treat literals as vocabulary words for this type of phrase 
<a name="4529"></a>         */
<a name="4530"></a>    }
<a name="4531"></a>;
<a name="4532"></a>
<a name="4533"></a>/*
<a name="4534"></a> *   MiscWordListProduction is a subclass of Production for miscellaneous
<a name="4535"></a> *   word list rules.  These are grammar rules of last resort, for matching
<a name="4536"></a> *   text that's positionally where a noun phrase ought to be, but which
<a name="4537"></a> *   doesn't match any of our other rules for constructing a valid noun
<a name="4538"></a> *   phrase.  These rules let us still recognize the overall verb-phrase
<a name="4539"></a> *   structure of a command, even though we can't make sense of what goes
<a name="4540"></a> *   where the nouns ought to be.  
<a name="4541"></a> */
<a name="4542"></a>class MiscWordListProduction: Production
<a name="4543"></a>    build(cmd, np)
<a name="4544"></a>    {
<a name="4545"></a>        /* tell the Command that it contains a misc word list */
<a name="4546"></a>        cmd.noteMiscWords(np);
<a name="4547"></a>
<a name="4548"></a>        /* do the normal work */
<a name="4549"></a>        inherited(cmd, np);
<a name="4550"></a>    }
<a name="4551"></a>;
<a name="4552"></a>
<a name="4553"></a>/*
<a name="4554"></a> *   An OopsProduction is a subclass for the word list part of an OOPS
<a name="4555"></a> *   command.  This must have a -&gt;toks_ property that holds the sub-tree
<a name="4556"></a> *   for the literal token list of the correction. 
<a name="4557"></a> */
<a name="4558"></a>class OopsProduction: Production
<a name="4559"></a>    /* 
<a name="4560"></a>     *   Class method: apply the correction for an OOPS command to an
<a name="4561"></a>     *   original token list.
<a name="4562"></a>     */
<a name="4563"></a>    applyCorrection(prod, toks, typoIdx)
<a name="4564"></a>    {
<a name="4565"></a>        /* build the tree into an OopsCommand object */
<a name="4566"></a>        local cmd = new OopsCommand();
<a name="4567"></a>        prod.build(cmd, nil);
<a name="4568"></a>
<a name="4569"></a>        /* 
<a name="4570"></a>         *   splice the corrected tokens into the original token list,
<a name="4571"></a>         *   replacing the unknown word token, and return the result 
<a name="4572"></a>         */
<a name="4573"></a>        return toks.splice(typoIdx, 1, cmd.tokens...);
<a name="4574"></a>    }
<a name="4575"></a>
<a name="4576"></a>    /* build the command */
<a name="4577"></a>    build(cmd, np)
<a name="4578"></a>    {
<a name="4579"></a>        /* add the token list of the correction to the command */
<a name="4580"></a>        cmd.tokens += toks_.getTokens();
<a name="4581"></a>    }
<a name="4582"></a>;
<a name="4583"></a>
<a name="4584"></a>/*
<a name="4585"></a> *   An OopsCommand is a fake Command object for building out an Oops tree.
<a name="4586"></a> */
<a name="4587"></a>class OopsCommand: object
<a name="4588"></a>    /* the token list: this is filled in when we build the Oops nodes */
<a name="4589"></a>    tokens = []
<a name="4590"></a>;
<a name="4591"></a>
<a name="4592"></a>/*
<a name="4593"></a> *   DisambigProduction is a subclass of Production for the root of a
<a name="4594"></a> *   disambiguation reply tree grammar. 
<a name="4595"></a> */
<a name="4596"></a>class DisambigProduction: Production
<a name="4597"></a>    addNounListItem(cmd, prod)
<a name="4598"></a>    {
<a name="4599"></a>        /* 
<a name="4600"></a>         *   add the new item to the disambig reply list for the original
<a name="4601"></a>         *   noun phrase 
<a name="4602"></a>         */
<a name="4603"></a>        return cmd.addDisambigNP(prod);
<a name="4604"></a>    }
<a name="4605"></a>;
<a name="4606"></a>
<a name="4607"></a>/*
<a name="4608"></a> *   Production class for Yes-or-No phrases 
<a name="4609"></a> */
<a name="4610"></a>property yesOrNoAnswer;
<a name="4611"></a>class YesOrNoProduction: Production
<a name="4612"></a>    build(cmd, np)
<a name="4613"></a>    {
<a name="4614"></a>        /* set the yes/no answer property in the Command */
<a name="4615"></a>        cmd.yesOrNoAnswer = answer;
<a name="4616"></a>
<a name="4617"></a>        /* do the normal work */
<a name="4618"></a>        inherited(cmd, np);
<a name="4619"></a>    }
<a name="4620"></a>;
<a name="4621"></a>
<a name="4622"></a>/* ------------------------------------------------------------------------ */
<a name="4623"></a>/*
<a name="4624"></a> *   Base class for pronouns.  We represent each type of pronoun with an
<a name="4625"></a> *   object, to abstract pronouns away from the vocabulary.
<a name="4626"></a> *   
<a name="4627"></a> *   The base library defines a set of pronouns that are common to most
<a name="4628"></a> *   languages: It, Him, Her, Them, You, Y'all, Me, and Us, plus reflexive
<a name="4629"></a> *   forms of It, Him, Her, and Them.  Some languages might not employ all
<a name="4630"></a> *   of these (French, for example, has no neuter gender, so there's no
<a name="4631"></a> *   equivalent of It), and some might need additional pronouns (e.g.,
<a name="4632"></a> *   French needs a feminine third-person plural).  If a pronoun we define
<a name="4633"></a> *   here has no equivalent in a given language, the language module should
<a name="4634"></a> *   simply omit any grammar mentioning it.  If the language has pronouns
<a name="4635"></a> *   that aren't in the basic set, the language module can provide
<a name="4636"></a> *   definitions for its own additional Pronoun objects, along with the
<a name="4637"></a> *   corresponding grammar rules.
<a name="4638"></a> *   
<a name="4639"></a> *   The library itself only directly references one pronoun object: You.
<a name="4640"></a> *   The parser specifically references this pronoun because it binds to
<a name="4641"></a> *   the addressee of a command, which has a special role in the parsing
<a name="4642"></a> *   process.  Apart from You, though, the library's use of pronouns is
<a name="4643"></a> *   directed by the grammar: if a given Pronoun doesn't appear in the
<a name="4644"></a> *   grammar anywhere, the library will never use it.  (Other than in
<a name="4645"></a> *   iterations over Pronoun instances, anyway; but these will be harmless
<a name="4646"></a> *   because the parser is just trying to be inclusive.)  This means that
<a name="4647"></a> *   language modules are free to ignore pronouns (other than You) from the
<a name="4648"></a> *   standard set when they're not a good match for the language's needs.
<a name="4649"></a> *   For example, if you need distinct Animate and Inanimate forms of Him
<a name="4650"></a> *   and Her, you could simply define four new Pronoun objects for these
<a name="4651"></a> *   forms, and use them in place of Him and Her throughout your grammar.  
<a name="4652"></a> *   
<a name="4653"></a> *   Note that these objects are NOT grammar rules or dictionary words.
<a name="4654"></a> *   These are abstract objects representing the "binding" of the pronouns
<a name="4655"></a> *   - basically the set of grammatical attributes (gender, number) that
<a name="4656"></a> *   determine whether a given noun phrase is a valid antecedent for a
<a name="4657"></a> *   given pronoun.  That's why we don't define separate Pronoun objects
<a name="4658"></a> *   the different grammatical cases (nominative, accusative, dative, etc):
<a name="4659"></a> *   case is a feature of the grammar, and we're one step removed from that
<a name="4660"></a> *   here.  
<a name="4661"></a> */
<a name="4662"></a>class Pronoun: object
<a name="4663"></a>    /*
<a name="4664"></a>     *   Resolve the pronoun during parsing.  The usual way of doing this
<a name="4665"></a>     *   is to return the list of antecedents we store as part of the
<a name="4666"></a>     *   pronoun object.  This lets each type of pronoun store an
<a name="4667"></a>     *   appropriate list of antecedents.
<a name="4668"></a>     *   
<a name="4669"></a>     *   For a reflexive pronoun, return the Pronoun object for the
<a name="4670"></a>     *   ordinary form of the pronoun.  This tells the parser that it needs
<a name="4671"></a>     *   to find a match for the pronoun within the command itself, rather
<a name="4672"></a>     *   than looking for an external antecedent.  Second person is
<a name="4673"></a>     *   inherently reflexive, in that it refers to the addressee(s), so
<a name="4674"></a>     *   this should return 'self' for a second-person pronoun.  
<a name="4675"></a>     */
<a name="4676"></a>    resolve() { return ante; }
<a name="4677"></a>
<a name="4678"></a>    /* 
<a name="4679"></a>     *   The grammatical person of the pronoun.  Pronouns come in three
<a name="4680"></a>     *   persons: first (me, us), second (you), and third (her, them).  We
<a name="4681"></a>     *   represent these as 1, 2, and 3.  
<a name="4682"></a>     */
<a name="4683"></a>    person = 3
<a name="4684"></a>
<a name="4685"></a>    /* 
<a name="4686"></a>     *   Set the antecedent(s) for future pronoun usage based on the
<a name="4687"></a>     *   objects mentioned in the current command input or narrative
<a name="4688"></a>     *   output.  'obj' can be a single antecedent object, or it can be a
<a name="4689"></a>     *   list.  Even a singular pronoun can have a list of antecedents:
<a name="4690"></a>     *   some commands have more than one noun phrase, and there's no way
<a name="4691"></a>     *   of knowing which one the user might want to refer to with a
<a name="4692"></a>     *   pronoun in a future command.  We can't know until we see the
<a name="4693"></a>     *   context of the future pronoun use.  For example, UNLOCK DOOR WITH
<a name="4694"></a>     *   KEY could be followed by OPEN IT, in which case IT is probably the
<a name="4695"></a>     *   door; or by DROP IT, in which case IT is probably the key.  The
<a name="4696"></a>     *   best thing to do is to save both the door and the key as possible
<a name="4697"></a>     *   antecedents, so that we can choose the most suitable object when
<a name="4698"></a>     *   we actually see a pronoun in a subsequent command.  
<a name="4699"></a>     */
<a name="4700"></a>    setAntecedents(obj){ ante = obj; }
<a name="4701"></a>
<a name="4702"></a>    /*
<a name="4703"></a>     *   Does this pronoun match the given object or list of objects?  By
<a name="4704"></a>     *   default, we won't match lists, and we'll ask the object if it
<a name="4705"></a>     *   thinks we're a match.  
<a name="4706"></a>     */
<a name="4707"></a>    matchObj(obj)
<a name="4708"></a>    {
<a name="4709"></a>        return !obj.ofKind(Collection) &amp;&amp; obj.matchPronoun(self);
<a name="4710"></a>    }
<a name="4711"></a>
<a name="4712"></a>    /* my antecedent or list of antecedents */
<a name="4713"></a>    ante = []
<a name="4714"></a>
<a name="4715"></a>    /* 
<a name="4716"></a>     *   the corresponding reflexive pronoun, if any - this is set up
<a name="4717"></a>     *   automatically during preinit 
<a name="4718"></a>     */
<a name="4719"></a>    reflexive = nil
<a name="4720"></a>
<a name="4721"></a>    /* 
<a name="4722"></a>     *   Class property - list of all regular Pronoun objects.  (Note that
<a name="4723"></a>     *   this excludes the reflexive pronouns, because the ReflexivePronoun
<a name="4724"></a>     *   class has its own separate 'all' list for its instances.)  
<a name="4725"></a>     */
<a name="4726"></a>    all = []
<a name="4727"></a>
<a name="4728"></a>    /* on initialization, add me to the master list of pronoun objects */
<a name="4729"></a>    construct()
<a name="4730"></a>    {
<a name="4731"></a>        /* get the nearest class that has a master list */
<a name="4732"></a>        local cl = propDefined(&amp;all, PropDefGetClass);
<a name="4733"></a>
<a name="4734"></a>        /* add me to my class's master list */
<a name="4735"></a>        cl.all += self;
<a name="4736"></a>    }
<a name="4737"></a>;
<a name="4738"></a>
<a name="4739"></a>/* It - third-person neuter singular */
<a name="4740"></a>It: Pronoun
<a name="4741"></a>;
<a name="4742"></a>
<a name="4743"></a>/* Her - third-person feminine singular */
<a name="4744"></a>Her: Pronoun
<a name="4745"></a>;
<a name="4746"></a>
<a name="4747"></a>/* Him - third-person masculine singular */
<a name="4748"></a>Him: Pronoun
<a name="4749"></a>;
<a name="4750"></a>
<a name="4751"></a>/* Them - third-person mixed-gender plural */
<a name="4752"></a>Them: Pronoun
<a name="4753"></a>    /* 
<a name="4754"></a>     *   Them is a plural, so it can match a list, as well as an individual
<a name="4755"></a>     *   object that matches Them 
<a name="4756"></a>     */
<a name="4757"></a>    matchObj(obj)
<a name="4758"></a>    {
<a name="4759"></a>        return obj.ofKind(Collection) || obj.matchPronoun(self);
<a name="4760"></a>    }
<a name="4761"></a>;
<a name="4762"></a>
<a name="4763"></a>/* 
<a name="4764"></a> *   You - the second-person singular.  YOU always binds to the addressee
<a name="4765"></a> *   of the command: either the player character, or the actor being given
<a name="4766"></a> *   orders via a construct like ACTOR, DO THIS.
<a name="4767"></a> *   
<a name="4768"></a> *   Binding to the PC is grammatically correct in a first-person
<a name="4769"></a> *   narration, because the PC is the narrator's ME and therefore the
<a name="4770"></a> *   player's YOU.  It's less so in a second-person game: the PC is the
<a name="4771"></a> *   narrator's YOU, so the player's YOU ought to be the narrator.
<a name="4772"></a> *   However, some players are literal-minded about second-person
<a name="4773"></a> *   narration, so rather than reflecting the narrator's YOU into the
<a name="4774"></a> *   player's ME, they simply say YOU too.  Fortunately, there's not any
<a name="4775"></a> *   serious ambiguity here.  The narrator is typically not a game-world
<a name="4776"></a> *   object, but is an entity that exists outside the game world, so it's
<a name="4777"></a> *   off-limits for discussion in commands.  So YOU can't mean the
<a name="4778"></a> *   narrator.  That means that if the player uses YOU at all, they must
<a name="4779"></a> *   mean the PC.  
<a name="4780"></a> */
<a name="4781"></a>You: Pronoun
<a name="4782"></a>    /* 
<a name="4783"></a>     *   The second-person pronoun binds to information contained within
<a name="4784"></a>     *   the command itself, namely the addressee of the command, so we
<a name="4785"></a>     *   need to resolve it using the parser's "late binding" scheme.  That
<a name="4786"></a>     *   is, we return 'self' to tell the parser that it needs to go back
<a name="4787"></a>     *   and resolve this pronoun after resolving other phrases.  
<a name="4788"></a>     */
<a name="4789"></a>    resolve() 
<a name="4790"></a>    { 
<a name="4791"></a>        /* 
<a name="4792"></a>         *   But if no other actor has been specified, 'YOU' must mean 'ME',
<a name="4793"></a>         *   i.e. the player character
<a name="4794"></a>         */
<a name="4795"></a>             
<a name="4796"></a>        if(gCommand &amp;&amp; gCommand.actorNPs == [] &amp;&amp; gCommand.actorPerson == 2)
<a name="4797"></a>            return [gPlayerChar];
<a name="4798"></a>        
<a name="4799"></a>        return [self]; 
<a name="4800"></a>    }
<a name="4801"></a>
<a name="4802"></a>    /* this is a second-person pronoun */
<a name="4803"></a>    person = 2
<a name="4804"></a>;
<a name="4805"></a>
<a name="4806"></a>/*
<a name="4807"></a> *   Y'all - the second-person plural.  ("Y'all" isn't exactly standard
<a name="4808"></a> *   English, but it's as close as English comes to having a distinct
<a name="4809"></a> *   plural You, and we had to call this *something*.)
<a name="4810"></a> *   
<a name="4811"></a> *   By default, we treat Y'all as a synonym for You, since there's rarely
<a name="4812"></a> *   any reason in an IF context to distinguish them.  The main value in
<a name="4813"></a> *   natural language is in group conversation, where it can be useful to
<a name="4814"></a> *   clarify whether the speaker is addressing the whole group or just an
<a name="4815"></a> *   individual.  In IF, though, this is never ambiguous: the addressee is
<a name="4816"></a> *   either explicitly stated in the command, or it's the player character.
<a name="4817"></a> *   The only thing we could do with a plural is check that the verb agrees
<a name="4818"></a> *   in number, and chastise the player's sloppy grammar if not.  But that
<a name="4819"></a> *   would be contrary to our general philosophy that we should be as lax
<a name="4820"></a> *   as we can about the input grammar, to minimize the player's typing
<a name="4821"></a> *   workload.  So our advice here is to implement a grammar rule for the
<a name="4822"></a> *   various YOUs that treats all of the second-person pronoun forms as
<a name="4823"></a> *   synonyms for the basic singular YOU.  
<a name="4824"></a> */
<a name="4825"></a>Yall: Pronoun
<a name="4826"></a>    resolve() { return You.resolve(); }
<a name="4827"></a>    person = 2
<a name="4828"></a>;
<a name="4829"></a>
<a name="4830"></a>/*
<a name="4831"></a> *   Me - the first-person singular.  ME always binds to the player
<a name="4832"></a> *   character.
<a name="4833"></a> *   
<a name="4834"></a> *   The discussion about the validity of binding YOU to the PC applies in
<a name="4835"></a> *   mirror image here.  In a second-person game, the PC is the narrator's
<a name="4836"></a> *   YOU and the player's ME; in a first-person game, she's the narrator's
<a name="4837"></a> *   ME and the player's YOU.  But there is no game-world object for ME to
<a name="4838"></a> *   bind to in commands in a first-person game - if anything, ME would be
<a name="4839"></a> *   the player (not the player character, but the actual player), who is
<a name="4840"></a> *   clearly not a game-world entity.  Since that's not meaningful, we can
<a name="4841"></a> *   assume that a player talking about ME in a first-person game is being
<a name="4842"></a> *   literal-minded and just using the same pronouns the narrator does, or
<a name="4843"></a> *   that they're so accustomed to the second-person convention of most IF
<a name="4844"></a> *   that they're saying ME out of habit.  In either case, the PC is the
<a name="4845"></a> *   one they're talking about.  
<a name="4846"></a> */
<a name="4847"></a>Me: Pronoun
<a name="4848"></a>    /* 
<a name="4849"></a>     *   the first person always resolves to the player character,
<a name="4850"></a>     *   regardless of context 
<a name="4851"></a>     */
<a name="4852"></a>    resolve() { return [libGlobal.playerChar]; }
<a name="4853"></a>
<a name="4854"></a>    /* this is a first-person pronoun */
<a name="4855"></a>    person = 1
<a name="4856"></a>;
<a name="4857"></a>
<a name="4858"></a>/* 
<a name="4859"></a> *   Us - the first-person plural.  We throw this one in for relative
<a name="4860"></a> *   completeness, but we simply treat it as a synonym for Me.  This could
<a name="4861"></a> *   be useful in a game with a PC that represents a group of people (an
<a name="4862"></a> *   adventuring party in a hack-n-slash game, say), or a royal personage.
<a name="4863"></a> *   
<a name="4864"></a> *   A more sophisticated use would be to allow the player to refer
<a name="4865"></a> *   collectively to the PC and a group of accompanying NPCs.  The base
<a name="4866"></a> *   library doesn't implement this because it doesn't define a way to
<a name="4867"></a> *   identify such a group, but a game could add that capability.  Once
<a name="4868"></a> *   you've defined what US means, you could make the pronoun US bind to
<a name="4869"></a> *   that group simply by modifying the resolve() method here.  
<a name="4870"></a> */
<a name="4871"></a>Us: Pronoun
<a name="4872"></a>    resolve() { return Me.resolve(); }
<a name="4873"></a>;
<a name="4874"></a>
<a name="4875"></a>
<a name="4876"></a>/*
<a name="4877"></a> *   Base class for reflexive pronouns.  These are pronouns like "himself"
<a name="4878"></a> *   that specifically refer to an antecedent in the same sentence, rather
<a name="4879"></a> *   than to an earlier sentence: ASK BOB ABOUT HIMSELF is an inquiry about
<a name="4880"></a> *   Bob, while ASK BOB ABOUT HIM refers to some male antecedent from an
<a name="4881"></a> *   earlier statement.  
<a name="4882"></a> *   
<a name="4883"></a> *   Note that the first- and second-person reflexives are generally not
<a name="4884"></a> *   needed in the parser.  (We define them here anyway, because they're
<a name="4885"></a> *   useful for message generation.)  The third-person reflexive pronouns
<a name="4886"></a> *   have distinct meanings in input from the corresponding ordinary
<a name="4887"></a> *   pronouns, in that they refer to noun phrases within the same command
<a name="4888"></a> *   rather than in earlier exchanges.  In contrast, the second-person
<a name="4889"></a> *   pronouns have the same meaning in ordinary and reflexive forms, at
<a name="4890"></a> *   least within the confines of the IF parser: EXAMINE ME and EXAMINE
<a name="4891"></a> *   MYSELF mean the same thing in all typical IF command syntax.
<a name="4892"></a> */
<a name="4893"></a>class ReflexivePronoun: Pronoun
<a name="4894"></a>    /* during construction, set the regular pronoun to point back at me */
<a name="4895"></a>    construct()
<a name="4896"></a>    {
<a name="4897"></a>        inherited();
<a name="4898"></a>        pronoun.reflexive = self;
<a name="4899"></a>    }
<a name="4900"></a>
<a name="4901"></a>    /*
<a name="4902"></a>     *   A reflexive pronoun binds to another noun phrase contained in the
<a name="4903"></a>     *   same command, so we resolve using the parser's "late binding"
<a name="4904"></a>     *   scheme.  We invoke this by returning the ordinary (non-reflexive)
<a name="4905"></a>     *   pronoun object representing the attributes that we match; upon
<a name="4906"></a>     *   seeing this, the parser will know to come back to this pronoun
<a name="4907"></a>     *   after it's finished resolving earlier phrases, and look for the
<a name="4908"></a>     *   appropriate pronoun binding within those other phrases.  
<a name="4909"></a>     */
<a name="4910"></a>    resolve() { return pronoun; }
<a name="4911"></a>
<a name="4912"></a>    /*
<a name="4913"></a>     *   Get the corresponding ordinary (non-reflexive) form of the
<a name="4914"></a>     *   pronoun.  For example, for HIMSELF we'd return HIM.  
<a name="4915"></a>     */
<a name="4916"></a>    pronoun = nil
<a name="4917"></a>
<a name="4918"></a>    /* my grammatical person is the same as my underlying pronoun's */
<a name="4919"></a>    person = (pronoun.person)
<a name="4920"></a>
<a name="4921"></a>    /* 
<a name="4922"></a>     *   Class property - list of all reflexive pronoun objects.  This
<a name="4923"></a>     *   keeps the reflexive pronouns in a separate list from the base
<a name="4924"></a>     *   Pronoun list.  
<a name="4925"></a>     */
<a name="4926"></a>    all = []
<a name="4927"></a>;
<a name="4928"></a>
<a name="4929"></a>/* first-person singular reflexive */
<a name="4930"></a>Myself: ReflexivePronoun
<a name="4931"></a>    pronoun = Me
<a name="4932"></a>;
<a name="4933"></a>
<a name="4934"></a>/* second-person singular reflexive */
<a name="4935"></a>Yourself: ReflexivePronoun
<a name="4936"></a>    pronoun = You
<a name="4937"></a>;
<a name="4938"></a>
<a name="4939"></a>/* third-person singular neuter reflexive */
<a name="4940"></a>Itself: ReflexivePronoun
<a name="4941"></a>    pronoun = It
<a name="4942"></a>;
<a name="4943"></a>
<a name="4944"></a>/* third-person singular feminine reflexive */
<a name="4945"></a>Herself: ReflexivePronoun
<a name="4946"></a>    pronoun = Her
<a name="4947"></a>;
<a name="4948"></a>
<a name="4949"></a>/* third-person singular masculine reflexive */
<a name="4950"></a>Himself: ReflexivePronoun
<a name="4951"></a>    pronoun = Him
<a name="4952"></a>;
<a name="4953"></a>
<a name="4954"></a>/* first-person plural reflexive */
<a name="4955"></a>Ourselves: ReflexivePronoun
<a name="4956"></a>    pronoun = Us
<a name="4957"></a>;
<a name="4958"></a>
<a name="4959"></a>/* second-person plural reflexive */
<a name="4960"></a>Yourselves: ReflexivePronoun
<a name="4961"></a>    pronoun = Yall
<a name="4962"></a>;
<a name="4963"></a>
<a name="4964"></a>/* third-person mixed-gender plural reflexive */
<a name="4965"></a>Themselves: ReflexivePronoun
<a name="4966"></a>    pronoun = Them
<a name="4967"></a>;
<a name="4968"></a>
<a name="4969"></a>
<a name="4970"></a>/* ------------------------------------------------------------------------ */
<a name="4971"></a>/*
<a name="4972"></a> *   Determiners.  A determiner qualifies a noun phrase with information on
<a name="4973"></a> *   how it relates to the objects it describes.  For example, "a book"
<a name="4974"></a> *   refers to any book that's in scope for the discussion (in IF terms,
<a name="4975"></a> *   this is usually any book that's physically present), while "the book"
<a name="4976"></a> *   refers to some specific single book.
<a name="4977"></a> *   
<a name="4978"></a> *   Language modules can add determiners as needed.  For example, a
<a name="4979"></a> *   language with grammatical gender would probably find gendered versions
<a name="4980"></a> *   of Definite and Indefinite useful, to represent the use of gendered
<a name="4981"></a> *   articles in input.
<a name="4982"></a> */
<a name="4983"></a>class Determiner: object;
<a name="4984"></a>
<a name="4985"></a>/* Unqualified mode ("book") */
<a name="4986"></a>Unqualified: Determiner;
<a name="4987"></a>
<a name="4988"></a>/* Definite mode ("the book", "book", "both books", "the three books") */
<a name="4989"></a>Definite: Determiner;
<a name="4990"></a>
<a name="4991"></a>/* Indefinite mode ("a book", "any book", "one of the books", three books") */
<a name="4992"></a>Indefinite: Determiner;
<a name="4993"></a>
<a name="4994"></a>/* All ("the books", "all", "all of the books") */
<a name="4995"></a>All: Determiner;
<a name="4996"></a>
<a name="4997"></a>
<a name="4998"></a>/* ------------------------------------------------------------------------ */
<a name="4999"></a>/*
<a name="5000"></a> *   ParseError is an Exception subclass for parsing errors. 
<a name="5001"></a> */
<a name="5002"></a>class ParseError: Exception
<a name="5003"></a>    /*
<a name="5004"></a>     *   Display the error message
<a name="5005"></a>     */
<a name="5006"></a>    display() { "Unknown parsing error."; }
<a name="5007"></a>
<a name="5008"></a>    /*
<a name="5009"></a>     *   Rank a spelling correction candidate for input that triggered this
<a name="5010"></a>     *   error on parsing.
<a name="5011"></a>     *   
<a name="5012"></a>     *   'toks' is the new token list, with the spelling correction
<a name="5013"></a>     *   applied; 'idx' is the index in the list of the corrected word.
<a name="5014"></a>     *   'dict' is the Dictionary used for parsing.
<a name="5015"></a>     *   
<a name="5016"></a>     *   Returns an integer value giving the ranking.  The ranking is used
<a name="5017"></a>     *   for sorting, so the scale is arbitrary - we simply take the
<a name="5018"></a>     *   highest ranking item.  The value 0 is special, though: it means
<a name="5019"></a>     *   that we should filter out the candidate and not consider it at
<a name="5020"></a>     *   all.  
<a name="5021"></a>     */
<a name="5022"></a>    rankCorrection(toks, idx, dict) { return 1; }
<a name="5023"></a>
<a name="5024"></a>    /*
<a name="5025"></a>     *   Is this error allowed on a spelling correction candidate?  By
<a name="5026"></a>     *   default, this is nil, meaning that this error invalidates a
<a name="5027"></a>     *   correction candidate.  We mostly reject spelling "corrections"
<a name="5028"></a>     *   that result in errors because these are probably false positives:
<a name="5029"></a>     *   they probably replace a misspelled word with one that's in the
<a name="5030"></a>     *   dictionary but that's still wrong.  However, there are a few
<a name="5031"></a>     *   curable errors where it can make sense to keep a correction, such
<a name="5032"></a>     *   as an ambiguous noun phrase: that's so close to being a working
<a name="5033"></a>     *   command that we probably have a good correction.  
<a name="5034"></a>     */
<a name="5035"></a>    allowOnRespell = nil
<a name="5036"></a>
<a name="5037"></a>    /*
<a name="5038"></a>     *   Is this a "curable" error?  A curable error is one that the user
<a name="5039"></a>     *   can fix by answering a question, such as "which one do you mean?"
<a name="5040"></a>     *   or "what do you want to unlock it with?"
<a name="5041"></a>     *   
<a name="5042"></a>     *   When we find more than one grammar match to an input string, the
<a name="5043"></a>     *   parser tries resolving each one, in order of the predicate match
<a name="5044"></a>     *   quality.  If one resolves without an error, the parser stops and
<a name="5045"></a>     *   uses that match.  But if *none* of the possible matches resolve
<a name="5046"></a>     *   without an error, the parser picks a match with a curable error
<a name="5047"></a>     *   over one with an incurable error.  
<a name="5048"></a>     */
<a name="5049"></a>    curable = nil
<a name="5050"></a>
<a name="5051"></a>    /*
<a name="5052"></a>     *   Try curing this error with the user's answer to the error message.
<a name="5053"></a>     *   The parser calls this when (a) the PREVIOUS command resulted in
<a name="5054"></a>     *   this error, (b) this error is curable, and (c) the user typed
<a name="5055"></a>     *   something on the CURRENT command that didn't parse as a valid new
<a name="5056"></a>     *   command.  Since the new input doesn't look like a valid command,
<a name="5057"></a>     *   the parser calls this to determine if the input was instead meant
<a name="5058"></a>     *   as an answer to the question posed by the last error.
<a name="5059"></a>     *   
<a name="5060"></a>     *   If this new command is indeed a valid response to the error
<a name="5061"></a>     *   message, we return a CommandList with the "cured" version of the
<a name="5062"></a>     *   command.  This new command list should supplement the command with
<a name="5063"></a>     *   the new information provided by the reply.  If not, we simply
<a name="5064"></a>     *   return nil.  
<a name="5065"></a>     */
<a name="5066"></a>    tryCuring(toks, dict) { return nil; }
<a name="5067"></a>
<a name="5068"></a>    /*
<a name="5069"></a>     *   The parsing "stage" of this error.  We can distinguish three
<a name="5070"></a>     *   levels of intelligibility as we work through the parsing process:
<a name="5071"></a>     *   (1) completely unintelligible, (2) valid verb structure, and (3)
<a name="5072"></a>     *   resolved noun phrases.  This property tells us which stage we
<a name="5073"></a>     *   finish in when we encounter an error of this type.
<a name="5074"></a>     */
<a name="5075"></a>    errStage = 1
<a name="5076"></a>;
<a name="5077"></a>
<a name="5078"></a>/*
<a name="5079"></a> *   The basic command-level parsing error.  This occurs when we can't find
<a name="5080"></a> *   a grammar match to the overall command phrasing. 
<a name="5081"></a> */
<a name="5082"></a>class NotUnderstoodError: ParseError
<a name="5083"></a>    display()
<a name="5084"></a>    {
<a name="5085"></a>        /*
<a name="5086"></a>         *   We couldn't parse a command.  This means that we were unable
<a name="5087"></a>         *   to find any grammar match for the input, so we basically have
<a name="5088"></a>         *   no idea what the player was trying to say.  
<a name="5089"></a>         */
<a name="5090"></a>        DMsg(not understood, 'I don\'t understand that command.');        
<a name="5091"></a>    }
<a name="5092"></a>
<a name="5093"></a>    /* 
<a name="5094"></a>     *   This is a general verb syntax error, so our best candidates will
<a name="5095"></a>     *   words that are used in verb phrases.  The next best is a corrected
<a name="5096"></a>     *   word that's used in any GrammarProd, since the problem might
<a name="5097"></a>     *   actually be in some other structural part of the command phrase
<a name="5098"></a>     *   above the verb phrase (a conjunction, for example).  
<a name="5099"></a>     */
<a name="5100"></a>    rankCorrection(toks, idx, dict)
<a name="5101"></a>    {
<a name="5102"></a>        /* get the text of the token */
<a name="5103"></a>        local txt = getTokVal(toks[idx]);
<a name="5104"></a>
<a name="5105"></a>        /* look up the word in the action vocabulary table */
<a name="5106"></a>        local w = actionDictionary.wordToAction[txt];
<a name="5107"></a>        if (w != nil)
<a name="5108"></a>        {
<a name="5109"></a>            /* get the highest spelling priority of the matching actions */
<a name="5110"></a>            local maxAct = w.maxVal({ a: a.spellingPriority });
<a name="5111"></a>
<a name="5112"></a>            /* 
<a name="5113"></a>             *   Look for other words in the token list that are also in
<a name="5114"></a>             *   this words associated word list.  (For example, if the
<a name="5115"></a>             *   candidate is 'up', look for words like 'pick', 'go', or
<a name="5116"></a>             *   'look' that occur in the same verb rules with 'up'.) 
<a name="5117"></a>             */
<a name="5118"></a>            local xlst = actionDictionary.xwords[txt] - txt;
<a name="5119"></a>            local xbonus = (toks.indexWhich(
<a name="5120"></a>                { t: xlst.indexOf(getTokVal(t)) != nil }) != nil);
<a name="5121"></a>
<a name="5122"></a>            /* 
<a name="5123"></a>             *   Give this a high rating, with the action priority and
<a name="5124"></a>             *   associated word bonuses to break ties.
<a name="5125"></a>             */
<a name="5126"></a>            return 200 + maxAct*2 + (xbonus ? 1 : 0);
<a name="5127"></a>        }
<a name="5128"></a>
<a name="5129"></a>        /* okay, no predicate; how about any other GrammarProd word? */
<a name="5130"></a>        w = dict.findWord(txt);
<a name="5131"></a>        if (w.indexWhich(
<a name="5132"></a>            { x: dataType(x) == TypeObject &amp;&amp; x.ofKind(GrammarProd) }) != nil)
<a name="5133"></a>            return 100;
<a name="5134"></a>
<a name="5135"></a>        /* 
<a name="5136"></a>         *   No luck on any of our preferences; give it our lowest rank.
<a name="5137"></a>         *   We still want to allow it to be considered, so give it a
<a name="5138"></a>         *   non-zero rank. 
<a name="5139"></a>         */
<a name="5140"></a>        return 1;
<a name="5141"></a>    }
<a name="5142"></a>;
<a name="5143"></a>
<a name="5144"></a>/*
<a name="5145"></a> *   An UnknownWordError points out a word that's not in the game's
<a name="5146"></a> *   dictionary. 
<a name="5147"></a> */
<a name="5148"></a>class UnknownWordError: ParseError
<a name="5149"></a>    construct(txt)
<a name="5150"></a>    {
<a name="5151"></a>        self.badWord = txt;
<a name="5152"></a>    }
<a name="5153"></a>
<a name="5154"></a>    display()
<a name="5155"></a>    {
<a name="5156"></a>        /*
<a name="5157"></a>         *   The command contains a word that's not in the dictionary.
<a name="5158"></a>         *   This error is only used when the parser is set to admit to
<a name="5159"></a>         *   unknown words, and only when we fail to parse the command.
<a name="5160"></a>         *   (It's possible for a command to succeed even when it contains
<a name="5161"></a>         *   words that aren't in the dictionary, since objects and topics
<a name="5162"></a>         *   can sometimes match arbitrary input.)  
<a name="5163"></a>         */
<a name="5164"></a>        DMsg(unknown word, 'I don\'t know the word "{1}".', badWord);
<a name="5165"></a>
<a name="5166"></a>    }
<a name="5167"></a>
<a name="5168"></a>    /* the text of the unknown word */
<a name="5169"></a>    badWord = nil
<a name="5170"></a>;
<a name="5171"></a>
<a name="5172"></a>/* 
<a name="5173"></a> *   OopsError is the base class for errors in an OOPS command.
<a name="5174"></a> */
<a name="5175"></a>class OopsError: ParseError
<a name="5176"></a>;
<a name="5177"></a>
<a name="5178"></a>/*
<a name="5179"></a> *   A CantOopsError means that the player typed OOPS when we don't have a
<a name="5180"></a> *   previous command typo we can correct.  
<a name="5181"></a> */
<a name="5182"></a>class CantOopsError: OopsError
<a name="5183"></a>    display()
<a name="5184"></a>    {
<a name="5185"></a>        /*
<a name="5186"></a>         *   The player typed an OOPS command, but we don't have anything
<a name="5187"></a>         *   from a past command that we can correct.  This means that
<a name="5188"></a>         *   either the last command succeeded, or that it simply didn't
<a name="5189"></a>         *   contain any non-dictionary words. 
<a name="5190"></a>         */
<a name="5191"></a>        DMsg(no oops now, 'Sorry, I\'m not sure what you\'re correcting.');
<a name="5192"></a>    }
<a name="5193"></a>;
<a name="5194"></a>
<a name="5195"></a>
<a name="5196"></a>/*
<a name="5197"></a> *   A CommandError is an error in parsing that occurs within the build
<a name="5198"></a> *   process for a Command object.  
<a name="5199"></a> */
<a name="5200"></a>class CommandError: ParseError
<a name="5201"></a>    construct(cmd)
<a name="5202"></a>    {
<a name="5203"></a>        /* remember the command */
<a name="5204"></a>        self.cmd = cmd;
<a name="5205"></a>    }
<a name="5206"></a>
<a name="5207"></a>    /* the Command object where the error occurred */
<a name="5208"></a>    cmd = nil
<a name="5209"></a>
<a name="5210"></a>    /* 
<a name="5211"></a>     *   these errors occur once we have a valid predicate structure, so
<a name="5212"></a>     *   we're in stage 2 of the parsing when we encounter an error of this
<a name="5213"></a>     *   type 
<a name="5214"></a>     */
<a name="5215"></a>    errStage = 2
<a name="5216"></a>;
<a name="5217"></a>
<a name="5218"></a>/*
<a name="5219"></a> *   Rejected parsing structure.  There are certain structures that are
<a name="5220"></a> *   hard to eliminate in the grammar, but which we don't want to accept
<a name="5221"></a> *   semantically.  This error can be thrown when such a structure is
<a name="5222"></a> *   encountered.  This effectively rules out a parse tree.  It's not a
<a name="5223"></a> *   displayable error; the parser simply rules out these structures.  
<a name="5224"></a> */
<a name="5225"></a>class RejectParseTreeError: CommandError
<a name="5226"></a>    display()
<a name="5227"></a>    {
<a name="5228"></a>        /* 
<a name="5229"></a>         *   users should never see this error - it should be handled
<a name="5230"></a>         *   internally to the library 
<a name="5231"></a>         */
<a name="5232"></a>        "\n(Internal: Parse tree rejected.)\n";
<a name="5233"></a>    }
<a name="5234"></a>;
<a name="5235"></a>
<a name="5236"></a>/*
<a name="5237"></a> *   Empty noun slot error.  This occurs when there are no noun phrases in
<a name="5238"></a> *   a functional slot in the predicate (e.g., when the player types "TAKE"
<a name="5239"></a> *   without a direct object).  
<a name="5240"></a> */
<a name="5241"></a>class EmptyNounError: CommandError
<a name="5242"></a>    construct(cmd, role)
<a name="5243"></a>    {
<a name="5244"></a>        inherited(cmd);
<a name="5245"></a>        self.role = role;
<a name="5246"></a>    }
<a name="5247"></a>
<a name="5248"></a>    /* our message is a missing noun query (e.g., "What do want to open?") */
<a name="5249"></a>    display()
<a name="5250"></a>    {
<a name="5251"></a>        askMissingNoun(cmd, role);
<a name="5252"></a>    }
<a name="5253"></a>
<a name="5254"></a>    /*
<a name="5255"></a>     *   Try curing the error.  After a missing noun query, the player can
<a name="5256"></a>     *   respond with a simple noun phrase answering the question. 
<a name="5257"></a>     */
<a name="5258"></a>    tryCuring(toks, dict)
<a name="5259"></a>    {
<a name="5260"></a>        /* try parsing against the appropriate reply grammar */
<a name="5261"></a>        local lst = new CommandList(
<a name="5262"></a>            cmd.verbProd.missingRoleProd(role), toks, dict,
<a name="5263"></a>            new function(prod)
<a name="5264"></a>        {
<a name="5265"></a>            /* create a copy of the original command */
<a name="5266"></a>            local newCmd = cmd.clone();
<a name="5267"></a>            
<a name="5268"></a>            /* plug the new noun phrase tree into the empty role */
<a name="5269"></a>            newCmd.addNounProd(role, prod);
<a name="5270"></a>                        
<a name="5271"></a>            /* the new command is the mapped list entry */
<a name="5272"></a>            return newCmd;
<a name="5273"></a>        });
<a name="5274"></a>
<a name="5275"></a>        /* accept curable resolutions as replies */
<a name="5276"></a>        lst.acceptCurable();
<a name="5277"></a>
<a name="5278"></a>        /* return the list */
<a name="5279"></a>        return lst;
<a name="5280"></a>    }
<a name="5281"></a>
<a name="5282"></a>    /* we can cure by asking the player for the missing noun phrase */
<a name="5283"></a>    curable = true
<a name="5284"></a>;
<a name="5285"></a>
<a name="5286"></a>
<a name="5287"></a>
<a name="5288"></a>/*
<a name="5289"></a> *   Noun phrase resolution error.  This is a special type of parsing error
<a name="5290"></a> *   that indicates that the problem is with resolving a noun phrase to
<a name="5291"></a> *   game-world objects.  
<a name="5292"></a> */
<a name="5293"></a>class ResolutionError: ParseError
<a name="5294"></a>    construct(np)
<a name="5295"></a>    {
<a name="5296"></a>        /* do the normal work */
<a name="5297"></a>        inherited();
<a name="5298"></a>        
<a name="5299"></a>        /* save the noun phrase */
<a name="5300"></a>        self.np = np;
<a name="5301"></a>
<a name="5302"></a>        /* note the error-display text of the noun phrase */
<a name="5303"></a>        self.txt = np.errName;
<a name="5304"></a>    }
<a name="5305"></a>
<a name="5306"></a>    /* the NounPhrase object for the errant phrase, if available */
<a name="5307"></a>    np = nil
<a name="5308"></a>
<a name="5309"></a>    /* the text of the errant phrase, if available */
<a name="5310"></a>    txt = nil
<a name="5311"></a>
<a name="5312"></a>    /*
<a name="5313"></a>     *   For a noun resolution error, our best bet for a spelling
<a name="5314"></a>     *   correction would be a word associated with a game-world object.
<a name="5315"></a>     *   Only consider in-scope objects when making the correction, to
<a name="5316"></a>     *   avoid spurious corrections that give away information on objects
<a name="5317"></a>     *   the player has yet to encounter.  We'll also allow words that are
<a name="5318"></a>     *   used in non-predicate grammar productions, since we might have a
<a name="5319"></a>     *   structural noun phrase word (an article, pronoun, etc).  
<a name="5320"></a>     */
<a name="5321"></a>    rankCorrection(toks, idx, dict)
<a name="5322"></a>    {
<a name="5323"></a>        /* make a list consisting of the single changed word */
<a name="5324"></a>        local disList = [getTokVal(toks[idx])];
<a name="5325"></a>
<a name="5326"></a>        /* look for an in-scope object association for the word */
<a name="5327"></a>        local m = 0;
<a name="5328"></a>        foreach (local obj in World.scope())
<a name="5329"></a>            m |= obj.matchNameDisambig(disList);
<a name="5330"></a>
<a name="5331"></a>        /* 
<a name="5332"></a>         *   if we found any matches, give this the highest score; adjust
<a name="5333"></a>         *   slightly to prefer nouns, then adjectives, then plurals 
<a name="5334"></a>         */
<a name="5335"></a>        if (m != 0)
<a name="5336"></a>        {
<a name="5337"></a>            return ((m &amp; MatchNoun) != 0 ? 102 :
<a name="5338"></a>                    (m &amp; MatchAdj) != 0 ? 101 : 100);
<a name="5339"></a>        }
<a name="5340"></a>
<a name="5341"></a>        /* check for non-predicate grammar words */
<a name="5342"></a>        local w = dict.findWord(getTokVal(toks[idx]))
<a name="5343"></a>            .subset({ x: dataType(x) == TypeObject });
<a name="5344"></a>
<a name="5345"></a>        if (w.indexWhich({ x: x.ofKind(GrammarProd) &amp;&amp; !x.ofKind(predicate) })
<a name="5346"></a>            != nil)
<a name="5347"></a>            return 90;
<a name="5348"></a>
<a name="5349"></a>        /* 
<a name="5350"></a>         *   it's not an in-scope object word or a structural word, so
<a name="5351"></a>         *   don't allow it, in case it refers to a yet-unseen object 
<a name="5352"></a>         */
<a name="5353"></a>        return 0;
<a name="5354"></a>    }
<a name="5355"></a>;
<a name="5356"></a>
<a name="5357"></a>/*
<a name="5358"></a> *   ActorResolutionError - this is for resolution errors that are in the
<a name="5359"></a> *   context of what the target actor of the command (the addressee) can
<a name="5360"></a> *   see.  These require the Command in addition to the noun phrase, since
<a name="5361"></a> *   that provides the target actor information.  
<a name="5362"></a> */
<a name="5363"></a>class ActorResolutionError: ResolutionError
<a name="5364"></a>    construct(cmd, np)
<a name="5365"></a>    {
<a name="5366"></a>        inherited(np);
<a name="5367"></a>        self.cmd = cmd;
<a name="5368"></a>    }
<a name="5369"></a>
<a name="5370"></a>    /* the command that we were attempting to resolve */
<a name="5371"></a>    cmd = nil
<a name="5372"></a>;
<a name="5373"></a>
<a name="5374"></a>/*
<a name="5375"></a> *   No objects match the addressee of a command (BOB, GO NORTH or TELL BOB
<a name="5376"></a> *   TO GO NORTH).  
<a name="5377"></a> */
<a name="5378"></a>class UnmatchedActorError: ResolutionError
<a name="5379"></a>    display()
<a name="5380"></a>    {
<a name="5381"></a>        /*
<a name="5382"></a>         *   An actor phrase in a command (BOB, GO NORTH) didn't match any
<a name="5383"></a>         *   in-scope objects.  This doesn't necessarily mean that the
<a name="5384"></a>         *   phrase doesn't refer to any object anywhere in the game, just
<a name="5385"></a>         *   that it doesn't refer to anything in scope.  Since we didn't
<a name="5386"></a>         *   match anything, all we have is the text of the actor phrase
<a name="5387"></a>         *   from the player's input.  
<a name="5388"></a>         */
<a name="5389"></a>        DMsg(unmatched actor, '{I} {see} no {1} {here}.', txt);
<a name="5390"></a>    }
<a name="5391"></a>;
<a name="5392"></a>
<a name="5393"></a>/*
<a name="5394"></a> *   No objects match a noun phrase. 
<a name="5395"></a> */
<a name="5396"></a>class UnmatchedNounError: ActorResolutionError
<a name="5397"></a>    display()
<a name="5398"></a>    {
<a name="5399"></a>        /*
<a name="5400"></a>         *   A noun phrase didn't match any in-scope objects.  This doesn't
<a name="5401"></a>         *   necessarily mean that the phrase doesn't refer to any object
<a name="5402"></a>         *   anywhere in the game, just that it doesn't refer to anything
<a name="5403"></a>         *   in scope.  Since we didn't find an object, all we have is the
<a name="5404"></a>         *   text of the noun phrase from the player's input.  
<a name="5405"></a>         */
<a name="5406"></a>        DMsg(unmatched noun, '{I} {see} no {2} {here}.', cmd, stripArticle(txt));
<a name="5407"></a>    }
<a name="5408"></a>;
<a name="5409"></a>
<a name="5410"></a>/*
<a name="5411"></a> *   Base class for resolution errors involving pronouns 
<a name="5412"></a> */
<a name="5413"></a>class PronounError: ResolutionError
<a name="5414"></a>    construct(np, pro)
<a name="5415"></a>    {
<a name="5416"></a>        inherited(np);
<a name="5417"></a>        pronoun = pro;
<a name="5418"></a>    }
<a name="5419"></a>
<a name="5420"></a>    /* the pronoun that caused the error, as a Pronoun object */
<a name="5421"></a>    pronoun = nil
<a name="5422"></a>;
<a name="5423"></a>        
<a name="5424"></a>
<a name="5425"></a>/*
<a name="5426"></a> *   No pronouns match a noun phrase. 
<a name="5427"></a> */
<a name="5428"></a>class NoAntecedentError: PronounError
<a name="5429"></a>    display()
<a name="5430"></a>    {
<a name="5431"></a>        /*
<a name="5432"></a>         *   The player used a pronoun for which there's currently no
<a name="5433"></a>         *   antecedent.  
<a name="5434"></a>         */
<a name="5435"></a>        DMsg(no antecedent,
<a name="5436"></a>             'I\'m not sure what you mean by "{1}".', np.prod.getText());
<a name="5437"></a>    }
<a name="5438"></a>;
<a name="5439"></a>
<a name="5440"></a>
<a name="5441"></a>/*
<a name="5442"></a> *   The antecedent of the pronoun is no longer in scope
<a name="5443"></a> */
<a name="5444"></a>class AntecedentScopeError: PronounError
<a name="5445"></a>    construct(cmd, np, pro)
<a name="5446"></a>    {
<a name="5447"></a>        inherited(np, pro);
<a name="5448"></a>        self.cmd = cmd;
<a name="5449"></a>    }
<a name="5450"></a>
<a name="5451"></a>    cmd = nil
<a name="5452"></a>
<a name="5453"></a>    display()
<a name="5454"></a>    {
<a name="5455"></a>        /*
<a name="5456"></a>         *   The player used a pronoun that refers to an object that's no
<a name="5457"></a>         *   longer in scope. 
<a name="5458"></a>         */
<a name="5459"></a>        DMsg(antecedent out of scope,
<a name="5460"></a>             '{I} no longer {see} that {here}.', cmd);
<a name="5461"></a>    }
<a name="5462"></a>;
<a name="5463"></a>
<a name="5464"></a>
<a name="5465"></a>/*
<a name="5466"></a> *   There aren't enough objects matching a noun phrase to satisfy a
<a name="5467"></a> *   quantifier (e.g., TAKE FIVE COINS, but only three coins are present). 
<a name="5468"></a> */
<a name="5469"></a>class InsufficientNounsError: ActorResolutionError
<a name="5470"></a>    display()
<a name="5471"></a>    { 
<a name="5472"></a>        
<a name="5473"></a>        if(cmd.matchedAll)
<a name="5474"></a>            
<a name="5475"></a>            /* 
<a name="5476"></a>             *   The player used ALL when there's nothing suitable for all to
<a name="5477"></a>             *   refer to.
<a name="5478"></a>             */
<a name="5479"></a>            DMsg(nothing suitable for all, 'There{\'s} nothing suitable for        
<a name="5480"></a>                ALL to refer to. ');
<a name="5481"></a>        
<a name="5482"></a>        else
<a name="5483"></a>            
<a name="5484"></a>            /*
<a name="5485"></a>             *   The player used a noun phrase that specifically calls for some
<a name="5486"></a>             *   number of objects (such as FIVE COINS or BOTH BOOKS), but there
<a name="5487"></a>             *   aren't enough of those objects present.
<a name="5488"></a>             */
<a name="5489"></a>            DMsg(not enough nouns,
<a name="5490"></a>                 '{I} {don\'t see} that many {2} {here}.', cmd, txt);       
<a name="5491"></a>
<a name="5492"></a>    }
<a name="5493"></a>;
<a name="5494"></a>
<a name="5495"></a>/*
<a name="5496"></a> *   The owner in a possessive phrase doesn't have any of the objects
<a name="5497"></a> *   named. 
<a name="5498"></a> */
<a name="5499"></a>class NoneInOwnerError: ActorResolutionError
<a name="5500"></a>    construct(cmd, np, poss)
<a name="5501"></a>    {
<a name="5502"></a>        inherited(cmd, np);
<a name="5503"></a>        possQual = poss;
<a name="5504"></a>    }
<a name="5505"></a>
<a name="5506"></a>    /* the possessive qualifier */
<a name="5507"></a>    possQual = nil
<a name="5508"></a>
<a name="5509"></a>    display()
<a name="5510"></a>    {
<a name="5511"></a>        /* 
<a name="5512"></a>         *   if we have other than one possible owner, show the original
<a name="5513"></a>         *   text of the owner phrase, since we can't be sure which matched
<a name="5514"></a>         *   object was intended; otherwise show the name of the actual
<a name="5515"></a>         *   owner we matched 
<a name="5516"></a>         */
<a name="5517"></a>        if (possQual.matches.length() != 1)
<a name="5518"></a>        {
<a name="5519"></a>            /*
<a name="5520"></a>             *   The player used a possessive to qualify a noun phrase, and
<a name="5521"></a>             *   we matched multiple objects for the possessive phrase, but
<a name="5522"></a>             *   none of those owners actually owns anything in scope that
<a name="5523"></a>             *   matches the main noun phrase.  For example, the player
<a name="5524"></a>             *   entered THE GUARD'S SWORD, and there are two guards
<a name="5525"></a>             *   present, but neither of them has a sword (not that's in
<a name="5526"></a>             *   scope, anyway).  
<a name="5527"></a>             */
<a name="5528"></a>            DMsg(none in owners, 'No {2} {dummy}appear{s/ed} to have any {3}.',
<a name="5529"></a>                 cmd, possQual.prod.getText(), txt);
<a name="5530"></a>        }
<a name="5531"></a>        else
<a name="5532"></a>        {
<a name="5533"></a>            /*
<a name="5534"></a>             *   The player used a possessive to qualify a noun phrase, and
<a name="5535"></a>             *   we matched a single object for the possessive phrase, but
<a name="5536"></a>             *   that owner doesn't actually possess anything in scope that
<a name="5537"></a>             *   matches the main noun phrase.  For example, the player
<a name="5538"></a>             *   entered BOB'S WALLET, and Bob is indeed in scope, but Bob
<a name="5539"></a>             *   doesn't own a wallet (not one that's in scope, anyway).  
<a name="5540"></a>             */
<a name="5541"></a>            local obj = possQual.matches[1].obj;
<a name="5542"></a>            gMessageParams(obj);
<a name="5543"></a>            
<a name="5544"></a>            DMsg(none in owner, '{The subj obj} {doesn\'t appear[ed]} to have
<a name="5545"></a>                any {2}.',  cmd,  txt);
<a name="5546"></a>                      
<a name="5547"></a>        }
<a name="5548"></a>    }    
<a name="5549"></a>    
<a name="5550"></a>;
<a name="5551"></a>
<a name="5552"></a>/*
<a name="5553"></a> *   The location in a locational qualifier doesn't contain any of the
<a name="5554"></a> *   objects named. 
<a name="5555"></a> */
<a name="5556"></a>class NoneInLocationError: ActorResolutionError
<a name="5557"></a>    construct(cmd, np, loc)
<a name="5558"></a>    {
<a name="5559"></a>        inherited(cmd, np);
<a name="5560"></a>        locQual = loc;
<a name="5561"></a>    }
<a name="5562"></a>
<a name="5563"></a>    /* the locational qualifier */
<a name="5564"></a>    locQual = nil
<a name="5565"></a>    
<a name="5566"></a>    display()
<a name="5567"></a>    {
<a name="5568"></a>        /* 
<a name="5569"></a>         *   if we have other than one possible location, show the original
<a name="5570"></a>         *   text of the locational phrase, since we can't be sure which
<a name="5571"></a>         *   matched object was intended; otherwise show the name of the
<a name="5572"></a>         *   actual location we matched 
<a name="5573"></a>         */
<a name="5574"></a>        if (locQual.matches.length() !=  1)
<a name="5575"></a>        {
<a name="5576"></a>            /*
<a name="5577"></a>             *   We have a locational qualifier, and we have multiple
<a name="5578"></a>             *   objects that match the location, but there's nothing in
<a name="5579"></a>             *   scope that matches the main noun phrase that's in any of
<a name="5580"></a>             *   those locations.  For example, the player typed THE BOX ON
<a name="5581"></a>             *   THE TABLE, and we have two tables in scope, but there's no
<a name="5582"></a>             *   box in scope that's on either of them.  
<a name="5583"></a>             */
<a name="5584"></a>            DMsg(none in locations,
<a name="5585"></a>                 '{I} {see} no {2} {3} any {4}.',
<a name="5586"></a>                 cmd, txt, locQual.locType.prep, locQual.prod.getText());
<a name="5587"></a>        }
<a name="5588"></a>        else
<a name="5589"></a>        {
<a name="5590"></a>            /*
<a name="5591"></a>             *   We have a locational qualifier, and we have exactly one
<a name="5592"></a>             *   object that matches the location, but there's nothing in
<a name="5593"></a>             *   scope that matches the main noun phrase that's in that
<a name="5594"></a>             *   location.  For example, the player typed THE BOX ON THE
<a name="5595"></a>             *   TABLE, and we have a table in scope, but there's no box on
<a name="5596"></a>             *   it. 
<a name="5597"></a>             */
<a name="5598"></a>            DMsg(none in location,
<a name="5599"></a>                 '{I} {see} no {2} {3} {the 4}.',
<a name="5600"></a>                 cmd, txt, locQual.locType.prep, locQual.matches[1].obj);
<a name="5601"></a>        }
<a name="5602"></a>    }
<a name="5603"></a>;
<a name="5604"></a>
<a name="5605"></a>/*
<a name="5606"></a> *   There are no objects matching this noun phrase name that have the
<a name="5607"></a> *   contents mentioned in the contents qualifier. 
<a name="5608"></a> */
<a name="5609"></a>class NoneWithContentsError: ActorResolutionError
<a name="5610"></a>    construct(cmd, np, cont)
<a name="5611"></a>    {
<a name="5612"></a>        inherited(cmd, np);
<a name="5613"></a>        contQual = cont;
<a name="5614"></a>    }
<a name="5615"></a>
<a name="5616"></a>    /* the contents qualifier */
<a name="5617"></a>    contQual = nil
<a name="5618"></a>
<a name="5619"></a>    display()
<a name="5620"></a>    {
<a name="5621"></a>        /* 
<a name="5622"></a>         *   if we have other than one possible contents object, show the
<a name="5623"></a>         *   original text of the contents phrase, since we can't be sure
<a name="5624"></a>         *   which matched object was intended; otherwise show the name of
<a name="5625"></a>         *   the object we matched 
<a name="5626"></a>         */
<a name="5627"></a>        if (contQual.matches.length() != 1)
<a name="5628"></a>        {
<a name="5629"></a>            /*
<a name="5630"></a>             *   We have a contents qualifier, and we have multiple objects
<a name="5631"></a>             *   in scope that match the contents phrase, but there's
<a name="5632"></a>             *   nothing in scope that matches the main noun phrase that
<a name="5633"></a>             *   actually contains any of the contents objects.  For
<a name="5634"></a>             *   example, the player typed THE BUCKET OF WATER, and we do
<a name="5635"></a>             *   have multiple "water" objects present, but none of them
<a name="5636"></a>             *   are inside buckets that are in scope.  
<a name="5637"></a>             */
<a name="5638"></a>            DMsg(none with contents in list,
<a name="5639"></a>                 '{I} {see} no {2} of {3}.',
<a name="5640"></a>                 cmd, txt, contQual.prod.getText());
<a name="5641"></a>        }
<a name="5642"></a>        else
<a name="5643"></a>        {
<a name="5644"></a>            /*
<a name="5645"></a>             *   We have a contents qualifier, and we have exactly one
<a name="5646"></a>             *   object in scope that matches the contents phrase, but
<a name="5647"></a>             *   there's nothing in scope that matches the main noun phrase
<a name="5648"></a>             *   that actually contains that object.  For example, the
<a name="5649"></a>             *   player typed THE BUCKET OF WATER, and we do have a "water"
<a name="5650"></a>             *   object present, but it's not inside anything called a
<a name="5651"></a>             *   bucket (not one that's in scope, anyway).  
<a name="5652"></a>             */
<a name="5653"></a>            DMsg(none with contents,
<a name="5654"></a>                 '{I} {see} no {2} of {3}.',
<a name="5655"></a>                 cmd, txt, contQual.matches[1].obj);
<a name="5656"></a>        }
<a name="5657"></a>    }
<a name="5658"></a>;
<a name="5659"></a>
<a name="5660"></a>/*
<a name="5661"></a> *   A noun phrase is ambiguous, so we'll have to ask for clarification.
<a name="5662"></a> */
<a name="5663"></a>class AmbiguousError: ResolutionError
<a name="5664"></a>    construct(cmd, np, names)
<a name="5665"></a>    {
<a name="5666"></a>        inherited(np);
<a name="5667"></a>        self.cmd = cmd;
<a name="5668"></a>        self.nameList = names;
<a name="5669"></a>    }
<a name="5670"></a>
<a name="5671"></a>    display()
<a name="5672"></a>    {
<a name="5673"></a>        /* ask the language-specific ambiguous noun question */
<a name="5674"></a>        askAmbiguous(cmd, np.role, nameList.mapAll({ n: n[1] }));     
<a name="5675"></a>        
<a name="5676"></a>    }
<a name="5677"></a>
<a name="5678"></a>    /* 
<a name="5679"></a>     *   Accept spelling corrections that trigger an ambiguous noun error.
<a name="5680"></a>     *   If we find an ambiguous noun it means that we have valid overall
<a name="5681"></a>     *   verb syntax *and* we have noun phrases that match in-scope objects
<a name="5682"></a>     *   - in fact, they match too many objects.  This is pretty good
<a name="5683"></a>     *   evidence that the respelling is valid.  
<a name="5684"></a>     */
<a name="5685"></a>    allowOnRespell = true
<a name="5686"></a>
<a name="5687"></a>
<a name="5688"></a>    /* 
<a name="5689"></a>     *   this is a curable error, since the player can fix the problem by
<a name="5690"></a>     *   answering the disambiguation question 
<a name="5691"></a>     */
<a name="5692"></a>    curable = true
<a name="5693"></a>
<a name="5694"></a>    /* 
<a name="5695"></a>     *   Try curing the error.  After an ambiguous noun error, the player
<a name="5696"></a>     *   can type a partial noun phrase that clarifies which object was
<a name="5697"></a>     *   intended: a distinguishing adjective, a locational phrase, a
<a name="5698"></a>     *   possessive, etc. 
<a name="5699"></a>     */
<a name="5700"></a>    tryCuring(toks, dict)
<a name="5701"></a>    {
<a name="5702"></a>        /* try parsing against the main disambiguation grammar */
<a name="5703"></a>        local lst = new CommandList(
<a name="5704"></a>            mainDisambigPhrase, toks, dict,
<a name="5705"></a>            new function(prod)
<a name="5706"></a>            {
<a name="5707"></a>                /* create a new copy of the Command to apply the change to */
<a name="5708"></a>                local newCmd = cmd.clone();
<a name="5709"></a>
<a name="5710"></a>                /* add the reply to the new command */
<a name="5711"></a>                local dnp = newCmd.startDisambigReply(np, prod);
<a name="5712"></a>
<a name="5713"></a>                /* build the reply tree */
<a name="5714"></a>                prod.build(newCmd, dnp);
<a name="5715"></a>
<a name="5716"></a>                /* the mapping is the new command */
<a name="5717"></a>                return newCmd;
<a name="5718"></a>            });
<a name="5719"></a>
<a name="5720"></a>        /* accept curable errors in the reply */
<a name="5721"></a>        lst.acceptCurable();
<a name="5722"></a>
<a name="5723"></a>        /* return the list */
<a name="5724"></a>        return lst;
<a name="5725"></a>    }
<a name="5726"></a>
<a name="5727"></a>    /* the original Command that we were trying to resolve */
<a name="5728"></a>    cmd = nil
<a name="5729"></a>
<a name="5730"></a>    /* 
<a name="5731"></a>     *   The list of object names, with distinguisher information.  This is
<a name="5732"></a>     *   the same information returned from Distinguisher.getNames(). 
<a name="5733"></a>     */
<a name="5734"></a>    nameList = []
<a name="5735"></a>;
<a name="5736"></a>
<a name="5737"></a>class AmbiguousMultiDefiniteError: UnmatchedNounError
<a name="5738"></a>    display()
<a name="5739"></a>    {
<a name="5740"></a>        DMsg(be more specific, 'I don\'t know which ones you mean.  
<a name="5741"></a>            Can you be more specific?');
<a name="5742"></a>    }
<a name="5743"></a>
<a name="5744"></a>    /* 
<a name="5745"></a>     *   this is not really curable, but we need to say it is curable so that
<a name="5746"></a>     *   our custom message is displayed.  Would like to find a way to do this
<a name="5747"></a>     *   where curable=nil
<a name="5748"></a>     */
<a name="5749"></a>    curable = true
<a name="5750"></a>;
<a name="5751"></a>
<a name="5752"></a>
<a name="5753"></a>/*
<a name="5754"></a> *   Ordinal out of range.  This occurs when the player replies to a
<a name="5755"></a> *   disambiguation query with an ordinal that's out of the bounds of the
<a name="5756"></a> *   offered list. 
<a name="5757"></a> */
<a name="5758"></a>class OrdinalRangeError: ResolutionError
<a name="5759"></a>    construct(np, ordinal)
<a name="5760"></a>    {
<a name="5761"></a>        inherited(np);
<a name="5762"></a>        self.ordinal = ordinal;
<a name="5763"></a>    }
<a name="5764"></a>
<a name="5765"></a>    display()
<a name="5766"></a>    {
<a name="5767"></a>        /*
<a name="5768"></a>         *   An ordinal reply to a disambiguation question is out of range.
<a name="5769"></a>         *   For example, we asked "Which do you mean, the red book or the
<a name="5770"></a>         *   blue book?", and the player answered THE THIRD ONE.  There are
<a name="5771"></a>         *   only two options, so THIRD is out of range.  
<a name="5772"></a>         */
<a name="5773"></a>        DMsg(ordinal out of range,
<a name="5774"></a>             'Sorry, I don\'t see what you\'re referring to.');
<a name="5775"></a>    }
<a name="5776"></a>
<a name="5777"></a>    /* the ordinal, as an integer value (1=first, 2=second, etc) */
<a name="5778"></a>    ordinal = nil
<a name="5779"></a>;
<a name="5780"></a>
<a name="5781"></a>class BadMultiError: ParseError
<a name="5782"></a>    display() 
<a name="5783"></a>    { 
<a name="5784"></a>        DMsg(multi not allowed, 'Sorry; multiple objects aren\'t allowed with
<a name="5785"></a>            that command.'); 
<a name="5786"></a>    }
<a name="5787"></a>;
<a name="5788"></a>
<a name="5789"></a>/* ------------------------------------------------------------------------ */
<a name="5790"></a>/*
<a name="5791"></a> *   A placeholder object for dictionary entries.  The Dictionary class
<a name="5792"></a> *   stores a three-way association: word string, part-of-speech property,
<a name="5793"></a> *   and object.  The object association is designed to allow the parser to
<a name="5794"></a> *   come up with a list of objects that could match a given word, but the
<a name="5795"></a> *   adv3L library doesn't use this feature.  We instead figure out the
<a name="5796"></a> *   word-to-object association by directly asking the objects in scope if
<a name="5797"></a> *   they're associated with a word.  We still need *something* to store as
<a name="5798"></a> *   the object association for each word entry in the dictionary, though.
<a name="5799"></a> *   That's where this object comes in: it's a dummy object that serves as
<a name="5800"></a> *   the required object to associate with each word.
<a name="5801"></a> *   
<a name="5802"></a> *   A language module can ignore this and use the word-object-property
<a name="5803"></a> *   association feature of the dictionary, if desired.
<a name="5804"></a> */
<a name="5805"></a>dictionaryPlaceholder: object
<a name="5806"></a>;
<a name="5807"></a>
<a name="5808"></a>
<a name="5809"></a>
<a name="5810"></a>/* Exception thrown by exit macro */
<a name="5811"></a>class ExitSignal: Exception
<a name="5812"></a>;
<a name="5813"></a>
<a name="5814"></a>/* Exception thrown by abortImplicit macro */
<a name="5815"></a>class AbortImplicitSignal: Exception
<a name="5816"></a>;
<a name="5817"></a>
<a name="5818"></a>/* Exception thrown by abort macro */
<a name="5819"></a>class AbortActionSignal: Exception
<a name="5820"></a>;
<a name="5821"></a>
<a name="5822"></a>/* Exception thrown by exitAction macro */
<a name="5823"></a>class ExitActionSignal: Exception  
<a name="5824"></a>;
<a name="5825"></a>
<a name="5826"></a>/* Exception thrown to terminate a command. */
<a name="5827"></a>class TerminateCommandException: Exception
<a name="5828"></a>;
<a name="5829"></a>
<a name="5830"></a>
<a name="5831"></a>/* 
<a name="5832"></a> *   A SpecialVerb allows us to define grammar for verbs applying to only a handful of objects in
<a name="5833"></a> *   our game, where we want the rarely used command to be translated into a common one, e.g. RIMG
<a name="5834"></a> *   BELL -&gt; PUSH BELL, which we could implement as:
<a name="5835"></a> *
<a name="5836"></a> *.  SpecialVerb 'ring' 'push' @doorbell
<a name="5837"></a> */
<a name="5838"></a>class SpecialVerb: object
<a name="5839"></a>    /* 
<a name="5840"></a>     *   The word or words this SpecialVerb should match, e.g. 'ring'. Different forms can be listed
<a name="5841"></a>     *   separated by a vertical bar, e.g. 'cross|go across|walk across'
<a name="5842"></a>     */
<a name="5843"></a>    specVerb = ''
<a name="5844"></a>    
<a name="5845"></a>    /* 
<a name="5846"></a>     *   The verb words needed to trigger the action we want this SpecialVerb to perform, e.g.
<a name="5847"></a>     *   'push' or 'go through'
<a name="5848"></a>     */
<a name="5849"></a>    stdVerb = ''
<a name="5850"></a>    
<a name="5851"></a>    /* 
<a name="5852"></a>     *   The object ot objects we want this SpecialVerb to apply to. This can be a single object or
<a name="5853"></a>     *   class or list of objecta and/or classes, but it should result only in a small number of
<a name="5854"></a>     *   matches.
<a name="5855"></a>     */
<a name="5856"></a>    matchObjs = nil
<a name="5857"></a>    
<a name="5858"></a>    /* 
<a name="5859"></a>     *   A Room, Region or list of Rooms and/or Regions where this SpecialVerb is applicable. Note
<a name="5860"></a>     *   we'd very rarely need to specficy this since SpecialVerb already makes scope checks.
<a name="5861"></a>     */
<a name="5862"></a>    where = nil
<a name="5863"></a>    
<a name="5864"></a>    /*  A Scene or list of Scenes that must be happening for this SpecialVerb to apply. */
<a name="5865"></a>    during = nil
<a name="5866"></a>    
<a name="5867"></a>    /*  
<a name="5868"></a>     *   A condition that must be true for this SpecialVerb to apply. This cannot refer to the
<a name="5869"></a>     *   objects involved in the command (e.g. dobj or iobj) since these won't be known the first
<a name="5870"></a>     *   time the when condition is tested. For conditions involving the dobj, iobj, or aobj of a
<a name="5871"></a>     *   the current command, use objCheck() instead.
<a name="5872"></a>     */     
<a name="5873"></a>    when = true
<a name="5874"></a>
<a name="5875"></a>    /* 
<a name="5876"></a>     *   A check that can be applied once the objects involved in the command are known, (e.g. to
<a name="5877"></a>     *   check whether dobj.isOpen). The method can return nil to reject the command at this stage,
<a name="5878"></a>     *   or else display a message to explain why it can't go ahead and then use abort to stop it.
<a name="5879"></a>     *   It's unlikely that this will be needed often.
<a name="5880"></a>     */
<a name="5881"></a>    objChecks(dobj, iobj, aobj)
<a name="5882"></a>    {
<a name="5883"></a>        return true;
<a name="5884"></a>    }
<a name="5885"></a>    
<a name="5886"></a>    /* 
<a name="5887"></a>     *   The priority we want to assign this SpecialVerb if the library needs to break a tie between
<a name="5888"></a>     *   two or more SpecialVerbs that might otherwise be matched after all other conditions have
<a name="5889"></a>     *   been applied. The default is 100. Other things being equal, the SpecialVerb with the
<a name="5890"></a>     *   higher/highest priority will be matched.
<a name="5891"></a>     */
<a name="5892"></a>    priority = 100
<a name="5893"></a>    
<a name="5894"></a>    /* 
<a name="5895"></a>     *   Our best guess at the direct object of the command this SpecialVerb will match before the
<a name="5896"></a>     *   objects of the command have been fully resolved.
<a name="5897"></a>     */
<a name="5898"></a>    tentativeDobj = nil
<a name="5899"></a>    
<a name="5900"></a>    /* 
<a name="5901"></a>     *   A list of the possible tentative direct objects of the command this SpecialVerb eill match
<a name="5902"></a>     *   before the objecs of the command have been fully resolved. This will be all the objects in
<a name="5903"></a>     *   scope that match our matchObjs property and the noun phrase the player apparently entered.
<a name="5904"></a>     */
<a name="5905"></a>    tentativeDobjList = []
<a name="5906"></a>    
<a name="5907"></a>    
<a name="5908"></a>    /* The verb phrase that's been matched to invoke this SpecialVerb. */
<a name="5909"></a>    verbPhrase = (specialVerbMgr.vWords.join())
<a name="5910"></a>    
<a name="5911"></a>    /* The remaining methods and properties of SpecialVerb are for internal library use. */
<a name="5912"></a>
<a name="5913"></a>    /* 
<a name="5914"></a>     *   This method is called once the command has been resolved and we kmow the objects involved
<a name="5915"></a>     *   in it. lst is a list containing the action followed by the objects involved in the action,
<a name="5916"></a>     *   e.g. [action, dobj]. svPhrase is the special verb phrase that's been translated into
<a name="5917"></a>     *   another action, e.g. 'ring' or 'walk across'
<a name="5918"></a>     */     
<a name="5919"></a>    checkSV(lst, svPhrase)
<a name="5920"></a>    {
<a name="5921"></a>        /* The direct object of the command, which is the second element of lst. */
<a name="5922"></a>        obj = lst.element(2);
<a name="5923"></a>        
<a name="5924"></a>        /* 
<a name="5925"></a>         *   If the direct object of the command does not not match any of the objects/classes
<a name="5926"></a>         *   listed in out matchObjs property, we fail the action at this stage.
<a name="5927"></a>         */
<a name="5928"></a>        if(!matchObjs.indexWhich({x:obj.ofKind(x)}))
<a name="5929"></a>           failCheck(svPhrase);
<a name="5930"></a>        
<a name="5931"></a>        /* Carry out the custom checks based on our where, when and during properties. */
<a name="5932"></a>        customChecks(lst);
<a name="5933"></a>    }
<a name="5934"></a>    
<a name="5935"></a>    /* 
<a name="5936"></a>     *   Display a messsage saying the command can't proceed and then stop it in its tracks.
<a name="5937"></a>     *   svPhrase is the command we matched, e.g. 'ring' or 'walk over'.
<a name="5938"></a>     */
<a name="5939"></a>    failCheck(svPhrase)
<a name="5940"></a>    {
<a name="5941"></a>        /* Display the failure message. */
<a name="5942"></a>        showFailureMsg(svPhrase);
<a name="5943"></a>        
<a name="5944"></a>        /* Abort the command. */
<a name="5945"></a>        abort;
<a name="5946"></a>    }
<a name="5947"></a>    
<a name="5948"></a>    /* Display our failure message. By default this is "You can't &lt;&lt;svPhrase&gt;&gt; that. */
<a name="5949"></a>    showFailureMsg(svPhrase)
<a name="5950"></a>    {
<a name="5951"></a>        DMsg(cant do that special, '{I} {can\'t} &lt;&lt;svPhrase&gt;&gt; {that dobj}. ');
<a name="5952"></a>    }
<a name="5953"></a>    
<a name="5954"></a>    /* Initialise (in fact preinitialize) this SpecialVerb */
<a name="5955"></a>    initSpec()
<a name="5956"></a>    {
<a name="5957"></a>        /* Make sure our matchObjs property contains a list. */
<a name="5958"></a>        matchObjs = valToList(matchObjs);
<a name="5959"></a>        
<a name="5960"></a>        /* 
<a name="5961"></a>         *   Ensure that specVerb is in lower case so that we can compare it with player input
<a name="5962"></a>         *   converted to lower case.
<a name="5963"></a>         */
<a name="5964"></a>        specVerb = specVerb.toLower();
<a name="5965"></a>        
<a name="5966"></a>        /* 
<a name="5967"></a>         *   Split our special verbs into a list, in case we have different options separated by a
<a name="5968"></a>         *   vertical bar.
<a name="5969"></a>         */
<a name="5970"></a>        local specVerbs = specVerb.split('|');
<a name="5971"></a>        
<a name="5972"></a>        /* 
<a name="5973"></a>         *   Then interate through every element in our special verb variants to add them to the
<a name="5974"></a>         *   special verbs Lookup table.
<a name="5975"></a>         */
<a name="5976"></a>        foreach(local s in specVerbs)
<a name="5977"></a>        {    
<a name="5978"></a>            /* 
<a name="5979"></a>             *   Split the grammar in variant s into a list of separate words, e.g. 'walk over' -&gt;
<a name="5980"></a>             *   ['walk', 'over']
<a name="5981"></a>             */
<a name="5982"></a>            local sWords = s.split(' ');
<a name="5983"></a>            
<a name="5984"></a>            /* Add this SpeciaVerb to the special verb table with sWords as the key/ */
<a name="5985"></a>            specialVerbMgr.addToTable(sWords, self); 
<a name="5986"></a>            
<a name="5987"></a>            /* 
<a name="5988"></a>             *   If the number of words in this variant is greater than the number of words
<a name="5989"></a>             *   encountered in any previous SpecialVerb that's been initialized, update the maximum
<a name="5990"></a>             *   length stored on specialVerbManager. We do this so SpecialVerbManager knows the
<a name="5991"></a>             *   maximum number of words it needs to look for when trying to match keys in its
<a name="5992"></a>             *   table.
<a name="5993"></a>             */             
<a name="5994"></a>            if(sWords.length &gt; specialVerbMgr.maxKeyLen)
<a name="5995"></a>                specialVerbMgr.maxKeyLen = sWords.length;
<a name="5996"></a>        }       
<a name="5997"></a>    }
<a name="5998"></a>    
<a name="5999"></a>    /* Check whether this SpecialVerb matches its conditions. */
<a name="6000"></a>    matches(scope_, toks)
<a name="6001"></a>    {       
<a name="6002"></a>        /* 
<a name="6003"></a>         *   Start calculating our score for this match by making it our priority plus the result of
<a name="6004"></a>         *   looking for mactching objects in scope.
<a name="6005"></a>         */        
<a name="6006"></a>        score = priority + vocabCheck(scope_, toks);
<a name="6007"></a>        
<a name="6008"></a>        /* Then carry out the custom checks, which may further adjuest our score */
<a name="6009"></a>        return customChecks();
<a name="6010"></a>    }
<a name="6011"></a> 
<a name="6012"></a>    
<a name="6013"></a>    /* 
<a name="6014"></a>     *   Check how well any objects in soope that match our matchObjs also match the noun phrase we
<a name="6015"></a>     *   think the player entered.
<a name="6016"></a>     */
<a name="6017"></a>    vocabCheck(scope_, toks)
<a name="6018"></a>    {
<a name="6019"></a>        /* Cache a list of all the objects in scope for the current command. */
<a name="6020"></a>        scope_ = scope_.toList();
<a name="6021"></a>        
<a name="6022"></a>        /* Our verb phrase length is the number of words in specialVerbMgr's vWords list. */
<a name="6023"></a>        local vPhraseLen = specialVerbMgr.vWords.length();
<a name="6024"></a>        
<a name="6025"></a>        /* 
<a name="6026"></a>         *   The tokens that come after the verb phrase tokens potentially constitute our noun
<a name="6027"></a>         *   phrase tokens, which is what we'll want to match.
<a name="6028"></a>         */
<a name="6029"></a>        local nPhraseToks = toks.sublist(vPhraseLen + 1);
<a name="6030"></a>        
<a name="6031"></a>        /* 
<a name="6032"></a>         *   Check for a preposition in the noun phrase; this may mark the end of the noun phrase
<a name="6033"></a>         *   proper.
<a name="6034"></a>         */
<a name="6035"></a>        local prepTokPos = nPhraseToks.indexWhich({x: prepositions.find(x)});
<a name="6036"></a>        
<a name="6037"></a>        /*  
<a name="6038"></a>         *   If we found a preposition, truncate our nounPhrase tokan list to end just before the
<a name="6039"></a>         *   preposition.
<a name="6040"></a>         */
<a name="6041"></a>        if(prepTokPos)
<a name="6042"></a>            nPhraseToks = nPhraseToks.sublist(1, prepTokPos - 1);
<a name="6043"></a>        
<a name="6044"></a>        /* Remove any articles from the noun phrase before attempting to match. */        
<a name="6045"></a>        nPhraseToks = nPhraseToks.subset({x: articles.find(x) == nil});
<a name="6046"></a>        
<a name="6047"></a>        /* Make a note of whether we found a potentially suitable object in scope. */
<a name="6048"></a>        local scopeMatch = nil;
<a name="6049"></a>        
<a name="6050"></a>        /* 
<a name="6051"></a>         *   We'll keep a note of the best match score from the ojects in scope that match our
<a name="6052"></a>         *   matchObjs.
<a name="6053"></a>         */
<a name="6054"></a>        local bestScore = 0;
<a name="6055"></a>        
<a name="6056"></a>        /* reset our tentativeDobj and tentativeDobjList */
<a name="6057"></a>        tentativeDobj = nil;
<a name="6058"></a>        tentativeDobjList = [];
<a name="6059"></a>        
<a name="6060"></a>        /* loop through every object in scope to find a match */
<a name="6061"></a>        foreach(local obj in matchObjs)
<a name="6062"></a>        {            
<a name="6063"></a>            /* We're looking for objects in scope that match one of our matchObjs */
<a name="6064"></a>            if(scope_.indexWhich({x: x.ofKind(obj)}))
<a name="6065"></a>            {
<a name="6066"></a>                /* Note that we have at least found a potential match in scope */
<a name="6067"></a>                scopeMatch = true;
<a name="6068"></a>                
<a name="6069"></a>                /* Obtain the vocab match score for the current obj. */
<a name="6070"></a>                local mScore = obj.matchName(nPhraseToks);
<a name="6071"></a>                
<a name="6072"></a>                if(mScore)
<a name="6073"></a>                {
<a name="6074"></a>                    /* If we have match, add obj to our list of tentative direct objects */
<a name="6075"></a>                    tentativeDobjList += obj;
<a name="6076"></a>                    
<a name="6077"></a>                    /* 
<a name="6078"></a>                     *   If our match score is grreater than any we've found up to now, update the
<a name="6079"></a>                     *   bestScore to that match score and make obj our tentativeDobj.
<a name="6080"></a>                     */
<a name="6081"></a>                    if(mScore &gt; bestScore)
<a name="6082"></a>                    {
<a name="6083"></a>                        bestScore = mScore;
<a name="6084"></a>                        
<a name="6085"></a>                        tentativeDobj = obj;
<a name="6086"></a>                    }
<a name="6087"></a>                }
<a name="6088"></a>            }
<a name="6089"></a>        }
<a name="6090"></a>            
<a name="6091"></a>        /* 
<a name="6092"></a>         *   If we haven't even found a suitable object in scope, return -500000 to note that we're
<a name="6093"></a>         *   a poor candidate for the best matching SpecialVerb; otherwise return 100 times out best
<a name="6094"></a>         *   vocab match score so that specialVerbMgr can prioritize the VerbRule that bests matches
<a name="6095"></a>         *   a suitable object in scope.
<a name="6096"></a>         */
<a name="6097"></a>        return scopeMatch ? (bestScore * 100) : -500000;           
<a name="6098"></a>    }
<a name="6099"></a>    
<a name="6100"></a>    /* 
<a name="6101"></a>     *   This method is called twice, first when the specialVerbMgr is seeking the best SpecialVerb
<a name="6102"></a>     *   option to match, and the second once the objects of the revised command have been
<a name="6103"></a>     *   identified and the command is about to be executed. The first time round the lst parameter
<a name="6104"></a>     *   won't be supplied (so will be effectively nil); the second time it will be a list
<a name="6105"></a>     *   containing the action and its objects. The customChecks() method uses this simply to
<a name="6106"></a>     *   determine at which stage its being invoked. The first time its being asked to adjust the
<a name="6107"></a>     *   match score; the second time its being asked to check whether or not the proposeed action
<a name="6108"></a>     *   should be allowed to proceed.
<a name="6109"></a>     */
<a name="6110"></a>    customChecks(lst?)
<a name="6111"></a>    {
<a name="6112"></a>        /* 
<a name="6113"></a>         *   If the Scenes module is present and our during property has been designed check whether
<a name="6114"></a>         *   one of the scenes in our suring list is currently happening.
<a name="6115"></a>         */
<a name="6116"></a>        if(defined(sceneManager) &amp;&amp; during &amp;&amp; !(valToList(during).indexWhich({x: x.isHappening})))
<a name="6117"></a>        {
<a name="6118"></a>            /* 
<a name="6119"></a>             *   If not, return nil on the second invocation and deduct 100000 from our score on the
<a name="6120"></a>             *   first.
<a name="6121"></a>             */
<a name="6122"></a>            if(lst)
<a name="6123"></a>                return nil;
<a name="6124"></a>            else
<a name="6125"></a>                score -= 100000;
<a name="6126"></a>        }
<a name="6127"></a>        
<a name="6128"></a>        /* 
<a name="6129"></a>         *   Check whether the actor is located in one of the rooms or regions in our where list, if
<a name="6130"></a>         *   the where list has been defined.
<a name="6131"></a>         */
<a name="6132"></a>        if(where &amp;&amp; !valToList(where).indexOf(gActorRoom))
<a name="6133"></a>            /* 
<a name="6134"></a>             *   If not, return nil on the second invocation and deduct 100000 from our score on the
<a name="6135"></a>             *   first.
<a name="6136"></a>             */
<a name="6137"></a>        {
<a name="6138"></a>            if(lst)
<a name="6139"></a>                return nil;
<a name="6140"></a>            else
<a name="6141"></a>                score -= 100000;
<a name="6142"></a>        }
<a name="6143"></a>        
<a name="6144"></a>        /* Check whether our when condition has been met. */
<a name="6145"></a>        if(!when)
<a name="6146"></a>        {
<a name="6147"></a>            /* 
<a name="6148"></a>             *   If not, return nil on the second invocation and deduct 100000 from our score on the
<a name="6149"></a>             *   first.
<a name="6150"></a>             */
<a name="6151"></a>            if(lst)
<a name="6152"></a>                return nil;
<a name="6153"></a>            else
<a name="6154"></a>                score -= 100000;       
<a name="6155"></a>        }
<a name="6156"></a>        
<a name="6157"></a>        /* 
<a name="6158"></a>         *   On the second invocation, return the value of objAfterChecks(lst); on the first simply
<a name="6159"></a>         *   return true.
<a name="6160"></a>         */
<a name="6161"></a>        return lst ? objAfterChecks(lst) : true;
<a name="6162"></a>    }
<a name="6163"></a>        
<a name="6164"></a>    /* Checks involving the objects of the commmand, once we know them */
<a name="6165"></a>    objAfterChecks(lst)
<a name="6166"></a>    {
<a name="6167"></a>        /* 
<a name="6168"></a>         *   Call objChecks with the second, third, and fourth elements of lst as arguments; these
<a name="6169"></a>         *   correspond to the dobj, iobj and aobj of the command. Note that the element(i) method
<a name="6170"></a>         *   simply returns nil if i is greater than the length of lst.
<a name="6171"></a>         */
<a name="6172"></a>        return objChecks(lst.element(2), lst.element(3), lst.element(4));
<a name="6173"></a>    }
<a name="6174"></a>        
<a name="6175"></a>    /* Our adjusted priority after attempting a match. */
<a name="6176"></a>    score = 0
<a name="6177"></a> 
<a name="6178"></a>    /* Verb phrases we want to exclude from matching, e.g. 'pick up' if our specVerb is 'pick' */
<a name="6179"></a>    exclusions = []
<a name="6180"></a>    
<a name="6181"></a>    /* Check whether the command entered by the player matches an item in our exclusions list. */
<a name="6182"></a>    matchExclusions(tokWords)
<a name="6183"></a>    {
<a name="6184"></a>        
<a name="6185"></a>        /* Iterate over our list of exclusions to see if any match */
<a name="6186"></a>        foreach(local ex in exclusions)
<a name="6187"></a>        {
<a name="6188"></a>            /* Split the current exclusion into a list of words */
<a name="6189"></a>            local excWords = ex.split(' ');
<a name="6190"></a>            
<a name="6191"></a>            /* Start by assuming we'll find a match */
<a name="6192"></a>            local matched = true;
<a name="6193"></a>           
<a name="6194"></a>            /* Iterate through the words in our excWords list. */
<a name="6195"></a>            for(local i in 1..excWords.length)
<a name="6196"></a>            {
<a name="6197"></a>                /* 
<a name="6198"></a>                 *   If we've run out of words in our tokwords list or we find a word in one list
<a name="6199"></a>                 *   that differs from the corresponding word in the other list, then we don't
<a name="6200"></a>                 *   match, so we can note that the match has failed and stop comparing the two
<a name="6201"></a>                 *   lists.
<a name="6202"></a>                 */               
<a name="6203"></a>                if(i &gt; tokWords.length() || tokWords[i] != excWords[i])
<a name="6204"></a>                {
<a name="6205"></a>                    matched = nil; 
<a name="6206"></a>                    break;                }
<a name="6207"></a>                
<a name="6208"></a>            }
<a name="6209"></a>            
<a name="6210"></a>            /* 
<a name="6211"></a>             *   If we didn't find a mismatch, then what the player entered matched our exclusions
<a name="6212"></a>             *   list, so we've found a match and can return true.
<a name="6213"></a>             */
<a name="6214"></a>            if(matched)
<a name="6215"></a>                return true;
<a name="6216"></a>        }
<a name="6217"></a>        
<a name="6218"></a>        /* 
<a name="6219"></a>         *   If we reach here then none of our exclusions match the player's input, so we return
<a name="6220"></a>         *   nil.
<a name="6221"></a>         */
<a name="6222"></a>        return nil;
<a name="6223"></a>    }
<a name="6224"></a>;
<a name="6225"></a>
<a name="6226"></a>
<a name="6227"></a>/* 
<a name="6228"></a> *   The specialVerbMgr carries out various tasks needed for working with SpecialVerbs. In
<a name="6229"></a> *   particular it preinitializes SpecialVerbs to add them to its LookupTable, and is responsible
<a name="6230"></a> *   for matching SpecialVerbs to player input and translating and checking actions appropriately.
<a name="6231"></a> *   Its methods and properties are entirely intended for internal use by the library and shouldn't
<a name="6232"></a> *   normally be invoked or changed in user game code.
<a name="6233"></a> */
<a name="6234"></a>specialVerbMgr: PreinitObject
<a name="6235"></a>    findMatchingSV(toks)
<a name="6236"></a>    {
<a name="6237"></a>        /* Get a list of words in toks list */         
<a name="6238"></a>        local tokWords = toks.mapAll({t: t[1].toLower}); 
<a name="6239"></a>        
<a name="6240"></a>        /* Set up a variable to hold the list of SpecialVerbs we'll match. */
<a name="6241"></a>        local specs = nil; // new
<a name="6242"></a>        
<a name="6243"></a>        /* 
<a name="6244"></a>         *   Work down from the maximum key length (in terms of the number of words it contains) to
<a name="6245"></a>         *   1, so that a shorter key doesn't mask a longer one.
<a name="6246"></a>         */
<a name="6247"></a>        for(local klen in maxKeyLen .. 1 step -1)
<a name="6248"></a>        {
<a name="6249"></a>            /* Then key we're looking to match is the first klen elements of our tokWords list. */
<a name="6250"></a>            local ky = tokWords.sublist(1, klen);
<a name="6251"></a>            
<a name="6252"></a>            /* Obtain the SpecialVerbs that match that key. */
<a name="6253"></a>            specs = specTable[ky];
<a name="6254"></a>            
<a name="6255"></a>            /* Exclude any SpecialVerbs whose exclusion property matches our tokWords. */
<a name="6256"></a>            specs = valToList(specs).subset({x: !x.matchExclusions(tokWords)});
<a name="6257"></a>            
<a name="6258"></a>            /* 
<a name="6259"></a>             *   If we find any, store the key in our vWords property (the words in the player input
<a name="6260"></a>             *   we're just matching) and break out of the loop, since we won't need to keep
<a name="6261"></a>             *   looking.
<a name="6262"></a>             */
<a name="6263"></a>            if(valToList(specs).length &gt; 0)
<a name="6264"></a>            {
<a name="6265"></a>                vWords = ky;
<a name="6266"></a>                break;
<a name="6267"></a>            }
<a name="6268"></a>        }
<a name="6269"></a>        
<a name="6270"></a>        /* If we don't find any we're done. */
<a name="6271"></a>        if(specs == nil || specs.length == 0)
<a name="6272"></a>            return nil;        
<a name="6273"></a>        
<a name="6274"></a>        /* Cache the player character's scope list. */
<a name="6275"></a>        local scope_ = Q.scopeList(gPlayerChar);
<a name="6276"></a>        
<a name="6277"></a>        /* Calculate each SpecialVerb's match score, based partly on what's in scope. */
<a name="6278"></a>        foreach(local s in specs)
<a name="6279"></a>            s.matches(scope_, tokWords);
<a name="6280"></a>        
<a name="6281"></a>        /* Sort the list in descending order of score. */
<a name="6282"></a>        local svmatches = specs.sort(true, {a, b: a.score  - b.score });
<a name="6283"></a>        
<a name="6284"></a>        /* Return the first one in the list, which should tbe the best match. */
<a name="6285"></a>        return svmatches[1];                                           
<a name="6286"></a>    }
<a name="6287"></a>    
<a name="6288"></a>    /* The verb words we're currently matching. */
<a name="6289"></a>    vWords = nil
<a name="6290"></a>    
<a name="6291"></a>    matchSV(toks)
<a name="6292"></a>    {
<a name="6293"></a>        /* Find the best SpecialVerb matching the tokens passed to us by the parser */
<a name="6294"></a>        local sv = findMatchingSV(toks);
<a name="6295"></a>        
<a name="6296"></a>        /* 
<a name="6297"></a>         *   If we've found one, update the parser's tokens acordingly, so they now contain the
<a name="6298"></a>         *   standard verb (stdVerb) we want to use in place of the special verb word.
<a name="6299"></a>         */
<a name="6300"></a>        if(sv)
<a name="6301"></a>        {              
<a name="6302"></a>            /* 
<a name="6303"></a>             *   We now need to add the rest of the toks back to the revised first one. We need to
<a name="6304"></a>             *   start from the next tok we just matched our special verb to.
<a name="6305"></a>             */
<a name="6306"></a>            local nToks = toks.sublist(vWords.length + 1);
<a name="6307"></a>            
<a name="6308"></a>            /* 
<a name="6309"></a>             *   Split the stdVerb into a list of words. Check its length. Update the first len toks
<a name="6310"></a>             *   with the list of words from stdVerb. Append nToks to the first stdVerb.length toks.
<a name="6311"></a>             */            
<a name="6312"></a>            local stdVerbWords = sv.stdVerb.split(' ');
<a name="6313"></a>            local stdVerbLen = stdVerbWords.length();
<a name="6314"></a>            local vToks = [];
<a name="6315"></a>            
<a name="6316"></a>            /* Create the toks for the new standard verb */
<a name="6317"></a>            for(local i in 1 .. stdVerbLen)
<a name="6318"></a>            {
<a name="6319"></a>                vToks = vToks.append([stdVerbWords[i], tokWord, stdVerbWords[i]]);                 
<a name="6320"></a>            }           
<a name="6321"></a>            
<a name="6322"></a>            /* Change toks to our new verb phrase plus the old noun phrase */
<a name="6323"></a>            toks = vToks + nToks;
<a name="6324"></a>            
<a name="6325"></a>            
<a name="6326"></a>            /* Make a note of the current SpecialVerb we're working with. */
<a name="6327"></a>            currentSV = sv;
<a name="6328"></a>            
<a name="6329"></a>        }
<a name="6330"></a>        
<a name="6331"></a>        /* Return the (possibly adjusted) list of tokens. */
<a name="6332"></a>        return toks;
<a name="6333"></a>    }
<a name="6334"></a>    
<a name="6335"></a>    /* 
<a name="6336"></a>     *   Call the checkSV() method on our currently active SpecialVerb, if we have one. Tbis is
<a name="6337"></a>     *   called by the current Command object just before invoking the relevant Doer for the
<a name="6338"></a>     *   command.
<a name="6339"></a>     */
<a name="6340"></a>    checkSV(lst)
<a name="6341"></a>    {
<a name="6342"></a>        try
<a name="6343"></a>        {
<a name="6344"></a>            /* 
<a name="6345"></a>             *   If have have a current SpecialVerb, invoke its checkSV method. lst is a list of
<a name="6346"></a>             *   objects involved in the action in the form [action, dobj, ...] whiile vWords
<a name="6347"></a>             *   contains the words making up the current SpecialVerb verb, e.g. ['ring'] or
<a name="6348"></a>             *   ['walk', 'across']
<a name="6349"></a>             */
<a name="6350"></a>            if(currentSV)
<a name="6351"></a>            {
<a name="6352"></a>                currentSV.checkSV(lst, vWords.join(' '));
<a name="6353"></a>                
<a name="6354"></a>                if(lst[1] == SpecialAction)
<a name="6355"></a>                    lst[1].specialPhrase = vWords.join(' ');
<a name="6356"></a>            }
<a name="6357"></a>        }
<a name="6358"></a>        finally
<a name="6359"></a>        {
<a name="6360"></a>            /* 
<a name="6361"></a>             *   Make sure we reset currentSV to nil, whataver happens in checkSV (which might well
<a name="6362"></a>             *   through an Exception such as abort to stop the action.
<a name="6363"></a>             */
<a name="6364"></a>            currentSV = nil;
<a name="6365"></a>        }
<a name="6366"></a>    }
<a name="6367"></a>    
<a name="6368"></a>    /* The SpecialVerb currently in use. */
<a name="6369"></a>    currentSV = nil
<a name="6370"></a>    
<a name="6371"></a>    /* Carry out our preinitialization. */
<a name="6372"></a>    execute()
<a name="6373"></a>    {
<a name="6374"></a>        /* Iterate over every object of the SpecialVerb class calling its initSpec() method. */
<a name="6375"></a>        for(local spec = firstObj(SpecialVerb); spec != nil; spec = nextObj(spec, SpecialVerb))
<a name="6376"></a>            spec.initSpec();               
<a name="6377"></a>    }
<a name="6378"></a>
<a name="6379"></a>    /* 
<a name="6380"></a>     *   Add a SpecialVerb to our specTable; s is the key value containing the words that can invoke
<a name="6381"></a>     *   the SpecialVerb (e.g. ['ring'] or ['walk', 'across'] and spec is the matching SpecialVerb.
<a name="6382"></a>     */
<a name="6383"></a>    addToTable(s, spec)
<a name="6384"></a>    {
<a name="6385"></a>        /* Obtain the current value corresponding to the s key in specTable. */
<a name="6386"></a>        local specs = valToList(specTable[s]);
<a name="6387"></a>        
<a name="6388"></a>        /* Add spec to the list of SpecialVerbs it matches. */
<a name="6389"></a>        specTable[s] = specs + spec;
<a name="6390"></a>    }
<a name="6391"></a>    
<a name="6392"></a>    /* 
<a name="6393"></a>     *   Our LookupTable containing lists of grammar tokens (e.g., ['ring'] or ['go', 'across']) as
<a name="6394"></a>     *   keys and a list of matching SpecialVerbs as values.
<a name="6395"></a>     */
<a name="6396"></a>    specTable = static new LookupTable
<a name="6397"></a>    
<a name="6398"></a>       
<a name="6399"></a>    /* 
<a name="6400"></a>     *   The maxium number of words that can occur in a key to our specTable. This is calculated and
<a name="6401"></a>     *   stored here at preinit.
<a name="6402"></a>     */
<a name="6403"></a>    maxKeyLen = 0
<a name="6404"></a>;
<a name="6405"></a>
<a name="6406"></a>
<a name="6407"></a>/* 
<a name="6408"></a> *   PreParser to strip punctuation from the start of the command line, since punctuation there is
<a name="6409"></a> *   unlikely to be valid and may lead to run-time errors.
<a name="6410"></a> */
<a name="6411"></a>InitialPunctPreparser:StringPreParser
<a name="6412"></a>    doParsing(str, which)
<a name="6413"></a>    {
<a name="6414"></a>        return str.findReplace(R'^&lt;Punct&gt;+', '');
<a name="6415"></a>        
<a name="6416"></a>    }    
<a name="6417"></a>;
<a name="6418"></a>
<a name="6419"></a>    
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 20/01/2025 from adv3Lite version 2.1.1.11</div>
</body>
</html>

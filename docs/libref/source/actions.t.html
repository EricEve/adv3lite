<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>actions.t</title></head><body>
<table class=ban><tr><td><h1>actions.t</h1><td align=right><a href="../file/actions.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>property handleTopic;
<a name="5"></a>property showSuggestions;
<a name="6"></a>property sayHello;
<a name="7"></a>property showScore;
<a name="8"></a>property scoreNotify;
<a name="9"></a>property showHints;
<a name="10"></a>property disableHints;
<a name="11"></a>property activated;
<a name="12"></a>property extraHintsExist;
<a name="13"></a>property showExitsCommand;
<a name="14"></a>property exitsOnOffCommand;
<a name="15"></a>property isOdor;
<a name="16"></a>property isNoise;
<a name="17"></a>property enumerateSuggestions;
<a name="18"></a>property hyperlinkSuggestions;
<a name="19"></a>property thinkDesc;
<a name="20"></a>property follow;
<a name="21"></a>property optionsExplained;
<a name="22"></a>
<a name="23"></a>DefineSystemAction(Quit)
<a name="24"></a>   
<a name="25"></a>    
<a name="26"></a>    execAction(cmd)
<a name="27"></a>    {        
<a name="28"></a>        DMsg(quit query, '&lt;.p&gt;Do you really want to quit? (y/n)?\n&gt;');
<a name="29"></a>       
<a name="30"></a>        if(yesOrNo())
<a name="31"></a>            throw new QuittingException;        
<a name="32"></a>    }
<a name="33"></a>;
<a name="34"></a>
<a name="35"></a>DefineSystemAction(Undo)
<a name="36"></a>   
<a name="37"></a>    
<a name="38"></a>    execAction(cmd)
<a name="39"></a>    {
<a name="40"></a>        if(undo())
<a name="41"></a>        {
<a name="42"></a>            DMsg(undo okay, 'One turn undone: {1}', 
<a name="43"></a>                 libGlobal.lastCommandForUndo);
<a name="44"></a>            
<a name="45"></a>            /* notify all PostUndoObject instances */
<a name="46"></a>            PostUndoObject.classExec();
<a name="47"></a>            
<a name="48"></a>            return true;
<a name="49"></a>        }
<a name="50"></a>        else
<a name="51"></a>        {
<a name="52"></a>            DMsg(undo failed, 'Undo failed. ');
<a name="53"></a>            return nil;
<a name="54"></a>        }
<a name="55"></a>    }
<a name="56"></a>    
<a name="57"></a>;
<a name="58"></a>
<a name="59"></a>DefineSystemAction(Restart)
<a name="60"></a>    
<a name="61"></a>    
<a name="62"></a>    execAction(cmd)
<a name="63"></a>    {
<a name="64"></a>        DMsg(restart query, 
<a name="65"></a>             'Do you really want to start again from the beginning (y/n)?\n&gt;');
<a name="66"></a>        
<a name="67"></a>        if(inputManager.getInputLine().toLower.startsWith(affirmativeLetter))
<a name="68"></a>            doRestartGame();
<a name="69"></a>        
<a name="70"></a>    }
<a name="71"></a>    
<a name="72"></a>    affirmativeLetter = 'y'
<a name="73"></a>    
<a name="74"></a>    doRestartGame()
<a name="75"></a>    {
<a name="76"></a>        /* before restarting, notify anyone interested of our intentions */
<a name="77"></a>        PreRestartObject.classExec();
<a name="78"></a>
<a name="79"></a>        /* 
<a name="80"></a>         *   Throw a 'restart' signal; the main entrypoint loop will catch
<a name="81"></a>         *   this and actually perform the restart.
<a name="82"></a>         *   
<a name="83"></a>         *   Note that we *could* do the VM reset (via restartGame()) here,
<a name="84"></a>         *   but there's an advantage to doing it in the main loop: we
<a name="85"></a>         *   won't be in the stack context of whatever command we're
<a name="86"></a>         *   performing.  If we did the restart here, it's possible that
<a name="87"></a>         *   some useless objects would survive the VM reset just because
<a name="88"></a>         *   they're referenced from within a caller's stack frame.  Those
<a name="89"></a>         *   objects would immediately go out of scope when we get back to
<a name="90"></a>         *   the main loop, but they might survive long enough to create
<a name="91"></a>         *   apparent inconsistencies.  In particular, if we did a
<a name="92"></a>         *   firstObj/nextObj loop, we could discover those objects and
<a name="93"></a>         *   re-establish more lasting references to them, which we
<a name="94"></a>         *   certainly don't want to do.  By deferring the VM reset until
<a name="95"></a>         *   we get back to the main loop, we'll ensure that objects won't
<a name="96"></a>         *   survive the reset just because they're on the stack
<a name="97"></a>         *   momentarily here.  
<a name="98"></a>         */
<a name="99"></a>        throw new RestartSignal();
<a name="100"></a>        
<a name="101"></a>    }
<a name="102"></a>;
<a name="103"></a>
<a name="104"></a>DefineSystemAction(Credits)
<a name="105"></a>    
<a name="106"></a>    
<a name="107"></a>    execAction(cmd)
<a name="108"></a>    {
<a name="109"></a>        versionInfo.showCredit();
<a name="110"></a>        "&lt;.p&gt;";
<a name="111"></a>    }
<a name="112"></a>;
<a name="113"></a>
<a name="114"></a>DefineSystemAction(About)
<a name="115"></a>    execAction(cmd)
<a name="116"></a>    {
<a name="117"></a>        versionInfo.showAbout();
<a name="118"></a>        "&lt;.p&gt;";
<a name="119"></a>    }
<a name="120"></a>;
<a name="121"></a>
<a name="122"></a>DefineSystemAction(Version)
<a name="123"></a>    execAction(cmd)
<a name="124"></a>    {
<a name="125"></a>        local lst = ModuleID.getModuleList();
<a name="126"></a>        foreach(local cur in lst)    
<a name="127"></a>           cur.showVersion();
<a name="128"></a>        
<a name="129"></a>        "&lt;.p&gt;";          
<a name="130"></a>    }
<a name="131"></a>;
<a name="132"></a>
<a name="133"></a>DefineSystemAction(Exits)
<a name="134"></a>    execAction(cmd)
<a name="135"></a>    {
<a name="136"></a>        if(gExitLister == nil)
<a name="137"></a>            sayNoExitLister();
<a name="138"></a>        else
<a name="139"></a>            gExitLister.showExitsCommand();
<a name="140"></a>    }
<a name="141"></a>;
<a name="142"></a>
<a name="143"></a>DefineSystemAction(ExitsMode)
<a name="144"></a>    execAction(cmd)
<a name="145"></a>    {
<a name="146"></a>        if(gExitLister == nil)
<a name="147"></a>        {
<a name="148"></a>            sayNoExitLister();
<a name="149"></a>            return;
<a name="150"></a>        }
<a name="151"></a>        
<a name="152"></a>        if(cmd.verbProd.on_ != nil)
<a name="153"></a>            gExitLister.exitsOnOffCommand(true, true);
<a name="154"></a>        
<a name="155"></a>        if(cmd.verbProd.off_ != nil)
<a name="156"></a>            gExitLister.exitsOnOffCommand(nil, nil);
<a name="157"></a>        
<a name="158"></a>        if(cmd.verbProd.look_ != nil)
<a name="159"></a>            gExitLister.exitsOnOffCommand(nil, true);
<a name="160"></a>        
<a name="161"></a>        if(cmd.verbProd.stat_ != nil)
<a name="162"></a>            gExitLister.exitsOnOffCommand(true, nil);
<a name="163"></a>    }
<a name="164"></a>        
<a name="165"></a>;
<a name="166"></a>
<a name="167"></a>DefineSystemAction(ExitsColour)
<a name="168"></a>    execAction(cmd)
<a name="169"></a>    {
<a name="170"></a>        if(gExitLister == nil)
<a name="171"></a>        {
<a name="172"></a>            sayNoExitLister(); 
<a name="173"></a>            return;
<a name="174"></a>        }
<a name="175"></a>        
<a name="176"></a>        if(defined(statuslineExitLister) &amp;&amp; cmd.verbProd.on_ != nil)
<a name="177"></a>        {
<a name="178"></a>            statuslineExitLister.highlightUnvisitedExits = 
<a name="179"></a>                (cmd.verbProd.on_ == 'on');
<a name="180"></a>            
<a name="181"></a>            DMsg(exit color onoff, 'Okay, colouring of unvisited exits is now
<a name="182"></a>                {1}.&lt;.p&gt;', cmd.verbProd.on_);
<a name="183"></a>        }
<a name="184"></a>        
<a name="185"></a>        if(defined(statuslineExitLister) &amp;&amp; cmd.verbProd.colour_ != nil)
<a name="186"></a>        {
<a name="187"></a>            statuslineExitLister.unvisitedExitColour = cmd.verbProd.colour_;
<a name="188"></a>            statuslineExitLister.highlightUnvisitedExits = true;
<a name="189"></a>            DMsg(exit color change, 'Okay, unvisited exits in the status line
<a name="190"></a>                will now be shown in {1}. ', cmd.verbProd.colour_);
<a name="191"></a>        }
<a name="192"></a>    }
<a name="193"></a>;
<a name="194"></a>
<a name="195"></a>sayNoExitLister()
<a name="196"></a>{
<a name="197"></a>    DMsg(no exit lister, 'Sorry, that command is not available in this
<a name="198"></a>                game, since there\'s no exit lister. ');    
<a name="199"></a>}
<a name="200"></a>
<a name="201"></a>
<a name="202"></a>DefineSystemAction(Score)
<a name="203"></a>    execAction(cmd)
<a name="204"></a>    {
<a name="205"></a>        /* show the simple score */
<a name="206"></a>        if (libGlobal.scoreObj != nil)
<a name="207"></a>        {
<a name="208"></a>            /* show the score */
<a name="209"></a>            libGlobal.scoreObj.showScore();
<a name="210"></a>
<a name="211"></a>            /* 
<a name="212"></a>             *   Mention the FULL SCORE command to the player if we haven't
<a name="213"></a>             *   already.  Note that we only want to mention 
<a name="214"></a>             */
<a name="215"></a>            if (!mentionedFullScore)
<a name="216"></a>            {
<a name="217"></a>                /* explain about it */
<a name="218"></a>                htmlSay(BMsg(mention full score, 'To see your complete list of
<a name="219"></a>                    achievements, use the &lt;&lt;aHref('full score', 'FULL SCORE',
<a name="220"></a>                                                  'show full score')&gt;&gt; command. 
<a name="221"></a>                    '));
<a name="222"></a>
<a name="223"></a>                /* don't mention it again */
<a name="224"></a>                Score.mentionedFullScore = true;
<a name="225"></a>            }
<a name="226"></a>        }
<a name="227"></a>        else
<a name="228"></a>            /* this game doesn't use scoring */
<a name="229"></a>            scoreNotPresent(); 
<a name="230"></a>        
<a name="231"></a>    }
<a name="232"></a>    
<a name="233"></a>    scoreNotPresent()
<a name="234"></a>    {
<a name="235"></a>          DMsg(score not present, '&lt;.parser&gt;This story doesn&amp;rsquo;t use
<a name="236"></a>               scoring.&lt;./parser&gt; ');            
<a name="237"></a>    }
<a name="238"></a>    
<a name="239"></a>    mentionedFullScore = nil
<a name="240"></a>;
<a name="241"></a>
<a name="242"></a>DefineSystemAction(FullScore)
<a name="243"></a>    execAction(cmd)
<a name="244"></a>    {
<a name="245"></a>        /* show the full score in response to an explicit player request */
<a name="246"></a>        showFullScore();
<a name="247"></a>
<a name="248"></a>        /* this counts as a mention of the FULL SCORE command */
<a name="249"></a>        Score.mentionedFullScore = true;
<a name="250"></a>    }
<a name="251"></a>
<a name="252"></a>    /* show the full score */
<a name="253"></a>    showFullScore()
<a name="254"></a>    {
<a name="255"></a>        /* show the full score */
<a name="256"></a>        if (libGlobal.scoreObj != nil)
<a name="257"></a>            libGlobal.scoreObj.showFullScore();
<a name="258"></a>        else
<a name="259"></a>            Score.scoreNotPresent;
<a name="260"></a>    }
<a name="261"></a>   
<a name="262"></a>;
<a name="263"></a>
<a name="264"></a>DefineSystemAction(Notify)
<a name="265"></a>    execAction(cmd)
<a name="266"></a>    {
<a name="267"></a>        /* show the current notification status */
<a name="268"></a>        if (libGlobal.scoreObj != nil)
<a name="269"></a>            showNotifyStatus(libGlobal.scoreObj.scoreNotify.isOn);        
<a name="270"></a>        else
<a name="271"></a>            commandNotPresent;
<a name="272"></a>    }
<a name="273"></a>    
<a name="274"></a>      /* show the current score notify status */
<a name="275"></a>    showNotifyStatus(stat)
<a name="276"></a>    {
<a name="277"></a>        DMsg(show notify status, '&lt;.notification&gt;Score notifications are
<a name="278"></a>        currently &lt;&lt;stat ? 'on' : 'off'&gt;&gt;.&lt;./notifcation&gt; ');
<a name="279"></a>    }
<a name="280"></a>;
<a name="281"></a>
<a name="282"></a>DefineSystemAction(NotifyOn)
<a name="283"></a>    execAction(cmd)
<a name="284"></a>    {
<a name="285"></a>        /* turn notifications on, and acknowledge the status */
<a name="286"></a>        if (libGlobal.scoreObj != nil)
<a name="287"></a>        {
<a name="288"></a>            libGlobal.scoreObj.scoreNotify.isOn = true;
<a name="289"></a>            acknowledgeNotifyStatus(true);
<a name="290"></a>        }
<a name="291"></a>        else
<a name="292"></a>            commandNotPresent;
<a name="293"></a>    }
<a name="294"></a>;
<a name="295"></a>
<a name="296"></a>DefineSystemAction(NotifyOff)
<a name="297"></a>    execAction(cmd)
<a name="298"></a>    {
<a name="299"></a>        /* turn notifications off, and acknowledge the status */
<a name="300"></a>        if (libGlobal.scoreObj != nil)
<a name="301"></a>        {
<a name="302"></a>            libGlobal.scoreObj.scoreNotify.isOn = nil;
<a name="303"></a>            acknowledgeNotifyStatus(nil);
<a name="304"></a>        }
<a name="305"></a>        else
<a name="306"></a>            commandNotPresent;
<a name="307"></a>    }
<a name="308"></a>;
<a name="309"></a>
<a name="310"></a>DefineSystemAction(ToggleDisambigEnumeration)    
<a name="311"></a>    execAction(cmd)
<a name="312"></a>    {
<a name="313"></a>        if(libGlobal.enumerateDisambigOptions)
<a name="314"></a>        {
<a name="315"></a>            libGlobal.enumerateDisambigOptions = nil;
<a name="316"></a>            DMsg(disambig enum off, 'Enumeration of disambiguation choices is now off. ');
<a name="317"></a>        }
<a name="318"></a>        else
<a name="319"></a>        {
<a name="320"></a>            libGlobal.enumerateDisambigOptions = true;
<a name="321"></a>            DMsg(disambig enum off, 'Enumeration of disambiguation choices is now on. ');
<a name="322"></a>        }
<a name="323"></a>    }
<a name="324"></a>;
<a name="325"></a>
<a name="326"></a>DefineSystemAction(EnumerateSuggestions)
<a name="327"></a>    execAction(cmd)
<a name="328"></a>    {
<a name="329"></a>        if(defined(suggestedTopicLister))
<a name="330"></a>        {
<a name="331"></a>            suggestedTopicLister.enumerateSuggestions = !suggestedTopicLister.enumerateSuggestions;
<a name="332"></a>            
<a name="333"></a>            DMsg(toggle suggestion enum, 'Enumeration of topic suggestions is now 
<a name="334"></a>                &lt;b&gt;&lt;&lt;suggestedTopicLister.enumerateSuggestions ? 'on' : 'off'&gt;&gt;&lt;/b&gt;.&lt;.p&gt;');          
<a name="335"></a>        }
<a name="336"></a>        if(!defined(suggestedTopicLister))
<a name="337"></a>            DMsg(no suggestions present, 'Topic suggestions are not present in this game');
<a name="338"></a>    }
<a name="339"></a>;
<a name="340"></a>
<a name="341"></a>DefineSystemAction(HyperlinkSuggestions)
<a name="342"></a>    execAction(cmd)       
<a name="343"></a>    {
<a name="344"></a>        /* First check that the player's interpreter is capable of displaying hyperlinks. */
<a name="345"></a>        if(systemInfo(SysInfoInterpClass) != SysInfoIClassHTML)
<a name="346"></a>        {
<a name="347"></a>            DMsg(needs html terp, 'This feature requires an HTML interpreter. ');
<a name="348"></a>            abort;
<a name="349"></a>        }
<a name="350"></a>        
<a name="351"></a>        if(defined(suggestedTopicLister))
<a name="352"></a>        {
<a name="353"></a>            suggestedTopicLister.hyperlinkSuggestions = !suggestedTopicLister.hyperlinkSuggestions;
<a name="354"></a>            
<a name="355"></a>            DMsg(toggle suggestion enum, 'Hyperlinking of topic suggestions is now 
<a name="356"></a>                &lt;b&gt;&lt;&lt;suggestedTopicLister.hyperlinkSuggestions ? 'on' : 'off'&gt;&gt;&lt;/b&gt;.&lt;.p&gt;');
<a name="357"></a>        }
<a name="358"></a>        if(!defined(suggestedTopicLister))
<a name="359"></a>            DMsg(no suggestions present, 'Topic suggestions are not present in this game');
<a name="360"></a>    }
<a name="361"></a>;
<a name="362"></a>
<a name="363"></a>DefineSystemAction(Hints)
<a name="364"></a>    execAction(cmd)
<a name="365"></a>    {
<a name="366"></a>        if(gHintManager == nil)
<a name="367"></a>            sayHintsNotPresent();
<a name="368"></a>        else        
<a name="369"></a>            gHintManager.showHints();
<a name="370"></a>        
<a name="371"></a>    }
<a name="372"></a>    
<a name="373"></a>    sayHintsNotPresent() 
<a name="374"></a>    {
<a name="375"></a>        DMsg(hints not present, '&lt;.parser&gt;Sorry, this story doesn&amp;rsquo;t
<a name="376"></a>                have any built-in hints.&lt;./parser&gt; ');
<a name="377"></a>    }
<a name="378"></a>;
<a name="379"></a>        
<a name="380"></a>
<a name="381"></a>DefineSystemAction(HintsOff)
<a name="382"></a>    execAction(cmd)
<a name="383"></a>    {
<a name="384"></a>        if(gHintManager == nil)
<a name="385"></a>            DMsg(no hints to disable, '&lt;.parser&gt;This game doesn\'t have any
<a name="386"></a>                hints to turn off.&lt;./parser&gt; ');
<a name="387"></a>        else
<a name="388"></a>            gHintManager.disableHints();
<a name="389"></a>    }
<a name="390"></a>;
<a name="391"></a>
<a name="392"></a>DefineSystemAction(ExtraHints)
<a name="393"></a>    execAction(cmd)
<a name="394"></a>    {
<a name="395"></a>        if(gExtraHintManager == nil || !gExtraHintManager.extraHintsExist())
<a name="396"></a>        {
<a name="397"></a>            DMsg(no extra hints, 'Sorry, there are no extra hints in this game.
<a name="398"></a>                ');
<a name="399"></a>            return;
<a name="400"></a>        }
<a name="401"></a>        
<a name="402"></a>        onOff = cmd.verbProd.onOff;
<a name="403"></a>        
<a name="404"></a>        if(onOff == nil)
<a name="405"></a>        {
<a name="406"></a>            showExtraHintStatus();
<a name="407"></a>            
<a name="408"></a>            return;
<a name="409"></a>                    
<a name="410"></a>        }
<a name="411"></a>        onOff = onOff.toLower();
<a name="412"></a>        
<a name="413"></a>        if(onOff == hintsOff)
<a name="414"></a>            gExtraHintManager.deactivate();
<a name="415"></a>        else
<a name="416"></a>            gExtraHintManager.activate();
<a name="417"></a>        
<a name="418"></a>        DMsg(extra hints on or off, 'Okay; extra hints are now {1}. ', onOff );
<a name="419"></a>    }
<a name="420"></a>    
<a name="421"></a>    /* 
<a name="422"></a>     *   Routine to display message saying that extra hints are on or off.
<a name="423"></a>     *   Translators may want to override this method to display a message if it
<a name="424"></a>     *   can't readily be done in a CustomMessages object.
<a name="425"></a>     */
<a name="426"></a>    showExtraHintStatus()
<a name="427"></a>    {
<a name="428"></a>        local cmdstr = extraHintsCmd + onOrOff(!extraHintsActive).toUpper();
<a name="429"></a>        
<a name="430"></a>        DMsg(extra hints status,            
<a name="431"></a>            'Extra hints are currently &lt;&lt;onOrOff(extraHintsActive)&gt;&gt;. To turn
<a name="432"></a>            them &lt;&lt;onOrOff(!extraHintsActive)&gt;&gt; use the command &lt;&lt;aHref(cmdstr,
<a name="433"></a>                cmdstr, 'Turn extra hints ' + onOrOff(!extraHintsActive))&gt;&gt;. ',
<a name="434"></a>                 cmdstr);
<a name="435"></a>            return;
<a name="436"></a>    }
<a name="437"></a>    
<a name="438"></a>    extraHintsActive = (gExtraHintManager != nil &amp;&amp; gExtraHintManager.activated)
<a name="439"></a>    
<a name="440"></a>    onOrOff(stat) { return stat ? hintsOn : hintsOff; }
<a name="441"></a>    
<a name="442"></a>    onOff = nil
<a name="443"></a>    
<a name="444"></a>    hintsOff = BMsg(extra hints off, 'off')
<a name="445"></a>    hintsOn = BMsg(extra hints on, 'on')
<a name="446"></a>    
<a name="447"></a>    extraHintsCmd = BMsg(extra hints command, 'EXTRA ')
<a name="448"></a>;
<a name="449"></a>
<a name="450"></a>DefineSystemAction(TipsOn)
<a name="451"></a>    execAction(cmd)
<a name="452"></a>    {
<a name="453"></a>        tipMode.isOn = true;
<a name="454"></a>        DMsg(tips on, 'Tips are now on. ');
<a name="455"></a>    }    
<a name="456"></a>;
<a name="457"></a>
<a name="458"></a>DefineSystemAction(TipsOff)
<a name="459"></a>    execAction(cmd)
<a name="460"></a>    {
<a name="461"></a>        tipMode.isOn = nil;
<a name="462"></a>        DMsg(tips on, 'Tips are now off. ');
<a name="463"></a>    }    
<a name="464"></a>;
<a name="465"></a>
<a name="466"></a>DefineSystemAction(Brief)
<a name="467"></a>    execAction(cmd)
<a name="468"></a>    {
<a name="469"></a>        if(gameMain.verbose)
<a name="470"></a>        {
<a name="471"></a>            gameMain.verbose = nil;
<a name="472"></a>            DMsg(game now brief, 'The game is now in BRIEF mode. &lt;&lt;first
<a name="473"></a>                  time&gt;&gt;Full room descriptions will now only be shown on the
<a name="474"></a>                first visit to a room or in response to an explicit
<a name="475"></a>                &lt;&lt;aHref('LOOK', 'LOOK', 'Look
<a name="476"></a>                    around')&gt;&gt; command.&lt;&lt;only&gt;&gt; ');
<a name="477"></a>        }
<a name="478"></a>        else
<a name="479"></a>            DMsg(game already brief, 'The game is already in BRIEF mode. ');
<a name="480"></a>    }
<a name="481"></a>;
<a name="482"></a>
<a name="483"></a>DefineSystemAction(Verbose)
<a name="484"></a>    execAction(cmd)
<a name="485"></a>    {
<a name="486"></a>        if(gameMain.verbose)            
<a name="487"></a>            DMsg(game already verbose, 'The game is already in VERBOSE mode. ');        
<a name="488"></a>        else
<a name="489"></a>        {
<a name="490"></a>            gameMain.verbose = true;
<a name="491"></a>            DMsg(game now verbose, 'The game is now in VERBOSE mode. &lt;&lt;first
<a name="492"></a>                  time&gt;&gt;Full room descriptions be shown each time a room is
<a name="493"></a>                visited.&lt;&lt;only&gt;&gt; ');
<a name="494"></a>        }            
<a name="495"></a>    }
<a name="496"></a>;
<a name="497"></a>
<a name="498"></a>
<a name="499"></a>/* Set Inventory to TALL format */
<a name="500"></a>DefineSystemAction(InventoryTall)
<a name="501"></a>    execAction(cmd)
<a name="502"></a>    {
<a name="503"></a>        /* Register with the Inventory action that inventory listing should now be in tall format. */
<a name="504"></a>        Inventory.inventoryStyle = self;
<a name="505"></a>        
<a name="506"></a>        /* Display a confirmation that this change has just taken place. */
<a name="507"></a>        DMsg(inventory tall, 'Inventory Listing is now set to TALL');
<a name="508"></a>    }
<a name="509"></a>;
<a name="510"></a>  
<a name="511"></a>/* Set Inventory to WIDE format */
<a name="512"></a>DefineSystemAction(InventoryWide)        
<a name="513"></a>    execAction(cmd)
<a name="514"></a>    {
<a name="515"></a>        /* Register the Inventory action that inventory listing should now be in wide format. */
<a name="516"></a>        Inventory.inventoryStyle = self;
<a name="517"></a>        
<a name="518"></a>        /* Display a confirmation that this change has just taken place. */
<a name="519"></a>        DMsg(inventory wide, 'Inventory Listing is now set to WIDE');
<a name="520"></a>    }
<a name="521"></a>;
<a name="522"></a>
<a name="523"></a>/* Set Inventory to HYBRID format */
<a name="524"></a>DefineSystemAction(InventoryHybrid)    
<a name="525"></a>    execAction(cmd)
<a name="526"></a>    {
<a name="527"></a>        /* Register with the Inventory action inventory listing should now be in wide format. */
<a name="528"></a>        Inventory.inventoryStyle = self;
<a name="529"></a>        
<a name="530"></a>        /* Display a confirmation that this change has just taken place. */
<a name="531"></a>        DMsg(inventory hybrid, 'Inventory Listing is now set to HYBRID');
<a name="532"></a>    }
<a name="533"></a>;
<a name="534"></a>
<a name="535"></a>
<a name="536"></a>DefineIAction(Inventory)
<a name="537"></a>    execAction(cmd)
<a name="538"></a>    {
<a name="539"></a>        /* 
<a name="540"></a>         *   If splitListing is true, we potentially need to display two lists,
<a name="541"></a>         *   one of what the actor is wearing and one of what the actor is
<a name="542"></a>         *   carrying.
<a name="543"></a>         */
<a name="544"></a>        if(splitListing)
<a name="545"></a>        {
<a name="546"></a>            /* Construct a list of what the actor is wearing */
<a name="547"></a>            local wornList = gActor.contents.subset({o: o.wornBy == gActor });
<a name="548"></a>            
<a name="549"></a>            /* Construst a list of what the actor is carrying */
<a name="550"></a>            local carriedList = gActor.contents.subset({o: o.wornBy == nil &amp;&amp;
<a name="551"></a>                o.isFixed == nil});
<a name="552"></a>            
<a name="553"></a>            /* Note whether we've displayed the worn list */
<a name="554"></a>            local wornListShown = 0;
<a name="555"></a>            
<a name="556"></a>            /* 
<a name="557"></a>                 *   If anything is being worn, get a list of it minus the final
<a name="558"></a>             *   paragraph break and then display it.
<a name="559"></a>             */
<a name="560"></a>            if(wornList.length &gt; 0)
<a name="561"></a>            {               
<a name="562"></a>                gActor.myWornLister.show(wornList, 0, nil);
<a name="563"></a>                
<a name="564"></a>                /* 
<a name="565"></a>                 *   If nothing is being carried, terminate the list with a full
<a name="566"></a>                 *   stop and a paragraph break.
<a name="567"></a>                 */
<a name="568"></a>                if(carriedList.length == 0 || inventoryStyle == InventoryHybrid)
<a name="569"></a>                    ".&lt;.p&gt;";
<a name="570"></a>                
<a name="571"></a>                /*  
<a name="572"></a>                 *   Note that the worn list has been shown.                 
<a name="573"></a>                 */
<a name="574"></a>                wornListShown = 1;
<a name="575"></a>                
<a name="576"></a>            }
<a name="577"></a>            /* 
<a name="578"></a>             *   If something's being carried or nothing's being worn, display
<a name="579"></a>             *   an inventory list of what's being carried. If nothing's being
<a name="580"></a>             *   worn or carried, this will display the "You are empty-handed"
<a name="581"></a>             *   message.
<a name="582"></a>             */
<a name="583"></a>            if(carriedList.length &gt; 0 || wornList.length == 0)
<a name="584"></a>                gActor.myInventoryLister.show(carriedList, wornListShown);
<a name="585"></a>        }
<a name="586"></a>        else
<a name="587"></a>        {
<a name="588"></a>            gActor.myInventoryLister.show(gActor.contents, 0);
<a name="589"></a>        }
<a name="590"></a>        
<a name="591"></a>        /* Mark eveything just listed as having been seen. */
<a name="592"></a>        gActor.contents.forEach({x: x.noteSeen()});
<a name="593"></a>    }
<a name="594"></a>   
<a name="595"></a>        
<a name="596"></a>    /* 
<a name="597"></a>     *   Do we want separate lists of what's worn and what's carried?  By default we do unless we're
<a name="598"></a>     *   doing a tall inventory listing
<a name="599"></a>     */
<a name="600"></a>    splitListing = (inventoryStyle != InventoryTall)
<a name="601"></a>    
<a name="602"></a>    
<a name="603"></a>    /* Our current inventtory style, wide, tall, or hybrid. */
<a name="604"></a>    inventoryStyle = InventoryWide
<a name="605"></a>;
<a name="606"></a>
<a name="607"></a>DefineIAction(Look)
<a name="608"></a>    execAction(cmd)
<a name="609"></a>    {
<a name="610"></a>        gActor.outermostVisibleParent().lookAroundWithin();
<a name="611"></a>    }
<a name="612"></a>
<a name="613"></a>;
<a name="614"></a>
<a name="615"></a>DefineIAction(Wait)
<a name="616"></a>    execAction(cmd)
<a name="617"></a>    {
<a name="618"></a>        DMsg(wait, 'Time {dummy} pass{es/ed}. ');
<a name="619"></a>    }
<a name="620"></a>   
<a name="621"></a>;
<a name="622"></a>
<a name="623"></a>Jump: SpecialTravelAction
<a name="624"></a>        
<a name="625"></a>    preCond = (gActor.location &amp;&amp; gActor.location.getOutToJump ?
<a name="626"></a>               [actorOutOfNested]: nil)
<a name="627"></a>    travelProp = &amp;jump
<a name="628"></a>    
<a name="629"></a>    fallback(loc) {  DMsg(jump, '{I} jump{s/ed} on the spot, fruitlessly. ');    }
<a name="630"></a>    
<a name="631"></a>    connotTravelInDark(loc)
<a name="632"></a>    {
<a name="633"></a>        DMsg(leap in the dark, 'It might be wiser not to hazard a leap in the dark {here}. ');
<a name="634"></a>    }
<a name="635"></a>    
<a name="636"></a>;
<a name="637"></a>
<a name="638"></a>DefineIAction(Yell)
<a name="639"></a>    execAction(cmd)
<a name="640"></a>    {
<a name="641"></a>        DMsg(yell, '{I} shout{s/ed} very loudly. ');
<a name="642"></a>    }
<a name="643"></a>;
<a name="644"></a>
<a name="645"></a>DefineIAction(Smell)
<a name="646"></a>    execAction(cmd)
<a name="647"></a>    {
<a name="648"></a>        /* 
<a name="649"></a>         *   Build a list of all the objects in scope that both (1) define a
<a name="650"></a>         *   smellDesc property that will display something and (2) whose
<a name="651"></a>         *   isProminentSmell property is true
<a name="652"></a>         */
<a name="653"></a>        local s_list = gActor.getOutermostRoom.allContents.subset(
<a name="654"></a>            {x: Q.canSmell(gActor, x)  &amp;&amp;  x.isProminentSmell});
<a name="655"></a>        
<a name="656"></a>        /* Include the current room in the list. */
<a name="657"></a>        s_list += gActor.getOutermostRoom;
<a name="658"></a>        
<a name="659"></a>        s_list = s_list.getUnique();
<a name="660"></a>        
<a name="661"></a>        /*  Obtain the corresponding list for remote rooms */
<a name="662"></a>        local r_list = getRemoteSmellList().getUnique() - s_list;
<a name="663"></a>               
<a name="664"></a>        /* 
<a name="665"></a>         *   Create a local variable to keep track of whether we've displayed
<a name="666"></a>         *   anything.
<a name="667"></a>         */
<a name="668"></a>        local somethingDisplayed = nil;
<a name="669"></a>        
<a name="670"></a>        
<a name="671"></a>        /* 
<a name="672"></a>         *   Display the smellDesc of every item in our local smell list,
<a name="673"></a>         *   keeping track of whether anything has actually been displayed as a
<a name="674"></a>         *   result.
<a name="675"></a>         */
<a name="676"></a>        foreach(local cur in s_list)
<a name="677"></a>        {
<a name="678"></a>            if(cur.displayAlt(&amp;smellDesc))
<a name="679"></a>                somethingDisplayed = true;
<a name="680"></a>        }
<a name="681"></a>        
<a name="682"></a>        /* Then list any smells from remote locations */
<a name="683"></a>        if(listRemoteSmells(r_list))
<a name="684"></a>            somethingDisplayed = true;
<a name="685"></a>        
<a name="686"></a>        
<a name="687"></a>        /*  If nothing has been displayed report that there is nothing to smell */        
<a name="688"></a>        if(!somethingDisplayed)            
<a name="689"></a>            DMsg(smell nothing intransitive, '{I} {smell} nothing out of the
<a name="690"></a>                ordinary.&lt;.p&gt;');
<a name="691"></a>
<a name="692"></a>    }
<a name="693"></a>    
<a name="694"></a>    /* Do nothing in the core library; senseRegion.t will override if present */
<a name="695"></a>    getRemoteSmellList() { return []; }
<a name="696"></a>    
<a name="697"></a>    /* Do nothing in the core library; senseRegion.t will override if present */
<a name="698"></a>    listRemoteSmells(lst) { return nil; }
<a name="699"></a>;
<a name="700"></a>
<a name="701"></a>
<a name="702"></a>DefineIAction(Listen)
<a name="703"></a>    execAction(cmd)
<a name="704"></a>    {
<a name="705"></a>        /* 
<a name="706"></a>         *   I may be able to hear things that aren't technically in scope,
<a name="707"></a>         *   since they may be hidden in containers that allow sound through.
<a name="708"></a>         */        
<a name="709"></a>        local s_list = gActor.getOutermostRoom.allContents.subset(
<a name="710"></a>            {x: Q.canHear(gActor,x) &amp;&amp; x.isProminentNoise});
<a name="711"></a>        
<a name="712"></a>        /* Include the current room in the list. */
<a name="713"></a>        s_list += gActor.getOutermostRoom;
<a name="714"></a>        
<a name="715"></a>        s_list = s_list.getUnique();
<a name="716"></a>        
<a name="717"></a>        local r_list = getRemoteSoundList().getUnique() - s_list;
<a name="718"></a>        
<a name="719"></a>        /* 
<a name="720"></a>         *   Create a local variable to keep track of whether we've displayed
<a name="721"></a>         *   anything.
<a name="722"></a>         */
<a name="723"></a>        local somethingDisplayed = nil;
<a name="724"></a>        
<a name="725"></a>        foreach(local cur in s_list)
<a name="726"></a>        {
<a name="727"></a>            if(cur.displayAlt(&amp;listenDesc))
<a name="728"></a>                somethingDisplayed = true;
<a name="729"></a>        }
<a name="730"></a>        
<a name="731"></a>        if(listRemoteSounds(r_list))
<a name="732"></a>            somethingDisplayed = true;
<a name="733"></a>        
<a name="734"></a>        
<a name="735"></a>        if(!somethingDisplayed)
<a name="736"></a>            DMsg(hear nothing listen, '{I} hear{s/d} nothing out of the
<a name="737"></a>                ordinary.&lt;.p&gt;');
<a name="738"></a>
<a name="739"></a>        
<a name="740"></a>    }
<a name="741"></a>    
<a name="742"></a>    /* Do nothing in the core library; senseRegion.t will override if present */
<a name="743"></a>    getRemoteSoundList() { return []; }
<a name="744"></a>    
<a name="745"></a>    /* Do nothing in the core library; senseRegion.t will override if present */
<a name="746"></a>    listRemoteSounds(lst) { return nil; }
<a name="747"></a>;
<a name="748"></a>
<a name="749"></a>DefineIAction(Sleep)
<a name="750"></a>    execAction(cmd)
<a name="751"></a>    {
<a name="752"></a>        DMsg(no sleeping, 'This {dummy} {is} no time for sleeping. ');
<a name="753"></a>    }
<a name="754"></a>;
<a name="755"></a>
<a name="756"></a>
<a name="757"></a>
<a name="758"></a>GoIn: TravelAction
<a name="759"></a>    direction = inDir
<a name="760"></a>    predefinedDirection = true
<a name="761"></a>;
<a name="762"></a>
<a name="763"></a>GoOut: TravelAction
<a name="764"></a>    direction = outDir
<a name="765"></a>    predefinedDirection = true
<a name="766"></a>    
<a name="767"></a>    execAction(cmd)
<a name="768"></a>    {
<a name="769"></a>        if(!gActor.location.ofKind(Room))
<a name="770"></a>        {
<a name="771"></a>            local getOffAction;
<a name="772"></a>            getOffAction = gActor.location.contType == On ? GetOff : GetOutOf;
<a name="773"></a>            replaceAction(getOffAction, gActor.location);
<a name="774"></a>        }
<a name="775"></a>        else
<a name="776"></a>        {
<a name="777"></a>            "&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;";
<a name="778"></a>            doTravel();
<a name="779"></a>        }
<a name="780"></a>    }
<a name="781"></a>;
<a name="782"></a>
<a name="783"></a>/* 
<a name="784"></a> *   The GO action is never triggered directly by a player command but can be
<a name="785"></a> *   used to synthesize a travel action in the direction supplied by the dobj.
<a name="786"></a> */
<a name="787"></a>
<a name="788"></a>Go: TravelAction
<a name="789"></a>    predefinedDirection = true
<a name="790"></a>    
<a name="791"></a>    /* 
<a name="792"></a>     *   We need to test for and set the direction property in both execCycle() and execAction(),
<a name="793"></a>     *   since statements such as doInstead(Go, northDir) might execute the Go action via either
<a name="794"></a>     *   route (depending where called from).
<a name="795"></a>     */
<a name="796"></a>    execCycle(cmd)
<a name="797"></a>    {
<a name="798"></a>        if(direction == nil)
<a name="799"></a>            direction = cmd.dobj;
<a name="800"></a>        inherited(cmd);
<a name="801"></a>    }
<a name="802"></a>    
<a name="803"></a>    execAction(cmd)
<a name="804"></a>    {
<a name="805"></a>        if(direction == nil)
<a name="806"></a>            direction = cmd.dobj;
<a name="807"></a>        inherited(cmd);
<a name="808"></a>    }
<a name="809"></a>    
<a name="810"></a>    /* Define this so that this action can be called from execNestedAction */
<a name="811"></a>    resolvedObjectsInScope() { return true; }
<a name="812"></a>
<a name="813"></a>;
<a name="814"></a>    
<a name="815"></a>/* 
<a name="816"></a> *   Base class for special travel actions like CLIMB or JUMP or XYZZY which refer to similar-named
<a name="817"></a> *   properties on the current room without implying any particular direction. This is similar to
<a name="818"></a> *   TravelAction except that we define the property pointer on the action subclasses rather than
<a name="819"></a> *   any associated direction.
<a name="820"></a> *
<a name="821"></a> *   Note that concrete instances of SpecialTravelAction can normally be defined using the macro
<a name="822"></a> *.
<a name="823"></a> *   DefSpecialTravel(action, prop, voc);
<a name="824"></a> *.
<a name="825"></a> *   Where action is both the action name and the associated VerbRule tag, prop is a property
<a name="826"></a> *   pointer for the property we want to use on Room, and voc is the vocab/grammar we want to use to
<a name="827"></a> *   invoke the action, e.g.,
<a name="828"></a> *.
<a name="829"></a> *   DefSpecialTravel(Xyzzy, &amp;xyzzy, 'xyzzy') darkTravelAllowed = true;
<a name="830"></a> */    
<a name="831"></a> class SpecialTravelAction: IAction
<a name="832"></a>    baseActionClass = SpecialTravelAction
<a name="833"></a>        
<a name="834"></a>    /* 
<a name="835"></a>     *   Property pointer for The property defined on a Room that this action will match, e.g. &amp;jump
<a name="836"></a>     *   or &amp;xyxxy. Subclasses MUST override this to an appropriate value.
<a name="837"></a>     */
<a name="838"></a>    travelProp = nil
<a name="839"></a>    
<a name="840"></a>    /* 
<a name="841"></a>     *   Is rhis travel permitted in the dark? By default we don't permit this but subclasses can
<a name="842"></a>     *   override (for example if implememting travel via a magic work like XYZZY where light levels
<a name="843"></a>     *   may not be relevant).
<a name="844"></a>     */
<a name="845"></a>    darkTravelAllowed = nil
<a name="846"></a>    
<a name="847"></a>    /* 
<a name="848"></a>     *   Does the traveler need to be out of any nested room before travel can proceed? Normally
<a name="849"></a>     *   this will be the case.
<a name="850"></a>     */
<a name="851"></a>    requireOutOfNested = true
<a name="852"></a>  
<a name="853"></a>    
<a name="854"></a>    /* Carry out the travel (or other action) defined on our associated room property. */
<a name="855"></a>    execAction(cmd)
<a name="856"></a>    {
<a name="857"></a>        /* Note the current actor's room. */
<a name="858"></a>        local loc = gActor.getOutermostRoom;
<a name="859"></a>        local conn;
<a name="860"></a>        
<a name="861"></a>        /* 
<a name="862"></a>         *   If location isn't illuminated and dark travel isn't allowed, just call our
<a name="863"></a>         *   cannotGoThatWayInDark() method and stop there.
<a name="864"></a>         */
<a name="865"></a>        if(!loc.isIlluminated &amp;&amp; !darkTravelAllowed)
<a name="866"></a>        {
<a name="867"></a>            "&lt;&lt;loc.cannotGoThatWayInDarkMsg&gt;&gt;&lt;.p&gt;";
<a name="868"></a>            return;
<a name="869"></a>        }    
<a name="870"></a>        
<a name="871"></a>        /* 
<a name="872"></a>         *   Otherwise, if our location doesn't define our travelProp property or that property is
<a name="873"></a>         *   nil, call our fsllback() method and stop there.
<a name="874"></a>         */     
<a name="875"></a>        if(!loc.propDefined(travelProp) || loc.propType(travelProp) == nil)
<a name="876"></a>        {
<a name="877"></a>            fallback(loc);
<a name="878"></a>            return;
<a name="879"></a>        }
<a name="880"></a>        
<a name="881"></a>        /* 
<a name="882"></a>         *   Otherwise, carry out the action appropriate to the type of whatever's defined on our
<a name="883"></a>         *   locatoions travelProp property.
<a name="884"></a>         */
<a name="885"></a>        switch(loc.propType(travelProp))
<a name="886"></a>        {
<a name="887"></a>            /* If we're pointing to an apparent travel connector, carry out travel via that connector. */
<a name="888"></a>        case TypeObject:
<a name="889"></a>            conn = loc.(travelProp);
<a name="890"></a>            if(conn.ofKind(TravelConnector) &amp;&amp; conn.isConnectorApparent)
<a name="891"></a>            {
<a name="892"></a>                getOutOfNested(conn);
<a name="893"></a>                conn.travelVia(gActor);
<a name="894"></a>            }
<a name="895"></a>            else
<a name="896"></a>                /* If it's any other kind of object, just display our noGoodHereMsg. */
<a name="897"></a>                noGoodHereMsg;
<a name="898"></a>            break;
<a name="899"></a>            /* 
<a name="900"></a>             *   If we're pointing to a double quoted string or method, call the methor or display
<a name="901"></a>             *   the string.
<a name="902"></a>             */
<a name="903"></a>        case TypeDString:
<a name="904"></a>        case TypeCode:
<a name="905"></a>            /* Execute the method and store its return value. */
<a name="906"></a>            conn = loc.(travelProp);
<a name="907"></a>            
<a name="908"></a>            /* 
<a name="909"></a>             *   If the return value is a travel connector, carry out travel via that travel
<a name="910"></a>             *   connector.
<a name="911"></a>             */
<a name="912"></a>            if(objOfKind(conn, TravelConnector))
<a name="913"></a>            {
<a name="914"></a>                getOutOfNested(conn);
<a name="915"></a>                conn.travelVia(gActor);       
<a name="916"></a>            }
<a name="917"></a>            /* Otherwise let out noteRetval() method handle the value returned. */
<a name="918"></a>            else 
<a name="919"></a>                noteRetval(loc, conn);                                
<a name="920"></a>            break;
<a name="921"></a>            /* If we're pointing to a aingle-quoted string, simply display the string */
<a name="922"></a>        case TypeSString:
<a name="923"></a>            say(loc.travelProp);
<a name="924"></a>            break;
<a name="925"></a>            /* Otherwise, just display our noGoodHereMsg */
<a name="926"></a>        default:
<a name="927"></a>            noGoodHereMsg;
<a name="928"></a>            break;            
<a name="929"></a>        } 
<a name="930"></a>    }
<a name="931"></a>    
<a name="932"></a>    /* 
<a name="933"></a>     *   Our fallback() method to use if our travelProp does not point to a non-nil property defined
<a name="934"></a>     *   on the actor's currec location. By default we just display our noGoodHereMsg.
<a name="935"></a>     */
<a name="936"></a>    fallback(loc) { noGoodHereMsg; }
<a name="937"></a>    
<a name="938"></a>    
<a name="939"></a>    /* 
<a name="940"></a>     *   The message to display is travel is attempted in the dark from loc when dark travel is not
<a name="941"></a>     *   allowed.
<a name="942"></a>     */
<a name="943"></a>    connotTravelInDark(loc)
<a name="944"></a>    {
<a name="945"></a>        /* Call the location's cannotGoThatWayInDark() method to handle it. */
<a name="946"></a>        loc.cannotGoThatWayInDark(&amp;travelProp);
<a name="947"></a>    }
<a name="948"></a>    
<a name="949"></a>    /* 
<a name="950"></a>     *   The message to display when our travelProp doesn't point to anything usable in the current
<a name="951"></a>     *   location.
<a name="952"></a>     */
<a name="953"></a>    noGoodHereMsg = DMsg(doesnt work here, 'That doesn\'t work here. ')
<a name="954"></a>    
<a name="955"></a>    /* 
<a name="956"></a>     *   A chance to do something else with the return value of a method, triggered by travel,
<a name="957"></a>     *   defined on a direction property of a Room. loc is the room in question (where the travel
<a name="958"></a>     *   started from) and val is the return value from the method. The detault is to display the
<a name="959"></a>     *   val if val is a single-quoted string but do nothing otherwise, but game code can override.
<a name="960"></a>     */
<a name="961"></a>    noteRetval(loc, val)
<a name="962"></a>    {
<a name="963"></a>        if(dataType(val) == TypeSString)
<a name="964"></a>           say(val);
<a name="965"></a>    }
<a name="966"></a>    
<a name="967"></a>    /* Get our traveler out of any nested room it's in. */
<a name="968"></a>    getOutOfNested(conn)
<a name="969"></a>    {
<a name="970"></a>        /* 
<a name="971"></a>         *   If we requuire the traveler to be out of any nested room, delagate handling this to
<a name="972"></a>         *   TravelAction.
<a name="973"></a>         */
<a name="974"></a>        if(requireOutOfNested)
<a name="975"></a>            delegated TravelAction(conn);
<a name="976"></a>    }
<a name="977"></a>;
<a name="978"></a>
<a name="979"></a>
<a name="980"></a>DefineIAction(GetOut)
<a name="981"></a>    execAction(cmd)
<a name="982"></a>    {        
<a name="983"></a>        GoOut.execAction(cmd);
<a name="984"></a>    }
<a name="985"></a>;
<a name="986"></a>
<a name="987"></a>ClimbVague: SpecialTravelAction
<a name="988"></a>    travelProp = &amp;climb    
<a name="989"></a>    
<a name="990"></a>    fallback(loc) { askForDobj(Climb);  }
<a name="991"></a>;
<a name="992"></a>
<a name="993"></a>/* 
<a name="994"></a> *   We'll take STAND to be a request to get out of the actor's immediate
<a name="995"></a> *   container, unless the actor is directly in a room in which case we'll
<a name="996"></a> *   simply say that he is standing.
<a name="997"></a> */
<a name="998"></a>
<a name="999"></a>DefineIAction(Stand)
<a name="1000"></a>    execAction(cmd)
<a name="1001"></a>    {
<a name="1002"></a>        if(!gActor.location.ofKind(Room))
<a name="1003"></a>            replaceAction(GetOff, gActor.location);
<a name="1004"></a>        else
<a name="1005"></a>        {
<a name="1006"></a>            DMsg(already standing, '{I} {am} standing. ');
<a name="1007"></a>        }
<a name="1008"></a>        
<a name="1009"></a>    }
<a name="1010"></a>;
<a name="1011"></a>
<a name="1012"></a>
<a name="1013"></a>DefineIAction(Sit)
<a name="1014"></a>    execAction(cmd)
<a name="1015"></a>    {
<a name="1016"></a>        askForDobj(SitOn);          
<a name="1017"></a>    }
<a name="1018"></a>;
<a name="1019"></a>
<a name="1020"></a>DefineIAction(Lie)
<a name="1021"></a>    execAction(cmd)
<a name="1022"></a>    {
<a name="1023"></a>        askForDobj(LieOn);
<a name="1024"></a>    }   
<a name="1025"></a>;
<a name="1026"></a>
<a name="1027"></a>
<a name="1028"></a>Travel: TravelAction
<a name="1029"></a>    direction = (dirMatch.dir)
<a name="1030"></a>;
<a name="1031"></a>
<a name="1032"></a>DefineIAction(VagueTravel)
<a name="1033"></a>    execAction(cmd)
<a name="1034"></a>    {
<a name="1035"></a>        DMsg(vague travel, 'Which way do you want to go? ');       
<a name="1036"></a>    }
<a name="1037"></a>;
<a name="1038"></a>
<a name="1039"></a>
<a name="1040"></a>DefineIAction(GoBack)
<a name="1041"></a>    execAction(cmd)
<a name="1042"></a>    {
<a name="1043"></a>        local pathBack = nil;
<a name="1044"></a>        
<a name="1045"></a>        if(libGlobal.lastLoc == nil)
<a name="1046"></a>        {
<a name="1047"></a>            DMsg(nowhere back, '{I} {have} nowhere to go back to. ');
<a name="1048"></a>            return;            
<a name="1049"></a>        }
<a name="1050"></a>        
<a name="1051"></a>        pathBack = defined(routeFinder) ? 
<a name="1052"></a>             routeFinder.findPath(gActor.getOutermostRoom,
<a name="1053"></a>                libGlobal.lastLoc) : nil;
<a name="1054"></a>               
<a name="1055"></a>        
<a name="1056"></a>        if(pathBack == nil)
<a name="1057"></a>        {
<a name="1058"></a>            DMsg(no way back, 'There{dummy}{\'s} no way back. ');
<a name="1059"></a>            return;
<a name="1060"></a>        }
<a name="1061"></a>        
<a name="1062"></a>        if(pathBack.length == 1)
<a name="1063"></a>        {
<a name="1064"></a>            DMsg(already back there, '{I}{\'m} already there. ');
<a name="1065"></a>            return;
<a name="1066"></a>        }
<a name="1067"></a>        
<a name="1068"></a>        local dir = pathBack[2][1];
<a name="1069"></a>        
<a name="1070"></a>        DMsg(going back dir, '(going {1})\n', dir.name);
<a name="1071"></a>        
<a name="1072"></a>        gActor.getOutermostRoom.(dir.dirProp).travelVia(gActor);
<a name="1073"></a>        
<a name="1074"></a>    }
<a name="1075"></a>;
<a name="1076"></a>
<a name="1077"></a>DefineSystemAction(GoToMode)
<a name="1078"></a>    execAction(c)
<a name="1079"></a>    {
<a name="1080"></a>        local vp = c.verbProd;
<a name="1081"></a>        if(vp.brief_ != nil)
<a name="1082"></a>        {
<a name="1083"></a>            gameMain.briefGoTo = true;
<a name="1084"></a>            DMsg(brief goto, 'Goto mode is now brief (no room descriptions or stopping to CONTINUE)');
<a name="1085"></a>        }
<a name="1086"></a>        if(vp.fast_ != nil)
<a name="1087"></a>        {
<a name="1088"></a>            gameMain.briefGoTo = nil;
<a name="1089"></a>            gameMain.fastGoTo = true;
<a name="1090"></a>            DMsg(brief goto, 'Goto mode is now fast (no stopping to CONTINUE)');
<a name="1091"></a>        }
<a name="1092"></a>        if(vp.normal_ != nil)
<a name="1093"></a>        {
<a name="1094"></a>            gameMain.briefGoTo = nil;
<a name="1095"></a>            gameMain.fastGoTo = nil;
<a name="1096"></a>            DMsg(brief goto, 'Goto mode is now normal (explicit CONTINUE needed for each step)');
<a name="1097"></a>        }       
<a name="1098"></a>        
<a name="1099"></a>    }
<a name="1100"></a>;
<a name="1101"></a>
<a name="1102"></a>DefineTAction(GoTo)
<a name="1103"></a>    
<a name="1104"></a>    /* Add all known items to scope */
<a name="1105"></a>    addExtraScopeItems(whichRole?)
<a name="1106"></a>    {
<a name="1107"></a>       scopeList = scopeList.appendUnique(Q.knownScopeList);
<a name="1108"></a>    }
<a name="1109"></a>    
<a name="1110"></a>    againRepeatsParse = nil
<a name="1111"></a>    
<a name="1112"></a>    reportImplicitActions = nil
<a name="1113"></a>;
<a name="1114"></a>
<a name="1115"></a>DefineIAction(Continue)
<a name="1116"></a>    execAction(cmd)
<a name="1117"></a>    {
<a name="1118"></a>        local path;
<a name="1119"></a>        path = defined(pcRouteFinder) ? pcRouteFinder.cachedRoute : nil;
<a name="1120"></a>        if(path == nil)
<a name="1121"></a>        {
<a name="1122"></a>            DMsg(no journey, '{I}{\'m} not going anywhere. ');
<a name="1123"></a>            return;
<a name="1124"></a>        }
<a name="1125"></a>        
<a name="1126"></a>        local idx = path.indexWhich({x: x[2] == gActor.getOutermostRoom});
<a name="1127"></a>        
<a name="1128"></a>        if(idx == nil)
<a name="1129"></a>        {
<a name="1130"></a>            path = defined(pcRouteFinder) ?
<a name="1131"></a>                pcRouteFinder.findPath(gActor.getOutermostRoom,
<a name="1132"></a>                                       pcRouteFinder.currentDestination) : nil;
<a name="1133"></a>            
<a name="1134"></a>            if(path == nil)
<a name="1135"></a>            {
<a name="1136"></a>                DMsg(off route, '{I}{\'m} no longer on {my} route. Use the GO TO
<a name="1137"></a>                    command to set up a new route. ');
<a name="1138"></a>                return;
<a name="1139"></a>            }
<a name="1140"></a>            else
<a name="1141"></a>                idx = 1;                
<a name="1142"></a>        }
<a name="1143"></a>        
<a name="1144"></a>        if(idx == path.length)
<a name="1145"></a>        {
<a name="1146"></a>            say(gActor.getOutermostRoom.alreadyThereMsg);
<a name="1147"></a>            return;
<a name="1148"></a>        }
<a name="1149"></a>        
<a name="1150"></a>        local dir = path[idx + 1][1];
<a name="1151"></a>        
<a name="1152"></a>        takeStep(dir, path[path.length][2]);
<a name="1153"></a>        
<a name="1154"></a>        
<a name="1155"></a>    }
<a name="1156"></a>    
<a name="1157"></a>    takeStep(dir, dest, fastGo?)    
<a name="1158"></a>    {
<a name="1159"></a>        
<a name="1160"></a>        local path = defined(pcRouteFinder) ? pcRouteFinder.cachedRoute : nil;
<a name="1161"></a>        
<a name="1162"></a>        local idx = path.indexWhich({x: x[2] == gActor.getOutermostRoom});
<a name="1163"></a>        /* 
<a name="1164"></a>         *   If we are in fastGo mode and we want each step of the journey to take a turn, then
<a name="1165"></a>         *   carry out the before action processing, provided it's not the first step when the
<a name="1166"></a>         *   GO TO command would have triggered its own action processing.
<a name="1167"></a>         */
<a name="1168"></a>        if(fastGo &amp;&amp; turnPerStep &amp;&amp; idx &amp;&amp; idx &gt; 1)
<a name="1169"></a>        {
<a name="1170"></a>            beforeAction();            
<a name="1171"></a>        }
<a name="1172"></a>        
<a name="1173"></a>        /* Report which way we're going in our next step. */
<a name="1174"></a>        DMsg(going dir, '(going {1})\n', dir.name);
<a name="1175"></a>        
<a name="1176"></a>        /* 
<a name="1177"></a>         *   Note where the actor is before we attempt to move the actor so we can check whether the
<a name="1178"></a>         *   next step succeeded.
<a name="1179"></a>         */
<a name="1180"></a>        local oldLoc = gActor.getOutermostRoom;
<a name="1181"></a>        
<a name="1182"></a>        /* Attempt to move the actor in the direction dictated by our next step. */
<a name="1183"></a>        gActor.getOutermostRoom.(dir.dirProp).travelVia(gActor);
<a name="1184"></a>        
<a name="1185"></a>        /* 
<a name="1186"></a>         *   If the actor hasn't changed room then there's a barrier to travel so we'd better stop
<a name="1187"></a>         *   there.
<a name="1188"></a>         */
<a name="1189"></a>        if(gActor.getOutermostRoom == oldLoc)
<a name="1190"></a>            exit;
<a name="1191"></a>        
<a name="1192"></a>        if(!gActor.isIn(dest) &amp;&amp; !fastGo)           
<a name="1193"></a>        {
<a name="1194"></a>            htmlSay(contMsg);
<a name="1195"></a>            if(!optionsExplained)
<a name="1196"></a>            {
<a name="1197"></a>                explainOptions();
<a name="1198"></a>                optionsExplained = true;
<a name="1199"></a>            }
<a name="1200"></a>        }
<a name="1201"></a>        
<a name="1202"></a>        /* 
<a name="1203"></a>         *   If we are in fastGo mode and we want each step of the journey to take a turn, then
<a name="1204"></a>         *   carry out the end of turn processing, unless we are taking the final step, in which
<a name="1205"></a>         *   case we should get the end of turn processing from the originating GO TO commsnd.
<a name="1206"></a>         */
<a name="1207"></a>        if(fastGo &amp;&amp; turnPerStep &amp;&amp; idx &amp;&amp; idx &lt; path.length - 1)
<a name="1208"></a>        {
<a name="1209"></a>            afterAction();
<a name="1210"></a>            turnSequence();
<a name="1211"></a>        }
<a name="1212"></a>        
<a name="1213"></a>    }
<a name="1214"></a>    
<a name="1215"></a>    /* 
<a name="1216"></a>     *   Flag - do we want each step of the way to count as one turn when we're in fastGo mode? In
<a name="1217"></a>     *   default we do but game code can override this by setting turnPerStep to nil.
<a name="1218"></a>     */
<a name="1219"></a>    turnPerStep = true
<a name="1220"></a>    
<a name="1221"></a>    contMsg =  BMsg(explain continue, 'To continue the journey
<a name="1222"></a>                use the command
<a name="1223"></a>                &lt;&lt;aHref('Continue','CONTINUE','Continue')&gt;&gt; or C. ')
<a name="1224"></a>    
<a name="1225"></a> 
<a name="1226"></a>    optionsExcplained = nil
<a name="1227"></a>    
<a name="1228"></a>    explainOptions()
<a name="1229"></a>    {
<a name="1230"></a>        DMsg(explain goto options, '&lt;.p&gt;&lt;.parser&gt;To enable swift GO TO without CONTINUE, use GOTO
<a name="1231"></a>            MODE FAST or GOTO MODE BRIEF (the latter suppresses the room descriptions of the rooms
<a name="1232"></a>            along the way). To resume the use of CONTINUE use GOTO MODE CONTINUE. Any change of mode
<a name="1233"></a>            will take effect on the next GO TO command.&lt;./parser&gt; ');
<a name="1234"></a>    }
<a name="1235"></a>;
<a name="1236"></a>
<a name="1237"></a>DefineSystemAction(Topics)
<a name="1238"></a>    execAction(cmd)
<a name="1239"></a>    {
<a name="1240"></a>        local otherActor = gPlayerChar.currentInterlocutor;
<a name="1241"></a>        
<a name="1242"></a>        if(otherActor == nil)
<a name="1243"></a>            DMsg(no interlocutor, '{I}{\'m} not talking to anyone. ');
<a name="1244"></a>        else
<a name="1245"></a>        {            
<a name="1246"></a>            otherActor.showSuggestions(true);
<a name="1247"></a>        }
<a name="1248"></a>    }
<a name="1249"></a>    
<a name="1250"></a>    afterAction() {}
<a name="1251"></a>;
<a name="1252"></a>    
<a name="1253"></a>
<a name="1254"></a>DefineTAction(Examine)
<a name="1255"></a>    announceMultiAction = true
<a name="1256"></a>    
<a name="1257"></a>    getAll(cmd, role)
<a name="1258"></a>    {
<a name="1259"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="1260"></a>    }
<a name="1261"></a>
<a name="1262"></a>    againRepeatsParse = nil
<a name="1263"></a>;
<a name="1264"></a>
<a name="1265"></a>/* 
<a name="1266"></a> *   The ExamineOrGoTo action is used as the default action by the Parser; it is
<a name="1267"></a> *   not an action the player can directly command. If the player enters a room
<a name="1268"></a> *   (and nothing else) on the command line, and the room is known to the player
<a name="1269"></a> *   character, and the player character is not already in the room, the command
<a name="1270"></a> *   will be treated as a GoTo action; otherwise it will be treated as an
<a name="1271"></a> *   Examine action.
<a name="1272"></a> */
<a name="1273"></a>   
<a name="1274"></a>DefineTAction(ExamineOrGoTo)
<a name="1275"></a>    exec(cmd)
<a name="1276"></a>    {        
<a name="1277"></a>        if(defined(pcRouteFinder) &amp;&amp; cmd.dobj.ofKind(Room)
<a name="1278"></a>           &amp;&amp; !cmd.actor.isIn(cmd.dobj))        
<a name="1279"></a>            cmd.action = GoTo;
<a name="1280"></a>        else
<a name="1281"></a>            cmd.action = Examine;
<a name="1282"></a>        
<a name="1283"></a>        gAction = cmd.action;
<a name="1284"></a>        gAction.reset();
<a name="1285"></a>        gAction.exec(cmd);     
<a name="1286"></a>    }
<a name="1287"></a>    
<a name="1288"></a>    
<a name="1289"></a>    /* For this action to work all known rooms also need to be in scope */
<a name="1290"></a>    addExtraScopeItems(whichRole?)
<a name="1291"></a>    {
<a name="1292"></a>        scopeList = scopeList.appendUnique(Q.knownScopeList.subset({x:
<a name="1293"></a>            x.ofKind(Room)}));
<a name="1294"></a>    }
<a name="1295"></a>    
<a name="1296"></a>    
<a name="1297"></a>;
<a name="1298"></a>
<a name="1299"></a>DefineTAction(Follow)
<a name="1300"></a>    againRepeatsParse = nil   
<a name="1301"></a>;
<a name="1302"></a>
<a name="1303"></a>
<a name="1304"></a>DefineTAction(Read)
<a name="1305"></a>    announceMultiAction = true
<a name="1306"></a>    
<a name="1307"></a>    getAll(cmd, role)
<a name="1308"></a>    {
<a name="1309"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="1310"></a>    }
<a name="1311"></a>
<a name="1312"></a>    againRepeatsParse = nil
<a name="1313"></a>;
<a name="1314"></a>
<a name="1315"></a>DefineTAction(SmellSomething)
<a name="1316"></a>    announceMultiAction = true
<a name="1317"></a>    againRepeatsParse = nil
<a name="1318"></a>    
<a name="1319"></a>    /* Add any Odors the actor can smell */
<a name="1320"></a>    addExtraScopeItems(whichRole?)
<a name="1321"></a>    {
<a name="1322"></a>        if(defined(Odor))
<a name="1323"></a>        {
<a name="1324"></a>            local odorList = gActor.getOutermostRoom.allContents.subset(
<a name="1325"></a>                { o: o.isOdor &amp;&amp; Q.canSmell(gActor, o) } );
<a name="1326"></a>            
<a name="1327"></a>            scopeList = scopeList.appendUnique(odorList);
<a name="1328"></a>        }
<a name="1329"></a>    }
<a name="1330"></a>    
<a name="1331"></a>;
<a name="1332"></a>
<a name="1333"></a>DefineTAction(ListenTo)
<a name="1334"></a>    announceMultiAction = true
<a name="1335"></a>    againRepeatsParse = nil
<a name="1336"></a>    
<a name="1337"></a>    /* Add any Noises the actor can hear */
<a name="1338"></a>    addExtraScopeItems(whichRole?)
<a name="1339"></a>    {
<a name="1340"></a>        if(defined(Noise))
<a name="1341"></a>        {
<a name="1342"></a>            local noiseList = gActor.getOutermostRoom.allContents.subset(
<a name="1343"></a>                { n: n.isNoise &amp;&amp; Q.canHear(gActor, n) } );
<a name="1344"></a>            
<a name="1345"></a>            scopeList = scopeList.appendUnique(noiseList);
<a name="1346"></a>        }
<a name="1347"></a>    }    
<a name="1348"></a>    
<a name="1349"></a>;
<a name="1350"></a>
<a name="1351"></a>DefineTAction(Taste)
<a name="1352"></a>    announceMultiAction = true
<a name="1353"></a>    getAll(cmd, role)
<a name="1354"></a>    {
<a name="1355"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="1356"></a>    }
<a name="1357"></a>    againRepeatsParse = nil
<a name="1358"></a>;
<a name="1359"></a>
<a name="1360"></a>DefineTAction(Feel)
<a name="1361"></a>    announceMultiAction = true
<a name="1362"></a>    getAll(cmd, role)
<a name="1363"></a>    {
<a name="1364"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="1365"></a>    }
<a name="1366"></a>    againRepeatsParse = nil
<a name="1367"></a>;
<a name="1368"></a>
<a name="1369"></a>
<a name="1370"></a>DefineTAction(Touch)
<a name="1371"></a>    announceMultiAction = true
<a name="1372"></a>    getAll(cmd, role)
<a name="1373"></a>    {
<a name="1374"></a>        return scopeList.subset({ x: !x.ofKind(Room)});
<a name="1375"></a>    }
<a name="1376"></a>    againRepeatsParse = nil
<a name="1377"></a>;
<a name="1378"></a>
<a name="1379"></a>DefineTAction(Take)
<a name="1380"></a>    
<a name="1381"></a>    getAll(cmd, role)
<a name="1382"></a>    {
<a name="1383"></a>        return scopeList.subset({ x: !x.isDirectlyIn(cmd.actor) &amp;&amp; !x.isFixed});
<a name="1384"></a>    }
<a name="1385"></a>    
<a name="1386"></a>    
<a name="1387"></a>    announceMultiAction = nil
<a name="1388"></a>    allowAll = true
<a name="1389"></a>   
<a name="1390"></a>;
<a name="1391"></a>
<a name="1392"></a>DefineTAction(Drop)      
<a name="1393"></a>    allowAll = true
<a name="1394"></a>    
<a name="1395"></a>    getAll(cmd, role)
<a name="1396"></a>    {
<a name="1397"></a>        return scopeList.subset({ x: x.isDirectlyIn(cmd.actor) &amp;&amp; !x.isFixed});
<a name="1398"></a>    }  
<a name="1399"></a>;
<a name="1400"></a>
<a name="1401"></a>DefineTAction(Throw)
<a name="1402"></a>    getAll(cmd, role)
<a name="1403"></a>    {
<a name="1404"></a>        return scopeList.subset({ x: !x.isFixed});
<a name="1405"></a>    }   
<a name="1406"></a>;
<a name="1407"></a>
<a name="1408"></a>
<a name="1409"></a>DefineTAction(Attack)
<a name="1410"></a>    againRepeatsParse = nil
<a name="1411"></a>;
<a name="1412"></a>
<a name="1413"></a>DefineTAction(Strike)
<a name="1414"></a>    againRepeatsParse = nil
<a name="1415"></a>;
<a name="1416"></a>
<a name="1417"></a>DefineTAction(Open)       
<a name="1418"></a>;
<a name="1419"></a>
<a name="1420"></a>DefineTAction(Close)        
<a name="1421"></a>;
<a name="1422"></a>
<a name="1423"></a>DefineTAction(LookIn)  
<a name="1424"></a>    againRepeatsParse = nil
<a name="1425"></a>;
<a name="1426"></a>
<a name="1427"></a>DefineTAction(LookUnder)    
<a name="1428"></a>    againRepeatsParse = nil
<a name="1429"></a>;
<a name="1430"></a>
<a name="1431"></a>DefineTAction(LookBehind)
<a name="1432"></a>    againRepeatsParse = nil
<a name="1433"></a>;
<a name="1434"></a>
<a name="1435"></a>DefineTAction(LookThrough)
<a name="1436"></a>    againRepeatsParse = nil
<a name="1437"></a>;
<a name="1438"></a>
<a name="1439"></a>DefineIAction(LookDir)
<a name="1440"></a>    baseActionClaas = LookDir    
<a name="1441"></a>       
<a name="1442"></a>    execAction(cmd)
<a name="1443"></a>    {   
<a name="1444"></a>        if(!handleLookIn())
<a name="1445"></a>            sayNoNeedToLookDir();
<a name="1446"></a>    }
<a name="1447"></a>    /* 
<a name="1448"></a>     *   If the command was LOOK IN then ask the player what they want to look in, otherwise simply
<a name="1449"></a>     *   return nil. 
<a name="1450"></a>     */
<a name="1451"></a>    handleLookIn()
<a name="1452"></a>    {
<a name="1453"></a>        if(direction == inDir)            
<a name="1454"></a>        {
<a name="1455"></a>            inLook();        
<a name="1456"></a>            return true;
<a name="1457"></a>        }
<a name="1458"></a>        return nil;            
<a name="1459"></a>    }
<a name="1460"></a>    
<a name="1461"></a>    /* 
<a name="1462"></a>     *   The command LOOK IN without an object is unlikely to make sense, so we ask the player to
<a name="1463"></a>     *   supply the missing direct object,
<a name="1464"></a>     */
<a name="1465"></a>    inLook()  { askForDobj(LookIn); }   
<a name="1466"></a>    
<a name="1467"></a>    sayNoNeedToLookDir()
<a name="1468"></a>    {
<a name="1469"></a>        DMsg(no need to lookdir, '&lt;.parser&gt;{There}{\'s} no need to look in particular directions
<a name="1470"></a>            {here}.&lt;./parser&gt;');
<a name="1471"></a>        abort;
<a name="1472"></a>    }
<a name="1473"></a>    
<a name="1474"></a>    direction = nil
<a name="1475"></a>;
<a name="1476"></a>
<a name="1477"></a>DefineIAction(LookDir2)    
<a name="1478"></a>    execAction(cmd)
<a name="1479"></a>    {
<a name="1480"></a>        LookDir.execAction(cmd);
<a name="1481"></a>        "&lt;.p&gt;";
<a name="1482"></a>        cmd.verbProd.dirMatch = cmd.verbProd.dirMatch2;                 
<a name="1483"></a>        LookDir.execAction(cmd);
<a name="1484"></a>    }
<a name="1485"></a>;
<a name="1486"></a>
<a name="1487"></a>
<a name="1488"></a>DefineTAction(Unlock)    
<a name="1489"></a>;
<a name="1490"></a>
<a name="1491"></a>DefineTAction(Lock)        
<a name="1492"></a>;
<a name="1493"></a>
<a name="1494"></a>DefineTAction(SwitchOn)        
<a name="1495"></a>;
<a name="1496"></a>
<a name="1497"></a>DefineTAction(SwitchOff)        
<a name="1498"></a>;
<a name="1499"></a>
<a name="1500"></a>DefineTAction(Turn)  
<a name="1501"></a>    againRepeatsParse = nil
<a name="1502"></a>;
<a name="1503"></a>
<a name="1504"></a>DefineTAction(Wear)       
<a name="1505"></a>;
<a name="1506"></a>
<a name="1507"></a>DefineTAction(Doff)    
<a name="1508"></a>    allowAll = true    
<a name="1509"></a>    
<a name="1510"></a>    getAll(cmd, role)
<a name="1511"></a>    {
<a name="1512"></a>        return scopeList.subset({ x: x.wornBy == gActor});
<a name="1513"></a>    }
<a name="1514"></a>;
<a name="1515"></a>
<a name="1516"></a>DefineIAction(TakeOff)
<a name="1517"></a>    execAction(c)
<a name="1518"></a>    {
<a name="1519"></a>        DMsg(not a bird, '{I} {\'m} not a bird or a plane. ');
<a name="1520"></a>        
<a name="1521"></a>        /* 
<a name="1522"></a>         *   Some game authors may prefer to comment out the line above and use the one below
<a name="1523"></a>         *   instead.
<a name="1524"></a>         */
<a name="1525"></a>//        askForDobj(Doff);
<a name="1526"></a>    }   
<a name="1527"></a>;
<a name="1528"></a>
<a name="1529"></a>DefineTAction(Break)
<a name="1530"></a>    againRepeatsParse = nil
<a name="1531"></a>;
<a name="1532"></a>
<a name="1533"></a>DefineTAction(Climb)       
<a name="1534"></a>;
<a name="1535"></a>
<a name="1536"></a>DefineTAction(ClimbUp)      
<a name="1537"></a>;
<a name="1538"></a>
<a name="1539"></a>DefineTAction(ClimbDown)        
<a name="1540"></a>;
<a name="1541"></a>
<a name="1542"></a>DefineTAction(Board)        
<a name="1543"></a>;
<a name="1544"></a>
<a name="1545"></a>DefineTAction(StandOn)   
<a name="1546"></a>;
<a name="1547"></a>
<a name="1548"></a>DefineTAction(SitOn)    
<a name="1549"></a>;
<a name="1550"></a>
<a name="1551"></a>DefineTAction(LieOn)    
<a name="1552"></a>;
<a name="1553"></a>
<a name="1554"></a>
<a name="1555"></a>DefineTAction(StandIn)    
<a name="1556"></a>;
<a name="1557"></a>
<a name="1558"></a>DefineTAction(SitIn)    
<a name="1559"></a>;
<a name="1560"></a>
<a name="1561"></a>DefineTAction(LieIn)   
<a name="1562"></a>;
<a name="1563"></a>
<a name="1564"></a>DefineTAction(Enter)   
<a name="1565"></a>;
<a name="1566"></a>
<a name="1567"></a>DefineTAction(GetOff)        
<a name="1568"></a>;
<a name="1569"></a>
<a name="1570"></a>DefineTAction(GetOutOf)    
<a name="1571"></a>;
<a name="1572"></a>    
<a name="1573"></a>DefineTAction(GoThrough)    
<a name="1574"></a>;
<a name="1575"></a>
<a name="1576"></a>DefineTAction(GoAlong)    
<a name="1577"></a>;
<a name="1578"></a>
<a name="1579"></a>DefineTAction(TravelVia)
<a name="1580"></a>;
<a name="1581"></a>
<a name="1582"></a>DefineTAction(Push)
<a name="1583"></a>    againRepeatsParse = nil
<a name="1584"></a>;
<a name="1585"></a>
<a name="1586"></a>DefineTAction(Pull)
<a name="1587"></a>    againRepeatsParse = nil
<a name="1588"></a>;
<a name="1589"></a>
<a name="1590"></a>DefineTAction(Search)
<a name="1591"></a>    againRepeatsParse = nil
<a name="1592"></a>;
<a name="1593"></a>
<a name="1594"></a>DefineTAction(Remove)
<a name="1595"></a>    againRepeatsParse = nil
<a name="1596"></a>;
<a name="1597"></a>
<a name="1598"></a>DefineTAction(Move)
<a name="1599"></a>    againRepeatsParse = nil
<a name="1600"></a>;
<a name="1601"></a>    
<a name="1602"></a>DefineTAction(Light)   
<a name="1603"></a>;
<a name="1604"></a>
<a name="1605"></a>DefineTAction(Extinguish)    
<a name="1606"></a>;
<a name="1607"></a>
<a name="1608"></a>DefineTAction(Eat)
<a name="1609"></a>;
<a name="1610"></a>
<a name="1611"></a>DefineTAction(Drink)
<a name="1612"></a>;
<a name="1613"></a>
<a name="1614"></a>DefineTAction(Clean)
<a name="1615"></a>    againRepeatsParse = nil
<a name="1616"></a>;
<a name="1617"></a>
<a name="1618"></a>DefineTAction(Dig)
<a name="1619"></a>    againRepeatsParse = nil
<a name="1620"></a>;
<a name="1621"></a>
<a name="1622"></a>DefineTAction(Kiss)
<a name="1623"></a>    againRepeatsParse = nil
<a name="1624"></a>;
<a name="1625"></a>
<a name="1626"></a>DefineTAction(Detach)
<a name="1627"></a>    getAll(cmd, role)
<a name="1628"></a>    {
<a name="1629"></a>        return scopeList.subset({ x: x.attachedTo != nil});
<a name="1630"></a>    }
<a name="1631"></a>;
<a name="1632"></a>
<a name="1633"></a>DefineTIAction(DigWith)
<a name="1634"></a>    resolveIobjFirst = nil
<a name="1635"></a>    againRepeatsParse = nil
<a name="1636"></a>;
<a name="1637"></a>
<a name="1638"></a>DefineTIAction(CleanWith)
<a name="1639"></a>    resolveIobjFirst = nil
<a name="1640"></a>    againRepeatsParse = nil
<a name="1641"></a>;
<a name="1642"></a>
<a name="1643"></a>DefineTIAction(MoveTo)
<a name="1644"></a>    resolveIobjFirst = nil
<a name="1645"></a>    getAll(cmd, role)
<a name="1646"></a>    {
<a name="1647"></a>        if(role==DirectObject)            
<a name="1648"></a>            return scopeList.subset({ x: x.isMoveable});
<a name="1649"></a>        else
<a name="1650"></a>            return inherited(cmd, role);
<a name="1651"></a>    }
<a name="1652"></a>    againRepeatsParse = nil
<a name="1653"></a>;
<a name="1654"></a>
<a name="1655"></a>DefineTIAction(MoveAwayFrom)    
<a name="1656"></a>    resolveIobjFirst = nil
<a name="1657"></a>    
<a name="1658"></a>    getAll(cmd, role)
<a name="1659"></a>    {
<a name="1660"></a>        if(role==DirectObject)            
<a name="1661"></a>            return scopeList.subset({ x: x.isMoveable &amp;&amp; x.movedTo != nil});
<a name="1662"></a>        else
<a name="1663"></a>            return inherited(cmd, role);
<a name="1664"></a>    }
<a name="1665"></a>    againRepeatsParse = nil
<a name="1666"></a>;
<a name="1667"></a>
<a name="1668"></a>DefineTIAction(MoveWith)
<a name="1669"></a>    resolveIobjFirst = nil
<a name="1670"></a>    
<a name="1671"></a>    getAll(cmd, role)
<a name="1672"></a>    {
<a name="1673"></a>        return scopeList.subset({ x: x.isMoveable});
<a name="1674"></a>    }
<a name="1675"></a>    againRepeatsParse = nil
<a name="1676"></a>;
<a name="1677"></a>
<a name="1678"></a>DefineTIAction(PutOn)       
<a name="1679"></a>    announceMultiAction = nil
<a name="1680"></a>    allowAll = true
<a name="1681"></a>    getAll(cmd, role)   
<a name="1682"></a>    {
<a name="1683"></a>        return putAllScope(curIobj, scopeList);
<a name="1684"></a>    }
<a name="1685"></a>;
<a name="1686"></a>
<a name="1687"></a>/* 
<a name="1688"></a> *   Return a suitable list of direct objects for a PUT ALL PREP XXX command,
<a name="1689"></a> *   where iobj is the indirect object of the command and slist is the full
<a name="1690"></a> *   scopelist for the action.
<a name="1691"></a> *
<a name="1692"></a> *   Ideally we want to return a list of all the objects that can be put in
<a name="1693"></a> *   iobj, namely all the objects in scope that are portable and not already in
<a name="1694"></a> *   iobj, and not the iobj. But if no objects fit the bill we have to fall back
<a name="1695"></a> *   on first, all portable objects in scope and, failing that, all objects in
<a name="1696"></a> *   scope except the room and the actor.
<a name="1697"></a> */
<a name="1698"></a>
<a name="1699"></a>putAllScope(iobj, slist)
<a name="1700"></a>{
<a name="1701"></a>    /* Get a list of all the portable objects in scope. */
<a name="1702"></a>    local portables = slist.subset({x: !x.isFixed});
<a name="1703"></a>    
<a name="1704"></a>    /* If there are none, return the scope list less the actor and any rooms */
<a name="1705"></a>    if(portables.length &lt; 1)
<a name="1706"></a>        return slist.subset({x: !x.ofKind(Room) &amp;&amp; x != gActor});
<a name="1707"></a>    
<a name="1708"></a>    /* 
<a name="1709"></a>     *   Get a list of suitable objects, i.e. portable objects that are not in
<a name="1710"></a>     *   the iobj and are not the iobj.
<a name="1711"></a>     */
<a name="1712"></a>    local suitables = portables.subset({x: iobj == nil || !x.isOrIsIn(iobj)});
<a name="1713"></a>    
<a name="1714"></a>    /* if there's anything in this list, return it */
<a name="1715"></a>    if(suitables.length &gt; 0)
<a name="1716"></a>        return suitables;
<a name="1717"></a>    
<a name="1718"></a>    /* Otherwise return the list of portable objects. */
<a name="1719"></a>    
<a name="1720"></a>    return portables;
<a name="1721"></a>}
<a name="1722"></a>
<a name="1723"></a>
<a name="1724"></a>DefineTIAction(PutIn)          
<a name="1725"></a>    announceMultiAction = nil
<a name="1726"></a>    allowAll = true
<a name="1727"></a>    
<a name="1728"></a>    getAll(cmd, role)   
<a name="1729"></a>    {
<a name="1730"></a>        return putAllScope(curIobj, scopeList);
<a name="1731"></a>    }
<a name="1732"></a>    
<a name="1733"></a>; 
<a name="1734"></a>
<a name="1735"></a>
<a name="1736"></a>
<a name="1737"></a>
<a name="1738"></a>DefineTIAction(PutUnder)      
<a name="1739"></a>    announceMultiAction = nil
<a name="1740"></a>    allowAll = true
<a name="1741"></a>    
<a name="1742"></a>    getAll(cmd, role)   
<a name="1743"></a>    {
<a name="1744"></a>        return putAllScope(curIobj, scopeList);
<a name="1745"></a>    }
<a name="1746"></a>;
<a name="1747"></a>
<a name="1748"></a>DefineTIAction(PutBehind)      
<a name="1749"></a>    announceMultiAction = nil
<a name="1750"></a>    allowAll = true
<a name="1751"></a>    
<a name="1752"></a>    getAll(cmd, role)   
<a name="1753"></a>    {
<a name="1754"></a>        return putAllScope(curIobj, scopeList);
<a name="1755"></a>    }
<a name="1756"></a>;
<a name="1757"></a>
<a name="1758"></a>
<a name="1759"></a>
<a name="1760"></a>DefineTIAction(UnlockWith)      
<a name="1761"></a>    resolveIobjFirst = nil
<a name="1762"></a>;
<a name="1763"></a>
<a name="1764"></a>DefineTIAction(LockWith)      
<a name="1765"></a>    resolveIobjFirst = nil
<a name="1766"></a>;
<a name="1767"></a>
<a name="1768"></a>DefineTAction(Attach)
<a name="1769"></a>;
<a name="1770"></a>
<a name="1771"></a>DefineTIAction(AttachTo)    
<a name="1772"></a>    resolveIobjFirst = nil
<a name="1773"></a>;
<a name="1774"></a>
<a name="1775"></a>DefineTIAction(DetachFrom)    
<a name="1776"></a>    getAll(cmd, role)
<a name="1777"></a>    {
<a name="1778"></a>        return scopeList.subset({ x: x.attachedTo == curIobj});
<a name="1779"></a>    }
<a name="1780"></a>;
<a name="1781"></a>
<a name="1782"></a>DefineTIAction(FastenTo)     
<a name="1783"></a>    resolveIobjFirst = nil
<a name="1784"></a>;
<a name="1785"></a>
<a name="1786"></a>DefineTIAction(TurnWith)
<a name="1787"></a>    resolveIobjFirst = nil
<a name="1788"></a>    againRepeatsParse = nil
<a name="1789"></a>;
<a name="1790"></a>
<a name="1791"></a>DefineTAction(Cut)
<a name="1792"></a>;
<a name="1793"></a>
<a name="1794"></a>DefineTIAction(CutWith)
<a name="1795"></a>    resolveIobjFirst = nil
<a name="1796"></a>    againRepeatsParse = nil
<a name="1797"></a>;
<a name="1798"></a>
<a name="1799"></a>DefineTIAction(TakeFrom)    
<a name="1800"></a>    /* 
<a name="1801"></a>     *   If the command matched ALL filter out dobjs that aren't in the iobj by
<a name="1802"></a>     *   not executing the command for them.
<a name="1803"></a>     */
<a name="1804"></a>    
<a name="1805"></a>    exec(cmd)
<a name="1806"></a>    {
<a name="1807"></a>        if(!cmd.matchedAll || cmd.iobj.notionalContents.indexOf(cmd.dobj) != nil)
<a name="1808"></a>            inherited(cmd);
<a name="1809"></a>        
<a name="1810"></a>        /* Otherwise note the current dobj in any case */
<a name="1811"></a>        else 
<a name="1812"></a>            curDobj = cmd.dobj;
<a name="1813"></a>    }
<a name="1814"></a>    
<a name="1815"></a>    reportAction()
<a name="1816"></a>    {
<a name="1817"></a>        if(reportList.length &gt; 0)
<a name="1818"></a>            inherited;
<a name="1819"></a>        
<a name="1820"></a>        /* 
<a name="1821"></a>         *   If the player tried to TAKE ALL FRMO IOBJ and there was nothing to
<a name="1822"></a>         *   take we need to report this
<a name="1823"></a>         */
<a name="1824"></a>        else if(gCommand.matchedAll)
<a name="1825"></a>            DMsg(nothing to take, 'There{dummy}{\'s} nothing available to
<a name="1826"></a>                    take from {1}. ', gCommand.iobj.theName);
<a name="1827"></a>    }
<a name="1828"></a>    
<a name="1829"></a>    getAll(cmd, role)
<a name="1830"></a>    {        
<a name="1831"></a>        return scopeList.subset({ x: !x.isFixed});
<a name="1832"></a>    }
<a name="1833"></a>    
<a name="1834"></a>    allowAll = true
<a name="1835"></a>    
<a name="1836"></a>    
<a name="1837"></a>;
<a name="1838"></a>
<a name="1839"></a>DefineTIAction(ThrowAt)    
<a name="1840"></a>    resolveIobjFirst = nil
<a name="1841"></a>;
<a name="1842"></a>
<a name="1843"></a>DefineTIAction(ThrowTo)    
<a name="1844"></a>    resolveIobjFirst = nil
<a name="1845"></a>;
<a name="1846"></a>
<a name="1847"></a>DefineTIAction(AttackWith)
<a name="1848"></a>    resolveIobjFirst = nil
<a name="1849"></a>    againRepeatsParse = nil
<a name="1850"></a>;
<a name="1851"></a>
<a name="1852"></a>DefineTAction(ThrowDir)
<a name="1853"></a>    execAction(cmd)
<a name="1854"></a>    {
<a name="1855"></a>        direction = cmd.verbProd.dirMatch.dir;
<a name="1856"></a>        inherited(cmd);
<a name="1857"></a>    }
<a name="1858"></a>    
<a name="1859"></a>    direction = nil
<a name="1860"></a>    againRepeatsParse = nil
<a name="1861"></a>;
<a name="1862"></a>
<a name="1863"></a>DefineIAction(JumpOffIntransitive)    
<a name="1864"></a>    execAction(cmd)
<a name="1865"></a>    {
<a name="1866"></a>        if(gActor.location.contType == On)
<a name="1867"></a>            replaceAction(JumpOff, gActor.location);
<a name="1868"></a>        else
<a name="1869"></a>            DMsg(not on anything, '{I}{\'m} not on anything. ');
<a name="1870"></a>    }    
<a name="1871"></a>;
<a name="1872"></a>
<a name="1873"></a>DefineTAction(JumpOff)    
<a name="1874"></a>;
<a name="1875"></a>
<a name="1876"></a>DefineTAction(JumpOver)
<a name="1877"></a>    againRepeatsParse = nil
<a name="1878"></a>;
<a name="1879"></a>
<a name="1880"></a>DefineLiteralTAction(TurnTo)    
<a name="1881"></a>;
<a name="1882"></a>
<a name="1883"></a>DefineLiteralTAction(SetTo)    
<a name="1884"></a>;
<a name="1885"></a>
<a name="1886"></a>DefineTAction(Set)
<a name="1887"></a>;
<a name="1888"></a>
<a name="1889"></a>DefineTAction(TypeOnVague)
<a name="1890"></a>;
<a name="1891"></a>
<a name="1892"></a>DefineLiteralTAction(TypeOn)
<a name="1893"></a>    againRepeatsParse = nil   
<a name="1894"></a>    
<a name="1895"></a>    doActionOnce()
<a name="1896"></a>    {
<a name="1897"></a>        libGlobal.lastTypedOnObj = curDobj;
<a name="1898"></a>        return inherited();
<a name="1899"></a>    }
<a name="1900"></a>;
<a name="1901"></a>
<a name="1902"></a>DefineLiteralAction(Type)
<a name="1903"></a>    againRepeatsParse = nil
<a name="1904"></a>    
<a name="1905"></a>    execAction(cmd) { askForIobj(TypeOn); }
<a name="1906"></a>;
<a name="1907"></a>
<a name="1908"></a>DefineIAction(TypeVague)
<a name="1909"></a>    execAction(s) { askMissingLiteral(Type, DirectObject); }
<a name="1910"></a>;
<a name="1911"></a>
<a name="1912"></a>DefineLiteralTAction(EnterOn)
<a name="1913"></a>    againRepeatsParse = nil
<a name="1914"></a>;
<a name="1915"></a>
<a name="1916"></a>DefineLiteralTAction(WriteOn)
<a name="1917"></a>    againRepeatsParse = nil
<a name="1918"></a>    
<a name="1919"></a>    doActionOnce()
<a name="1920"></a>    {
<a name="1921"></a>        libGlobal.lastWrittenOnObj = curDobj;
<a name="1922"></a>        return inherited();
<a name="1923"></a>    }
<a name="1924"></a>;
<a name="1925"></a>
<a name="1926"></a>DefineLiteralAction(Write)
<a name="1927"></a>    againRepeatsParse = nil
<a name="1928"></a>
<a name="1929"></a>    execAction(cmd) { askForIobj(WriteOn); }
<a name="1930"></a>;
<a name="1931"></a>
<a name="1932"></a>DefineIAction(WriteVague)
<a name="1933"></a>    execAction(c)
<a name="1934"></a>    {
<a name="1935"></a>        askMissingLiteral(Write, DirectObject);
<a name="1936"></a>    }
<a name="1937"></a>;
<a name="1938"></a>
<a name="1939"></a>
<a name="1940"></a>DefineTopicTAction(ConsultAbout)
<a name="1941"></a>    againRepeatsParse = nil
<a name="1942"></a>;
<a name="1943"></a>
<a name="1944"></a>DefineTopicAction(ConsultWhatAbout)
<a name="1945"></a>    execAction(cmd)
<a name="1946"></a>    {
<a name="1947"></a>        askForDobj(ConsultAbout);
<a name="1948"></a>    }
<a name="1949"></a>;
<a name="1950"></a>
<a name="1951"></a>DefineIAction(ConsultAboutVague)
<a name="1952"></a>    execAction(c)
<a name="1953"></a>    {
<a name="1954"></a>        DMsg(consult about vague, 'Please be more specific, e.g, CONSULT BLACK BOOK ABOUT MAGIC or
<a name="1955"></a>            READ ABOUT MAGIC IN BLACK BOOK. ' );
<a name="1956"></a>    }
<a name="1957"></a>;
<a name="1958"></a>
<a name="1959"></a>DefineTAction(SwitchVague)
<a name="1960"></a>    againRepeatsParse = nil
<a name="1961"></a>;
<a name="1962"></a>
<a name="1963"></a>DefineTAction(Flip)
<a name="1964"></a>    againRepeatsParse = nil
<a name="1965"></a>;
<a name="1966"></a>
<a name="1967"></a>DefineTAction(Fasten)   
<a name="1968"></a>;
<a name="1969"></a>
<a name="1970"></a>
<a name="1971"></a>DefineTAction(Burn)   
<a name="1972"></a>;
<a name="1973"></a>
<a name="1974"></a>DefineTIAction(BurnWith)
<a name="1975"></a>    resolveIobjFirst = nil
<a name="1976"></a>;
<a name="1977"></a>
<a name="1978"></a>DefineTAction(Pour)
<a name="1979"></a>    againRepeatsParse = nil
<a name="1980"></a>;
<a name="1981"></a>
<a name="1982"></a>DefineTIAction(PourOnto)    
<a name="1983"></a>    resolveIobjFirst = nil
<a name="1984"></a>    againRepeatsParse = nil
<a name="1985"></a>;
<a name="1986"></a>
<a name="1987"></a>DefineTIAction(PourInto)
<a name="1988"></a>    resolveIobjFirst = nil
<a name="1989"></a>    againRepeatsParse = nil
<a name="1990"></a>;
<a name="1991"></a>
<a name="1992"></a>DefineTAction(Screw)    
<a name="1993"></a>;
<a name="1994"></a>
<a name="1995"></a>DefineTIAction(ScrewWith)    
<a name="1996"></a>    resolveIobjFirst = nil
<a name="1997"></a>;
<a name="1998"></a>    
<a name="1999"></a>DefineTAction(Unscrew)
<a name="2000"></a>;
<a name="2001"></a>
<a name="2002"></a>DefineTIAction(UnscrewWith)    
<a name="2003"></a>    resolveIobjFirst = nil
<a name="2004"></a>;
<a name="2005"></a>
<a name="2006"></a>DefineTAction(Unfasten)
<a name="2007"></a>;
<a name="2008"></a>
<a name="2009"></a>DefineTIAction(UnfastenFrom)    
<a name="2010"></a>;
<a name="2011"></a>
<a name="2012"></a>DefineTIAction(PlugInto)   
<a name="2013"></a>    resolveIobjFirst = nil
<a name="2014"></a>;
<a name="2015"></a>
<a name="2016"></a>DefineTAction(PlugIn)    
<a name="2017"></a>;
<a name="2018"></a>
<a name="2019"></a>DefineTIAction(UnplugFrom)        
<a name="2020"></a>;
<a name="2021"></a>
<a name="2022"></a>DefineTAction(Unplug)    
<a name="2023"></a>;
<a name="2024"></a>
<a name="2025"></a>
<a name="2026"></a>DefineTAction(PushTravelDir)
<a name="2027"></a>    
<a name="2028"></a>    isPushTravelAction = true
<a name="2029"></a>    
<a name="2030"></a>    execAction(cmd)
<a name="2031"></a>    {
<a name="2032"></a>        local conn;
<a name="2033"></a>        
<a name="2034"></a>        /* Note whether travel is allowed. This can be adjusted by the dobj */
<a name="2035"></a>        travelAllowed = nil;
<a name="2036"></a>        
<a name="2037"></a>        /* Get the direction of travel from the command */
<a name="2038"></a>        direction = cmd.verbProd.dirMatch.dir;
<a name="2039"></a>        
<a name="2040"></a>        /* Note the actor's location. */
<a name="2041"></a>        local loc = gActor.getOutermostRoom; 
<a name="2042"></a>        
<a name="2043"></a>//        /* Note whether we meed the lighting conditions to permit travel */
<a name="2044"></a>//        local illum = loc.allowDarkTravel || loc.isIlluminated;
<a name="2045"></a>        
<a name="2046"></a>        /* 
<a name="2047"></a>         *   first find out what our direction might take us to; if it's an object that defines the
<a name="2048"></a>         *   PushTravlVia property, change the action to PushTravelVia that connector
<a name="2049"></a>         */
<a name="2050"></a>        
<a name="2051"></a>    retry:
<a name="2052"></a>        /* 
<a name="2053"></a>         *   See if the direction we're due to go in points to an object and if so process it
<a name="2054"></a>         *   accordingly.
<a name="2055"></a>         */
<a name="2056"></a>        if(loc.propType(direction.dirProp) == TypeObject)
<a name="2057"></a>        {
<a name="2058"></a>            /* Note the connector object in the relevant direction */
<a name="2059"></a>            conn = loc.(direction.dirProp); 
<a name="2060"></a>            
<a name="2061"></a>            /* 
<a name="2062"></a>             *   If this connector is an UnlistedProxy Connector we need to carry out the rest of
<a name="2063"></a>             *   the processing on whatever it's a proxy for.
<a name="2064"></a>             */
<a name="2065"></a>            if(conn.ofKind(UnlistedProxyConnector))
<a name="2066"></a>            {
<a name="2067"></a>                /* Reset our direction to that of the UnlistedProxyConnector. */
<a name="2068"></a>                direction = conn.direction;
<a name="2069"></a>                
<a name="2070"></a>                /* Start over again with our new direction. */
<a name="2071"></a>                goto retry;                  
<a name="2072"></a>            }
<a name="2073"></a>            
<a name="2074"></a>            /*  
<a name="2075"></a>             *   If the connector object defines a PushTravelVia action, then replace the current
<a name="2076"></a>             *   action with that PushTravelVia action (e.g. PushTravelGoThrough or
<a name="2077"></a>             *   PushTravelClimbUp).
<a name="2078"></a>             */
<a name="2079"></a>            if(conn.PushTravelVia)
<a name="2080"></a>                replaceAction(conn.PushTravelVia, gDobj, conn);
<a name="2081"></a>            
<a name="2082"></a>            /* 
<a name="2083"></a>             *   Maybe conn looks like an object but is actually an anonymous or dynamic function,
<a name="2084"></a>             *   in which case we can try to execute it.
<a name="2085"></a>             */
<a name="2086"></a>            if(dataTypeXlat(conn) == TypeFuncPtr)
<a name="2087"></a>            {
<a name="2088"></a>                try
<a name="2089"></a>                {
<a name="2090"></a>                    conn();                    
<a name="2091"></a>                }
<a name="2092"></a>                catch (Exception ex)
<a name="2093"></a>                {
<a name="2094"></a>                    "Problem with function object attached to the &lt;&lt;direction.name&gt;&gt; property of
<a name="2095"></a>                    &lt;&lt;loc.name&gt;&gt;.&lt;.p&gt;";
<a name="2096"></a>                    
<a name="2097"></a>                    ex.displayException();
<a name="2098"></a>                }
<a name="2099"></a>            }
<a name="2100"></a>            else        
<a name="2101"></a>                
<a name="2102"></a>            /* 
<a name="2103"></a>             *   if we reach this point, there must be something fishy going on, since we really
<a name="2104"></a>             *   shouldn't have any other kind of object attached to a direction property, so
<a name="2105"></a>             *   display a message saying so.
<a name="2106"></a>             */                
<a name="2107"></a>                "&lt;b&gt;ERROR!&lt;/b&gt; Illegal object &lt;&lt;conn&gt;&gt; attached to the &lt;&lt;direction.name&gt;&gt; property 
<a name="2108"></a>                of &lt;&lt;loc.name&gt;&gt;. ";
<a name="2109"></a>            
<a name="2110"></a>        }
<a name="2111"></a>        /* 
<a name="2112"></a>         *   If our direction isn't attached to an object, it must be to a method or string that's
<a name="2113"></a>         *   going to display a message explaining why we can't travel. So call the nonTravel()
<a name="2114"></a>         *   function to handle it.            
<a name="2115"></a>         */
<a name="2116"></a>        else
<a name="2117"></a>            nonTravel(loc, direction);
<a name="2118"></a>    }
<a name="2119"></a>    
<a name="2120"></a>    
<a name="2121"></a>
<a name="2122"></a>    travelAllowed = nil
<a name="2123"></a>    direction = nil
<a name="2124"></a>    curIobj = nil
<a name="2125"></a>    
<a name="2126"></a>    
<a name="2127"></a>    doTravel() { delegated TravelAction(); }
<a name="2128"></a>;
<a name="2129"></a>
<a name="2130"></a>DefineTIAction(PushTravelThrough)
<a name="2131"></a>    viaMode = Through
<a name="2132"></a>    
<a name="2133"></a>    isPushTravelAction = true
<a name="2134"></a>    
<a name="2135"></a>    addExtraScopeItems(role)
<a name="2136"></a>    {
<a name="2137"></a>        /* 
<a name="2138"></a>         *   If our indirect object is a TravelConnector it may not be a physical object that would
<a name="2139"></a>         *   normally be considered in scope, so we need to add it to our scope list.
<a name="2140"></a>         */        
<a name="2141"></a>        if(objOfKind(curIobj, TravelConnector))
<a name="2142"></a>            scopeList = scopeList.appendUnique(valToList(curIobj));
<a name="2143"></a>        
<a name="2144"></a>        /* 
<a name="2145"></a>         *   Append the extra scope items defined on this Room to the action's
<a name="2146"></a>         *   scope list.
<a name="2147"></a>         */
<a name="2148"></a>        inherited(role);
<a name="2149"></a>    }
<a name="2150"></a>;
<a name="2151"></a>
<a name="2152"></a>DefineTIAction(PushTravelEnter)
<a name="2153"></a>    viaMode = Into
<a name="2154"></a>    
<a name="2155"></a>    isPushTravelAction = true
<a name="2156"></a>;
<a name="2157"></a>
<a name="2158"></a>DefineTIAction(PushTravelGetOutOf)
<a name="2159"></a>    viaMode = OutOf
<a name="2160"></a>    
<a name="2161"></a>    isPushTravelAction = true
<a name="2162"></a>;
<a name="2163"></a>
<a name="2164"></a>DefineTIAction(PushTravelClimbUp)
<a name="2165"></a>    viaMode = Up
<a name="2166"></a>    
<a name="2167"></a>    isPushTravelAction = true
<a name="2168"></a>;
<a name="2169"></a>
<a name="2170"></a>DefineTIAction(PushTravelClimbDown)
<a name="2171"></a>    viaMode = Down
<a name="2172"></a>    
<a name="2173"></a>    isPushTravelAction = true
<a name="2174"></a>;
<a name="2175"></a>
<a name="2176"></a>
<a name="2177"></a>
<a name="2178"></a>
<a name="2179"></a>
<a name="2180"></a>DefineTAction(TalkTo)
<a name="2181"></a>    isConversational = true
<a name="2182"></a>;
<a name="2183"></a>
<a name="2184"></a>class MiscConvAction: IAction
<a name="2185"></a>    execAction(cmd)
<a name="2186"></a>    {
<a name="2187"></a>        if(gPlayerChar.currentInterlocutor == nil 
<a name="2188"></a>           || !Q.canTalkTo(gPlayerChar, gPlayerChar.currentInterlocutor))
<a name="2189"></a>            sayNotTalking();
<a name="2190"></a>        else
<a name="2191"></a>        {           
<a name="2192"></a>            curObj = gPlayerChar.currentInterlocutor;
<a name="2193"></a>            gPlayerChar.currentInterlocutor.handleTopic(responseProp, 
<a name="2194"></a>                [topicObj]);
<a name="2195"></a>        }
<a name="2196"></a>            
<a name="2197"></a>    }
<a name="2198"></a>    curObj = nil
<a name="2199"></a>    
<a name="2200"></a>    getMessageParam(objName)
<a name="2201"></a>    {
<a name="2202"></a>        switch(objName)
<a name="2203"></a>        {
<a name="2204"></a>        case 'dobj':
<a name="2205"></a>            /* return the current direct object */
<a name="2206"></a>            return curObj;
<a name="2207"></a>            
<a name="2208"></a>        case 'cobj':
<a name="2209"></a>            /* return the current object */
<a name="2210"></a>            return curObj;
<a name="2211"></a>
<a name="2212"></a>        default:
<a name="2213"></a>            /* inherit default handling */
<a name="2214"></a>            return inherited(objName);
<a name="2215"></a>        }
<a name="2216"></a>    }
<a name="2217"></a>    
<a name="2218"></a>    responseProp = nil
<a name="2219"></a>    topicObj = nil
<a name="2220"></a>    
<a name="2221"></a>    isConversational = true
<a name="2222"></a>;
<a name="2223"></a>
<a name="2224"></a>sayNotTalking()
<a name="2225"></a>{
<a name="2226"></a>    DMsg(not talking, '{I}{\'m} not talking to anyone. ');
<a name="2227"></a>}
<a name="2228"></a>
<a name="2229"></a>
<a name="2230"></a>/* 
<a name="2231"></a> *   Singleton object used to trigger a YesTopic; we must make it familiar so
<a name="2232"></a> *   that YesTopics can be listed as suggested topics. We define this as
<a name="2233"></a> *   noTopicObj in actions.t rather than actor.t so that the SayYes and SayNo
<a name="2234"></a> *   actions in actions.t will compile even if actor.t is absent from the build.
<a name="2235"></a> */
<a name="2236"></a>yesTopicObj: object familiar = true;
<a name="2237"></a>
<a name="2238"></a>/* Singleton object used to trigger a NoTopic */
<a name="2239"></a>noTopicObj: object familiar = true;
<a name="2240"></a>
<a name="2241"></a>SayYes: MiscConvAction
<a name="2242"></a>    baseActionClass = SayYes
<a name="2243"></a>    responseProp = &amp;miscTopics
<a name="2244"></a>    topicObj = yesTopicObj
<a name="2245"></a>;
<a name="2246"></a>
<a name="2247"></a>SayNo: MiscConvAction
<a name="2248"></a>    baseActionClass = SayNo
<a name="2249"></a>    responseProp = &amp;miscTopics
<a name="2250"></a>    topicObj = noTopicObj
<a name="2251"></a>;
<a name="2252"></a>
<a name="2253"></a>QueryVague: MiscConvAction
<a name="2254"></a>    baseActionClass = QueryVague
<a name="2255"></a>    execAction(cmd)
<a name="2256"></a>    {
<a name="2257"></a>        qType = cmd.verbProd.qtype;
<a name="2258"></a>        /* 
<a name="2259"></a>         *   Mark this as a special Topic designed to match a QueryTopic of the appropriate type.
<a name="2260"></a>         */
<a name="2261"></a>        topicObj = new Topic(qType + '!');
<a name="2262"></a>        
<a name="2263"></a>        inherited(cmd);
<a name="2264"></a>    }
<a name="2265"></a>    
<a name="2266"></a>    qType = nil
<a name="2267"></a>    responseProp = &amp;queryTopics
<a name="2268"></a>;
<a name="2269"></a>
<a name="2270"></a>Goodbye: IAction
<a name="2271"></a>    baseActionClass = Goodbye
<a name="2272"></a>    
<a name="2273"></a>    execAction(cmd)
<a name="2274"></a>    {
<a name="2275"></a>        curObj = gPlayerChar.currentInterlocutor;
<a name="2276"></a>    
<a name="2277"></a>        if(gPlayerChar.currentInterlocutor == nil ||
<a name="2278"></a>           !Q.canTalkTo(gPlayerChar, gPlayerChar.currentInterlocutor))	
<a name="2279"></a>            sayNotTalking();
<a name="2280"></a>        else if(defined(endConvBye) &amp;&amp;
<a name="2281"></a>            gPlayerChar.currentInterlocutor.endConversation(endConvBye));
<a name="2282"></a>    }    
<a name="2283"></a>    
<a name="2284"></a>    curObj = nil   
<a name="2285"></a>    
<a name="2286"></a>    isConversational = true
<a name="2287"></a>;
<a name="2288"></a>
<a name="2289"></a>Hello: IAction
<a name="2290"></a>    baseActionClass = Hello
<a name="2291"></a>    
<a name="2292"></a>    execAction(cmd)
<a name="2293"></a>    {
<a name="2294"></a>        /* first build the scope list so we know which actors are in scope */
<a name="2295"></a>        buildScopeList();
<a name="2296"></a>        
<a name="2297"></a>        /* 
<a name="2298"></a>         *   if the pc isn't already talking to someone then this is an attempt
<a name="2299"></a>         *   to engage a new interlocutor in conversation.
<a name="2300"></a>         */
<a name="2301"></a>        if(gPlayerChar.currentInterlocutor == nil)
<a name="2302"></a>        {
<a name="2303"></a>            /* 
<a name="2304"></a>             *   Ascertain how many actors other than the player char are in
<a name="2305"></a>             *   scope (and thus potentially greetable.
<a name="2306"></a>             */
<a name="2307"></a>
<a name="2308"></a>            local greetList;
<a name="2309"></a>            
<a name="2310"></a>            /* 
<a name="2311"></a>             *   We do this a slightly roundabout way to avoid compilation
<a name="2312"></a>             *   errors and warnings when actor.t is omitted from the build.
<a name="2313"></a>             */
<a name="2314"></a>            local cls = (defined(Actor) ? Actor : nil);
<a name="2315"></a>            
<a name="2316"></a>            if(cls)                
<a name="2317"></a>                greetList = scopeList.subset(
<a name="2318"></a>                    { x: x.ofKind(cls) &amp;&amp; x != gPlayerChar });            
<a name="2319"></a>            else
<a name="2320"></a>                greetList = [];
<a name="2321"></a>            
<a name="2322"></a>            local greetCount = greetList.length;
<a name="2323"></a>            
<a name="2324"></a>            /* If there are no other actors in scope, say so. */            
<a name="2325"></a>            if(greetCount == 0)
<a name="2326"></a>            {
<a name="2327"></a>                DMsg(no one here, 'There{dummy}{\'s} no one {here} to talk to.
<a name="2328"></a>                    ');
<a name="2329"></a>            }
<a name="2330"></a>            /* 
<a name="2331"></a>             *   Otherwise construct a list of all the actors in scope and greet
<a name="2332"></a>             *   all of them (rather than asking the player to disambiguate -
<a name="2333"></a>             *   after all the pc may have just said 'hello' to a room full of
<a name="2334"></a>             *   people and there's no reason why they shouldn't all respond).
<a name="2335"></a>             */
<a name="2336"></a>            else
<a name="2337"></a>            {               
<a name="2338"></a>                foreach(local greeted in greetList)
<a name="2339"></a>                {
<a name="2340"></a>                    curObj = greeted;
<a name="2341"></a>                    greeted.sayHello();
<a name="2342"></a>                }
<a name="2343"></a>            }
<a name="2344"></a>        }
<a name="2345"></a>        /* 
<a name="2346"></a>         *   If the player char is currently talking to someone, say so and
<a name="2347"></a>         *   carry out a repeat greeting.
<a name="2348"></a>         */
<a name="2349"></a>        else
<a name="2350"></a>        {            
<a name="2351"></a>            gPlayerChar.currentInterlocutor.sayHello();
<a name="2352"></a>        }
<a name="2353"></a>    }
<a name="2354"></a>    
<a name="2355"></a>    curObj = nil
<a name="2356"></a>    
<a name="2357"></a>    isConversational = true
<a name="2358"></a>;
<a name="2359"></a>
<a name="2360"></a>DefineLiteralTAction(TellTo)
<a name="2361"></a>    exec(cmd)
<a name="2362"></a>    {
<a name="2363"></a>        /* 
<a name="2364"></a>         *   Take a command of the form of TELL FOO TO BAR, turn it into FOO,
<a name="2365"></a>         *   BAR and then send it back to parser to execute
<a name="2366"></a>         */
<a name="2367"></a>        local str = cmd.dobj.name + ', ' + cmd.iobj.name;
<a name="2368"></a>        Parser.parse(str);
<a name="2369"></a>    }
<a name="2370"></a>    afterAction() {}
<a name="2371"></a>    
<a name="2372"></a>    isConversational = true
<a name="2373"></a>;
<a name="2374"></a>
<a name="2375"></a>
<a name="2376"></a>DefineTopicTAction(AskAbout)    
<a name="2377"></a>    isConversational = true
<a name="2378"></a>;
<a name="2379"></a>
<a name="2380"></a>DefineTopicTAction(AskFor)    
<a name="2381"></a>    isConversational = true
<a name="2382"></a>;
<a name="2383"></a>
<a name="2384"></a>DefineTopicTAction(TellAbout)   
<a name="2385"></a>    isConversational = true
<a name="2386"></a>;
<a name="2387"></a>
<a name="2388"></a>DefineTopicTAction(TalkAbout)    
<a name="2389"></a>    isConversational = true
<a name="2390"></a>;
<a name="2391"></a>
<a name="2392"></a>DefineTopicTAction(QueryAbout)    
<a name="2393"></a>    execAction(cmd)
<a name="2394"></a>    {
<a name="2395"></a>        qType = cmd.verbProd.qtype;
<a name="2396"></a>
<a name="2397"></a>        inherited(cmd);
<a name="2398"></a>    }
<a name="2399"></a>    qType = nil
<a name="2400"></a>    
<a name="2401"></a>    #ifdef __DEBUG    
<a name="2402"></a>    iqinfo = (gCommand.verbProd.qtype)
<a name="2403"></a>    #endif
<a name="2404"></a>    
<a name="2405"></a>    isConversational = true
<a name="2406"></a>;
<a name="2407"></a>
<a name="2408"></a>DefineTopicTAction(SayTo)    
<a name="2409"></a>    isConversational = true
<a name="2410"></a>;
<a name="2411"></a>
<a name="2412"></a>DefineTIAction(GiveTo)     
<a name="2413"></a>    /* 
<a name="2414"></a>     *   The summaryReport can be set by a GiveTopic to a single-quoted string in
<a name="2415"></a>     *   BMsg format, with {1} standing in for gActionListStr, in order to
<a name="2416"></a>     *   report on a whole set of objects given at once; e.g. '{I} {give} Bob
<a name="2417"></a>     *   {1}. '
<a name="2418"></a>     */
<a name="2419"></a>    summaryReport = nil
<a name="2420"></a>    
<a name="2421"></a>    /* 
<a name="2422"></a>     *   The summaryProp can be a propertyPointer to a method on the Actor being
<a name="2423"></a>     *   conversed with that's called at once a whole set of objects has been
<a name="2424"></a>     *   given. It will normally be set by a gAction.summaryProp = &amp;prop
<a name="2425"></a>     *   statement in a GiveTopic.
<a name="2426"></a>     */
<a name="2427"></a>    summaryProp = nil
<a name="2428"></a>    
<a name="2429"></a>    /* 
<a name="2430"></a>     *   Reset the summaryReport and the summaryProp to nil for the whole group
<a name="2431"></a>     *   of objects this action may act on, so that they're only used if they're
<a name="2432"></a>     *   explicitly requested this turn.
<a name="2433"></a>     */
<a name="2434"></a>    execGroup(cmd) 
<a name="2435"></a>    { 
<a name="2436"></a>        summaryReport = nil; 
<a name="2437"></a>        summaryProp = nil;
<a name="2438"></a>    }
<a name="2439"></a>;
<a name="2440"></a>
<a name="2441"></a>DefineTIAction(ShowTo)   
<a name="2442"></a>    showReport = nil
<a name="2443"></a>    summaryProp = nil
<a name="2444"></a>    
<a name="2445"></a>    /* 
<a name="2446"></a>     *   Reset the showReport to nil for the whole group of objects this action
<a name="2447"></a>     *   may act on.
<a name="2448"></a>     */
<a name="2449"></a>    execGroup(cmd) 
<a name="2450"></a>    { 
<a name="2451"></a>        summaryReport = nil; 
<a name="2452"></a>        summaryProp = nil;
<a name="2453"></a>    }
<a name="2454"></a>    
<a name="2455"></a>    isConversational = true
<a name="2456"></a>;
<a name="2457"></a>
<a name="2458"></a>ThinkAbout: TopicAction
<a name="2459"></a>    baseActionClass = ThinkAbout
<a name="2460"></a>    
<a name="2461"></a>    execAction(cmd)
<a name="2462"></a>    {
<a name="2463"></a>        /* 
<a name="2464"></a>         *   We don't want this action treated as conversational if it results in the use of reveal
<a name="2465"></a>         *   tags, so we store the current interlocutor and then set the current interlocutor to nil
<a name="2466"></a>         *   before proceeding.
<a name="2467"></a>         */                 
<a name="2468"></a>        local interlocutor = gPlayerChar.currentInterlocutor;
<a name="2469"></a>        
<a name="2470"></a>        try
<a name="2471"></a>        {
<a name="2472"></a>            
<a name="2473"></a>            gPlayerChar.currentInterlocutor = nil;            
<a name="2474"></a>            
<a name="2475"></a>            /* If we have thought manager object, let that handle the THINK ABOUT command. */
<a name="2476"></a>            if(libGlobal.thoughtManagerObj != nil)
<a name="2477"></a>                libGlobal.thoughtManagerObj.handleTopic(cmd.dobj.topicList);            
<a name="2478"></a>            
<a name="2479"></a>            /* Otherwise see if we can redirect it to the object's thuinkDesc property. */
<a name="2480"></a>            else
<a name="2481"></a>            {
<a name="2482"></a>                /* Set up a local variable to hold the list of topics matched by this command. */
<a name="2483"></a>                local tList = cmd.dobj.topicList;
<a name="2484"></a>                
<a name="2485"></a>                /* 
<a name="2486"></a>                 *   Remove all the newly created Topics from the list of topics matched by this
<a name="2487"></a>                 *   commnand, provided that will leave at least one topic remaining.
<a name="2488"></a>                 */
<a name="2489"></a>                if(tList.length &gt; 1 &amp;&amp; tList.indexWhich({t: t.newlyCreated == nil}))
<a name="2490"></a>                    tList = tList.subset({t: t.newlyCreated == nil});                
<a name="2491"></a>                
<a name="2492"></a>                /* Choose the first item from the list that remains. */
<a name="2493"></a>                local top = tList[1];
<a name="2494"></a>                
<a name="2495"></a>                /* If that topic defines a thinkDesc property, attempt to display it. */
<a name="2496"></a>                if(top.propDefined(&amp;thinkDesc))
<a name="2497"></a>                    top.displayAlt(&amp;thinkDesc, &amp;noThought);
<a name="2498"></a>                
<a name="2499"></a>                /* If all else fails, display out noThought message. */
<a name="2500"></a>                else
<a name="2501"></a>                    say(noThought);
<a name="2502"></a>            }
<a name="2503"></a>        }
<a name="2504"></a>        finally
<a name="2505"></a>        {
<a name="2506"></a>            /* Restore the current interlocutor. */
<a name="2507"></a>            gPlayerChar.currentInterlocutor = interlocutor;
<a name="2508"></a>        }
<a name="2509"></a>    }
<a name="2510"></a>    
<a name="2511"></a>    /* Our fallback message if we can't match anything. */
<a name="2512"></a>    noThought = BMsg(no thought comes to mind, 'Nothing comes to mind. ')
<a name="2513"></a>    
<a name="2514"></a>    againRepeatsParse = nil
<a name="2515"></a>;
<a name="2516"></a>
<a name="2517"></a>DefineIAction(Think)
<a name="2518"></a>    execAction(cmd)
<a name="2519"></a>    {
<a name="2520"></a>        /* 
<a name="2521"></a>         *   If we have an associated RuleBook and it returns something other than nil, then assume
<a name="2522"></a>         *   the RuleBook has handled the THINK command, so stop here.
<a name="2523"></a>         */
<a name="2524"></a>        if(ruleBook &amp;&amp; ruleBook.follow() != null)
<a name="2525"></a>            return;
<a name="2526"></a>        
<a name="2527"></a>        /* Otherwise, display our default response. */
<a name="2528"></a>        sayDefaultThought();
<a name="2529"></a>    }    
<a name="2530"></a>    
<a name="2531"></a>    sayDefaultThought() { DMsg(think, '{I} {think}, therefore {i} {am}. '); }
<a name="2532"></a>    
<a name="2533"></a>    /* 
<a name="2534"></a>     *   A rulebook to follow when a THINK command is issued. This required the Rules extension to
<a name="2535"></a>     *   be present.
<a name="2536"></a>     */
<a name="2537"></a>    ruleBook = nil
<a name="2538"></a>;
<a name="2539"></a>
<a name="2540"></a>class ImplicitConversationAction: TopicAction
<a name="2541"></a>    execAction(cmd)
<a name="2542"></a>    {
<a name="2543"></a>        if(cmd.iobj == nil &amp;&amp; cmd.dobj != nil)
<a name="2544"></a>        {
<a name="2545"></a>            if(cmd.dobj.ofKind(ResolvedTopic))
<a name="2546"></a>                topics = cmd.dobj.topicList;
<a name="2547"></a>            else
<a name="2548"></a>                topics = cmd.dobj;
<a name="2549"></a>            
<a name="2550"></a>            curTopic = cmd.dobj;
<a name="2551"></a>        }
<a name="2552"></a>        else if (cmd.dobj == nil &amp;&amp; cmd.iobj != nil)
<a name="2553"></a>        {
<a name="2554"></a>            if(cmd.iobj.ofKind(ResolvedTopic))
<a name="2555"></a>                topics = cmd.iobj.topicList;
<a name="2556"></a>            else
<a name="2557"></a>                topics = cmd.iobj;
<a name="2558"></a>            
<a name="2559"></a>            curTopic = cmd.iobj;
<a name="2560"></a>        }
<a name="2561"></a>        
<a name="2562"></a>        if(gPlayerChar.currentInterlocutor == nil ||
<a name="2563"></a>           !Q.canTalkTo(gPlayerChar, gPlayerChar.currentInterlocutor))	
<a name="2564"></a>            sayNotTalking();
<a name="2565"></a>        else
<a name="2566"></a>        {
<a name="2567"></a>            notePronounAntecedent(gPlayerChar.currentInterlocutor);
<a name="2568"></a>            resolvePronouns();
<a name="2569"></a>            curObj = gPlayerChar.currentInterlocutor;
<a name="2570"></a>            gPlayerChar.currentInterlocutor.handleTopic(topicListProperty, 
<a name="2571"></a>                topics, defaultProperty);
<a name="2572"></a>        }
<a name="2573"></a>    }
<a name="2574"></a>    
<a name="2575"></a>    /* The default property to call on the Actor if there's not matching TopicEntry */
<a name="2576"></a>    defaultProperty = &amp;noResponseMsg
<a name="2577"></a>    
<a name="2578"></a>    
<a name="2579"></a>    /* 
<a name="2580"></a>     *   This is a bit of a kludge to deal with the fact that the Parser doesn't
<a name="2581"></a>     *   seem able to resolve pronouns within ResolvedTopics. We do it here
<a name="2582"></a>     *   instead.
<a name="2583"></a>     */
<a name="2584"></a>    
<a name="2585"></a>    resolvePronouns()
<a name="2586"></a>    {
<a name="2587"></a>        local actor = gPlayerChar.currentInterlocutor;
<a name="2588"></a>        for(local cur in topics, local i = 1;; ++i)
<a name="2589"></a>        {
<a name="2590"></a>            if(cur == Him &amp;&amp; actor.isHim)
<a name="2591"></a>                topics[i] = actor;
<a name="2592"></a>            
<a name="2593"></a>            if(cur == Her &amp;&amp; actor.isHer)
<a name="2594"></a>                topics[i] = actor;
<a name="2595"></a>            
<a name="2596"></a>            if(cur == It &amp;&amp; actor.isIt)
<a name="2597"></a>                topics[i] = actor;
<a name="2598"></a>            
<a name="2599"></a>            if(cur == Them &amp;&amp; actor.plural)
<a name="2600"></a>                topics[i] = actor;
<a name="2601"></a>        }
<a name="2602"></a>    }
<a name="2603"></a>    
<a name="2604"></a>    
<a name="2605"></a>    topicListProperty = nil
<a name="2606"></a>    topics = nil
<a name="2607"></a>    
<a name="2608"></a>    isConversational = true
<a name="2609"></a>;
<a name="2610"></a>
<a name="2611"></a>        
<a name="2612"></a>AskAboutImplicit: ImplicitConversationAction
<a name="2613"></a>    baseActionClass = AskAboutImplicit
<a name="2614"></a>    topicListProperty = &amp;askTopics
<a name="2615"></a>;
<a name="2616"></a>
<a name="2617"></a>AskForImplicit: ImplicitConversationAction
<a name="2618"></a>    baseActionClass = AskForImplicit
<a name="2619"></a>    topicListProperty = &amp;askForTopics
<a name="2620"></a>;
<a name="2621"></a>
<a name="2622"></a>TellAboutImplicit: ImplicitConversationAction
<a name="2623"></a>    baseActionClass = TellAboutImplicit
<a name="2624"></a>    topicListProperty = &amp;tellTopics
<a name="2625"></a>;
<a name="2626"></a>
<a name="2627"></a>TalkAboutImplicit: ImplicitConversationAction
<a name="2628"></a>    baseActionClass = TalkAboutImplicit
<a name="2629"></a>    topicListProperty = &amp;talkTopics
<a name="2630"></a>;
<a name="2631"></a>
<a name="2632"></a>DefineTAction(ShowToImplicit)
<a name="2633"></a>    showReport = nil
<a name="2634"></a>    
<a name="2635"></a>    /* 
<a name="2636"></a>     *   The summaryProp can be a propertyPointer to a method on the Actor being
<a name="2637"></a>     *   conversed with that's called at once a whole set of objects has been
<a name="2638"></a>     *   given. It will normally be set by a gAction.summaryProp = &amp;prop
<a name="2639"></a>     *   statement in a ShowTopic.
<a name="2640"></a>     */
<a name="2641"></a>    summaryProp = nil
<a name="2642"></a>    
<a name="2643"></a>    /* 
<a name="2644"></a>     *   Reset the showReport to nil for the whole group of objects this action
<a name="2645"></a>     *   may act on.
<a name="2646"></a>     */
<a name="2647"></a>    execGroup(cmd) 
<a name="2648"></a>    { 
<a name="2649"></a>        summaryReport = nil; 
<a name="2650"></a>        summaryProp = nil;
<a name="2651"></a>    }
<a name="2652"></a>;
<a name="2653"></a>
<a name="2654"></a>DefineTAction(GiveToImplicit)
<a name="2655"></a>    showReport = nil
<a name="2656"></a>    
<a name="2657"></a>    /* 
<a name="2658"></a>     *   The summaryProp can be a propertyPointer to a method on the Actor being
<a name="2659"></a>     *   conversed with that's called at once a whole set of objects has been
<a name="2660"></a>     *   given. It will normally be set by a gAction.summaryProp = &amp;prop
<a name="2661"></a>     *   statement in a GiveTopic.
<a name="2662"></a>     */
<a name="2663"></a>    summaryProp = nil
<a name="2664"></a>    /* 
<a name="2665"></a>     *   Reset the showReport to nil for the whole group of objects this action
<a name="2666"></a>     *   may act on.
<a name="2667"></a>     */
<a name="2668"></a>    execGroup(cmd) 
<a name="2669"></a>    { 
<a name="2670"></a>        summaryReport = nil; 
<a name="2671"></a>        summaryProp = nil;
<a name="2672"></a>    }
<a name="2673"></a>;
<a name="2674"></a>              
<a name="2675"></a>
<a name="2676"></a>Query: ImplicitConversationAction
<a name="2677"></a>    baseActionClass = Query
<a name="2678"></a>    execAction(cmd)
<a name="2679"></a>    {
<a name="2680"></a>        qType = cmd.verbProd.qtype;
<a name="2681"></a>
<a name="2682"></a>        inherited(cmd);
<a name="2683"></a>    }
<a name="2684"></a>    qType = nil
<a name="2685"></a>    topicListProperty = &amp;queryTopics
<a name="2686"></a>    
<a name="2687"></a>    #ifdef __DEBUG
<a name="2688"></a>    dqinfo = (gCommand.verbProd.qtype)
<a name="2689"></a>    #endif
<a name="2690"></a>;
<a name="2691"></a>
<a name="2692"></a>SayAction: ImplicitConversationAction
<a name="2693"></a>    baseActionClass = SayAction
<a name="2694"></a>    topicListProperty = &amp;sayTopics
<a name="2695"></a>    defaultProperty = &amp;defaultSayResponse
<a name="2696"></a>;
<a name="2697"></a>
<a name="2698"></a>/* 
<a name="2699"></a> *   A Special Action is one that's been triggered from a SpecialAction object to cover cases where
<a name="2700"></a> *   there's no other existing action in the game it can divert to.
<a name="2701"></a> */
<a name="2702"></a>DefineTAction(SpecialAction)
<a name="2703"></a>    specialPhrase = nil
<a name="2704"></a>;
<a name="2705"></a>
<a name="2706"></a>
<a name="2707"></a>/*
<a name="2708"></a> *   A state object that keeps track of our logging (scripting) status.
<a name="2709"></a> *   This is transient, because logging is controlled through the output
<a name="2710"></a> *   layer in the interpreter, which does not participate in any of the
<a name="2711"></a> *   persistence mechanisms.  
<a name="2712"></a> */
<a name="2713"></a>transient scriptStatus: object
<a name="2714"></a>    /*
<a name="2715"></a>     *   Script file name.  This is nil when logging is not in effect, and
<a name="2716"></a>     *   is set to the name of the scripting file when a log file is
<a name="2717"></a>     *   active. 
<a name="2718"></a>     */
<a name="2719"></a>    scriptFile = nil
<a name="2720"></a>
<a name="2721"></a>    /* RECORD file name */
<a name="2722"></a>    recordFile = nil
<a name="2723"></a>
<a name="2724"></a>    /* have we warned about using NOTE without logging in effect? */
<a name="2725"></a>    noteWithoutScriptWarning = nil
<a name="2726"></a>;
<a name="2727"></a>
<a name="2728"></a>
<a name="2729"></a>
<a name="2730"></a>/* 
<a name="2731"></a> *   Property: object is a web temp file.  The Web UI uses this to flag
<a name="2732"></a> *   that a file we're saving to is actually a temp file that will be
<a name="2733"></a> *   offered as a downloadable file to the client after the file is written
<a name="2734"></a> *   and closed. 
<a name="2735"></a> */
<a name="2736"></a>property isWebTempFile;
<a name="2737"></a>
<a name="2738"></a>/*
<a name="2739"></a> *   A base class for file-oriented actions, such as SCRIPT, RECORD, and
<a name="2740"></a> *   REPLAY.  We provide common handling that prompts interactively for a
<a name="2741"></a> *   filename; subclasses must override a few methods and properties to
<a name="2742"></a> *   carry out the specific subclassed operation on the file.  
<a name="2743"></a> */
<a name="2744"></a>class FileOpAction: SystemAction
<a name="2745"></a>    /* our file dialog prompt message */
<a name="2746"></a>    filePromptMsg = ''
<a name="2747"></a>
<a name="2748"></a>    /* the file dialog open/save type */
<a name="2749"></a>    fileDisposition = InFileSave
<a name="2750"></a>
<a name="2751"></a>    /* the file dialog type ID */
<a name="2752"></a>    fileTypeID = FileTypeLog
<a name="2753"></a>
<a name="2754"></a>    /* show our cancellation mesage */
<a name="2755"></a>    showCancelMsg = ""
<a name="2756"></a>
<a name="2757"></a>    /* 
<a name="2758"></a>     *   Carry out our file operation.
<a name="2759"></a>     *   
<a name="2760"></a>     *   'desc' is an optional named argument giving a description string
<a name="2761"></a>     *   entered by the user via the Save Game dialog.  Some versions of
<a name="2762"></a>     *   the Save Game dialog let the user enter this additional
<a name="2763"></a>     *   information, which can be stored as part of the saved game
<a name="2764"></a>     *   metadata.  
<a name="2765"></a>     */
<a name="2766"></a>    performFileOp(fname, ack, desc:?)
<a name="2767"></a>    {
<a name="2768"></a>        /* 
<a name="2769"></a>         *   Each concrete action subclass must override this to carry out
<a name="2770"></a>         *   our operation.  This is called when the user has successfully
<a name="2771"></a>         *   selected a filename for the operation.  
<a name="2772"></a>         */
<a name="2773"></a>    }
<a name="2774"></a>
<a name="2775"></a>    execAction(cmd)
<a name="2776"></a>    {
<a name="2777"></a>        /* 
<a name="2778"></a>         *   ask for a file and carry out our action; since the command is
<a name="2779"></a>         *   being performed directly from the command line, we want an
<a name="2780"></a>         *   acknowledgment message on success 
<a name="2781"></a>         */
<a name="2782"></a>        setUpFileOp(true);
<a name="2783"></a>    }
<a name="2784"></a>
<a name="2785"></a>    /* ask for a file, and carry out our operation is we get one */
<a name="2786"></a>    setUpFileOp(ack)
<a name="2787"></a>    {
<a name="2788"></a>        local result;
<a name="2789"></a>
<a name="2790"></a>
<a name="2791"></a>        /* ask for a file */
<a name="2792"></a>        result = getInputFile(filePromptMsg, fileDisposition, fileTypeID, 0);
<a name="2793"></a>
<a name="2794"></a>        /* check the inputFile result */
<a name="2795"></a>        switch(result[1])
<a name="2796"></a>        {
<a name="2797"></a>        case InFileSuccess:
<a name="2798"></a>            /* carry out our file operation */
<a name="2799"></a>            if (result.length &gt;= 3)
<a name="2800"></a>                performFileOp(result[2], ack, desc:result[3]);
<a name="2801"></a>            else
<a name="2802"></a>                performFileOp(result[2], ack);
<a name="2803"></a>            break;
<a name="2804"></a>
<a name="2805"></a>        case InFileFailure:
<a name="2806"></a>            /* advise of the failure of the prompt */
<a name="2807"></a>            if (result.length() &gt; 1)
<a name="2808"></a>                filePromptFailedMsg(result[2]);
<a name="2809"></a>            else
<a name="2810"></a>                filePromptFailed();
<a name="2811"></a>            break;
<a name="2812"></a>
<a name="2813"></a>        case InFileCancel:
<a name="2814"></a>            /* acknowledge the cancellation */
<a name="2815"></a>            showCancelMsg();
<a name="2816"></a>            break;
<a name="2817"></a>        }
<a name="2818"></a>
<a name="2819"></a>        
<a name="2820"></a>    }
<a name="2821"></a>
<a name="2822"></a>    /* we can't include this in undo, as it affects external files */
<a name="2823"></a>    includeInUndo = nil
<a name="2824"></a>
<a name="2825"></a>    /* don't allow repeating with AGAIN */
<a name="2826"></a>    isRepeatable = nil
<a name="2827"></a>;
<a name="2828"></a>
<a name="2829"></a>/*
<a name="2830"></a> *   Turn scripting on.  This creates a text file that contains a
<a name="2831"></a> *   transcript of all commands and responses from this point forward.
<a name="2832"></a> */
<a name="2833"></a>DefineAction(ScriptOn, FileOpAction)
<a name="2834"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="2835"></a>    filePromptMsg = (BMsg(get scripting prompt, 'Please select a name for the
<a name="2836"></a>        new script file'))
<a name="2837"></a>    
<a name="2838"></a>    fileTypeID = FileTypeLog
<a name="2839"></a>    fileDisposition = InFileSave
<a name="2840"></a>
<a name="2841"></a>    /* show our cancellation mesasge */
<a name="2842"></a>    showCancelMsg() { DMsg(scripting canceled, '&lt;.parser&gt;Canceled.&lt;./parser&gt;'); }
<a name="2843"></a>
<a name="2844"></a>    /* 
<a name="2845"></a>     *   set up scripting - this can be used to set up scripting
<a name="2846"></a>     *   programmatically, in the course of carrying out another action 
<a name="2847"></a>     */
<a name="2848"></a>    setUpScripting(ack) { setUpFileOp(ack); }
<a name="2849"></a>
<a name="2850"></a>    /* turn on scripting to the given file */
<a name="2851"></a>    performFileOp(fname, ack)
<a name="2852"></a>    {
<a name="2853"></a>        /* turn on logging */
<a name="2854"></a>        local ok = nil, exc = nil;
<a name="2855"></a>        try
<a name="2856"></a>        {
<a name="2857"></a>            ok = aioSetLogFile(fname, LogTypeTranscript);
<a name="2858"></a>        }
<a name="2859"></a>        catch (Exception e)
<a name="2860"></a>        {
<a name="2861"></a>            exc = e;
<a name="2862"></a>        }
<a name="2863"></a>        if (ok)
<a name="2864"></a>        {
<a name="2865"></a>            /* remember that scripting is in effect */
<a name="2866"></a>            scriptStatus.scriptFile = fname;
<a name="2867"></a>
<a name="2868"></a>            /* 
<a name="2869"></a>             *   forget any past warning that we've issued about NOTE
<a name="2870"></a>             *   without a script in effect; the next time scripting isn't
<a name="2871"></a>             *   active, we'll want to issue a new warning, since they
<a name="2872"></a>             *   might not be aware at that point that the scripting we're
<a name="2873"></a>             *   starting now has ended 
<a name="2874"></a>             */
<a name="2875"></a>            scriptStatus.noteWithoutScriptWarning = nil;
<a name="2876"></a>
<a name="2877"></a>            /* note that logging is active, if acknowledgment is desired */
<a name="2878"></a>            if (ack)
<a name="2879"></a>            {
<a name="2880"></a>                if (fname.isWebTempFile)
<a name="2881"></a>                    htmlSay(scriptingOkayWebTemp);                  
<a name="2882"></a>                else
<a name="2883"></a>                    htmlSay(scriptingOkay);
<a name="2884"></a>                    
<a name="2885"></a>            }
<a name="2886"></a>        }
<a name="2887"></a>        else
<a name="2888"></a>        {
<a name="2889"></a>            /* scripting is no longer in effect */
<a name="2890"></a>            scriptStatus.scriptFile = nil;
<a name="2891"></a>
<a name="2892"></a>            /* show an error, if acknowledgment is desired */
<a name="2893"></a>            if (ack)
<a name="2894"></a>            {
<a name="2895"></a>                if (exc != nil)
<a name="2896"></a>                    DMsg(scripting failed exception, '&lt;.parser&gt;Failed; 
<a name="2897"></a>                        &lt;&lt;exc.displayException&gt;&gt;&lt;./parser&gt;&lt;.p&gt;');
<a name="2898"></a>                    
<a name="2899"></a>                else
<a name="2900"></a>                    DMsg(scripting failed, '&lt;.parser&gt;Failed; an error occurred
<a name="2901"></a>                        opening the script file.&lt;./parser&gt;&lt;.p&gt; ');
<a name="2902"></a>                   
<a name="2903"></a>            }
<a name="2904"></a>        }
<a name="2905"></a>    }
<a name="2906"></a>    
<a name="2907"></a>    scriptingOkayWebTemp = BMsg(scripting okay web temp,
<a name="2908"></a>                                '&lt;.parser&gt;The transcript will be saved.
<a name="2909"></a>                                Type &lt;&lt;aHref('script off', 'SCRIPT OFF', 
<a name="2910"></a>                                             'Turn off scripting')&gt;&gt;
<a name="2911"></a>                                to discontinue scripting and download the saved
<a name="2912"></a>                                transcript.&lt;./parser&gt;&lt;.p&gt; ')
<a name="2913"></a>    
<a name="2914"></a>    scriptingOkay = BMsg(scripting okay, '&lt;.parser&gt;The transcript will
<a name="2915"></a>                        be saved to the file. Type &lt;&lt;aHref('script off', 
<a name="2916"></a>                            'SCRIPT OFF', 'Turn off scripting')&gt;&gt; to
<a name="2917"></a>                        discontinue scripting.&lt;./parser&gt;&lt;.p&gt; ')
<a name="2918"></a>;
<a name="2919"></a>
<a name="2920"></a>/*
<a name="2921"></a> *   Subclass of Script action taking a quoted string as part of the
<a name="2922"></a> *   command syntax.  The grammar rule must set our fname_ property to a
<a name="2923"></a> *   quotedStringPhrase subproduction. 
<a name="2924"></a> */
<a name="2925"></a>DefineAction(ScriptString, ScriptOn)
<a name="2926"></a>    execAction(cmd)
<a name="2927"></a>    {
<a name="2928"></a>        /* if there's a filename, we don't need to prompt */
<a name="2929"></a>        if (fname_ != nil)
<a name="2930"></a>        {
<a name="2931"></a>            /* set up scripting to the filename specified in the command */
<a name="2932"></a>            performFileOp(fname_.getStringText(), true);
<a name="2933"></a>        }
<a name="2934"></a>        else
<a name="2935"></a>        {
<a name="2936"></a>            /* there's no filename, so prompt as usual */
<a name="2937"></a>            inherited();
<a name="2938"></a>        }
<a name="2939"></a>    }
<a name="2940"></a>;
<a name="2941"></a>
<a name="2942"></a>/*
<a name="2943"></a> *   Turn scripting off.  This stops recording the game transcript started
<a name="2944"></a> *   with the most recent SCRIPT command. 
<a name="2945"></a> */
<a name="2946"></a>DefineSystemAction(ScriptOff)
<a name="2947"></a>    execAction(cmd)
<a name="2948"></a>    {
<a name="2949"></a>        /* turn off scripting */
<a name="2950"></a>        turnOffScripting(true);
<a name="2951"></a>    }
<a name="2952"></a>
<a name="2953"></a>    /* turn off scripting */
<a name="2954"></a>    turnOffScripting(ack)
<a name="2955"></a>    {
<a name="2956"></a>        /* if we're not in a script file, ignore it */
<a name="2957"></a>        if (scriptStatus.scriptFile == nil)
<a name="2958"></a>        {
<a name="2959"></a>            DMsg(script off ignored, '&lt;.parser&gt;No script is currently being
<a name="2960"></a>                        recorded.&lt;./parser&gt;&lt;.p&gt;');
<a name="2961"></a>
<a name="2962"></a>            return;
<a name="2963"></a>        }
<a name="2964"></a>
<a name="2965"></a>        /* cancel scripting in the interpreter's output layer */
<a name="2966"></a>        aioSetLogFile(nil, LogTypeTranscript);
<a name="2967"></a>
<a name="2968"></a>        /* remember that scripting is no longer in effect */
<a name="2969"></a>        scriptStatus.scriptFile = nil;
<a name="2970"></a>
<a name="2971"></a>        /* acknowledge the change, if desired */
<a name="2972"></a>        if (ack)
<a name="2973"></a>            DMsg(script off okay, '&lt;.parser&gt;Scripting ended.&lt;./parser&gt;&lt;.p&gt;');
<a name="2974"></a>           
<a name="2975"></a>    }
<a name="2976"></a>
<a name="2977"></a>    /* we can't include this in undo, as it affects external files */
<a name="2978"></a>    includeInUndo = nil
<a name="2979"></a>;
<a name="2980"></a>
<a name="2981"></a>/*
<a name="2982"></a> *   RECORD - this is similar to SCRIPT, but stores a file containing only
<a name="2983"></a> *   the command input, not the output. 
<a name="2984"></a> */
<a name="2985"></a>DefineAction(Record, FileOpAction)
<a name="2986"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="2987"></a>    filePromptMsg = (BMsg(get recording prompt, 'Please select a name for the 
<a name="2988"></a>        new command log file'))
<a name="2989"></a>    
<a name="2990"></a>    fileTypeID = FileTypeCmd
<a name="2991"></a>    fileDisposition = InFileSave
<a name="2992"></a>
<a name="2993"></a>    /* show our cancellation mesasge */
<a name="2994"></a>    showCancelMsg() { DMsg(recording canceled, '&lt;.parser&gt;Canceled.&lt;./parser&gt;&lt;.p&gt; '); }
<a name="2995"></a>
<a name="2996"></a>    /* 
<a name="2997"></a>     *   set up recording - this can be used to set up scripting
<a name="2998"></a>     *   programmatically, in the course of carrying out another action 
<a name="2999"></a>     */
<a name="3000"></a>    setUpRecording(ack) { setUpFileOp(ack); }
<a name="3001"></a>
<a name="3002"></a>    /* turn on recording to the given file */
<a name="3003"></a>    performFileOp(fname, ack)
<a name="3004"></a>    {
<a name="3005"></a>        /* turn on command logging */
<a name="3006"></a>        local ok = nil, exc = nil;
<a name="3007"></a>        try
<a name="3008"></a>        {
<a name="3009"></a>            ok = aioSetLogFile(fname, logFileType);
<a name="3010"></a>        }
<a name="3011"></a>        catch (Exception e)
<a name="3012"></a>        {
<a name="3013"></a>            exc = e;
<a name="3014"></a>        }
<a name="3015"></a>        if (ok)
<a name="3016"></a>        {
<a name="3017"></a>            /* remember that recording is in effect */
<a name="3018"></a>            scriptStatus.recordFile = fname;
<a name="3019"></a>
<a name="3020"></a>            /* note that logging is active, if acknowledgment is desired */
<a name="3021"></a>            if (ack)
<a name="3022"></a>                 htmlSay(BMsg(recording okay, 
<a name="3023"></a>                              '&lt;.parser&gt;Commands will now be recorded.  Type
<a name="3024"></a>                     &lt;&lt;aHref('record off', 'RECORD OFF',
<a name="3025"></a>                             'Turn off recording')&gt;&gt;
<a name="3026"></a>                              to stop recording commands.&lt;./parser&gt;&lt;.p&gt; '));                
<a name="3027"></a>                
<a name="3028"></a>        }
<a name="3029"></a>        else
<a name="3030"></a>        {
<a name="3031"></a>            /* recording failed */
<a name="3032"></a>            scriptStatus.recordFile = nil;
<a name="3033"></a>
<a name="3034"></a>            /* show an error if acknowledgment is desired */
<a name="3035"></a>            if (ack)
<a name="3036"></a>            {
<a name="3037"></a>                if (exc != nil)
<a name="3038"></a>                    DMsg(recording failed exception, '&lt;.parser&gt;Failed; 
<a name="3039"></a>                        &lt;&lt;exc.displayException()&gt;&gt;&lt;./parser&gt;');
<a name="3040"></a>                    
<a name="3041"></a>                else
<a name="3042"></a>                    DMsg(recording failed, '&lt;.parser&gt;Failed; an error occurred
<a name="3043"></a>                        opening the command recording file.&lt;./parser&gt;&lt;.p&gt;');
<a name="3044"></a>            }
<a name="3045"></a>        }
<a name="3046"></a>    }
<a name="3047"></a>
<a name="3048"></a>    /* the log file type - by default, we open a regular command log */
<a name="3049"></a>    logFileType = LogTypeCommand
<a name="3050"></a>;
<a name="3051"></a>
<a name="3052"></a>/* subclass of Record action that sets up an event script recording */
<a name="3053"></a>DefineAction(RecordEvents, Record)
<a name="3054"></a>    logFileType = LogTypeScript
<a name="3055"></a>;
<a name="3056"></a>
<a name="3057"></a>/* subclass of Record action taking a quoted string for the filename */
<a name="3058"></a>DefineAction(RecordString, Record)
<a name="3059"></a>    execAction(cmd)
<a name="3060"></a>    {
<a name="3061"></a>        /* set up scripting to the filename specified in the command */
<a name="3062"></a>        performFileOp(fname_.getStringText(), true);
<a name="3063"></a>    }
<a name="3064"></a>;
<a name="3065"></a>
<a name="3066"></a>/* subclass of RecordString action that sets up an event script recording */
<a name="3067"></a>DefineAction(RecordEventsString, RecordString)
<a name="3068"></a>    logFileType = LogTypeScript
<a name="3069"></a>;
<a name="3070"></a>
<a name="3071"></a>/*
<a name="3072"></a> *   Turn command recording off.  This stops recording the command log
<a name="3073"></a> *   started with the most recent RECORD command.  
<a name="3074"></a> */
<a name="3075"></a>DefineSystemAction(RecordOff)
<a name="3076"></a>    execAction(cmd)
<a name="3077"></a>    {
<a name="3078"></a>        /* turn off recording */
<a name="3079"></a>        turnOffRecording(true);
<a name="3080"></a>    }
<a name="3081"></a>
<a name="3082"></a>    /* turn off recording */
<a name="3083"></a>    turnOffRecording(ack)
<a name="3084"></a>    {
<a name="3085"></a>        /* if we're not recording anything, ignore it */
<a name="3086"></a>        if (scriptStatus.recordFile == nil)
<a name="3087"></a>        {
<a name="3088"></a>            DMsg(record off ignored, '&lt;.parser&gt;No command recording is currently
<a name="3089"></a>                being made.&lt;./parser&gt;&lt;.p&gt; ');
<a name="3090"></a>           
<a name="3091"></a>            return;
<a name="3092"></a>        }
<a name="3093"></a>
<a name="3094"></a>        /* cancel recording in the interpreter's output layer */
<a name="3095"></a>        aioSetLogFile(nil, LogTypeCommand);
<a name="3096"></a>
<a name="3097"></a>        /* remember that recording is no longer in effect */
<a name="3098"></a>        scriptStatus.recordFile = nil;
<a name="3099"></a>
<a name="3100"></a>        /* acknowledge the change, if desired */
<a name="3101"></a>        if (ack)
<a name="3102"></a>            DMsg(record off okay, '&lt;.parser&gt;Command recording ended.&lt;./parser&gt;&lt;.p&gt; ');
<a name="3103"></a>    }
<a name="3104"></a>
<a name="3105"></a>    /* we can't include this in undo, as it affects external files */
<a name="3106"></a>    includeInUndo = nil
<a name="3107"></a>;
<a name="3108"></a>
<a name="3109"></a>/*
<a name="3110"></a> *   REPLAY - play back a command log previously recorded. 
<a name="3111"></a> */
<a name="3112"></a>DefineAction(Replay, FileOpAction)
<a name="3113"></a>    /* our file dialog parameters - ask for a log file to save */
<a name="3114"></a>    filePromptMsg = (BMsg(get replay prompt, 'Please select the command log file
<a name="3115"></a>        to replay'))
<a name="3116"></a>    
<a name="3117"></a>    fileTypeID = FileTypeCmd
<a name="3118"></a>    fileDisposition = InFileOpen
<a name="3119"></a>
<a name="3120"></a>    /* show our cancellation mesasge */
<a name="3121"></a>    showCancelMsg() { DMsg(replay canceled, '&lt;.parser&gt;Canceled.&lt;./parser&gt;&lt;.p&gt; '); }
<a name="3122"></a>
<a name="3123"></a>    /* script flags passed to setScriptFile */
<a name="3124"></a>    scriptOptionFlags = 0
<a name="3125"></a>
<a name="3126"></a>    /* replay the given file */
<a name="3127"></a>    performFileOp(fname, ack)
<a name="3128"></a>    {
<a name="3129"></a>        /* 
<a name="3130"></a>         *   Note that we're reading from the script file if desired.  Do
<a name="3131"></a>         *   this before opening the script, so that we display the
<a name="3132"></a>         *   acknowledgment even if we're in 'quiet' mode. 
<a name="3133"></a>         */
<a name="3134"></a>        if (ack)
<a name="3135"></a>            inputScriptOkay(
<a name="3136"></a>                fname.ofKind(TemporaryFile) ? fname.getFilename() : fname);
<a name="3137"></a>
<a name="3138"></a>        /* activate the script file */
<a name="3139"></a>        local ok = nil, exc = nil;
<a name="3140"></a>        try
<a name="3141"></a>        {
<a name="3142"></a>            ok = setScriptFile(fname, scriptOptionFlags);
<a name="3143"></a>        }
<a name="3144"></a>        catch (Exception e)
<a name="3145"></a>        {
<a name="3146"></a>            exc = e;
<a name="3147"></a>        }
<a name="3148"></a>        if (!ok)
<a name="3149"></a>        {
<a name="3150"></a>            if (exc != nil)
<a name="3151"></a>                DMsg(input script failed exception, '&lt;.parser&gt;Failed; 
<a name="3152"></a>                    &lt;&lt;exc.displayException&gt;&gt;&lt;./parser&gt;');               
<a name="3153"></a>            else
<a name="3154"></a>                DMsg(input script failed, '&lt;.parser&gt;Failed; the script input
<a name="3155"></a>                    file could not be opened.&lt;./parser&gt;');
<a name="3156"></a>              
<a name="3157"></a>        }
<a name="3158"></a>    }
<a name="3159"></a>    
<a name="3160"></a>    /* acknowledge starting an input script */
<a name="3161"></a>    inputScriptOkay(fname)
<a name="3162"></a>    {
<a name="3163"></a>        DMsg(input script okay, '&lt;.parser&gt;Reading commands from &lt;q&gt;&lt;&lt;
<a name="3164"></a>          File.getRootName(fname).htmlify()&gt;&gt;&lt;/q&gt;...&lt;./parser&gt;\n ');
<a name="3165"></a>    }
<a name="3166"></a>
<a name="3167"></a>    
<a name="3168"></a>;
<a name="3169"></a>
<a name="3170"></a>/* subclass of Replay action taking a quoted string for the filename */
<a name="3171"></a>DefineAction(ReplayString, Replay)
<a name="3172"></a>    execAction(cmd)
<a name="3173"></a>    {
<a name="3174"></a>        /* 
<a name="3175"></a>         *   if there's a string, use the string as the filename;
<a name="3176"></a>         *   otherwise, inherit the default handling to ask for a filename 
<a name="3177"></a>         */
<a name="3178"></a>        if (fname_ != nil)
<a name="3179"></a>        {
<a name="3180"></a>            /* set up scripting to the filename specified in the command */
<a name="3181"></a>            performFileOp(fname_.getStringText(), true);
<a name="3182"></a>        }
<a name="3183"></a>        else
<a name="3184"></a>        {
<a name="3185"></a>            /* inherit the default handling to ask for a filename */
<a name="3186"></a>            inherited();
<a name="3187"></a>        }
<a name="3188"></a>    }
<a name="3189"></a>;
<a name="3190"></a>
<a name="3191"></a>
<a name="3192"></a>/* ------------------------------------------------------------------------ */
<a name="3193"></a>/*
<a name="3194"></a> *   Special "save" action.  This command saves the current game state to
<a name="3195"></a> *   an external file for later restoration. 
<a name="3196"></a> */
<a name="3197"></a>DefineAction(Save, FileOpAction)
<a name="3198"></a>    /* the file dialog prompt */
<a name="3199"></a>    filePromptMsg = (BMsg(get save prompt, 'Save game to file'))
<a name="3200"></a>
<a name="3201"></a>    /* we're asking for a file to save, or type t3-save */
<a name="3202"></a>    fileDisposition = InFileSave
<a name="3203"></a>    fileTypeID = FileTypeT3Save
<a name="3204"></a>
<a name="3205"></a>    /* cancel message */
<a name="3206"></a>    showCancelMsg() { DMsg(save cancelled, '&lt;.parser&gt;Canceled.&lt;./parser&gt; '); }
<a name="3207"></a>    
<a name="3208"></a>    /* perform a save */
<a name="3209"></a>    performFileOp(fname, ack, desc:?)
<a name="3210"></a>    {
<a name="3211"></a>        /* before saving the game, notify all PreSaveObject instances */
<a name="3212"></a>        PreSaveObject.classExec();
<a name="3213"></a>        
<a name="3214"></a>        /* 
<a name="3215"></a>         *   Save the game to the given file.  If an error occurs, the
<a name="3216"></a>         *   save routine will throw a runtime error.  
<a name="3217"></a>         */
<a name="3218"></a>        try
<a name="3219"></a>        {
<a name="3220"></a>            /* try saving the game */
<a name="3221"></a>            saveGame(fname, gameMain.getSaveDesc(desc));
<a name="3222"></a>        }
<a name="3223"></a>        catch (StorageServerError sse)
<a name="3224"></a>        {
<a name="3225"></a>            /* the save failed due to a storage server problem - explain */           
<a name="3226"></a>            DMsg(save failed on server, '&lt;.parser&gt;Failed, because of a problem
<a name="3227"></a>                accessing the storage server:
<a name="3228"></a>                &lt;&lt;makeSentence(sse.errMsg)&gt;&gt;&lt;./parser&gt;');
<a name="3229"></a>
<a name="3230"></a>            /* done */
<a name="3231"></a>            return;
<a name="3232"></a>        }
<a name="3233"></a>        catch (RuntimeError err)
<a name="3234"></a>        {
<a name="3235"></a>            /* the save failed - mention the problem */
<a name="3236"></a>            DMsg(save failed, '&lt;.parser&gt;Failed; your computer might be running
<a name="3237"></a>                low on disk space, or you might not have the necessary
<a name="3238"></a>                permissions to write this file.&lt;./parser&gt;');            
<a name="3239"></a>            
<a name="3240"></a>            /* done */
<a name="3241"></a>            return;
<a name="3242"></a>        }
<a name="3243"></a>        
<a name="3244"></a>        /* note the successful save */
<a name="3245"></a>        DMsg(save okay, '&lt;.parser&gt;Saved.&lt;./parser&gt; ');
<a name="3246"></a>        
<a name="3247"></a>    }
<a name="3248"></a>
<a name="3249"></a>    /* 
<a name="3250"></a>     *   Saving has no effect on game state, so it's irrelevant whether or
<a name="3251"></a>     *   not it's undoable; but it might be confusing to say we undid a
<a name="3252"></a>     *   "save" command, because the player might think we deleted the
<a name="3253"></a>     *   saved file.  To avoid such confusion, do not include "save"
<a name="3254"></a>     *   commands in the undo log.  
<a name="3255"></a>     */
<a name="3256"></a>    includeInUndo = nil
<a name="3257"></a>
<a name="3258"></a>    /* 
<a name="3259"></a>     *   Don't allow this to be repeated with AGAIN.  There's no point in
<a name="3260"></a>     *   repeating a SAVE immediately, as nothing will have changed in the
<a name="3261"></a>     *   game state to warrant saving again.  
<a name="3262"></a>     */
<a name="3263"></a>    isRepeatable = nil
<a name="3264"></a>;
<a name="3265"></a>
<a name="3266"></a>/*
<a name="3267"></a> *   Subclass of Save action that takes a literal string as part of the
<a name="3268"></a> *   command.  The filename must be a literal enclosed in quotes, and the
<a name="3269"></a> *   string (with the quotes) must be stored in our fname_ property by
<a name="3270"></a> *   assignment of a quotedStringPhrase production in the grammar rule.  
<a name="3271"></a> */
<a name="3272"></a>DefineAction(SaveString, Save)
<a name="3273"></a>    execAction(cmd)
<a name="3274"></a>    {
<a name="3275"></a>        /* 
<a name="3276"></a>         *   Perform the save, using the filename given in our fname_
<a name="3277"></a>         *   parameter, trimmed of quotes.  
<a name="3278"></a>         */
<a name="3279"></a>        performFileOp(fname_.getStringText(), true);
<a name="3280"></a>    }
<a name="3281"></a>;
<a name="3282"></a>
<a name="3283"></a>DefineSystemAction(Restore)
<a name="3284"></a>    execAction(cmd)
<a name="3285"></a>    {
<a name="3286"></a>        /* ask for a file and restore it */
<a name="3287"></a>        askAndRestore();
<a name="3288"></a>
<a name="3289"></a>        /* 
<a name="3290"></a>         *   regardless of what happened, abandon any additional commands
<a name="3291"></a>         *   on the same command line 
<a name="3292"></a>         */
<a name="3293"></a>        throw new TerminateCommandException();
<a name="3294"></a>    }
<a name="3295"></a>
<a name="3296"></a>    /*
<a name="3297"></a>     *   Ask for a file and try to restore it.  Returns true on success,
<a name="3298"></a>     *   nil on failure.  (Failure could indicate that the user chose to
<a name="3299"></a>     *   cancel out of the file selector, that we couldn't find the file to
<a name="3300"></a>     *   restore, or that the file isn't a valid saved state file.  In any
<a name="3301"></a>     *   case, we show an appropriate message on failure.)  
<a name="3302"></a>     */
<a name="3303"></a>    askAndRestore()
<a name="3304"></a>    {
<a name="3305"></a>        local succ;        
<a name="3306"></a>        local result;
<a name="3307"></a>
<a name="3308"></a>
<a name="3309"></a>        /* presume failure */
<a name="3310"></a>        succ = nil;
<a name="3311"></a>
<a name="3312"></a>        /* ask for a file */
<a name="3313"></a>        result = getInputFile(BMsg(get restore prompt, 'Restore game from file'), 
<a name="3314"></a>                              InFileOpen, FileTypeT3Save, 0);
<a name="3315"></a>
<a name="3316"></a>        /* check the inputFile response */
<a name="3317"></a>        switch(result[1])
<a name="3318"></a>        {
<a name="3319"></a>        case InFileSuccess:
<a name="3320"></a>            /* 
<a name="3321"></a>             *   try restoring the file; use code 2 to indicate that the
<a name="3322"></a>             *   restoration was performed by an explicit RESTORE command 
<a name="3323"></a>             */
<a name="3324"></a>            if (performRestore(result[2], 2))
<a name="3325"></a>            {
<a name="3326"></a>                /* note that we succeeded */
<a name="3327"></a>                succ = true;
<a name="3328"></a>            }
<a name="3329"></a>           
<a name="3330"></a>            /* done */
<a name="3331"></a>            break;
<a name="3332"></a>
<a name="3333"></a>        case InFileFailure:
<a name="3334"></a>            /* advise of the failure of the prompt */
<a name="3335"></a>            if (result.length() &gt; 1)
<a name="3336"></a>                filePromptFailedMsg(result[2]);
<a name="3337"></a>            else
<a name="3338"></a>                filePromptFailed();
<a name="3339"></a>            break;
<a name="3340"></a>
<a name="3341"></a>        case InFileCancel:
<a name="3342"></a>            /* acknowledge the cancellation */
<a name="3343"></a>            DMsg(restore canceled, '&lt;.parser&gt;Canceled.&lt;./parser&gt; ');            
<a name="3344"></a>            break;
<a name="3345"></a>        }
<a name="3346"></a>
<a name="3347"></a>        /* 
<a name="3348"></a>         *   If we were successful, clear out the AGAIN memory.  This
<a name="3349"></a>         *   avoids any confusion about whether we're repeating the RESTORE
<a name="3350"></a>         *   command itself, the command just before RESTORE from the
<a name="3351"></a>         *   current session, or the last command before SAVE from the
<a name="3352"></a>         *   restored game. 
<a name="3353"></a>         */
<a name="3354"></a>        if (succ)
<a name="3355"></a>            Again.clearForAgain();
<a name="3356"></a>
<a name="3357"></a>        /* return the success/failure indication */
<a name="3358"></a>        return succ;
<a name="3359"></a>    }
<a name="3360"></a>
<a name="3361"></a>    /*
<a name="3362"></a>     *   Restore a game on startup.  This can be called from mainRestore()
<a name="3363"></a>     *   to restore a saved game directly as part of loading the game.
<a name="3364"></a>     *   (Most interpreters provide a way of starting the interpreter
<a name="3365"></a>     *   directly with a saved game to be restored, skipping the
<a name="3366"></a>     *   intermediate step of running the game and using a RESTORE
<a name="3367"></a>     *   command.)
<a name="3368"></a>     *   
<a name="3369"></a>     *   Returns true on success, nil on failure.  On failure, the caller
<a name="3370"></a>     *   should simply exit the program.  On success, the caller should
<a name="3371"></a>     *   start the game running, usually using runGame(), after showing any
<a name="3372"></a>     *   desired introductory messages.  
<a name="3373"></a>     */
<a name="3374"></a>    startupRestore(fname)
<a name="3375"></a>    {
<a name="3376"></a>        /* 
<a name="3377"></a>         *   try restoring the game, using code 1 to indicate that this is
<a name="3378"></a>         *   a direct startup restore 
<a name="3379"></a>         */
<a name="3380"></a>        if (performRestore(fname, 1))
<a name="3381"></a>        {
<a name="3382"></a>            /* success - tell the caller to proceed with the restored game */
<a name="3383"></a>            return true;
<a name="3384"></a>        }
<a name="3385"></a>        else
<a name="3386"></a>        {
<a name="3387"></a>            /* 
<a name="3388"></a>             *   Failure.  We've described the problem, so ask the user
<a name="3389"></a>             *   what they want to do about it. 
<a name="3390"></a>             */
<a name="3391"></a>            try
<a name="3392"></a>            {
<a name="3393"></a>                /* show options and read the response */
<a name="3394"></a>                failedRestoreOptions();
<a name="3395"></a>
<a name="3396"></a>                /* if we get here, proceed with the game */
<a name="3397"></a>                return true;
<a name="3398"></a>            }
<a name="3399"></a>            catch (QuittingException qe)
<a name="3400"></a>            {
<a name="3401"></a>                /* quitting - tell the caller to terminate */
<a name="3402"></a>                return nil;
<a name="3403"></a>            }
<a name="3404"></a>        }
<a name="3405"></a>    }
<a name="3406"></a>    
<a name="3407"></a>
<a name="3408"></a>    /*
<a name="3409"></a>     *   Restore a file.  'code' is the restoreCode value for the
<a name="3410"></a>     *   PostRestoreObject notifications.  Returns true on success, nil on
<a name="3411"></a>     *   failure.  
<a name="3412"></a>     */
<a name="3413"></a>    performRestore(fname, code)
<a name="3414"></a>    {
<a name="3415"></a>        try
<a name="3416"></a>        {
<a name="3417"></a>            /* restore the file */
<a name="3418"></a>            restoreGame(fname);
<a name="3419"></a>        }
<a name="3420"></a>        catch (StorageServerError sse)
<a name="3421"></a>        {
<a name="3422"></a>            /* failed due to a storage server error - explain the problem */
<a name="3423"></a>            DMsg(restore failed on server,'&lt;.parser&gt;Failed, because of a problem
<a name="3424"></a>                accessing the storage server:
<a name="3425"></a>                &lt;&lt;makeSentence(sse.errMsg)&gt;&gt;&lt;./parser&gt;');            
<a name="3426"></a>
<a name="3427"></a>            /* indicate failure */
<a name="3428"></a>            return nil;
<a name="3429"></a>        }
<a name="3430"></a>        catch (RuntimeError err)
<a name="3431"></a>        {
<a name="3432"></a>            /* failed - check the error to see what went wrong */
<a name="3433"></a>            switch(err.errno_)
<a name="3434"></a>            {
<a name="3435"></a>            case 1201:
<a name="3436"></a>                /* not a saved state file */
<a name="3437"></a>                DMsg(restore invalid file, '&lt;.parser&gt;Failed: this is not a valid
<a name="3438"></a>                    saved position file.&lt;./parser&gt; ');                
<a name="3439"></a>                break;
<a name="3440"></a>                
<a name="3441"></a>            case 1202:
<a name="3442"></a>                /* saved by different game or different version */
<a name="3443"></a>                DMsg(restore invalid match, '&lt;.parser&gt;Failed: the file was not
<a name="3444"></a>                    saved by this story (or was saved by an incompatible version
<a name="3445"></a>                    of the story).&lt;./parser&gt; ');               
<a name="3446"></a>                break;
<a name="3447"></a>                
<a name="3448"></a>            case 1207:
<a name="3449"></a>                /* corrupted saved state file */
<a name="3450"></a>                DMsg(restore corrupted file, '&lt;.parser&gt;Failed: this saved state
<a name="3451"></a>                    file appears to be corrupted.  This can occur if the file
<a name="3452"></a>                    was modified by another program, or the file was copied
<a name="3453"></a>                    between computers in a non-binary transfer mode, or the
<a name="3454"></a>                    physical media storing the file were damaged.&lt;./parser&gt; ');                
<a name="3455"></a>                break;
<a name="3456"></a>                
<a name="3457"></a>            default:
<a name="3458"></a>                /* some other failure */
<a name="3459"></a>                DMsg(restore failed, '&lt;.parser&gt;Failed: the position could not be
<a name="3460"></a>                    restored.&lt;./parser&gt;');                
<a name="3461"></a>                break;
<a name="3462"></a>            }
<a name="3463"></a>
<a name="3464"></a>            /* indicate failure */
<a name="3465"></a>            return nil;
<a name="3466"></a>        }
<a name="3467"></a>
<a name="3468"></a>        /* note that we've successfully restored the game */
<a name="3469"></a>        DMsg(restore okay, '&lt;.parser&gt;Restored.&lt;./parser&gt; ');
<a name="3470"></a>               
<a name="3471"></a>        /* set the appropriate restore-action code */
<a name="3472"></a>        PostRestoreObject.restoreCode = code;
<a name="3473"></a>
<a name="3474"></a>        /* notify all PostRestoreObject instances */
<a name="3475"></a>        PostRestoreObject.classExec();
<a name="3476"></a>
<a name="3477"></a>        /* 
<a name="3478"></a>         *   look around, to refresh the player's memory of the state the
<a name="3479"></a>         *   game was in when saved 
<a name="3480"></a>         */
<a name="3481"></a>        "\b";
<a name="3482"></a>        libGlobal.playerChar.outermostVisibleParent().lookAroundWithin();
<a name="3483"></a>
<a name="3484"></a>        /* indicate success */
<a name="3485"></a>        return true;
<a name="3486"></a>    }
<a name="3487"></a>    
<a name="3488"></a>    /* 
<a name="3489"></a>     *   There's no point in including this in undo.  If the command
<a name="3490"></a>     *   succeeds, it's not undoable itself, and there won't be any undo
<a name="3491"></a>     *   information in the newly restored state.  If the command fails, it
<a name="3492"></a>     *   won't make any changes to the game state, so there won't be
<a name="3493"></a>     *   anything to undo.  
<a name="3494"></a>     */
<a name="3495"></a>    includeInUndo = nil
<a name="3496"></a>    
<a name="3497"></a>    /* error showing the input file dialog (or character-mode equivalent) */
<a name="3498"></a>    filePromptFailed()
<a name="3499"></a>    {
<a name="3500"></a>        DMsg(file prompt failed, '&lt;.parser&gt;A system error occurred asking for a
<a name="3501"></a>            filename. Your computer might be running low on memory, or might
<a name="3502"></a>            have a configuration problem.&lt;./parser&gt; ');
<a name="3503"></a>    }
<a name="3504"></a>
<a name="3505"></a>    /* error showing the input file dialog, with a system error message */
<a name="3506"></a>    filePromptFailedMsg(msg)
<a name="3507"></a>    {
<a name="3508"></a>        DMsg(file prompt failed msg, '&lt;.parser&gt;Failed:
<a name="3509"></a>            &lt;&lt;makeSentence(msg)&gt;&gt;&lt;./parser&gt; ');
<a name="3510"></a>    }
<a name="3511"></a>;
<a name="3512"></a>
<a name="3513"></a>/*
<a name="3514"></a> *   Subclass of Restore action that takes a literal string as part of the
<a name="3515"></a> *   command.  The filename must be a literal enclosed in quotes, and the
<a name="3516"></a> *   string (with the quotes) must be stored in our fname_ property by
<a name="3517"></a> *   assignment of a quotedStringPhrase production in the grammar rule.  
<a name="3518"></a> */
<a name="3519"></a>DefineAction(RestoreString, Restore)
<a name="3520"></a>    execAction(cmd)
<a name="3521"></a>    {
<a name="3522"></a>        /* 
<a name="3523"></a>         *   Perform the restore, using the filename given in our fname_
<a name="3524"></a>         *   parameter, trimmed of quotes.  Use code 2, the same as any
<a name="3525"></a>         *   other explicit RESTORE command.  
<a name="3526"></a>         */
<a name="3527"></a>        performRestore(fname_.getStringText(), 2);
<a name="3528"></a>
<a name="3529"></a>        /* abandon any additional commands on the same command line */
<a name="3530"></a>        throw new TerminateCommandException();
<a name="3531"></a>    }
<a name="3532"></a>;
<a name="3533"></a>
<a name="3534"></a>
<a name="3535"></a>DefineSystemAction(Again)
<a name="3536"></a>    
<a name="3537"></a>    exec(cmd)
<a name="3538"></a>    {
<a name="3539"></a>        if((gameMain.againRepeatsParse &amp;&amp; libGlobal.lastCommandForAgain is in
<a name="3540"></a>           ('',nil)) || (!gameMain.againRepeatsParse &amp;&amp; libGlobal.lastCommand is
<a name="3541"></a>           in ('', nil)))
<a name="3542"></a>        {
<a name="3543"></a>            DMsg(no repeat, 'Sorry, there is no action available to repeat. ');
<a name="3544"></a>        }
<a name="3545"></a>        else if (gameMain.againRepeatsParse)
<a name="3546"></a>        {
<a name="3547"></a>            Parser.parse(libGlobal.lastCommandForAgain);
<a name="3548"></a>        }
<a name="3549"></a>        else
<a name="3550"></a>        {
<a name="3551"></a>            libGlobal.lastCommand.exec();
<a name="3552"></a>        }
<a name="3553"></a>    }
<a name="3554"></a>    
<a name="3555"></a>    clearForAgain()
<a name="3556"></a>    {
<a name="3557"></a>        libGlobal.lastAction = nil;
<a name="3558"></a>        libGlobal.lastCommand = nil;
<a name="3559"></a>    }
<a name="3560"></a>    
<a name="3561"></a>    againRepeatsParse = nil 
<a name="3562"></a>    
<a name="3563"></a>;
<a name="3564"></a>
<a name="3565"></a>/* Dummy action to provide an action context. */
<a name="3566"></a>
<a name="3567"></a>DefineTIAction(DoNothing)
<a name="3568"></a>    curDobj = gPlayerChar
<a name="3569"></a>    curIobj = gPlayerChar.location
<a name="3570"></a>    curObj = curDobj
<a name="3571"></a>    grammarTemplates = ['do nothing']
<a name="3572"></a>;
<a name="3573"></a>
<a name="3574"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 08/12/2025 from adv3Lite version 2.2.2</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>file.h</title></head><body>
<table class=ban><tr><td><h1>file.h</h1><td align=right><a href="../file/file.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   Copyright (c) 2001, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This header defines the File intrinsic class.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>
<a name="13"></a>/* include our base class definition */
<a name="14"></a>#include "systype.h"
<a name="15"></a>
<a name="16"></a>/*
<a name="17"></a> *   File methods use the CharacterSet and ByteArray intrinsic
<a name="18"></a> *   classes, so include their headers to make sure they're available to
<a name="19"></a> *   File users.  
<a name="20"></a> */
<a name="21"></a>#include "charset.h"
<a name="22"></a>#include "bytearr.h"
<a name="23"></a>
<a name="24"></a>/* if we're using File objects, we probably want FileName objects as well */
<a name="25"></a>#include "filename.h"
<a name="26"></a>
<a name="27"></a>/* ------------------------------------------------------------------------ */
<a name="28"></a>/*
<a name="29"></a> *   File access modes.  These are used when calling the file open methods
<a name="30"></a> *   to specify how the file is to be accessed.
<a name="31"></a> */
<a name="32"></a>
<a name="33"></a>/* 
<a name="34"></a> *   Read mode - the file is opened for reading (writing is not allowed).
<a name="35"></a> *   When opened in this mode, the file must exist, or a
<a name="36"></a> *   FileNotFoundException is thrown from the open method. 
<a name="37"></a> */
<a name="38"></a>#define FileAccessRead            0x0001
<a name="39"></a>
<a name="40"></a>/*
<a name="41"></a> *   Write mode - the file is opened for writing (reading is not allowed).
<a name="42"></a> *   When opened in this mode, if the file doesn't already exist, a new file
<a name="43"></a> *   is created; if the file does already exist, the existing data in the
<a name="44"></a> *   file are discarded (i.e., the file is truncated to zero length) on
<a name="45"></a> *   open. 
<a name="46"></a> */
<a name="47"></a>#define FileAccessWrite           0x0002
<a name="48"></a>
<a name="49"></a>/*
<a name="50"></a> *   Read/write mode, keeping existing contents - the file is opened for
<a name="51"></a> *   both reading and writing.  If the file does not exist, a new file is
<a name="52"></a> *   created.  If the file does already exist, the existing contents of the
<a name="53"></a> *   file are kept intact on open.  
<a name="54"></a> */
<a name="55"></a>#define FileAccessReadWriteKeep   0x0003
<a name="56"></a>
<a name="57"></a>/*
<a name="58"></a> *   Read/write mode, truncating existing contents - the file is opened for
<a name="59"></a> *   both reading and writing.  If the file does not exist, a new file is
<a name="60"></a> *   created.  If the file does already exist, the existing contents of the
<a name="61"></a> *   file are discarded (i.e., the file is truncated to zero length) on
<a name="62"></a> *   open.  
<a name="63"></a> */
<a name="64"></a>#define FileAccessReadWriteTrunc  0x0004
<a name="65"></a>
<a name="66"></a>
<a name="67"></a>/* ------------------------------------------------------------------------ */
<a name="68"></a>/*
<a name="69"></a> *   File mode constants.  These are returned from getFileMode() to indicate
<a name="70"></a> *   the mode used to open the file.  
<a name="71"></a> */
<a name="72"></a>
<a name="73"></a>/* text mode */
<a name="74"></a>#define FileModeText  1
<a name="75"></a>
<a name="76"></a>/* "data" mode */
<a name="77"></a>#define FileModeData  2
<a name="78"></a>
<a name="79"></a>/* "raw" mode */
<a name="80"></a>#define FileModeRaw   3
<a name="81"></a>
<a name="82"></a>
<a name="83"></a>/* ------------------------------------------------------------------------ */
<a name="84"></a>/*
<a name="85"></a> *   Special file identifiers.  These identifiers can be passed to the 'open'
<a name="86"></a> *   routines in place of the filename string argument.
<a name="87"></a> *   
<a name="88"></a> *   The actual name and location of a special file is determined by the
<a name="89"></a> *   interpreter.  Since games use these internal identifiers rather than the
<a name="90"></a> *   actual system filenames when accessing special files, different
<a name="91"></a> *   interpreters can adapt to different local conventions without bothering
<a name="92"></a> *   the game code with the details.  The game code simply refers to the file
<a name="93"></a> *   it wants using the virtual identifier, and the interpreter takes care of
<a name="94"></a> *   the rest.
<a name="95"></a> *   
<a name="96"></a> *   Note that special files generally bypass the interpreter "file safety"
<a name="97"></a> *   settings.  This is important because it allows the library and games a
<a name="98"></a> *   degree of controlled access to the file system, even when the file
<a name="99"></a> *   safety settings wouldn't normally allow similar access for arbitrary
<a name="100"></a> *   file operations.  Even though this special file access can bypass the
<a name="101"></a> *   file safety level, it doesn't compromise security, because the
<a name="102"></a> *   interpreter has exclusive control over the names and locations of the
<a name="103"></a> *   special files - thus a game can only access the particular files that
<a name="104"></a> *   the interpreter designates as special, and can't use special files to
<a name="105"></a> *   access arbitrary file system entities.  
<a name="106"></a> */
<a name="107"></a>
<a name="108"></a>/*
<a name="109"></a> *   The library defaults file.  This is the special file where the library
<a name="110"></a> *   stores user-controlled start-up default settings.  
<a name="111"></a> */
<a name="112"></a>#define LibraryDefaultsFile    0x0001
<a name="113"></a>
<a name="114"></a>/*
<a name="115"></a> *   Web UI preference settings file.  This is the special file where we
<a name="116"></a> *   store display style settings for the Web UI.  
<a name="117"></a> */
<a name="118"></a>#define WebUIPrefsFile         0x0002
<a name="119"></a>
<a name="120"></a>
<a name="121"></a>/* ------------------------------------------------------------------------ */
<a name="122"></a>/*
<a name="123"></a> *   The File intrinsic class provides access to files in the external file
<a name="124"></a> *   system.  This lets you create, read, and write files.  The class
<a name="125"></a> *   supports text files (with translations to and from local character
<a name="126"></a> *   sets), "data" files (using the special TADS 2 binary file format), and
<a name="127"></a> *   "raw" files (this mode lets you manipulate files in arbitrary text or
<a name="128"></a> *   binary formats by giving you direct access to the raw bytes in the
<a name="129"></a> *   file).  
<a name="130"></a> */
<a name="131"></a>intrinsic class File 'file/030003': Object
<a name="132"></a>{
<a name="133"></a>    /*
<a name="134"></a>     *   File has no constructors.  Instead of using 'new', you create a File
<a name="135"></a>     *   object by opening a file through one of the openXxxFile methods:
<a name="136"></a>     *   
<a name="137"></a>     *   f = File.openTextFile()
<a name="138"></a>     *   
<a name="139"></a>     *   All of the open methods have a 'filename' argument giving the name
<a name="140"></a>     *   of the file to open.  This is usually a string giving a file name in
<a name="141"></a>     *   the local file system.  You can also use a TemporaryFile object in
<a name="142"></a>     *   place of a filename, to open a temporary file.
<a name="143"></a>     *   
<a name="144"></a>     *   All of the open methods throw exceptions if the open fails:
<a name="145"></a>     *   
<a name="146"></a>     *   FileNotFoundException - indicates that the requested file doesn't
<a name="147"></a>     *   exist.  This is thrown when the access mode requires an existing
<a name="148"></a>     *   file but the named file does not exist.
<a name="149"></a>     *   
<a name="150"></a>     *   FileCreationException - indicates that the requested file couldn't
<a name="151"></a>     *   be created.  This is thrown when the access mode requires creating a
<a name="152"></a>     *   new file but the named file cannot be created.
<a name="153"></a>     *   
<a name="154"></a>     *   FileOpenException - indicates that the requested file couldn't be
<a name="155"></a>     *   opened.  This is thrown when the access mode allows either an
<a name="156"></a>     *   existing file to be opened or a new file to be created, but neither
<a name="157"></a>     *   could be accomplished.
<a name="158"></a>     *   
<a name="159"></a>     *   FileSafetyException - the requested access mode isn't allowed for
<a name="160"></a>     *   the given file due to the current file safety level set by the user.
<a name="161"></a>     *   Users can set the file safety level (through command-line switches
<a name="162"></a>     *   or other preference mechanisms which vary by interpreter) to
<a name="163"></a>     *   restrict the types of file operations that applications are allowed
<a name="164"></a>     *   to perform, in order to protect their systems from malicious
<a name="165"></a>     *   programs.  This exception indicates that the user has set a safety
<a name="166"></a>     *   level that is too restrictive for the requested operation.  
<a name="167"></a>     */
<a name="168"></a>
<a name="169"></a>    /*
<a name="170"></a>     *   Static creator method: open a text file.  Returns a File object that
<a name="171"></a>     *   can be used to read or write the file.
<a name="172"></a>     *   
<a name="173"></a>     *   'filename' is the name of the file to open.  This is a string giving
<a name="174"></a>     *   the name of a file in the local file system.  It can alternatively
<a name="175"></a>     *   be a TemporaryFile object, to open a temporary file.
<a name="176"></a>     *   
<a name="177"></a>     *   'access' is the read/write mode, and must be one of FileAccessRead
<a name="178"></a>     *   or FileAccessWrite.
<a name="179"></a>     *   
<a name="180"></a>     *   'charset' is a CharacterSet object, or can optionally be a string
<a name="181"></a>     *   naming a character set, in which case a CharacterSet object for the
<a name="182"></a>     *   named character set will automatically be created.  If 'charset' is
<a name="183"></a>     *   omitted, the local system's default character set for file contents
<a name="184"></a>     *   is used.
<a name="185"></a>     *   
<a name="186"></a>     *   When a file is opened in text mode for reading, each call to
<a name="187"></a>     *   readFile() reads and returns a line of text from the file.  When a
<a name="188"></a>     *   file is opened in text mode for writing, any existing file is
<a name="189"></a>     *   discarded and replaced with the new data.  Each read and write to a
<a name="190"></a>     *   text file is mapped through the CharacterSet in effect at the time
<a name="191"></a>     *   of the read or write.  
<a name="192"></a>     */
<a name="193"></a>    static openTextFile(filename, access, charset?);
<a name="194"></a>
<a name="195"></a>    /*
<a name="196"></a>     *   Static creator method: open a file in 'data' mode.  Returns a File
<a name="197"></a>     *   object that can be used to read or write the file.
<a name="198"></a>     *   
<a name="199"></a>     *   'filename' is a string giving the file name in the local file
<a name="200"></a>     *   system, or a TemporaryFile object.
<a name="201"></a>     *   
<a name="202"></a>     *   'access' indicates the desired read/write access and the disposition
<a name="203"></a>     *   of any existing file; any of the FileAccessXxx modes can be used.
<a name="204"></a>     *   
<a name="205"></a>     *   When a file is opened in data mode, you can read and write integers,
<a name="206"></a>     *   strings, and 'true' values to the file, and the values in the file
<a name="207"></a>     *   are marked with their datatype in a private data format.  Because
<a name="208"></a>     *   the file uses a tads-specific format, this mode cannot be used to
<a name="209"></a>     *   read files created by other applications or write files for use by
<a name="210"></a>     *   other applications; however, this storage format is convenient for
<a name="211"></a>     *   storing simple data values because the File object takes care of
<a name="212"></a>     *   converting to and from a portable binary format.  
<a name="213"></a>     */
<a name="214"></a>    static openDataFile(filename, access);
<a name="215"></a>
<a name="216"></a>    /*
<a name="217"></a>     *   Static creator method: open a file in 'raw' mode.  Returns a File
<a name="218"></a>     *   object that can be used to read or write the file.
<a name="219"></a>     *   
<a name="220"></a>     *   'filename' is a string giving the name of the file in the local file
<a name="221"></a>     *   system, or a TemporaryFile object.
<a name="222"></a>     *   
<a name="223"></a>     *   'access' indicates the desired read/write access mode and the
<a name="224"></a>     *   disposition of any existing file; any of the FileAccessXxx modes can
<a name="225"></a>     *   be used.
<a name="226"></a>     *   
<a name="227"></a>     *   When a file is opened in raw mode, only ByteArray values can be read
<a name="228"></a>     *   and written.  The File object performs no translations of the bytes
<a name="229"></a>     *   read or written.  This mode requires the calling program itself to
<a name="230"></a>     *   perform all data conversions to and from a raw byte format, but the
<a name="231"></a>     *   benefit of this extra work is that this mode can be used to read and
<a name="232"></a>     *   write files in arbitrary data formats, including formats defined by
<a name="233"></a>     *   other applications.  
<a name="234"></a>     */
<a name="235"></a>    static openRawFile(filename, access);
<a name="236"></a>
<a name="237"></a>    /* 
<a name="238"></a>     *   get the CharacterSet object the File is currently using; returns
<a name="239"></a>     *   nil for a non-text file 
<a name="240"></a>     */
<a name="241"></a>    getCharacterSet();
<a name="242"></a>
<a name="243"></a>    /*
<a name="244"></a>     *   Set the CharacterSet object the File is to use from now on.  This
<a name="245"></a>     *   isn't meaningful except for text files.  'charset' can be a
<a name="246"></a>     *   CharacterSet object, a string giving the name of a character mapping
<a name="247"></a>     *   (in which case a CharacterSet object is automatically created based
<a name="248"></a>     *   on the name), or nil (in which case the local system's default
<a name="249"></a>     *   character set for text files is used).  
<a name="250"></a>     */
<a name="251"></a>    setCharacterSet(charset);
<a name="252"></a>
<a name="253"></a>    /*
<a name="254"></a>     *   Close the file.  Flushes any buffered information to the underlying
<a name="255"></a>     *   system file and releases any system resources (such as share locks
<a name="256"></a>     *   or system buffers) associated with the file.  After this routine is
<a name="257"></a>     *   called, no further operations on the file can be performed (a
<a name="258"></a>     *   FileClosedException will be thrown if any subsequent operations are
<a name="259"></a>     *   attempted).
<a name="260"></a>     *   
<a name="261"></a>     *   If the game is running in web server mode, the file might be on a
<a name="262"></a>     *   remote storage server.  In this case, if the file was opened with
<a name="263"></a>     *   write access, closing it will send the file to the storage server.
<a name="264"></a>     *   
<a name="265"></a>     *   Note that this method can throw an error, so you shouldn't consider
<a name="266"></a>     *   updates to the file to be "safe" until this method returns
<a name="267"></a>     *   successfully.  On many systems, writes are buffered in memory, so
<a name="268"></a>     *   closing the file can involve flushing buffers, which can trigger the
<a name="269"></a>     *   same sorts of errors that can happen with ordinary writes (running
<a name="270"></a>     *   out of disk space, physical media defects, etc).  In addition, when
<a name="271"></a>     *   the file is on a remote network storage server, closing a file
<a name="272"></a>     *   opened with write access transmits the file to the storage server,
<a name="273"></a>     *   which can encounter network errors.
<a name="274"></a>     *   
<a name="275"></a>     *   You should always explicitly close files when done with them.  This
<a name="276"></a>     *   is especially important when writing to a file, because many systems
<a name="277"></a>     *   buffer written data in memory and don't write changes to the
<a name="278"></a>     *   physical media until the file is closed.  This means that updates
<a name="279"></a>     *   can be lost if the program crashes (or the computer loses power,
<a name="280"></a>     *   etc) while the file is still open.  Closing the file as soon as
<a name="281"></a>     *   you're done with it reduces the chances of this kind of data loss.
<a name="282"></a>     *   It also helps overall system performance to release resources back
<a name="283"></a>     *   to the operating system as soon as you're done with them.
<a name="284"></a>     *   
<a name="285"></a>     *   If you *don't* close a file, though, the system will close it
<a name="286"></a>     *   automatically when the File object becomes unreachable and is
<a name="287"></a>     *   deleted by the garbage collector.  It's considered bad form to
<a name="288"></a>     *   depend on this for the reasons above, and it's also problematic
<a name="289"></a>     *   because you won't have any way of finding out if an error should
<a name="290"></a>     *   happen on close.  
<a name="291"></a>     */
<a name="292"></a>    closeFile();
<a name="293"></a>
<a name="294"></a>    /*
<a name="295"></a>     *   Read from the file.  Returns a data value that depends on the file
<a name="296"></a>     *   mode, as described below, or nil at end of file.
<a name="297"></a>     *   
<a name="298"></a>     *   If the file is open in text mode, this reads a line of text from the
<a name="299"></a>     *   file and returns a string with the text of the line read.  A line of
<a name="300"></a>     *   text is a sequence of characters terminated with a line-ending
<a name="301"></a>     *   sequence, which is a carriage return, line feed, CR/LF pair, LF/CR
<a name="302"></a>     *   pair, or a Unicode line terminator character (0x2028) if the file is
<a name="303"></a>     *   being read with one of the Unicode encodings.  If the line read ends
<a name="304"></a>     *   in a line-ending sequence, the returned text will end in a '\n'
<a name="305"></a>     *   character, regardless of which of the possible line-ending sequences
<a name="306"></a>     *   is actually in the file, so the caller need not worry about the
<a name="307"></a>     *   details of the external file's format.  Every line read from the
<a name="308"></a>     *   file will end in a '\n' except possibly the last line - if the file
<a name="309"></a>     *   doesn't end with a line-ending sequence, then the last line read
<a name="310"></a>     *   from the file won't end in a '\n' character.  All bytes read from
<a name="311"></a>     *   the file will be mapped to characters through the CharacterSet
<a name="312"></a>     *   object currently in effect in the file, so the returned string will
<a name="313"></a>     *   always be a standard Unicode string, regardless of the byte encoding
<a name="314"></a>     *   of the file.
<a name="315"></a>     *   
<a name="316"></a>     *   If the file is open in 'data' mode, this reads one data element
<a name="317"></a>     *   using the private tads-specific data format.  The result is a value
<a name="318"></a>     *   of one of the types writable with writeFile() in 'data' mode.  In
<a name="319"></a>     *   order to read a 'data' file, the file must have been previously
<a name="320"></a>     *   written in 'data' mode.  
<a name="321"></a>     */
<a name="322"></a>    readFile();
<a name="323"></a>
<a name="324"></a>    /*
<a name="325"></a>     *   Write to the file.  Writes the given value to the file in a format
<a name="326"></a>     *   that depends on the file mode, as described below.  No return
<a name="327"></a>     *   value; if an error occurs writing the data, this throws a
<a name="328"></a>     *   FileIOException.
<a name="329"></a>     *   
<a name="330"></a>     *   If the file is open in text mode, this writes text to the file,
<a name="331"></a>     *   converting the given value to a string if necessary (and throwing
<a name="332"></a>     *   an error if such a conversion isn't possible), and translating the
<a name="333"></a>     *   string to be written to bytes by mapping the string through the
<a name="334"></a>     *   CharacterSet object currently in effect for the file.  Note that no
<a name="335"></a>     *   line-ending characters are automatically added to the output, so if
<a name="336"></a>     *   the caller wishes to write line terminators, it should simply
<a name="337"></a>     *   include a '\n' character at the end of each line.
<a name="338"></a>     *   
<a name="339"></a>     *   If the file is open in 'data' mode, this writes the value, which
<a name="340"></a>     *   must be a string, integer, enum, or 'true' value, in a private
<a name="341"></a>     *   tads-specific data format that can later be read using the same
<a name="342"></a>     *   format.  The values are converted to the private binary format,
<a name="343"></a>     *   which is portable across platforms: a file written in 'data' mode
<a name="344"></a>     *   on one machine can be copied (byte-for-byte) to another machine,
<a name="345"></a>     *   even one that uses different hardware and a different operating
<a name="346"></a>     *   system, and read back in 'data' mode on the new machine to yield
<a name="347"></a>     *   the original values written.  
<a name="348"></a>     */
<a name="349"></a>    writeFile(val);
<a name="350"></a>
<a name="351"></a>    /*
<a name="352"></a>     *   Read bytes from the file into the given ByteArray object.  This can
<a name="353"></a>     *   only be used for a file opened in 'raw' mode.  If 'start' and 'cnt'
<a name="354"></a>     *   are given, they give the starting index in the byte array at which
<a name="355"></a>     *   the bytes read are to be stored, and the number of bytes to read,
<a name="356"></a>     *   respectively; if these are omitted, one byte is read from the file
<a name="357"></a>     *   for each byte in the byte array.
<a name="358"></a>     *   
<a name="359"></a>     *   Returns the number of bytes actually read into the byte array,
<a name="360"></a>     *   which will be less than or equal to the number requested.  If the
<a name="361"></a>     *   number read is less than the number requested, it means that the
<a name="362"></a>     *   end of the file was encountered, and only the returned number of
<a name="363"></a>     *   bytes were available.  
<a name="364"></a>     */
<a name="365"></a>    readBytes(byteArr, start?, cnt?);
<a name="366"></a>
<a name="367"></a>    /*
<a name="368"></a>     *   Write bytes from the given source object into the file.  This can
<a name="369"></a>     *   only be used for a file opened in 'raw' mode.
<a name="370"></a>     *   
<a name="371"></a>     *   The source object must be one of the following object types:
<a name="372"></a>     *   
<a name="373"></a>     *   File: the contents of the given source file are copied to 'self'.
<a name="374"></a>     *   'start' is the starting seek position in the source file; if
<a name="375"></a>     *   omitted, the current seek position is the default.  'cnt' is the
<a name="376"></a>     *   number of bytes to copy; if omitted, the file is copied from the
<a name="377"></a>     *   given starting position to the end of the file.
<a name="378"></a>     *   
<a name="379"></a>     *   ByteArray: the bytes of the byte array are copied to the file.
<a name="380"></a>     *   'start' is the starting index in the byte array; if omitted, the
<a name="381"></a>     *   default is the first byte (index 1).  'cnt' is the number of bytes
<a name="382"></a>     *   to copy; if omitted, bytes are copied from the start position to the
<a name="383"></a>     *   end of the array.
<a name="384"></a>     *   
<a name="385"></a>     *   No return value; if an error occurs writing the data, a
<a name="386"></a>     *   FileIOException is thrown.  
<a name="387"></a>     */
<a name="388"></a>    writeBytes(source, start?, cnt?);
<a name="389"></a>
<a name="390"></a>    /*
<a name="391"></a>     *   Get the current read/write position in the file.  Returns the byte
<a name="392"></a>     *   offset in the file of the next byte to be read or written.  Note
<a name="393"></a>     *   that this value is an offset, so 0 is the offset of the first byte
<a name="394"></a>     *   in the file.  
<a name="395"></a>     */
<a name="396"></a>    getPos();
<a name="397"></a>
<a name="398"></a>    /*
<a name="399"></a>     *   Set the current read/write position in the file.  'pos' is a byte
<a name="400"></a>     *   offset in the file; 0 is the offset of the first byte.
<a name="401"></a>     *   
<a name="402"></a>     *   For files in 'text' and 'data' modes, a caller should NEVER set the
<a name="403"></a>     *   file position to any value other than a value previously returned
<a name="404"></a>     *   by getPos(), because other positions might violate the format
<a name="405"></a>     *   constraints.  For example, if you move the file position to a byte
<a name="406"></a>     *   in the middle of a line-ending sequence in a text file, subsequent
<a name="407"></a>     *   reading from the file might misinterpret the sequence as something
<a name="408"></a>     *   other than a line ending, or as an extra line ending.  If you move
<a name="409"></a>     *   the position in a 'data' file to a byte in the middle of an integer
<a name="410"></a>     *   value, reading from the file would misinterpret as a data type tag
<a name="411"></a>     *   a byte that is part of the integer value instead.  So it is never
<a name="412"></a>     *   meaningful or safe to set an arbitrary byte offset in these file
<a name="413"></a>     *   formats; only values known to be valid by virtue of having been
<a name="414"></a>     *   returned from getPos() can be used here in these modes.  
<a name="415"></a>     */
<a name="416"></a>    setPos(pos);
<a name="417"></a>
<a name="418"></a>    /*
<a name="419"></a>     *   Set the current read/write position to the end of the file.  This
<a name="420"></a>     *   can be used, for example, to open a 'data' mode file for
<a name="421"></a>     *   read/write/keep access (keeping the contents of an existing file)
<a name="422"></a>     *   and then adding more data after all of the existing data in the
<a name="423"></a>     *   file.  
<a name="424"></a>     */
<a name="425"></a>    setPosEnd();
<a name="426"></a>
<a name="427"></a>    /*
<a name="428"></a>     *   Static creator method: open a resource in 'text' mode.  This acts
<a name="429"></a>     *   like openTextFile(), but rather than opening an ordinary file, this
<a name="430"></a>     *   method opens a resource.  Resources differ from ordinary files in
<a name="431"></a>     *   two important respects.  First, a resource is named with a
<a name="432"></a>     *   URL-style path rather than a local file system name.  Second, a
<a name="433"></a>     *   resource can be embedded in the program's executable (.t3) file, or
<a name="434"></a>     *   can be embedded in an external resource bundle (.3r0, etc) file.
<a name="435"></a>     *   
<a name="436"></a>     *   Resources are read-only, so the access mode is implicitly
<a name="437"></a>     *   FileAccessRead.  
<a name="438"></a>     */
<a name="439"></a>    static openTextResource(resname, charset?);
<a name="440"></a>
<a name="441"></a>    /*
<a name="442"></a>     *   Static creator method: open a resource in 'raw' mode.  This acts
<a name="443"></a>     *   like openRawFile(), but opens a resource rather than an ordinary
<a name="444"></a>     *   file.
<a name="445"></a>     *   
<a name="446"></a>     *   Resources are read-only, so the access mode is implicitly
<a name="447"></a>     *   FileAccessRead.  
<a name="448"></a>     */
<a name="449"></a>    static openRawResource(resname);
<a name="450"></a>
<a name="451"></a>    /* get the size in bytes of the file */
<a name="452"></a>    getFileSize();
<a name="453"></a>
<a name="454"></a>    /*
<a name="455"></a>     *   Get the file mode.  This returns one of the FileModeXxx constants,
<a name="456"></a>     *   indicating the mode used to open the file (text, data, raw).  
<a name="457"></a>     */
<a name="458"></a>    getFileMode();
<a name="459"></a>
<a name="460"></a>    /*
<a name="461"></a>     *   Extract the file's "root name" from the given filename string.  This
<a name="462"></a>     *   returns a new string giving the portion of the filename excluding
<a name="463"></a>     *   any directory path.  This parses the filename according to the local
<a name="464"></a>     *   file system's syntax rules.  For example, given the filename
<a name="465"></a>     *   'a/b/c.txt', if you're running on a Unix or Linux machine, the
<a name="466"></a>     *   function returns 'c.txt'.
<a name="467"></a>     *   
<a name="468"></a>     *   Note that this function doesn't attempt to open the file or check
<a name="469"></a>     *   for its existence or validity; it simply parses the name according
<a name="470"></a>     *   to the local syntax conventions.
<a name="471"></a>     *   
<a name="472"></a>     *   (It's recommended that you use the newer FileName.getBaseName() in
<a name="473"></a>     *   place of this function.)
<a name="474"></a>     */
<a name="475"></a>    static getRootName(filename);
<a name="476"></a>
<a name="477"></a>    /*
<a name="478"></a>     *   Delete the file with the given name.  This erases the file from
<a name="479"></a>     *   disk.  'filename' is a string giving the name of the file to delete,
<a name="480"></a>     *   or one of the special file identifier values.
<a name="481"></a>     *   
<a name="482"></a>     *   The file can only be deleted if the file safety level would allow
<a name="483"></a>     *   you to write to the file; if not, a file safety exception is thrown.
<a name="484"></a>     *   
<a name="485"></a>     *   (It's recommended that you use the newer FileName.deleteFile() in
<a name="486"></a>     *   place of this function.)
<a name="487"></a>     */
<a name="488"></a>    static deleteFile(filename);
<a name="489"></a>
<a name="490"></a>    /*
<a name="491"></a>     *   Change the file mode.  'mode' is a FileModeXxx value giving the
<a name="492"></a>     *   desired new file mode.
<a name="493"></a>     *   
<a name="494"></a>     *   If the mode is FileModeText, 'charset' is the character set mapping
<a name="495"></a>     *   to use for the file; this can be given as a CharacterSet object, or
<a name="496"></a>     *   as a string giving the name of a character set.  If the value is nil
<a name="497"></a>     *   or the argument is omitted, the local system's default character for
<a name="498"></a>     *   file contents is used.  The 'charset' parameter is ignored for other
<a name="499"></a>     *   modes.
<a name="500"></a>     */
<a name="501"></a>    setFileMode(mode, charset?);
<a name="502"></a>
<a name="503"></a>    /*
<a name="504"></a>     *   Pack the given data values into bytes according to a format
<a name="505"></a>     *   definition string, and write the packed bytes to the file.  This
<a name="506"></a>     *   function is designed to simplify writing files that use structured
<a name="507"></a>     *   binary formats defined by third parties, such as JPEG or PDF.  The
<a name="508"></a>     *   function translates native TADS data values into selected binary
<a name="509"></a>     *   formats, and writes the resulting bytes to the file, all in a single
<a name="510"></a>     *   operation.
<a name="511"></a>     *   
<a name="512"></a>     *   'format' is the format string, and the remaining arguments are the
<a name="513"></a>     *   values to be packed.
<a name="514"></a>     *   
<a name="515"></a>     *   Returns the number of bytes written to the file.  (More precisely,
<a name="516"></a>     *   returns the final file position as a byte offset from the starting
<a name="517"></a>     *   file pointer.  If a positioning code like @ or X is used in the
<a name="518"></a>     *   string, it's possible that more bytes were actually written.)
<a name="519"></a>     *   
<a name="520"></a>     *   See Byte Packing in the System Manual for details.  
<a name="521"></a>     */
<a name="522"></a>    packBytes(format, ...);
<a name="523"></a>
<a name="524"></a>    /*
<a name="525"></a>     *   Read bytes and unpack into a data structure, according to the format
<a name="526"></a>     *   description string 'desc'.
<a name="527"></a>     *   
<a name="528"></a>     *   'format' is the format string.  The function reads bytes from the
<a name="529"></a>     *   current location in the file and translates them into data values
<a name="530"></a>     *   according to the format string, returning a list of the unpacked
<a name="531"></a>     *   values.
<a name="532"></a>     *   
<a name="533"></a>     *   Refer to Byte Packing in the System Manual for details.  
<a name="534"></a>     */
<a name="535"></a>    unpackBytes(format);
<a name="536"></a>
<a name="537"></a>    /*
<a name="538"></a>     *   Calculate the 256-bit SHA-2 hash of bytes read from the file,
<a name="539"></a>     *   starting at the current seek location and continuing for the given
<a name="540"></a>     *   number of bytes.  If the length is omitted, the whole rest of the
<a name="541"></a>     *   file is hashed.  This has the side effect of reading the given
<a name="542"></a>     *   number of bytes from the file, so it leaves the seek position set to
<a name="543"></a>     *   the next byte after the bytes hashed.
<a name="544"></a>     *   
<a name="545"></a>     *   Returns a string of 64 hex digits giving the hash result.
<a name="546"></a>     *   
<a name="547"></a>     *   This can only be used on files opened in raw mode with read access.
<a name="548"></a>     */
<a name="549"></a>    sha256(length?);
<a name="550"></a>
<a name="551"></a>    /*
<a name="552"></a>     *   Calculate the MD5 digest of bytes read from the file, starting at
<a name="553"></a>     *   the current seek location and continuing for the given number of
<a name="554"></a>     *   bytes.  If the length is omitted, the whole rest of the file is
<a name="555"></a>     *   digested.  This has the side effect of reading the given number of
<a name="556"></a>     *   bytes from the file, so it leaves the seek position set to the next
<a name="557"></a>     *   byte after the bytes digested.
<a name="558"></a>     *   
<a name="559"></a>     *   Returns a string of 32 hex digits giving the digest result.
<a name="560"></a>     *   
<a name="561"></a>     *   This can only be used on files opened in raw mode with read access. 
<a name="562"></a>     */
<a name="563"></a>    digestMD5(length?);
<a name="564"></a>}
<a name="565"></a>
<a name="566"></a>
<a name="567"></a>/* ------------------------------------------------------------------------ */
<a name="568"></a>/*
<a name="569"></a> *   The TemporaryFile intrinsic class represents a temporary file name in
<a name="570"></a> *   the local file system.  Temporary files can be used to store data too
<a name="571"></a> *   large to conveniently store in memory.
<a name="572"></a> *   
<a name="573"></a> *   You create a temporary file with 'new TemporaryFile()'.  This
<a name="574"></a> *   automatically assigns the object a unique filename in the local file
<a name="575"></a> *   system, typically in a system directory reserved for temporary files.
<a name="576"></a> *   The local file can then be opened, read, written, and otherwise
<a name="577"></a> *   manipulated via the File class, just like any other file.  Simply pass
<a name="578"></a> *   the TemporaryFile object in place of a filename to the File.openXxx
<a name="579"></a> *   methods.  
<a name="580"></a> *   
<a name="581"></a> *   The underlying file system file will be deleted automatically when the
<a name="582"></a> *   TemporaryFile object is collected by the garbage collector (or when the
<a name="583"></a> *   program terminates).  This means that you don't have to worry about
<a name="584"></a> *   cleaning up the file system space used by the file; it'll be released
<a name="585"></a> *   automatically when the file is no longer needed.  However, you can call
<a name="586"></a> *   the deleteFile() method to explicitly release the file when you're done
<a name="587"></a> *   with it, if you want to ensure that the resource is returned to the
<a name="588"></a> *   operating system as soon as possible.
<a name="589"></a> *   
<a name="590"></a> *   TemporaryFile objects are inherently transient - they're only valid for
<a name="591"></a> *   the current session on the current local system, so they can't be saved
<a name="592"></a> *   or restored.
<a name="593"></a> *   
<a name="594"></a> *   Temporary files are exempt from the file safety level settings, because
<a name="595"></a> *   the inherent restrictions on temporary files provide the same system
<a name="596"></a> *   protections that the safety level settings provide for ordinary files.
<a name="597"></a> */
<a name="598"></a>intrinsic class TemporaryFile 'tempfile/030000': Object
<a name="599"></a>{
<a name="600"></a>    /*
<a name="601"></a>     *   Get the name of the underlying file system object.  This returns a
<a name="602"></a>     *   string with the local filename.  This is mostly for debugging
<a name="603"></a>     *   purposes or for displaying to the user.  You can't necessarily use
<a name="604"></a>     *   this filename in a call to File.openXxxFile, because the file path
<a name="605"></a>     *   is usually in a system directory reserved for temporary files, and
<a name="606"></a>     *   the file safety level settings often prohibit opening files outside
<a name="607"></a>     *   of the program's own home directory.  To open the temp file, you
<a name="608"></a>     *   should always pass the TemporaryFile object itself in place of the
<a name="609"></a>     *   filename.
<a name="610"></a>     */
<a name="611"></a>    getFilename();
<a name="612"></a>
<a name="613"></a>    /*
<a name="614"></a>     *   Delete the underlying file system object.  This deletes the
<a name="615"></a>     *   temporary file and marks the TemporaryFile object as invalid.  After
<a name="616"></a>     *   calling this, you can no longer open the file via the
<a name="617"></a>     *   File.openXxxFile methods.
<a name="618"></a>     *   
<a name="619"></a>     *   This method allows you to release the underlying file system
<a name="620"></a>     *   resources as soon as you're done with the temp file.  It's never
<a name="621"></a>     *   necessary to do this.  TADS automatically deletes the underlying
<a name="622"></a>     *   file system resources when the TemporaryFile object is deleted by
<a name="623"></a>     *   the garbage collector (or when the program terminates), so the
<a name="624"></a>     *   operating system file will be deleted eventually whether you call
<a name="625"></a>     *   this method or not.  The point of this method is to let you tell the
<a name="626"></a>     *   system *exactly* when you're done with the file, so that the
<a name="627"></a>     *   resources can be released earlier than if we waited for garbage
<a name="628"></a>     *   collection to take care of it.  This should make little difference
<a name="629"></a>     *   in most situations, but in a program that will run for a long time
<a name="630"></a>     *   and use a lot of temporary files, it might be worthwhile to release
<a name="631"></a>     *   resources manually as soon as possible.  
<a name="632"></a>     */
<a name="633"></a>    deleteFile();
<a name="634"></a>}
<a name="635"></a>
<a name="636"></a>
<a name="637"></a>/* ------------------------------------------------------------------------ */
<a name="638"></a>/*
<a name="639"></a> *   The filename passed to the File "open" methods, as well as to most
<a name="640"></a> *   system functions that accept filename arguments, can be a TadsObject
<a name="641"></a> *   object in lieu of a string.  Such an object must implement the following
<a name="642"></a> *   methods:
<a name="643"></a> *   
<a name="644"></a> *   getFilename() - return the actual filename to use, which must be a
<a name="645"></a> *   string or TemporaryFile object.
<a name="646"></a> *   
<a name="647"></a> *   closeFile() - optional.  This is called just after the underlying system
<a name="648"></a> *   file is closed, allowing the program to perform any desired
<a name="649"></a> *   post-processing on the file.  
<a name="650"></a> */
<a name="651"></a>export getFilename 'FileSpec.getFilename';
<a name="652"></a>export closeFile 'FileSpec.closeFile';
<a name="653"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/01/2025 from adv3Lite version 2.1.1.14</div>
</body>
</html>

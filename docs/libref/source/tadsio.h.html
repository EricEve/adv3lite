<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>tadsio.h</title></head><body>
<table class=ban><tr><td><h1>tadsio.h</h1><td align=right><a href="../file/tadsio.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 1999, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3
<a name="8"></a> *   
<a name="9"></a> *   This header defines the tads-io intrinsic function set.  
<a name="10"></a> *   
<a name="11"></a> *   The TADS input/output function set provides access to the user
<a name="12"></a> *   interface.  This lets you read input from the keyboard and display
<a name="13"></a> *   output on the monitor or terminal.  It also provides access to windowing
<a name="14"></a> *   features (via the "banner" functions) on systems that support multiple
<a name="15"></a> *   display windows (which doesn't necessarily mean GUI-type systems: many
<a name="16"></a> *   character-mode systems support the banner operations as well, simply by
<a name="17"></a> *   dividing up the character-mode screen into rectangular regions).  
<a name="18"></a> */
<a name="19"></a>
<a name="20"></a>
<a name="21"></a>/*
<a name="22"></a> *   tads-io - the TADS Input/Output intrinsic function set 
<a name="23"></a> */
<a name="24"></a>intrinsic 'tads-io/030007'
<a name="25"></a>{
<a name="26"></a>    /* 
<a name="27"></a>     *   Display values on the console.  One or more values can be displayed.
<a name="28"></a>     *   Each value can be a string, in which case the string is displayed as
<a name="29"></a>     *   given (with HTML interpretation); an integer, in which case it's
<a name="30"></a>     *   converted to a string, using a decimal (base 10) radix and
<a name="31"></a>     *   displayed; a BigNumber, in which case it's converted to a string
<a name="32"></a>     *   using the default formatting; or nil, in which case nothing is
<a name="33"></a>     *   displayed.  
<a name="34"></a>     */
<a name="35"></a>    tadsSay(val, ...);
<a name="36"></a>
<a name="37"></a>    /* 
<a name="38"></a>     *   Set the output log file (which records the output transcript) or the
<a name="39"></a>     *   command log file (which records command lines the user enters).
<a name="40"></a>     *   'fname' is the name of the file to open, and 'logType' gives the
<a name="41"></a>     *   type of log to open, as a LogTypeXxx value.  
<a name="42"></a>     */
<a name="43"></a>    setLogFile(fname, logType?);
<a name="44"></a>
<a name="45"></a>    /* 
<a name="46"></a>     *   Clear the display.  This clears the main window.  
<a name="47"></a>     */
<a name="48"></a>    clearScreen();
<a name="49"></a>
<a name="50"></a>    /* 
<a name="51"></a>     *   Show the "more" prompt, if supported on the platform.  This causes a
<a name="52"></a>     *   "more" prompt to be displayed, according to local system
<a name="53"></a>     *   conventions, as though consecutive text output had exceeded the
<a name="54"></a>     *   screen/window height.  
<a name="55"></a>     */
<a name="56"></a>    morePrompt();
<a name="57"></a>
<a name="58"></a>    /* 
<a name="59"></a>     *   Read a line of text from the keyboard.  Pauses to let the user edit
<a name="60"></a>     *   and enter a command line, then returns the entered text as a string.
<a name="61"></a>     */
<a name="62"></a>    inputLine();
<a name="63"></a>
<a name="64"></a>    /* 
<a name="65"></a>     *   Read a single keystroke from the keyboard.  Waits until the user
<a name="66"></a>     *   presses a key, then returns the keystroke as a string.  
<a name="67"></a>     */
<a name="68"></a>    inputKey();
<a name="69"></a>
<a name="70"></a>    /* 
<a name="71"></a>     *   Read a single input event.  Waits until an input event is available,
<a name="72"></a>     *   then returns the event as a list.  The first element of the list is
<a name="73"></a>     *   an InEvtXxx value indicating the type of the event; the remainder of
<a name="74"></a>     *   the list varies according to the event type.  If 'timeout' is
<a name="75"></a>     *   provided, it gives the maximum waiting interval in milliseconds; if
<a name="76"></a>     *   no input event occurs within this interval, the function returns an
<a name="77"></a>     *   InEvtTimeout event.  
<a name="78"></a>     */
<a name="79"></a>    inputEvent(timeout?);
<a name="80"></a>
<a name="81"></a>    /* 
<a name="82"></a>     *   Display a simple "message box" dialog (known on some systems as an
<a name="83"></a>     *   "alert" dialog).  This displays a dialog that includes a short
<a name="84"></a>     *   message for the user to read, an icon indicating the general nature
<a name="85"></a>     *   of the condition that gave rise to the dialog (an error, a warning,
<a name="86"></a>     *   a choice for the user to make, etc.), and a set of push-buttons that
<a name="87"></a>     *   dismiss the dialog and (in some cases) let the user choose among
<a name="88"></a>     *   options.  'icon' is an InDlgIconXxx value giving the type of icon to
<a name="89"></a>     *   show, if any; 'prompt' is the message string to display; 'buttons'
<a name="90"></a>     *   gives the set of buttons to display; 'defaultButton' is the index
<a name="91"></a>     *   (starting at 1) among the buttons of the default button; and
<a name="92"></a>     *   'cancelButton' is the index of the cancellation button.
<a name="93"></a>     *   
<a name="94"></a>     *   'buttons' can be given as an InDlgXxx constant (InDlgOk,
<a name="95"></a>     *   InDlgOkCancel, etc.) to select one of the standard sets of buttons.
<a name="96"></a>     *   Or, it can be a list giving a custom set of buttons, in which case
<a name="97"></a>     *   each element of the list is either a string giving a custom label
<a name="98"></a>     *   for the button, or one of the InDlgLblXxx values to select a
<a name="99"></a>     *   standard label.  The standard labels should be used when possible,
<a name="100"></a>     *   as these will be automatically localized; labels given explicitly as
<a name="101"></a>     *   strings will be used exactly as given.  If a list of custom button
<a name="102"></a>     *   labels is given, the buttons are displayed in the dialog in the
<a name="103"></a>     *   order of the list (usually left to right, but this could vary
<a name="104"></a>     *   according to system conventions and localization).
<a name="105"></a>     *   
<a name="106"></a>     *   Each custom button label string can incorporate an ampersand ("&amp;").
<a name="107"></a>     *   The letter immediately following the ampersand, if provided, is used
<a name="108"></a>     *   as the keyboard shortcut for the button.  This is particularly
<a name="109"></a>     *   important on character-mode systems, where the "dialog" is typically
<a name="110"></a>     *   shown merely as a text prompt, and the user responds by selecting
<a name="111"></a>     *   the letter of the desired option.  Typically, you should use the
<a name="112"></a>     *   first character of a button label as its keyboard shortcut, but this
<a name="113"></a>     *   obviously won't work when two button labels have the same first
<a name="114"></a>     *   letter; in these cases, you should choose another letter from the
<a name="115"></a>     *   button label, preferably something like the first letter of the
<a name="116"></a>     *   second word of the button label, or the first letter of the stressed
<a name="117"></a>     *   syllable of the most important word of the label.
<a name="118"></a>     *   
<a name="119"></a>     *   The return value is the index among the buttons of the button that
<a name="120"></a>     *   the user selects to dismiss the dialog.  The function doesn't return
<a name="121"></a>     *   until the user selects one of the buttons.  
<a name="122"></a>     */
<a name="123"></a>    inputDialog(icon, prompt, buttons, defaultButton, cancelButton);
<a name="124"></a>
<a name="125"></a>    /* 
<a name="126"></a>     *   Display a file selector dialog.  This prompts the user to select a
<a name="127"></a>     *   file.  On GUI systems, this will typically display the standard
<a name="128"></a>     *   system file selection dialog; on character-mode systems, it might
<a name="129"></a>     *   simply display the prompt string and let the user type the name of a
<a name="130"></a>     *   file directly.
<a name="131"></a>     *   
<a name="132"></a>     *   'prompt' is the message string to display in the dialog to let the
<a name="133"></a>     *   user know what type of file is being requested.  'dialogType' is one
<a name="134"></a>     *   of the InFileXxx constants specifying whether the request is to
<a name="135"></a>     *   select an existing file or to specify the name for a new file.
<a name="136"></a>     *   'fileType' is a FileTypeXxx constant giving the format of the file
<a name="137"></a>     *   being requested; this is used on some systems to filter the
<a name="138"></a>     *   displayed list of existing files so that only files of the same
<a name="139"></a>     *   format are included, to reduce clutter.  'flags' is reserved for
<a name="140"></a>     *   future use and should simply be set to zero.
<a name="141"></a>     *   
<a name="142"></a>     *   The return value is a list.  The first element is an integer giving
<a name="143"></a>     *   the status: InFileSuccess indicates that the user successfully
<a name="144"></a>     *   selected a file, whose name is given as a string in the second
<a name="145"></a>     *   element of the result list; InFileFailure indicates a system error
<a name="146"></a>     *   of some kind showing the dialog; and InFileCancel indicates that the
<a name="147"></a>     *   user explicitly canceled the dialog.
<a name="148"></a>     *   
<a name="149"></a>     *   On success (return list[1] == InFileSuccess), the list contains the
<a name="150"></a>     *   following additional elements:
<a name="151"></a>     *   
<a name="152"></a>     *.     [2] = the selected filename
<a name="153"></a>     *.     [3] = nil (reserved for future use)
<a name="154"></a>     *.     [4] = script warning message, or nil if no warning
<a name="155"></a>     *   
<a name="156"></a>     *   The warning message is a string to be displayed to the user to warn
<a name="157"></a>     *   about a possible error condition in the script input.  The script
<a name="158"></a>     *   reader checks the file specified in the script to see if it's valid;
<a name="159"></a>     *   if the dialog type is Open, the script reader verifies that the file
<a name="160"></a>     *   exists, and for a Save dialog the reader warns if the file *does*
<a name="161"></a>     *   already exist or is not writable.  In the conventional UI, the
<a name="162"></a>     *   script reader displays these warnings directly to the user through
<a name="163"></a>     *   the console UI, but this isn't possible in the Web UI since the user
<a name="164"></a>     *   might be running on a remote browser.  Instead, the script reader
<a name="165"></a>     *   still checks for the possible errors, but rather than displaying any
<a name="166"></a>     *   warnings, it returns them here.  The caller is responsible for
<a name="167"></a>     *   displaying the warning and asking the user for confirmation.
<a name="168"></a>     *   
<a name="169"></a>     *   For localization purposes, the warning message starts with a
<a name="170"></a>     *   two-letter code indicating the specific error, followed by a space,
<a name="171"></a>     *   followed by the English text of the warning.  The codes are:
<a name="172"></a>     *   
<a name="173"></a>     *.   OV - the script might overwrite an existing file (Save dialog)
<a name="174"></a>     *.   WR - the file can't be created/written (Save dialog)
<a name="175"></a>     *.   RD - the file doesn't exist/can't be read (Open dialog)
<a name="176"></a>     *   
<a name="177"></a>     *   Note that the warning message will always be nil if the script
<a name="178"></a>     *   reader displayed the warning message itself.  This means that your
<a name="179"></a>     *   program can unconditionally display this message if it's non-nil -
<a name="180"></a>     *   there's no danger that the script reader will have redundantly
<a name="181"></a>     *   displayed the message.  
<a name="182"></a>     */
<a name="183"></a>    inputFile(prompt, dialogType, fileType, flags);
<a name="184"></a>
<a name="185"></a>    /* 
<a name="186"></a>     *   Pause for the given number of milliseconds.  
<a name="187"></a>     */
<a name="188"></a>    timeDelay(delayMilliseconds);
<a name="189"></a>
<a name="190"></a>    /* 
<a name="191"></a>     *   Retrieve local system information.  'infoType' is a SysInfoXxx
<a name="192"></a>     *   constant giving the type of information to retrieve.  Additional
<a name="193"></a>     *   arguments and the return value vary according to the infoType value.
<a name="194"></a>     */
<a name="195"></a>    systemInfo(infoType, ...);
<a name="196"></a>
<a name="197"></a>    /* 
<a name="198"></a>     *   Set the status-line display mode.  This is meaningful only with
<a name="199"></a>     *   text-only interpreters that don't support banner windows; other
<a name="200"></a>     *   interpreters ignore this.  'mode' is a StatModeXxx constant giving
<a name="201"></a>     *   the new mode.  
<a name="202"></a>     */
<a name="203"></a>    statusMode(mode);
<a name="204"></a>
<a name="205"></a>    /* 
<a name="206"></a>     *   Write text on the right half of the status line.  This is meaningful
<a name="207"></a>     *   only for text-only interpreters that don't support banner windows;
<a name="208"></a>     *   other interpreters ignore this.  On non-banner interpreters, this
<a name="209"></a>     *   sets the right half of the status line to display the given text,
<a name="210"></a>     *   right-justified.  
<a name="211"></a>     */
<a name="212"></a>    statusRight(txt);
<a name="213"></a>    
<a name="214"></a>    /* 
<a name="215"></a>     *   Determine if a multimedia resource exists.  'fname' is the name of a
<a name="216"></a>     *   resource (a JPEG image file, PNG image file, etc), given in
<a name="217"></a>     *   URL-style path notation.  Returns true if the resource is available,
<a name="218"></a>     *   nil if not.  
<a name="219"></a>     */
<a name="220"></a>    resExists(fname);
<a name="221"></a>
<a name="222"></a>    /* 
<a name="223"></a>     *   Set the script input file.  This opens the given file as the script
<a name="224"></a>     *   input file.  'filename' is a string giving the name of the file to
<a name="225"></a>     *   open, and 'flags' is a combination of ScriptFileXxx bit flags giving
<a name="226"></a>     *   the mode to use to read the file.  When a script file is active, the
<a name="227"></a>     *   system reads command-line input from the file rather than from the
<a name="228"></a>     *   keyboard.  This lets the program replay an input script.
<a name="229"></a>     *   
<a name="230"></a>     *   Note that the ScriptFileEvent flag is ignored if included in the
<a name="231"></a>     *   'flags' parameter.  The script reader automatically determines the
<a name="232"></a>     *   script type by examining the file's contents, so you can't set the
<a name="233"></a>     *   type using flags.  This flag is used only in "get status" requests
<a name="234"></a>     *   (ScriptReqGetStatus) - it's included in the returned flags if
<a name="235"></a>     *   applicable.  The purpose of this flag is to let you determine what
<a name="236"></a>     *   the script reader decided about the script, rather than telling the
<a name="237"></a>     *   script reader how to interpret the script.
<a name="238"></a>     *   
<a name="239"></a>     *   If 'filename' is nil, this cancels the current script.  If the
<a name="240"></a>     *   script was invoked from an enclosing script, this resumes the
<a name="241"></a>     *   enclosing script, otherwise it resumes reading input from the
<a name="242"></a>     *   keyboard.  The 'flags' argument is ignored in this case.
<a name="243"></a>     *   
<a name="244"></a>     *   New in 3.0.17: if 'filename' is one of the ScriptReqXxx constants,
<a name="245"></a>     *   this performs a special script request.  See the ScriptReqXxx
<a name="246"></a>     *   constants for details.  Note that calling this function with a
<a name="247"></a>     *   ScriptReqXxx constant on an VM prior to 3.0.17 will result in a
<a name="248"></a>     *   run-time error, so you can use try-catch to detect whether the
<a name="249"></a>     *   request is supported.  
<a name="250"></a>     */
<a name="251"></a>    setScriptFile(filename, flags?);
<a name="252"></a>
<a name="253"></a>    /* 
<a name="254"></a>     *   Get the local default character set.  'which' is a CharsetXxx value
<a name="255"></a>     *   giving which local character set to retrieve.  Returns a string
<a name="256"></a>     *   giving the name of the given local character set.  
<a name="257"></a>     */
<a name="258"></a>    getLocalCharSet(which);
<a name="259"></a>    
<a name="260"></a>    /* 
<a name="261"></a>     *   Flush text output and update the main display window.  This ensures
<a name="262"></a>     *   that any text displayed with tadsSay() is actually displayed, for
<a name="263"></a>     *   the user to see (rather than being held in internal buffers).  
<a name="264"></a>     */
<a name="265"></a>    flushOutput();
<a name="266"></a>
<a name="267"></a>    /* 
<a name="268"></a>     *   Read a line of text from the keyboard.  Waits for the user to edit
<a name="269"></a>     *   and enter a command line.  If a 'timeout' value is specified, it
<a name="270"></a>     *   gives the maximum interval to wait for the user to finish entering
<a name="271"></a>     *   the input, in milliseconds.  If the timeout expires before the user
<a name="272"></a>     *   finishes entering the line, the function stops waiting and returns.
<a name="273"></a>     *   
<a name="274"></a>     *   The return value is a list.  The first element is an InEvtXxx code
<a name="275"></a>     *   giving the status.  If the status is InEvtLine, the second element
<a name="276"></a>     *   is a string giving the command line the user entered.  If the status
<a name="277"></a>     *   is InEvtTimeout, the second element is a string giving the text of
<a name="278"></a>     *   the command line so far - that is, the text that the user had typed
<a name="279"></a>     *   up to the point when the timeout expired.  Other status codes have
<a name="280"></a>     *   no additional list elements.
<a name="281"></a>     *   
<a name="282"></a>     *   When an InEvtTimeout status is returned, the caller must either
<a name="283"></a>     *   cancel the interrupted input line with inputLineCancel(), or must
<a name="284"></a>     *   make another call to inputLineTimeout() without any intervening call
<a name="285"></a>     *   to any output function that displays anything in the main window, or
<a name="286"></a>     *   any input function other than inputLineTimeout().  
<a name="287"></a>     */
<a name="288"></a>    inputLineTimeout(timeout?);
<a name="289"></a>
<a name="290"></a>    /* 
<a name="291"></a>     *   Cancel an input line that was interrupted by timeout.  This function
<a name="292"></a>     *   must be called after an inputLineTimeout() returns with an
<a name="293"></a>     *   InEvtTimeout status indication and before any subsequent output
<a name="294"></a>     *   function that displays anything in the main window, or any input
<a name="295"></a>     *   fucntion other than inputLineTimeout().
<a name="296"></a>     *   
<a name="297"></a>     *   This function updates the UI to reflect that command line editing is
<a name="298"></a>     *   no longer in progress.  If 'reset' is true, it also resets the
<a name="299"></a>     *   internal memory of the command editing session, so that a subsequent
<a name="300"></a>     *   call to inputLineTimeout() will start from scratch with an empty
<a name="301"></a>     *   command line.  If 'reset' is nil, this function merely adjusts the
<a name="302"></a>     *   UI, but does not clear the internal memory; the next call to
<a name="303"></a>     *   inputLineTimeout() will automatically restore the editing status,
<a name="304"></a>     *   re-displaying what the user had typed so far on the interrupted
<a name="305"></a>     *   command line and restoring the cursor position to its position when
<a name="306"></a>     *   the timeout occurred.
<a name="307"></a>     *   
<a name="308"></a>     *   Note that it's not necessary (or desirable) to call this function
<a name="309"></a>     *   after a timed-out input line if the next input/output function that
<a name="310"></a>     *   affects the main window is simply another call to
<a name="311"></a>     *   inputLineTimeout().  In this case, inputLineTimeout() simply picks
<a name="312"></a>     *   up where it left off, without any indication to the user that the
<a name="313"></a>     *   input editing was ever interrupted.  
<a name="314"></a>     */
<a name="315"></a>    inputLineCancel(reset);
<a name="316"></a>    
<a name="317"></a>    /* 
<a name="318"></a>     *   Create a banner window.  Returns the "handle" of the new window,
<a name="319"></a>     *   which is used to identify the window in subsequent bannerXxx()
<a name="320"></a>     *   functions.  Not all interpreters support banner windows; if the
<a name="321"></a>     *   interpreter does not support this feature, the return value is nil.
<a name="322"></a>     *   
<a name="323"></a>     *   'parent' is the handle of the parent window; if this is nil, the
<a name="324"></a>     *   banner is split off from the main display window.  'where' is a
<a name="325"></a>     *   BannerXxx value giving the list position; if this is BannerBefore or
<a name="326"></a>     *   BannerAfter, 'other' is the handle of an existing banner window
<a name="327"></a>     *   child of the same parent.  'windowType' is a BannerTypeXxx value
<a name="328"></a>     *   giving the type of window to create.  'align' is a BannerAlignXxx
<a name="329"></a>     *   value giving the alignment - that is, the edge of the parent window
<a name="330"></a>     *   to which the new banner window attaches.  'size' is the size of the
<a name="331"></a>     *   window, in the units given by 'sizeUnits', which is a BannerSizeXxx
<a name="332"></a>     *   value.  'styleFlags' is a combination of BannerStyleXxx bit flags
<a name="333"></a>     *   that specifies the desired combination of visual styles and UI
<a name="334"></a>     *   behavior for the new window.  
<a name="335"></a>     */
<a name="336"></a>    bannerCreate(parent, where, other, windowType, align,
<a name="337"></a>                 size, sizeUnits, styleFlags);
<a name="338"></a>
<a name="339"></a>    /* 
<a name="340"></a>     *   Delete a banner window.  'handle' is the handle to the window to be
<a name="341"></a>     *   removed. 
<a name="342"></a>     */
<a name="343"></a>    bannerDelete(handle);
<a name="344"></a>
<a name="345"></a>    /* 
<a name="346"></a>     *   Clear the contents of a banner window.  'color' is the color to use
<a name="347"></a>     *   for the screen color after clearing the window, given as a ColorXxx
<a name="348"></a>     *   value (see below).  
<a name="349"></a>     */
<a name="350"></a>    bannerClear(handle);
<a name="351"></a>
<a name="352"></a>    /* 
<a name="353"></a>     *   Write text to a banner window.  The text is displayed in the given
<a name="354"></a>     *   banner.  For a BannerTypeText window, HTML tags in the text are
<a name="355"></a>     *   interpreted; for a BannerTypeTextGrid window, the text is written
<a name="356"></a>     *   exactly as given, without any HTML interpretation.
<a name="357"></a>     *   
<a name="358"></a>     *   The value list is handled the same way as the arguments to tadsSay()
<a name="359"></a>     *   in terms of type conversions.  
<a name="360"></a>     */
<a name="361"></a>    bannerSay(handle, ...);
<a name="362"></a>
<a name="363"></a>    /* 
<a name="364"></a>     *   Flush all buffers for a banner window.  This ensures that any text
<a name="365"></a>     *   written with bannerSay() is actually displayed for the user to see
<a name="366"></a>     *   (rather than being held in internal buffers).  
<a name="367"></a>     */
<a name="368"></a>    bannerFlush(handle);
<a name="369"></a>
<a name="370"></a>    /* 
<a name="371"></a>     *   Size a banner to fit its contents.  This resizes the banner such
<a name="372"></a>     *   that the contents just fit.  In the case of a top- or bottom-aligned
<a name="373"></a>     *   banner, the height is set just high enough to hold all of the text
<a name="374"></a>     *   currently displayed.  In the case of a left- or right-aligned
<a name="375"></a>     *   banner, the width is set just wide enough to hold the widest single
<a name="376"></a>     *   word that can't be broken across lines.  In all cases, the size
<a name="377"></a>     *   includes any fixed margin space, to ensure that all of the text in
<a name="378"></a>     *   the window is actually visible without scrolling.
<a name="379"></a>     *   
<a name="380"></a>     *   Note that not all systems support this function.  On systems where
<a name="381"></a>     *   the function is not supported, this call has no effect.  Because of
<a name="382"></a>     *   this, you should always use this function in conjunction with an
<a name="383"></a>     *   "advisory" call to bannerSetSize().  
<a name="384"></a>     */
<a name="385"></a>    bannerSizeToContents(handle);
<a name="386"></a>
<a name="387"></a>    /* 
<a name="388"></a>     *   Go to to an output position.  This is meaningful only for
<a name="389"></a>     *   BannerTypeTextGrid windows.  This sets the next text output position
<a name="390"></a>     *   to the given row and column in the text grid; the next call to
<a name="391"></a>     *   bannerSay() will display its output starting at this position.  
<a name="392"></a>     */
<a name="393"></a>    bannerGoTo(handle, row, col);
<a name="394"></a>
<a name="395"></a>    /* 
<a name="396"></a>     *   Set text foreground and background colors.  This affects the color
<a name="397"></a>     *   of subsequently displayed text; text displayed previously is not
<a name="398"></a>     *   affected.  The colors are given as ColorXxx values (see below).  If
<a name="399"></a>     *   'bg' is ColorTransparent, then text is shown with the current screen
<a name="400"></a>     *   color in the window.  
<a name="401"></a>     */
<a name="402"></a>    bannerSetTextColor(handle, fg, bg);
<a name="403"></a>
<a name="404"></a>    /*
<a name="405"></a>     *   Set the "screen color" in the banner window.  This is the color used
<a name="406"></a>     *   to fill parts of the window that aren't displaying any text, and as
<a name="407"></a>     *   the background color for all text displayed when the text background
<a name="408"></a>     *   color is ColorTransparent.  Setting the screen color immediately
<a name="409"></a>     *   sets the color for the entire window - even text previously
<a name="410"></a>     *   displayed in the window is affected by this change.  
<a name="411"></a>     */
<a name="412"></a>    bannerSetScreenColor(handle, color);
<a name="413"></a>
<a name="414"></a>    /* 
<a name="415"></a>     *   Get information on the banner.  This returns a list giving a
<a name="416"></a>     *   detailed set of information describing the banner.  
<a name="417"></a>     */
<a name="418"></a>    bannerGetInfo(handle);
<a name="419"></a>
<a name="420"></a>    /* 
<a name="421"></a>     *   Set the size of a banner.  This explicitly sets the banner's height
<a name="422"></a>     *   (for a top or bottom banner) or width (for a left or right) banner
<a name="423"></a>     *   to the 'size', which is specified in units given by 'sizeUnits',
<a name="424"></a>     *   which is a BannerSizeXxx constant.  If 'isAdvisory' is true, the
<a name="425"></a>     *   caller is indicating that this call will be followed soon by a call
<a name="426"></a>     *   to bannerSizeToContents().  On systems that support sizing to
<a name="427"></a>     *   contents, an "advisory" call to bannerSetSize() will simply be
<a name="428"></a>     *   ignored in anticipation of the upcoming call to
<a name="429"></a>     *   bannerSizeToContents().  On systems that don't support sizing to
<a name="430"></a>     *   contents, an advisory call will actually resize the window.  
<a name="431"></a>     */
<a name="432"></a>    bannerSetSize(handle, size, sizeUnits, isAdvisory);
<a name="433"></a>
<a name="434"></a>    /* 
<a name="435"></a>     *   Create a log file console.  This creates a console that has no
<a name="436"></a>     *   display, but simply captures its output to the given log file.
<a name="437"></a>     *   Writing to a log console is different from writing to a regular text
<a name="438"></a>     *   file in that we apply all of the normal formatting (including
<a name="439"></a>     *   text-only-mode HTML interpretation) to the output sent to this
<a name="440"></a>     *   console.  
<a name="441"></a>     */
<a name="442"></a>    logConsoleCreate(filename, charset, width);
<a name="443"></a>
<a name="444"></a>    /* 
<a name="445"></a>     *   Close a log console.  This closes the file associated with the log
<a name="446"></a>     *   console and deletes the console object.  The given console handle is
<a name="447"></a>     *   no longer valid after this function is called.  
<a name="448"></a>     */
<a name="449"></a>    logConsoleClose(handle);
<a name="450"></a>
<a name="451"></a>    /* 
<a name="452"></a>     *   Write text to a log console.  This works the same as tadsSay(), but
<a name="453"></a>     *   writes the output to the given log console rather than to the main
<a name="454"></a>     *   output window.  
<a name="455"></a>     */
<a name="456"></a>    logConsoleSay(handle, ...);
<a name="457"></a>
<a name="458"></a>    /*
<a name="459"></a>     *   Log an input event that's obtained externally - i.e., from a source
<a name="460"></a>     *   other than the system input APIs (inputLine, inputKey, inputEvent,
<a name="461"></a>     *   etc).  This adds the event to any command or event log that the
<a name="462"></a>     *   system is currently writing, as set with setLogFile().
<a name="463"></a>     *   
<a name="464"></a>     *   It's only necessary to call this function when obtaining user input
<a name="465"></a>     *   from custom code that bypasses the system input APIs.  The system
<a name="466"></a>     *   input functions all log events automatically, so you must not call
<a name="467"></a>     *   this for input obtained from them (doing so would write each input
<a name="468"></a>     *   twice, since it's already being written once by the input
<a name="469"></a>     *   functions).  For example, this is useful for the Web UI, since it
<a name="470"></a>     *   obtains input via network transactions with the javascript client.
<a name="471"></a>     *   
<a name="472"></a>     *   'evt' is a list describing the event, using the same format that
<a name="473"></a>     *   inputEvent() returns.  Note one special extension: if the first
<a name="474"></a>     *   element of the list is a string, the string is used as the tag name
<a name="475"></a>     *   if we're writing an event script.  This can be used to write custom
<a name="476"></a>     *   events or events with no InEvtXxx type code, such as &lt;dialog&gt; input
<a name="477"></a>     *   events.
<a name="478"></a>     */
<a name="479"></a>    logInputEvent(evt);
<a name="480"></a>}
<a name="481"></a>
<a name="482"></a>/* log file types */
<a name="483"></a>#define LogTypeTranscript 1     /* log all input and output to a transcript */
<a name="484"></a>#define LogTypeCommand    2                  /* log only command-line input */
<a name="485"></a>#define LogTypeScript     3                         /* log all input events */
<a name="486"></a>
<a name="487"></a>/* 
<a name="488"></a> *   The special log console handle for the main console window's transcript.
<a name="489"></a> *   This can be used as the handle in logConsoleSay(), to write text
<a name="490"></a> *   directly to the main console's log file, if any.  Note that this console
<a name="491"></a> *   cannot be closed via logConsoleClose(); use setLogFile(nil) instead.  
<a name="492"></a> */
<a name="493"></a>#define MainWindowLogHandle  (-1)
<a name="494"></a>
<a name="495"></a>/* 
<a name="496"></a> *   constants for the event codes returned by the inputEvent() and
<a name="497"></a> *   inputLineTimeout() intrinsic functions 
<a name="498"></a> */
<a name="499"></a>#define InEvtKey         1
<a name="500"></a>#define InEvtTimeout     2
<a name="501"></a>#define InEvtHref        3
<a name="502"></a>#define InEvtNoTimeout   4
<a name="503"></a>#define InEvtNotimeout   4         /* (note minor capitalization variation) */
<a name="504"></a>#define InEvtEof         5
<a name="505"></a>#define InEvtLine        6
<a name="506"></a>#define InEvtSysCommand  0x100
<a name="507"></a>#define InEvtEndQuietScript  10000
<a name="508"></a>#define InEvtEndScript       10003
<a name="509"></a>
<a name="510"></a>/*
<a name="511"></a> *   Command codes for InEvtSysCommand 
<a name="512"></a> */
<a name="513"></a>#define SaveCommand       0x0001               /* SAVE the current position */
<a name="514"></a>#define RestoreCommand    0x0002                /* RESTORE a saved position */
<a name="515"></a>#define UndoCommand       0x0003                           /* UNDO one turn */
<a name="516"></a>#define QuitCommand       0x0004                           /* QUIT the game */
<a name="517"></a>#define CloseCommand      0x0005                   /* close the game window */
<a name="518"></a>#define HelpCommand       0x0006                          /* show game HELP */
<a name="519"></a>
<a name="520"></a>
<a name="521"></a>/*
<a name="522"></a> *   constants for inputDialog() 
<a name="523"></a> */
<a name="524"></a>#define InDlgOk              1
<a name="525"></a>#define InDlgOkCancel        2
<a name="526"></a>#define InDlgYesNo           3
<a name="527"></a>#define InDlgYesNoCancel     4
<a name="528"></a>
<a name="529"></a>#define InDlgIconNone        0
<a name="530"></a>#define InDlgIconWarning     1
<a name="531"></a>#define InDlgIconInfo        2
<a name="532"></a>#define InDlgIconQuestion    3
<a name="533"></a>#define InDlgIconError       4
<a name="534"></a>
<a name="535"></a>#define InDlgLblOk           1
<a name="536"></a>#define InDlgLblCancel       2
<a name="537"></a>#define InDlgLblYes          3
<a name="538"></a>#define InDlgLblNo           4
<a name="539"></a>
<a name="540"></a>/*
<a name="541"></a> *   inputFile() dialog types 
<a name="542"></a> */
<a name="543"></a>#define InFileOpen    1                /* open an existing file for reading */
<a name="544"></a>#define InFileSave    2                                 /* save to the file */
<a name="545"></a>
<a name="546"></a>/*
<a name="547"></a> *   inputFile() return codes - these are returned in the first element of
<a name="548"></a> *   the list returned from inputFile() 
<a name="549"></a> */
<a name="550"></a>#define InFileSuccess        0    /* success - 2nd list element is filename */
<a name="551"></a>#define InFileFailure        1       /* an error occurred asking for a file */
<a name="552"></a>#define InFileCancel         2         /* player canceled the file selector */
<a name="553"></a>
<a name="554"></a>/*
<a name="555"></a> *   constants for inputFile() file type codes 
<a name="556"></a> */
<a name="557"></a>#define FileTypeLog     2                        /* a transcript (log) file */
<a name="558"></a>#define FileTypeData    4                            /* arbitrary data file */
<a name="559"></a>#define FileTypeCmd     5                             /* command input file */
<a name="560"></a>#define FileTypeText    7                                      /* text file */
<a name="561"></a>#define FileTypeBin     8                               /* binary data file */
<a name="562"></a>#define FileTypeUnknown 11                             /* unknown file type */
<a name="563"></a>#define FileTypeT3Image 12               /* T3 executable image (game) file */
<a name="564"></a>#define FileTypeT3Save  15                           /* T3 saved state file */
<a name="565"></a>
<a name="566"></a>/*
<a name="567"></a> *   constants for systemInfo information type codes 
<a name="568"></a> */
<a name="569"></a>#define SysInfoVersion       2
<a name="570"></a>#define SysInfoOsName        3
<a name="571"></a>#define SysInfoJpeg          5
<a name="572"></a>#define SysInfoPng           6
<a name="573"></a>#define SysInfoWav           7
<a name="574"></a>#define SysInfoMidi          8
<a name="575"></a>#define SysInfoWavMidiOvl    9
<a name="576"></a>#define SysInfoWavOvl        10
<a name="577"></a>#define SysInfoPrefImages    11
<a name="578"></a>#define SysInfoPrefSounds    12
<a name="579"></a>#define SysInfoPrefMusic     13
<a name="580"></a>#define SysInfoPrefLinks     14
<a name="581"></a>#define SysInfoMpeg          15
<a name="582"></a>#define SysInfoMpeg1         16
<a name="583"></a>#define SysInfoMpeg2         17
<a name="584"></a>#define SysInfoMpeg3         18
<a name="585"></a>#define SysInfoLinksHttp     20
<a name="586"></a>#define SysInfoLinksFtp      21
<a name="587"></a>#define SysInfoLinksNews     22
<a name="588"></a>#define SysInfoLinksMailto   23
<a name="589"></a>#define SysInfoLinksTelnet   24
<a name="590"></a>#define SysInfoPngTrans      25
<a name="591"></a>#define SysInfoPngAlpha      26
<a name="592"></a>#define SysInfoOgg           27
<a name="593"></a>#define SysInfoMng           28
<a name="594"></a>#define SysInfoMngTrans      29
<a name="595"></a>#define SysInfoMngAlpha      30
<a name="596"></a>#define SysInfoTextHilite    31
<a name="597"></a>#define SysInfoTextColors    32
<a name="598"></a>#define SysInfoBanners       33
<a name="599"></a>#define SysInfoInterpClass   34
<a name="600"></a>#define SysInfoAudioFade     35
<a name="601"></a>#define SysInfoAudioCrossfade 36
<a name="602"></a>
<a name="603"></a>/* SysInfoTextColors support level codes */
<a name="604"></a>#define SysInfoTxcNone       0
<a name="605"></a>#define SysInfoTxcParam      1
<a name="606"></a>#define SysInfoTxcAnsiFg     2
<a name="607"></a>#define SysInfoTxcAnsiFgBg   3
<a name="608"></a>#define SysInfoTxcRGB        4
<a name="609"></a>
<a name="610"></a>/* SysInfoInterpClass codes */
<a name="611"></a>#define SysInfoIClassText    1
<a name="612"></a>#define SysInfoIClassTextGUI 2
<a name="613"></a>#define SysInfoIClassHTML    3
<a name="614"></a>
<a name="615"></a>/* SysInfoAudioFade and SysInfoAudioCrossfade result codes */
<a name="616"></a>#define SysInfoFadeMPEG      0x0001
<a name="617"></a>#define SysInfoFadeOGG       0x0002
<a name="618"></a>#define SysInfoFadeWAV       0x0004
<a name="619"></a>#define SysInfoFadeMIDI      0x0008
<a name="620"></a>
<a name="621"></a>/*
<a name="622"></a> *   constants for statusMode 
<a name="623"></a> */
<a name="624"></a>#define StatModeNormal    0                       /* displaying normal text */
<a name="625"></a>#define StatModeStatus    1                     /* display status line text */
<a name="626"></a>
<a name="627"></a>/*
<a name="628"></a> *   flags for setScriptFile 
<a name="629"></a> */
<a name="630"></a>#define ScriptFileQuiet    1  /* do not display output while reading script */
<a name="631"></a>#define ScriptFileNonstop  2   /* turn off MORE prompt while reading script */
<a name="632"></a>#define ScriptFileEvent    4        /* this is an event script (query only) */
<a name="633"></a>
<a name="634"></a>/*
<a name="635"></a> *   Script Request - get current script status.  In 3.0.17+, passing this
<a name="636"></a> *   constant as the 'filename' argument to getScriptFile() will perform a
<a name="637"></a> *   "get script status" request.  If there's no script file in progress, the
<a name="638"></a> *   function returns nil.  If a script file is being read, the function
<a name="639"></a> *   returns an integer value giving a combination of ScriptFileXxx flag
<a name="640"></a> *   values indicating the current script status.  Note that a return value
<a name="641"></a> *   of 0 (zero) means that a script is running but none of the ScriptFileXxx
<a name="642"></a> *   flags are applicable.  
<a name="643"></a> */
<a name="644"></a>#define ScriptReqGetStatus   0x7000
<a name="645"></a>
<a name="646"></a>/*
<a name="647"></a> *   selectors for getLocalCharSet
<a name="648"></a> */
<a name="649"></a>#define CharsetDisplay  1             /* the display/keyboard character set */
<a name="650"></a>#define CharsetFileName 2                  /* the file system character set */
<a name="651"></a>#define CharsetFileCont 3            /* default file contents character set */
<a name="652"></a>
<a name="653"></a>/*
<a name="654"></a> *   banner insertion point specifies (for 'where' in bannerCreate)
<a name="655"></a> */
<a name="656"></a>#define BannerFirst   1
<a name="657"></a>#define BannerLast    2
<a name="658"></a>#define BannerBefore  3
<a name="659"></a>#define BannerAfter   4
<a name="660"></a>
<a name="661"></a>/*
<a name="662"></a> *   banner types 
<a name="663"></a> */
<a name="664"></a>#define BannerTypeText     1                 /* ordinary text stream window */
<a name="665"></a>#define BannerTypeTextGrid 2                            /* text grid window */
<a name="666"></a>
<a name="667"></a>/* 
<a name="668"></a> *   banner alignment types 
<a name="669"></a> */
<a name="670"></a>#define BannerAlignTop     0
<a name="671"></a>#define BannerAlignBottom  1
<a name="672"></a>#define BannerAlignLeft    2
<a name="673"></a>#define BannerAlignRight   3
<a name="674"></a>
<a name="675"></a>/*
<a name="676"></a> *   banner size unit types 
<a name="677"></a> */
<a name="678"></a>#define BannerSizePercent   1    /* size is a percentage of available space */
<a name="679"></a>#define BannerSizeAbsolute  2    /* size is in natural units of window type */
<a name="680"></a>
<a name="681"></a>/*
<a name="682"></a> *   banner style flags 
<a name="683"></a> */
<a name="684"></a>#define BannerStyleBorder       0x0001       /* banner has a visible border */
<a name="685"></a>#define BannerStyleVScroll      0x0002                /* vertical scrollbar */
<a name="686"></a>#define BannerStyleHScroll      0x0004              /* horizontal scrollbar */
<a name="687"></a>#define BannerStyleAutoVScroll  0x0008      /* automatic vertical scrolling */
<a name="688"></a>#define BannerStyleAutoHScroll  0x0010    /* automatic horizontal scrolling */
<a name="689"></a>#define BannerStyleTabAlign     0x0020           /* &lt;TAB&gt; alignment support */
<a name="690"></a>#define BannerStyleMoreMode     0x0040                     /* use MORE mode */
<a name="691"></a>#define BannerStyleHStrut       0x0080    /* include in parent's auto width */
<a name="692"></a>#define BannerStyleVStrut       0x0100   /* include in parent's auto height */
<a name="693"></a>
<a name="694"></a>/*
<a name="695"></a> *   Color codes.  A color can be specified with explicit RGB
<a name="696"></a> *   (red-green-blue) component values, or can be "parameterized," which
<a name="697"></a> *   means that the color uses a pre-defined color for a particular purpose.
<a name="698"></a> *   
<a name="699"></a> *   RGB colors are specified with each component given in the range 0 to
<a name="700"></a> *   255; the color (0,0,0) is pure black, and (255,255,255) is pure white.
<a name="701"></a> *   
<a name="702"></a> *   The special value "transparent" is not a color at all, but rather
<a name="703"></a> *   specifies that the current screen color should be used.
<a name="704"></a> *   
<a name="705"></a> *   The "Text" and "TextBg" colors are the current default text and text
<a name="706"></a> *   background colors.  The actual colors displayed for these values depend
<a name="707"></a> *   on the system, and on some systems these colors might be configurable by
<a name="708"></a> *   the user through a preferences selection.  These are the same colors
<a name="709"></a> *   selected by the HTML parameterized color names 'text' and 'bgcolor'.
<a name="710"></a> *   
<a name="711"></a> *   The "StatusText" and "StatusBg" colors are the current default
<a name="712"></a> *   statusline text and background colors, which depend on the system and
<a name="713"></a> *   may be user-configurable on some systems.  These are the same colors
<a name="714"></a> *   selected by the HTML parameterized color names 'statustext' and
<a name="715"></a> *   'statusbg'.
<a name="716"></a> *   
<a name="717"></a> *   The "input" color is the current default input text color.  
<a name="718"></a> */
<a name="719"></a>#define ColorRGB(r, g, b) \
<a name="720"></a>    ((((r) &amp; 0xff) &lt;&lt; 16) + (((g) &amp; 0xff) &lt;&lt; 8) + ((b) &amp; 0xff))
<a name="721"></a>#define ColorTransparent     0x01000000
<a name="722"></a>#define ColorText            0x02000000
<a name="723"></a>#define ColorTextBg          0x03000000
<a name="724"></a>#define ColorStatusText      0x04000000
<a name="725"></a>#define ColorStatusBg        0x05000000
<a name="726"></a>#define ColorInput           0x06000000
<a name="727"></a>
<a name="728"></a>/* some specific colors by name, for convenience */
<a name="729"></a>#define ColorBlack    ColorRGB(0x00, 0x00, 0x00)
<a name="730"></a>#define ColorWhite    ColorRGB(0xff, 0xff, 0xff)
<a name="731"></a>#define ColorRed      ColorRGB(0xff, 0x00, 0x00)
<a name="732"></a>#define ColorBlue     ColorRGB(0x00, 0x00, 0xFF)
<a name="733"></a>#define ColorGreen    ColorRGB(0x00, 0x80, 0x00)
<a name="734"></a>#define ColorYellow   ColorRGB(0xFF, 0xFF, 0x00)
<a name="735"></a>#define ColorCyan     ColorRGB(0x00, 0xFF, 0xFF)
<a name="736"></a>#define ColorAqua     ColorRGB(0x00, 0xFF, 0xFF)
<a name="737"></a>#define ColorMagenta  ColorRGB(0xFF, 0x00, 0xFF)
<a name="738"></a>#define ColorSilver   ColorRGB(0xC0, 0xC0, 0xC0)
<a name="739"></a>#define ColorGray     ColorRGB(0x80, 0x80, 0x80)
<a name="740"></a>#define ColorMaroon   ColorRGB(0x80, 0x00, 0x00)
<a name="741"></a>#define ColorPurple   ColorRGB(0x80, 0x00, 0x80)
<a name="742"></a>#define ColorFuchsia  ColorRGB(0xFF, 0x00, 0xFF)
<a name="743"></a>#define ColorLime     ColorRGB(0x00, 0xFF, 0x00)
<a name="744"></a>#define ColorOlive    ColorRGB(0x80, 0x80, 0x00)
<a name="745"></a>#define ColorNavy     ColorRGB(0x00, 0x00, 0x80)
<a name="746"></a>#define ColorTeal     ColorRGB(0x00, 0x80, 0x80)
<a name="747"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 13/06/2025 from adv3Lite version 2.2.1</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>input.t</title></head><body>
<table class=ban><tr><td><h1>input.t</h1><td align=right><a href="../file/input.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   ************************************************************************
<a name="6"></a> *   actor.t This module forms part of the adv3Lite library
<a name="7"></a> *.  (c) 2012-13 Eric Eve.
<a name="8"></a> *.  Based substantially on input.t in the adv3 library
<a name="9"></a> *.  Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="10"></a> *
<a name="11"></a> *
<a name="12"></a> *
<a name="13"></a> *   This modules defines functions and objects related to reading input from
<a name="14"></a> *   the player.
<a name="15"></a> */
<a name="16"></a>
<a name="17"></a>
<a name="18"></a>
<a name="19"></a>/* ------------------------------------------------------------------------ */
<a name="20"></a>/*
<a name="21"></a> *   Keyboard input parameter definition. 
<a name="22"></a> */
<a name="23"></a>class InputDef: object
<a name="24"></a>    /* 
<a name="25"></a>     *   The prompt function.  This is a function pointer (which is
<a name="26"></a>     *   frequently given as an anonymous function) or nil; if it's nil,
<a name="27"></a>     *   we won't show any prompt at all, otherwise we'll call the
<a name="28"></a>     *   function pointer to display a prompt as needed. 
<a name="29"></a>     */
<a name="30"></a>    promptFunc = nil
<a name="31"></a>
<a name="32"></a>    
<a name="33"></a>    /* 
<a name="34"></a>     *   Begin the input style.  This should do anything required to set
<a name="35"></a>     *   the font to the desired attributes for the input text.  By
<a name="36"></a>     *   default, we'll simply display &lt;.inputline&gt; to set up the default
<a name="37"></a>     *   input style.  
<a name="38"></a>     */
<a name="39"></a>    beginInputFont() { "&lt;.inputline&gt;"; }
<a name="40"></a>
<a name="41"></a>    /* 
<a name="42"></a>     *   End the input style.  By default, we'll close the &lt;.inputline&gt;
<a name="43"></a>     *   that we opened in beginInputFont(). 
<a name="44"></a>     */
<a name="45"></a>    endInputFont() { "&lt;./inputline&gt;"; }
<a name="46"></a>;
<a name="47"></a>
<a name="48"></a>/*
<a name="49"></a> *   Basic keyboard input parameter definition.  This class defines
<a name="50"></a> *   keyboard input parameters with the real-time status and prompt
<a name="51"></a> *   function specified via the constructor.  
<a name="52"></a> */
<a name="53"></a>class BasicInputDef: InputDef
<a name="54"></a>    construct(promptFunc)   
<a name="55"></a>    {
<a name="56"></a>        self.promptFunc = promptFunc;
<a name="57"></a>    }
<a name="58"></a>;
<a name="59"></a>
<a name="60"></a>
<a name="61"></a>/* ------------------------------------------------------------------------ */
<a name="62"></a>/*
<a name="63"></a> *   Keyboard input manager. 
<a name="64"></a> */
<a name="65"></a>inputManager: PostRestoreObject
<a name="66"></a>    /*
<a name="67"></a>     *   Read a line of input from the keyboard.
<a name="68"></a>     *
<a name="69"></a>     *   promptFunc can either be a callback function to invoke to display the
<a name="70"></a>     *   prompt, or a single-quoted string containing the prompt. Of course, the
<a name="71"></a>     *   caller can simply display the prompt before calling this routine rather
<a name="72"></a>     *   than passing in a prompt callback, if desired.
<a name="73"></a>     *
<a name="74"></a>     *   If we're in HTML mode, this will switch into the 'tads-input' font
<a name="75"></a>     *   while reading the line, so this routine should be used wherever
<a name="76"></a>     *   possible rather than calling inputLine() or inputLineTimeout()
<a name="77"></a>     *   directly.
<a name="78"></a>     */
<a name="79"></a>    getInputLine(promptFunc?)
<a name="80"></a>    {
<a name="81"></a>        /* read input using a basic InputDef for the given parameters */
<a name="82"></a>        return getInputLineExt(new BasicInputDef(promptFunc));
<a name="83"></a>    }
<a name="84"></a>
<a name="85"></a>    /*
<a name="86"></a>     *   Read a line of input from the keyboard - extended interface,
<a name="87"></a>     *   using the InputDef object to define the input parameters.
<a name="88"></a>     *   'defObj' is an instance of class InputDef, defining how we're to
<a name="89"></a>     *   handle the input.  
<a name="90"></a>     */
<a name="91"></a>    getInputLineExt(defObj)
<a name="92"></a>    {
<a name="93"></a>
<a name="94"></a>        /* 
<a name="95"></a>         *   If a previous input was in progress, cancel it - this must be
<a name="96"></a>         *   a recursive entry from a real-time event that's interrupting
<a name="97"></a>         *   the enclosing input attempt. Simply cancel out the enclosing
<a name="98"></a>         *   read attempt entirely in this case; if and when we return to
<a name="99"></a>         *   the enclosing reader, that reader will start over with a
<a name="100"></a>         *   fresh read attempt at that point.  
<a name="101"></a>         */
<a name="102"></a>        cancelInputInProgress(true);
<a name="103"></a>        
<a name="104"></a>        /* 
<a name="105"></a>         *   Keep going until we finish reading the command.  We might
<a name="106"></a>         *   have to try several times, because our attempts might be
<a name="107"></a>         *   interrupted by real-time events. 
<a name="108"></a>         */
<a name="109"></a>        for (;;)
<a name="110"></a>        {
<a name="111"></a>            local result;
<a name="112"></a>            local timeout;
<a name="113"></a>
<a name="114"></a>
<a name="115"></a>            /* show the prompt and any pre-input codes */
<a name="116"></a>            inputLineBegin(defObj);
<a name="117"></a>
<a name="118"></a>        getInput:
<a name="119"></a>            /* 
<a name="120"></a>             *   Read the input.  (Note that if our timeout is nil, this
<a name="121"></a>             *   will simply act like the ordinary untimed inputLine.)  
<a name="122"></a>             */
<a name="123"></a>            result = aioInputLineTimeout(timeout);
<a name="124"></a>
<a name="125"></a>            
<a name="126"></a>            /* check the event code from the result list */
<a name="127"></a>            switch(result[1])
<a name="128"></a>            {
<a name="129"></a>            case InEvtNoTimeout:
<a name="130"></a>                /* 
<a name="131"></a>                 *   the platform doesn't support timeouts - note it for
<a name="132"></a>                 *   future reference so that we don't ask for input with
<a name="133"></a>                 *   timeout again, then go back to try the input again
<a name="134"></a>                 *   without a timeout 
<a name="135"></a>                 */
<a name="136"></a>                noInputTimeout = true;
<a name="137"></a>                timeout = nil;
<a name="138"></a>                goto getInput;
<a name="139"></a>            
<a name="140"></a>            case InEvtLine:
<a name="141"></a>                /* we've finished the current line - end input mode */
<a name="142"></a>                inputLineEnd();
<a name="143"></a>
<a name="144"></a>                /* return the line of text we got */
<a name="145"></a>                return result[2];
<a name="146"></a>            
<a name="147"></a>            case InEvtTimeout:
<a name="148"></a>                /* 
<a name="149"></a>                 *   We got a timeout without finishing the input line.
<a name="150"></a>                 *   This means that we've reached the time when the next
<a name="151"></a>                 *   real-time event is ready to execute.  Simply continue
<a name="152"></a>                 *   looping; we'll process all real-time events that are
<a name="153"></a>                 *   ready to go, then we'll resume reading the command.  
<a name="154"></a>                 *   
<a name="155"></a>                 *   Before we proceed, though, notify the command
<a name="156"></a>                 *   sequencer (via the command-interrupt pseudo-tag) that
<a name="157"></a>                 *   we're at the start of output text after an interrupted
<a name="158"></a>                 *   command line input 
<a name="159"></a>                 */
<a name="160"></a>                "&lt;.commandint&gt;";
<a name="161"></a>                break;
<a name="162"></a>            
<a name="163"></a>            case InEvtEof:
<a name="164"></a>                /* 
<a name="165"></a>                 *   End of file - this indicates that the user has closed
<a name="166"></a>                 *   down the application, or that the keyboard has become
<a name="167"></a>                 *   unreadable due to a hardware or OS error.
<a name="168"></a>                 *   
<a name="169"></a>                 *   Write a blank line to the display in an attempt to
<a name="170"></a>                 *   flush any partially-entered command line text, then
<a name="171"></a>                 *   throw an error to signal the EOF condition.  
<a name="172"></a>                 */
<a name="173"></a>                "\b";
<a name="174"></a>                throw new EndOfFileException();
<a name="175"></a>
<a name="176"></a>            case InEvtEndQuietScript:
<a name="177"></a>                /* 
<a name="178"></a>                 *   End of "quiet" script - this indicates that we've
<a name="179"></a>                 *   been reading input from a script file, but we've now
<a name="180"></a>                 *   reached the end of that file and are about to return
<a name="181"></a>                 *   to reading from the keyboard.
<a name="182"></a>                 *   
<a name="183"></a>                 *   "Quiet script" mode causes all output to be hidden
<a name="184"></a>                 *   while the script is being processed.  This means that
<a name="185"></a>                 *   we won't have displayed a prompt for the current
<a name="186"></a>                 *   line, or updated the status line.  We'll
<a name="187"></a>                 *   automatically display a new prompt when we loop back
<a name="188"></a>                 *   for another line of input, but we have to mark the
<a name="189"></a>                 *   current input line as actually ended now for that to
<a name="190"></a>                 *   happen.  
<a name="191"></a>                 */
<a name="192"></a>                inputLineInProgress = nil;
<a name="193"></a>                inProgressDefObj = nil;
<a name="194"></a>
<a name="195"></a>                /* 
<a name="196"></a>                 *   update the status line, since the quiet script mode
<a name="197"></a>                 *   will have suppressed all status line updates while we
<a name="198"></a>                 *   were reading the script, and thus the last update
<a name="199"></a>                 *   before this prompt won't have been shown 
<a name="200"></a>                 */
<a name="201"></a>                statusLine.showStatusLine();
<a name="202"></a>
<a name="203"></a>                /* back for more */
<a name="204"></a>                break;
<a name="205"></a>
<a name="206"></a>            case 'newGuest':
<a name="207"></a>                /* 
<a name="208"></a>                 *   Synthetic "new guest" event from the Web UI.  This
<a name="209"></a>                 *   indicates that a new user has joined the session.  The
<a name="210"></a>                 *   parameter is the new user's screen name.  Announce the
<a name="211"></a>                 *   new user's arrival as a real-time event, and go back
<a name="212"></a>                 *   to reading input.  
<a name="213"></a>                 */
<a name="214"></a>                "&lt;.commandint&gt;";
<a name="215"></a>                libMessages.webNewUser(result[2]);
<a name="216"></a>                break;
<a name="217"></a>
<a name="218"></a>            case 'logError':
<a name="219"></a>                /*
<a name="220"></a>                 *   Synthetic "log error" event from the Web UI.  The UI
<a name="221"></a>                 *   posts this type of an event when an error occurs in an
<a name="222"></a>                 *   asynchronous task, where it's not possible to display
<a name="223"></a>                 *   an error message directly. 
<a name="224"></a>                 */
<a name="225"></a>                "&lt;.commandint&gt;\b&lt;&lt;result[2]&gt;&gt;\b";
<a name="226"></a>                break;
<a name="227"></a>            }
<a name="228"></a>        }
<a name="229"></a>    }
<a name="230"></a>
<a name="231"></a>    /*
<a name="232"></a>     *   Pause for a MORE prompt.            
<a name="233"></a>     */
<a name="234"></a>    pauseForMore()
<a name="235"></a>    {
<a name="236"></a>        /* run the MORE prompt */
<a name="237"></a>        aioMorePrompt();
<a name="238"></a>    }
<a name="239"></a>
<a name="240"></a>    /*
<a name="241"></a>     *   Ask for an input file. 
<a name="242"></a>     */
<a name="243"></a>    getInputFile(prompt, dialogType, fileType, flags)
<a name="244"></a>    {
<a name="245"></a>       
<a name="246"></a>        /* ask for a file */
<a name="247"></a>        local result = aioInputFile(prompt, dialogType, fileType, flags);
<a name="248"></a>
<a name="249"></a>        /* return the result from inputFile */
<a name="250"></a>        return result;
<a name="251"></a>    }
<a name="252"></a>
<a name="253"></a>    /*
<a name="254"></a>     *   Ask for input through a dialog.    The arguments are the same as for
<a name="255"></a>     *   the built-in inputDialog() function.
<a name="256"></a>     */
<a name="257"></a>    getInputDialog(icon, prompt, buttons, defaultButton, cancelButton)
<a name="258"></a>    {       
<a name="259"></a>        /* show the dialog */
<a name="260"></a>        local result = aioInputDialog(icon, prompt, buttons,
<a name="261"></a>                                      defaultButton, cancelButton);
<a name="262"></a>
<a name="263"></a>        /* return the dialog result */
<a name="264"></a>        return result;
<a name="265"></a>    }
<a name="266"></a>    
<a name="267"></a>
<a name="268"></a>    /*
<a name="269"></a>     *   Read a keystroke, processing real-time events while waiting.
<a name="270"></a>     *   'promptFunc' works the same way it does with getInputLine().
<a name="271"></a>     */
<a name="272"></a>    getKey(promptFunc?)
<a name="273"></a>    {
<a name="274"></a>        local evt;
<a name="275"></a>        
<a name="276"></a>        /* get an event */
<a name="277"></a>        evt = getEventOrKey(promptFunc, true);
<a name="278"></a>
<a name="279"></a>        /* 
<a name="280"></a>         *   the only event that getEventOrKey will return is a keystroke,
<a name="281"></a>         *   so return the keystroke from the event record 
<a name="282"></a>         */
<a name="283"></a>        return evt[2];
<a name="284"></a>    }
<a name="285"></a>
<a name="286"></a>    /*
<a name="287"></a>     *   Read an event, processing real-time events while waiting, if
<a name="288"></a>     *   desired.  'allowRealTime' and 'promptFunc' work the same way they
<a name="289"></a>     *   do with getInputLine().  
<a name="290"></a>     */
<a name="291"></a>    getEvent(promptFunc?)
<a name="292"></a>    {
<a name="293"></a>        /* read and return an event */
<a name="294"></a>        return getEventOrKey(promptFunc, nil);
<a name="295"></a>    }
<a name="296"></a>
<a name="297"></a>    /*
<a name="298"></a>     *   Read an event or keystroke.  'promptFunc' works the same way it does in
<a name="299"></a>     *   getInputLine().  If 'keyOnly' is true, then we're only interested in
<a name="300"></a>     *   keystroke events, and we'll ignore any other events entered.
<a name="301"></a>     *
<a name="302"></a>     *   Note that this routine is not generally called directly; callers should
<a name="303"></a>     *   usually call the convenience routines getKey() or getEvent(), as
<a name="304"></a>     *   needed.
<a name="305"></a>     */
<a name="306"></a>    getEventOrKey(promptFunc, keyOnly)
<a name="307"></a>    {
<a name="308"></a>        
<a name="309"></a>        /* 
<a name="310"></a>         *   Cancel any in-progress input.  If there's an in-progress
<a name="311"></a>         *   input, a real-time event must be interrupting the input,
<a name="312"></a>         *   which is recursively invoking us to start a new input. 
<a name="313"></a>         */
<a name="314"></a>        cancelInputInProgress(true);
<a name="315"></a>        
<a name="316"></a>        /* keep going until we get a keystroke or other event */
<a name="317"></a>        for (;;)
<a name="318"></a>        {
<a name="319"></a>            local result;
<a name="320"></a>            local timeout;
<a name="321"></a>
<a name="322"></a>
<a name="323"></a>            /* show the prompt and any pre-input codes */
<a name="324"></a>            inputEventBegin(promptFunc);
<a name="325"></a>
<a name="326"></a>        getInput:
<a name="327"></a>            /* 
<a name="328"></a>             *   Read the input.  (Note that if our timeout is nil, this
<a name="329"></a>             *   will simply act like the ordinary untimed inputLine.)  
<a name="330"></a>             */
<a name="331"></a>            result = aioInputEvent(timeout);
<a name="332"></a>           
<a name="333"></a>
<a name="334"></a>            /* check the event code from the result list */
<a name="335"></a>            switch(result[1])
<a name="336"></a>            {
<a name="337"></a>            case InEvtNoTimeout:
<a name="338"></a>                /* 
<a name="339"></a>                 *   the platform doesn't support timeouts - note it for
<a name="340"></a>                 *   future reference so that we don't ask for input with
<a name="341"></a>                 *   timeout again, then go back to try the input again
<a name="342"></a>                 *   without a timeout 
<a name="343"></a>                 */
<a name="344"></a>                noInputTimeout = true;
<a name="345"></a>                timeout = nil;
<a name="346"></a>                goto getInput;
<a name="347"></a>            
<a name="348"></a>            case InEvtTimeout:
<a name="349"></a>                /* 
<a name="350"></a>                 *   We got a timeout without finishing the input line.
<a name="351"></a>                 *   This means that we've reached the time when the next
<a name="352"></a>                 *   real-time event is ready to execute.  Simply continue
<a name="353"></a>                 *   looping; we'll process all real-time events that are
<a name="354"></a>                 *   ready to go, then we'll restart the event wait.
<a name="355"></a>                 */
<a name="356"></a>                break;
<a name="357"></a>            
<a name="358"></a>            case InEvtEof:
<a name="359"></a>                /* 
<a name="360"></a>                 *   End of file - this indicates that the user has closed
<a name="361"></a>                 *   down the application, or that the keyboard has become
<a name="362"></a>                 *   unreadable due to a hardware or OS error.
<a name="363"></a>                 *   
<a name="364"></a>                 *   Write a blank line to the display in an attempt to
<a name="365"></a>                 *   flush any partially-entered command line text, then
<a name="366"></a>                 *   throw an error to signal the EOF condition.  
<a name="367"></a>                 */
<a name="368"></a>                "\b";
<a name="369"></a>                throw new EndOfFileException();
<a name="370"></a>
<a name="371"></a>            case InEvtKey:
<a name="372"></a>                /* keystroke - finish the input and return the event */
<a name="373"></a>                inputEventEnd();
<a name="374"></a>                return result;
<a name="375"></a>
<a name="376"></a>            case InEvtHref:
<a name="377"></a>                /* 
<a name="378"></a>                 *   Hyperlink activation - if we're allowed to return
<a name="379"></a>                 *   events other than keystrokes, finish the input and
<a name="380"></a>                 *   return the event; otherwise, ignore the event and keep
<a name="381"></a>                 *   looping.  
<a name="382"></a>                 */
<a name="383"></a>                if (!keyOnly)
<a name="384"></a>                {
<a name="385"></a>                    inputEventEnd();
<a name="386"></a>                    return result;
<a name="387"></a>                }
<a name="388"></a>                break;
<a name="389"></a>
<a name="390"></a>            default:
<a name="391"></a>                /* ignore other events */
<a name="392"></a>                break;
<a name="393"></a>            }
<a name="394"></a>        }
<a name="395"></a>    }
<a name="396"></a>
<a name="397"></a>    /*
<a name="398"></a>     *   Cancel input in progress.
<a name="399"></a>     *   
<a name="400"></a>     *   If 'reset' is true, we'll clear any input state saved from the
<a name="401"></a>     *   interrupted in-progress editing session; otherwise, we'll retain
<a name="402"></a>     *   the saved editing state for restoration on the next input.
<a name="403"></a>     *   
<a name="404"></a>     *   This MUST be called before calling tadsSay().  Games should
<a name="405"></a>     *   generally never call tadsSay() directly (call the library
<a name="406"></a>     *   function say() instead), so in most cases authors will not need
<a name="407"></a>     *   to worry about calling this on output.
<a name="408"></a>     *   
<a name="409"></a>     *   This MUST ALSO be called before performing any keyboard input.
<a name="410"></a>     *   Callers using inputManager methods for keyboard operations won't
<a name="411"></a>     *   have to worry about this, because the inputManager methods call
<a name="412"></a>     *   this routine when necessary.  
<a name="413"></a>     */
<a name="414"></a>    cancelInputInProgress(reset)
<a name="415"></a>    {
<a name="416"></a>        /* cancel the interpreter's internal input state */
<a name="417"></a>        aioInputLineCancel(reset);
<a name="418"></a>
<a name="419"></a>        /* if we were editing a command line, terminate the editing session */
<a name="420"></a>        if (inputLineInProgress)
<a name="421"></a>        {
<a name="422"></a>            /* do our normal after-input work */
<a name="423"></a>            inputLineEnd();
<a name="424"></a>        }
<a name="425"></a>
<a name="426"></a>        /* if we were waiting for event input, note that we are no longer */
<a name="427"></a>        if (inputEventInProgress)
<a name="428"></a>        {
<a name="429"></a>            /* do our normal after-input work */
<a name="430"></a>            inputEventEnd();
<a name="431"></a>        }
<a name="432"></a>    }
<a name="433"></a>
<a name="434"></a>    
<a name="435"></a>
<a name="436"></a>    /*
<a name="437"></a>     *   Begin reading key/event input.  We'll cancel any report gatherer
<a name="438"></a>     *   so that prompt text shows immediately, and show the prompt if
<a name="439"></a>     *   desired.  
<a name="440"></a>     */
<a name="441"></a>    inputEventBegin(promptFunc)
<a name="442"></a>    {
<a name="443"></a>        /* if we're not continuing previous input, show the prompt */
<a name="444"></a>        if (!inputEventInProgress)
<a name="445"></a>        {
<a name="446"></a>            inputBegin(promptFunc);
<a name="447"></a>
<a name="448"></a>            /* note that we're in input mode */
<a name="449"></a>            inputEventInProgress = true;
<a name="450"></a>        }
<a name="451"></a>    }
<a name="452"></a>
<a name="453"></a>    /*
<a name="454"></a>     *   End keystroke/event input.
<a name="455"></a>     */
<a name="456"></a>    inputEventEnd()
<a name="457"></a>    {
<a name="458"></a>        /* if input is in progress, terminate it */
<a name="459"></a>        if (inputEventInProgress)
<a name="460"></a>        {
<a name="461"></a>            /* note that we're no longer reading an event */
<a name="462"></a>            inputEventInProgress = nil;
<a name="463"></a>        }
<a name="464"></a>    }
<a name="465"></a>
<a name="466"></a>    /*
<a name="467"></a>     *   Begin command line editing.  If we're in HTML mode, we'll show
<a name="468"></a>     *   the appropriate codes to establish the input font.  
<a name="469"></a>     */
<a name="470"></a>    inputLineBegin(defObj)
<a name="471"></a>    {
<a name="472"></a>        /* notify the command sequencer that we're reading a command */
<a name="473"></a>        "&lt;.commandbefore&gt;";
<a name="474"></a>        
<a name="475"></a>        /* if we're not resuming a session, set up a new session */
<a name="476"></a>        if (!inputLineInProgress)
<a name="477"></a>        {
<a name="478"></a>            /* begin input */
<a name="479"></a>            inputBegin(defObj.promptFunc);
<a name="480"></a>            
<a name="481"></a>            /* switch to input font */
<a name="482"></a>            defObj.beginInputFont();
<a name="483"></a>
<a name="484"></a>            /* note that we're in input mode */
<a name="485"></a>            inputLineInProgress = true;
<a name="486"></a>
<a name="487"></a>            /* remember the parameter object for this input */
<a name="488"></a>            inProgressDefObj = defObj;
<a name="489"></a>        }
<a name="490"></a>    }
<a name="491"></a>
<a name="492"></a>    /*
<a name="493"></a>     *   End command line editing.  If we're in HTML mode, we'll show the
<a name="494"></a>     *   appropriate codes to close the input font.  
<a name="495"></a>     */
<a name="496"></a>    inputLineEnd()
<a name="497"></a>    {
<a name="498"></a>        /* if input is in progress, terminate it */
<a name="499"></a>        if (inputLineInProgress)
<a name="500"></a>        {
<a name="501"></a>            /* note that we're no longer reading a line of input */
<a name="502"></a>            inputLineInProgress = nil;
<a name="503"></a>
<a name="504"></a>            /* end input font mode */
<a name="505"></a>            inProgressDefObj.endInputFont();
<a name="506"></a>
<a name="507"></a>            /* notify the command sequencer that we're done reading */
<a name="508"></a>            "&lt;.commandafter&gt;";
<a name="509"></a>
<a name="510"></a>            /* 
<a name="511"></a>             *   tell the main text area's output stream that we just
<a name="512"></a>             *   ended an input line 
<a name="513"></a>             */
<a name="514"></a>            mainOutputStream.inputLineEnd();
<a name="515"></a>
<a name="516"></a>            /* forget the parameter object for the input */
<a name="517"></a>            inProgressDefObj = nil;
<a name="518"></a>        }
<a name="519"></a>    }
<a name="520"></a>
<a name="521"></a>    /*
<a name="522"></a>     *   Begin generic input.  Cancels command report list capture, and
<a name="523"></a>     *   shows the prompt if given.  
<a name="524"></a>     */
<a name="525"></a>    inputBegin(promptFunc)
<a name="526"></a>    {        
<a name="527"></a>        switch(dataTypeXlat(promptFunc))
<a name="528"></a>        {
<a name="529"></a>            /* if we have a prompt, display it */
<a name="530"></a>        case TypeSString:
<a name="531"></a>            say(promptFunc);
<a name="532"></a>            break;
<a name="533"></a>        case TypeFuncPtr:         
<a name="534"></a>            (promptFunc)();
<a name="535"></a>            break;
<a name="536"></a>        default:
<a name="537"></a>            /* Do nothing */
<a name="538"></a>            break;
<a name="539"></a>        }
<a name="540"></a>    }
<a name="541"></a>    
<a name="542"></a>    /* receive post-restore notification */
<a name="543"></a>    execute()
<a name="544"></a>    {
<a name="545"></a>        /* 
<a name="546"></a>         *   Reset the inputLine state.  If we had any previously
<a name="547"></a>         *   interrupted input from the current interpreter session, forget
<a name="548"></a>         *   it by canceling and resetting the input line.  If we had an
<a name="549"></a>         *   interrupted line in the session being restored, forget about
<a name="550"></a>         *   that, too.  
<a name="551"></a>         */
<a name="552"></a>        aioInputLineCancel(true);
<a name="553"></a>        inputLineInProgress = nil;
<a name="554"></a>        inputEventInProgress = nil;
<a name="555"></a>
<a name="556"></a>        /* 
<a name="557"></a>         *   Clear the inputLineTimeout disabling flag - we might be
<a name="558"></a>         *   restoring the game on a different platform from the one where
<a name="559"></a>         *   the game started, so we might be able to use timed command
<a name="560"></a>         *   line input even if we didn't when we started the game.  By
<a name="561"></a>         *   clearing this flag, we'll check again to see if we can
<a name="562"></a>         *   perform timed input; if we can't, we'll just set the flag
<a name="563"></a>         *   again, so there will be no harm done.  
<a name="564"></a>         */
<a name="565"></a>        noInputTimeout = nil;
<a name="566"></a>    }
<a name="567"></a>
<a name="568"></a>    /* 
<a name="569"></a>     *   Flag: command line input is in progress.  If this is set, it means
<a name="570"></a>     *   that we interrupted command-line editing by a timeout, so we
<a name="571"></a>     *   should not show a prompt the next time we go back to the keyboard
<a name="572"></a>     *   for input.  
<a name="573"></a>     */
<a name="574"></a>    inputLineInProgress = nil
<a name="575"></a>
<a name="576"></a>    /* the InputDef object for the input in progress */
<a name="577"></a>    inProgressDefObj = nil
<a name="578"></a>
<a name="579"></a>    /* flag: keystroke/event input is in progress */
<a name="580"></a>    inputEventInProgress = nil
<a name="581"></a>
<a name="582"></a>    /*
<a name="583"></a>     *   Flag: inputLine does not support timeouts on the current platform.
<a name="584"></a>     *   We set this when we get an InEvtNoTimeout return code from
<a name="585"></a>     *   inputLineTimeout, so that we'll know not to try calling again with
<a name="586"></a>     *   a timeout.  This applies to the current interpreter only, so we
<a name="587"></a>     *   must ignore any value restored from a previously saved game, since
<a name="588"></a>     *   the game might have been saved on a different platform.
<a name="589"></a>     *   
<a name="590"></a>     *   Note that if this value is nil, it means only that we've never
<a name="591"></a>     *   seen an InEvtNoTimeout return code from inputLineEvent - it does
<a name="592"></a>     *   NOT mean that timeouts are supported locally.
<a name="593"></a>     *   
<a name="594"></a>     *   We assume that the input functions are uniform in their treatment
<a name="595"></a>     *   of timeouts; that is, we assume that if inputLineTimeout supports
<a name="596"></a>     *   timeout, then so does inputEvent, and that if one doesn't support
<a name="597"></a>     *   timeout, the other won't either.  
<a name="598"></a>     */
<a name="599"></a>    noInputTimeout = nil
<a name="600"></a>;
<a name="601"></a>
<a name="602"></a>
<a name="603"></a>
<a name="604"></a>/* ------------------------------------------------------------------------ */
<a name="605"></a>/*
<a name="606"></a> *   End-of-file exception - this is thrown when readMainCommand()
<a name="607"></a> *   encounters end of file reading the console input. 
<a name="608"></a> */
<a name="609"></a>class EndOfFileException: Exception
<a name="610"></a>;
<a name="611"></a>
<a name="612"></a>
<a name="613"></a>/* ------------------------------------------------------------------------ */
<a name="614"></a>/*
<a name="615"></a> *   'Quitting' exception.  This isn't an error - it merely indicates that
<a name="616"></a> *   the user has explicitly asked to quit the game. 
<a name="617"></a> */
<a name="618"></a>class QuittingException: Exception
<a name="619"></a>;
<a name="620"></a>
<a name="621"></a>/* ------------------------------------------------------------------------ */
<a name="622"></a>/*
<a name="623"></a> *   Base class for command input string preparsers.
<a name="624"></a> *   
<a name="625"></a> *   Preparsers must be registered in order to run.  During
<a name="626"></a> *   preinitialization, we will automatically register any existing
<a name="627"></a> *   preparser objects; preparsers that are created dynamically during
<a name="628"></a> *   execution must be registered explicitly, which can be accomplished by
<a name="629"></a> *   inheriting the default constructor from this class.  
<a name="630"></a> */
<a name="631"></a>class StringPreParser: PreinitObject
<a name="632"></a>    /*
<a name="633"></a>     *   My execution order number.  When multiple preparsers are
<a name="634"></a>     *   registered, we'll run the preparsers in ascending order of this
<a name="635"></a>     *   value (i.e., smallest runOrder goes first).  
<a name="636"></a>     */
<a name="637"></a>    runOrder = 100
<a name="638"></a>
<a name="639"></a>    /*
<a name="640"></a>     *   Do our parsing.  Each instance should override this method to
<a name="641"></a>     *   define the parsing that it does.
<a name="642"></a>     *   
<a name="643"></a>     *   'str' is the string to parse, and 'which' is the rmcXxx enum
<a name="644"></a>     *   giving the type of command we're working with.
<a name="645"></a>     *   
<a name="646"></a>     *   This method returns a string or nil.  If the method returns a
<a name="647"></a>     *   string, the caller will forget the original string and work from
<a name="648"></a>     *   here on out with the new version returned; this allows the method
<a name="649"></a>     *   to rewrite the original input as desired.  If the method returns
<a name="650"></a>     *   nil, it means that the string has been fully handled and that
<a name="651"></a>     *   further parsing of the same string is not desired.  
<a name="652"></a>     */
<a name="653"></a>    doParsing(str, which)
<a name="654"></a>    {
<a name="655"></a>        /* return the original string unchanged */
<a name="656"></a>        return str;
<a name="657"></a>    }
<a name="658"></a>
<a name="659"></a>    /* 
<a name="660"></a>     *   construction - when we dynamically create a preparser, register
<a name="661"></a>     *   it by default
<a name="662"></a>     */
<a name="663"></a>    construct()
<a name="664"></a>    {
<a name="665"></a>        /* register the preparser */
<a name="666"></a>        StringPreParser.registerPreParser(self);
<a name="667"></a>    }
<a name="668"></a>
<a name="669"></a>    /* run pre-initialization */
<a name="670"></a>    execute()
<a name="671"></a>    {
<a name="672"></a>        /* register the preparser if it's not already registered */
<a name="673"></a>        StringPreParser.registerPreParser(self);
<a name="674"></a>    }
<a name="675"></a>
<a name="676"></a>    /* register a preparser */
<a name="677"></a>    registerPreParser(pp)
<a name="678"></a>    {
<a name="679"></a>        /* if the preparser isn't already in our list, add it */
<a name="680"></a>        if (regList.indexOf(pp) == nil)
<a name="681"></a>        {
<a name="682"></a>            /* append this new item to the list */
<a name="683"></a>            regList.append(pp);
<a name="684"></a>
<a name="685"></a>            /* the list is no longer sorted */
<a name="686"></a>            regListSorted = nil;
<a name="687"></a>        }
<a name="688"></a>    }
<a name="689"></a>
<a name="690"></a>    /*
<a name="691"></a>     *   Class method - Run all preparsers.  Returns the result of
<a name="692"></a>     *   successively calling each preparser on the given string.  
<a name="693"></a>     */
<a name="694"></a>    runAll(str, which)
<a name="695"></a>    {
<a name="696"></a>        /* 
<a name="697"></a>         *   if the list of preparsers isn't sorted, sort it in ascending
<a name="698"></a>         *   order of execution order number
<a name="699"></a>         */
<a name="700"></a>        if (!regListSorted)
<a name="701"></a>        {
<a name="702"></a>            /* sort the list */
<a name="703"></a>            regList.sort(SortAsc, {x, y: x.runOrder - y.runOrder});
<a name="704"></a>            
<a name="705"></a>            /* the list is now sorted */
<a name="706"></a>            regListSorted = true;
<a name="707"></a>        }
<a name="708"></a>
<a name="709"></a>        /* run each preparser */
<a name="710"></a>        foreach (local cur in regList)
<a name="711"></a>        {
<a name="712"></a>            /* run this preparser, provided it's active */
<a name="713"></a>            if(cur.isActive)
<a name="714"></a>                str = cur.doParsing(str, which);
<a name="715"></a>
<a name="716"></a>            /* 
<a name="717"></a>             *   if the result is nil, it means that the string has been
<a name="718"></a>             *   fully handled, so we need not run any further preparsing 
<a name="719"></a>             */
<a name="720"></a>            if (str == nil)
<a name="721"></a>                return nil;
<a name="722"></a>        }
<a name="723"></a>
<a name="724"></a>        /* return the result of the series of preparsing steps */
<a name="725"></a>        return str;
<a name="726"></a>    }
<a name="727"></a>
<a name="728"></a>    /* class property containing the list of registered parsers */
<a name="729"></a>    regList = static new Vector(10)
<a name="730"></a>
<a name="731"></a>    /* class property - the registration list has been sorted */
<a name="732"></a>    regListSorted = nil
<a name="733"></a>    
<a name="734"></a>    /* Flag, is this PreParser active? */
<a name="735"></a>    isActive = true
<a name="736"></a>;
<a name="737"></a>
<a name="738"></a>/* ------------------------------------------------------------------------ */
<a name="739"></a>/*
<a name="740"></a> *   The "comment" pre-parser.  If the command line starts with a special
<a name="741"></a> *   prefix string (by default, "*", but this can be changed via our
<a name="742"></a> *   commentPrefix property), this pre-parser intercepts the command,
<a name="743"></a> *   treating it as a comment from the player and otherwise ignoring the
<a name="744"></a> *   entire input line.  The main purpose is to give players a way to put
<a name="745"></a> *   comments into recorded transcripts, as notes to themselves when later
<a name="746"></a> *   reviewing the transcripts or as notes to the author when submitting
<a name="747"></a> *   play-testing feedback.  
<a name="748"></a> */
<a name="749"></a>commentPreParser: StringPreParser
<a name="750"></a>    doParsing(str, which)
<a name="751"></a>    {
<a name="752"></a>        /* get the amount of leading whitespace, so we can ignore it */
<a name="753"></a>        local sp = rexMatch(leadPat, str);
<a name="754"></a>        
<a name="755"></a>        /* 
<a name="756"></a>         *   if the command line starts with the comment prefix, treat it
<a name="757"></a>         *   as a comment 
<a name="758"></a>         */
<a name="759"></a>        if (str.substr(sp + 1, commentPrefix.length()) == commentPrefix)
<a name="760"></a>        {
<a name="761"></a>            /*
<a name="762"></a>             *   It's a comment.
<a name="763"></a>             *   
<a name="764"></a>             *   If a transcript is being recorded, simply acknowledge the
<a name="765"></a>             *   comment; if not, acknowledge it, but with a warning that
<a name="766"></a>             *   the comment isn't being saved anywhere 
<a name="767"></a>             */
<a name="768"></a>            if (scriptStatus.scriptFile != nil)
<a name="769"></a>                DMsg(note with script, 'Comment recorded. ');
<a name="770"></a>            else if (warningCount++ == 0)
<a name="771"></a>                DMsg(note without script warning, 'Comment NOT recorded. ');
<a name="772"></a>            else
<a name="773"></a>                DMsg(note without script, 'Comment NOT recorded. ');
<a name="774"></a>
<a name="775"></a>            /* 
<a name="776"></a>             *   Otherwise completely ignore the command line.  To do this,
<a name="777"></a>             *   simply return nil: this tells the parser that the command
<a name="778"></a>             *   has been fully handled by the preparser. 
<a name="779"></a>             */
<a name="780"></a>            return nil;
<a name="781"></a>        }
<a name="782"></a>        else
<a name="783"></a>        {
<a name="784"></a>            /* it's not a command - return the string unchanged */
<a name="785"></a>            return str;
<a name="786"></a>        }
<a name="787"></a>    }
<a name="788"></a>
<a name="789"></a>    /* 
<a name="790"></a>     *   The comment prefix.  You can change this to any character, or to
<a name="791"></a>     *   any sequence of characters (longer sequences, such as '//', will
<a name="792"></a>     *   work fine).  If a command line starts with this exact string (or
<a name="793"></a>     *   starts with whitespace followed by this string), we'll consider
<a name="794"></a>     *   the line to be a comment.  
<a name="795"></a>     */
<a name="796"></a>    commentPrefix = '*'
<a name="797"></a>    
<a name="798"></a>    /* 
<a name="799"></a>     *   The leading-whitespace pattern.  We skip any text that matches
<a name="800"></a>     *   this pattern at the start of a command line before looking for the
<a name="801"></a>     *   comment prefix.
<a name="802"></a>     *   
<a name="803"></a>     *   If you don't want to allow leading whitespace before the comment
<a name="804"></a>     *   prefix, you can simply change this to '' - a pattern consisting of
<a name="805"></a>     *   an empty string always matches zero characters, so it will prevent
<a name="806"></a>     *   us from skipping any leading charactres in the player's input.  
<a name="807"></a>     */
<a name="808"></a>    leadPat = static new RexPattern('&lt;space&gt;*')
<a name="809"></a>
<a name="810"></a>    /* warning count for entering comments without SCRIPT in effect */
<a name="811"></a>    warningCount = 0
<a name="812"></a>
<a name="813"></a>    /*
<a name="814"></a>     *   Use a lower execution order than the default, so that we run
<a name="815"></a>     *   before most other pre-parsers.  Most other pre-parsers are written
<a name="816"></a>     *   to handle actual commands, so it's usually just a waste of time to
<a name="817"></a>     *   have them look at comments at all - and can occasionally be
<a name="818"></a>     *   problematic, since the free-form text of a comment could confuse a
<a name="819"></a>     *   pre-parser that's expecting a more conventional command format.
<a name="820"></a>     *   When the comment pre-parser detects a comment, it halts any
<a name="821"></a>     *   further processing of the command - so by running ahead of other
<a name="822"></a>     *   pre-parsers, we'll effectively bypass other pre-parsers when we
<a name="823"></a>     *   detect a comment.  
<a name="824"></a>     */
<a name="825"></a>    runOrder = 50
<a name="826"></a>;
<a name="827"></a>
<a name="828"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 07/01/2025 from adv3Lite version 2.1.1.8</div>
</body>
</html>

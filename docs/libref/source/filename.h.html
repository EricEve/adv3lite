<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>filename.h</title></head><body>
<table class=ban><tr><td><h1>filename.h</h1><td align=right><a href="../file/filename.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   Copyright (c) 2001, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This header defines the FileName intrinsic class.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>
<a name="13"></a>/* include our base class definition */
<a name="14"></a>#include "systype.h"
<a name="15"></a>
<a name="16"></a>/* if we're using FileName objects, we probably want File objects as well */
<a name="17"></a>#include "file.h"
<a name="18"></a>
<a name="19"></a>
<a name="20"></a>/* ------------------------------------------------------------------------ */
<a name="21"></a>/*
<a name="22"></a> *   A FileName represents the name of a file in the local operating
<a name="23"></a> *   system.  The File object methods that take filename specifications
<a name="24"></a> *   accept FileName objects as well as ordinary strings.
<a name="25"></a> *   
<a name="26"></a> *   It's easier to write portable code if you manipulate filenames using
<a name="27"></a> *   the FileName class rather than using ordinary strings.  TADS runs on
<a name="28"></a> *   several different operating systems with differing syntax rules for
<a name="29"></a> *   constructing file names and directory paths.  The FileName class
<a name="30"></a> *   handles the different rules that apply on each system.
<a name="31"></a> *   
<a name="32"></a> *   Construction:
<a name="33"></a> *   
<a name="34"></a> *.    new FileName() - creates a FileName object representing the working
<a name="35"></a> *.            directory (e.g., '.' on Unix or Windows)
<a name="36"></a> *   
<a name="37"></a> *.    new FileName(str) - creates a FileName from a string 'str' giving a
<a name="38"></a> *.            file path in local filename syntax.
<a name="39"></a> *   
<a name="40"></a> *.    new FileName(path, name) - creates a FileName from a path and
<a name="41"></a> *.            a file name.  'path' and 'name' can each be a FileName
<a name="42"></a> *.            object or a string using local filename syntax.  The
<a name="43"></a> *.            new object represents the combined path
<a name="44"></a> *   
<a name="45"></a> *.    new FileName(specialID) - creates a FileName from one of the special
<a name="46"></a> *.            file identifiers defined in file.h.
<a name="47"></a> *   
<a name="48"></a> *   You can also use the fromUniversal() static method, which creates a
<a name="49"></a> *   FileName from a path in universal (URL-style) notation.
<a name="50"></a> *   
<a name="51"></a> *   String conversions: using a FileName object in a context where a
<a name="52"></a> *   string is required (such as displaying it) automatically converts the
<a name="53"></a> *   object to a string giving the local file name path.
<a name="54"></a> *   
<a name="55"></a> *   Operators:
<a name="56"></a> *   
<a name="57"></a> *.    FileName + string  =&gt; yields a new FileName object combining
<a name="58"></a> *.            the path given by FileName and the string naming a file,
<a name="59"></a> *.            in local naming conventions.
<a name="60"></a> *   
<a name="61"></a> *.    FileName + FileName  =&gt; yields a new FileName object combining
<a name="62"></a> *.            the two names, treating the first as a directory path.
<a name="63"></a> *   
<a name="64"></a> *.    FileName == string (or !=) OR
<a name="65"></a> *.    FileName == FileName 
<a name="66"></a> *.            Compares the FileName to the string or other filename path.
<a name="67"></a> *.            This does a superficial comparison of the path contents,
<a name="68"></a> *.            without attempting to correlate the path to the actual file
<a name="69"></a> *.            system layout.  For example, it doesn't resolve symbolic
<a name="70"></a> *.            links on Unix or apply working directories to local paths.
<a name="71"></a> */
<a name="72"></a>intrinsic class FileName 'filename/030000' : Object
<a name="73"></a>{
<a name="74"></a>    /*
<a name="75"></a>     *   Get the filename.  This returns a string with the filename this
<a name="76"></a>     *   object represents, in the local syntax used by the host operating
<a name="77"></a>     *   system, including the path and base filename portions.  (This is
<a name="78"></a>     *   the same string returned for toString(self), and the same string
<a name="79"></a>     *   used if the filename is displayed as though it were a string, such
<a name="80"></a>     *   as with "&lt;&lt; &gt;&gt;".)
<a name="81"></a>     */
<a name="82"></a>    getName();
<a name="83"></a>
<a name="84"></a>    /* 
<a name="85"></a>     *   Get the base filename portion, without the path.  This returns a
<a name="86"></a>     *   string giving the filename without any directory location
<a name="87"></a>     *   information; for a Unix-style path or Windows-style path, this is
<a name="88"></a>     *   simply the last element of the path.
<a name="89"></a>     */
<a name="90"></a>    getBaseName();
<a name="91"></a>
<a name="92"></a>    /* 
<a name="93"></a>     *   Get the path portion name, without the file name.  This returns a
<a name="94"></a>     *   FileName object containing the path portion of the file name, with
<a name="95"></a>     *   the last path element removed.  If the path only contains one path
<a name="96"></a>     *   element (so it contains only a file name, not a directory path),
<a name="97"></a>     *   this returns nil.
<a name="98"></a>     */
<a name="99"></a>    getPath();
<a name="100"></a>
<a name="101"></a>    /*
<a name="102"></a>     *   Create a new FileName object from a path in universal URL-style
<a name="103"></a>     *   syntax.  Path elements are separated with "/" characters.  The
<a name="104"></a>     *   universal path syntax is converted to the local path notation for
<a name="105"></a>     *   the new FileName object.
<a name="106"></a>     */
<a name="107"></a>    static fromUniversal(path);
<a name="108"></a>
<a name="109"></a>    /* 
<a name="110"></a>     *   Get the universal URL-style notation for this file name.  Returns
<a name="111"></a>     *   a string giving the universal notation for the file name
<a name="112"></a>     *   (including any path portion).
<a name="113"></a>     */
<a name="114"></a>    toUniversal();
<a name="115"></a>
<a name="116"></a>    /* 
<a name="117"></a>     *   Add a path element (a string or FileName object) to the end of
<a name="118"></a>     *   this filename, yielding a new FileName object with the combined
<a name="119"></a>     *   path.  Uses the correct local syntax to combine the path elements.
<a name="120"></a>     *   This yields the same results as FileName + element.
<a name="121"></a>     *   
<a name="122"></a>     *   The new FileName object is in canonical form, meaning that any
<a name="123"></a>     *   internal relative path elements (e.g., Unix "." and "..") are
<a name="124"></a>     *   processed by combining them with adjacent elements as appropriate.
<a name="125"></a>     *   For example, adding ".." to the Unix path "a/b/c" yields "a/b".
<a name="126"></a>     */
<a name="127"></a>    addToPath(element);
<a name="128"></a>
<a name="129"></a>    /* 
<a name="130"></a>     *   Is this an absolute path on the local system?  An absolute path is
<a name="131"></a>     *   one that contains a root folder specification, such as a Unix path
<a name="132"></a>     *   starting with "/", Windows path starting with "C:\", or a Windows
<a name="133"></a>     *   UNC name such as "\\SERVER\SHARE".
<a name="134"></a>     *   
<a name="135"></a>     *   Note that a Windows path can start with a drive letter without
<a name="136"></a>     *   being absolute, as in "C:path\file" (that's relative to the
<a name="137"></a>     *   working folder on the C: drive), and can start with a backslash
<a name="138"></a>     *   without being absolute, as in "\path\file" (that's relative to the
<a name="139"></a>     *   working drive letter).  Similar subtleties might apply to other
<a name="140"></a>     *   systems; this routine figures it out using local conventions.
<a name="141"></a>     */
<a name="142"></a>    isAbsolute();
<a name="143"></a>
<a name="144"></a>    /* 
<a name="145"></a>     *   Get a FileName giving the absolute path to this file.  This
<a name="146"></a>     *   applies the current working directory and/or volume (e.g., drive
<a name="147"></a>     *   letter on Windows) to produce the full path in absolute notation,
<a name="148"></a>     *   using the appropriate syntax for the local operating system.  If
<a name="149"></a>     *   the name is already in absolute format, the result will usually be
<a name="150"></a>     *   unchanged, although the exact syntax might be modified on some
<a name="151"></a>     *   systems to change the name to a more canonical format.
<a name="152"></a>     *   
<a name="153"></a>     *   If it's not possible to convert the filename into an absolute
<a name="154"></a>     *   path, returns nil.  
<a name="155"></a>     */
<a name="156"></a>    getAbsolutePath();
<a name="157"></a>
<a name="158"></a>    /*
<a name="159"></a>     *   Get the list of root directories on the local system.  Returns a
<a name="160"></a>     *   list of FileName objects representing the root directories.  The
<a name="161"></a>     *   list only includes roots that are accessible under the file safety
<a name="162"></a>     *   settings for getFileInfo(); note that other operations, such as
<a name="163"></a>     *   listing the directory contents, might not be allowed even if the
<a name="164"></a>     *   metdata are accessible.
<a name="165"></a>     *   
<a name="166"></a>     *   Most Unix-like systems only have one root directory, usually
<a name="167"></a>     *   called '/'.  Many other systems have a separate root directory for
<a name="168"></a>     *   each volume or device; for example, Windows has a root folder for
<a name="169"></a>     *   each drive letter, so the root list might contain paths like C:\,
<a name="170"></a>     *   D:\, etc.  Some systems have no concept of a root directory at
<a name="171"></a>     *   all, in which case the result will be an empty list; this is the
<a name="172"></a>     *   case for the network storage server.
<a name="173"></a>     */
<a name="174"></a>    static getRootDirs();
<a name="175"></a>
<a name="176"></a>   /*   
<a name="177"></a>    *   Get the type of the file.  If the file named by this object exists,
<a name="178"></a>    *   returns an integer with a bitwise combination of FileTypeXxx values
<a name="179"></a>    *   indicating the type of the file.  If the file doesn't exist, or
<a name="180"></a>    *   can't be accessed due to file system permissions or some other
<a name="181"></a>    *   operating system error, the return value is nil.  Note that it's
<a name="182"></a>    *   also possible for the return value to be zero, which means
<a name="183"></a>    *   something different from nil: zero means that the file exists, but
<a name="184"></a>    *   it doesn't fit any of the FileTypeXxx classifications.
<a name="185"></a>    *   
<a name="186"></a>    *   If the file is a symbolic link, the method's behavior depends on
<a name="187"></a>    *   'asLink'.  A symbolic link is a special type of file supported on
<a name="188"></a>    *   some operating systems that serves as a pointer or proxy for
<a name="189"></a>    *   another file.  If the file is a link, and 'asLink' is omitted or
<a name="190"></a>    *   nil, the method returns information on the target of the link; this
<a name="191"></a>    *   is the default because symbolic links in generally act as
<a name="192"></a>    *   transparent proxies for their targets, so for most purposes a
<a name="193"></a>    *   caller should be interested in the target file's metadata.
<a name="194"></a>    *   However, a symbolic link also has a separate identity of its own as
<a name="195"></a>    *   a link, so callers might sometimes be interested in the metadata
<a name="196"></a>    *   for the link rather than its target.  To get information on the
<a name="197"></a>    *   link itself, set 'asLink' to true.  'asLink' has no effect for
<a name="198"></a>    *   ordinary non-link files, and also has no effect for "hard" links on
<a name="199"></a>    *   systems that support those as well.
<a name="200"></a>    *   
<a name="201"></a>    *   Most of the FileTypeXxx bits are mutually exclusive, but it's
<a name="202"></a>    *   possible that more than one bit will be set, so test using '&amp;'
<a name="203"></a>    *   (e.g., (f.getFileType() &amp; FileTypeDir)).
<a name="204"></a>    *   
<a name="205"></a>    *   The file safety settings must allow read access to the file.
<a name="206"></a>    */
<a name="207"></a>    getFileType(followLinks?);
<a name="208"></a>
<a name="209"></a>    /*
<a name="210"></a>     *   Get extended information on the file named by this object.  This
<a name="211"></a>     *   retrieves the size of the file, timestamps, and the file's type,
<a name="212"></a>     *   and returns the information as a FileInfo object (see file.t).  If
<a name="213"></a>     *   the file doesn't exist, or can't be accessed for some other reason
<a name="214"></a>     *   at the operating system level, returns nil.
<a name="215"></a>     *   
<a name="216"></a>     *   'asLink' has the same meaning as in getFileType(), and has no
<a name="217"></a>     *   effect at all unless the file named is a symbolic link.
<a name="218"></a>     *   
<a name="219"></a>     *   The file safety settings must allow read access to the file.
<a name="220"></a>     */
<a name="221"></a>    getFileInfo(followLinks?);
<a name="222"></a>
<a name="223"></a>    /* 
<a name="224"></a>     *   Delete the disk file named by this object.  The file safety level
<a name="225"></a>     *   must allow write access to the file; a file safety exception is
<a name="226"></a>     *   thrown if not. 
<a name="227"></a>     */
<a name="228"></a>    deleteFile();
<a name="229"></a>
<a name="230"></a>    /*
<a name="231"></a>     *   Rename or move the file.  This changes the name and/or file path
<a name="232"></a>     *   location of the file named by 'self' to the given new path, which
<a name="233"></a>     *   can be a string giving a filename in local path notation, or a
<a name="234"></a>     *   FileName object with the new name.  The file safety settings must
<a name="235"></a>     *   allow write access to both the original file and the new file.
<a name="236"></a>     *   The new file must not already exist.
<a name="237"></a>     */
<a name="238"></a>    renameFile(newname);
<a name="239"></a>
<a name="240"></a>    /*
<a name="241"></a>     *   Get a list of files in the directory named by this object.  Returns
<a name="242"></a>     *   a list of FileName objects giving the names of the files.
<a name="243"></a>     *   
<a name="244"></a>     *   The file safety settings must allow read access to the directory's
<a name="245"></a>     *   contents.
<a name="246"></a>     *   
<a name="247"></a>     *   On systems where the file system has special directory entries for
<a name="248"></a>     *   relative links, such as "." and ".." on Windows and Unix-likes, the
<a name="249"></a>     *   listing that this method returns will include entries for those
<a name="250"></a>     *   relative links.  Be careful with these when performing recursive
<a name="251"></a>     *   directory traversals, since recursing into "." or ".." would cause
<a name="252"></a>     *   an infinite loop.  You can test an entry in the returned list to see
<a name="253"></a>     *   if it's one of these special links by calling its getFileInfo()
<a name="254"></a>     *   method, and testing the specialLink property of the returned
<a name="255"></a>     *   information object.  Not that if you're performing a recursive
<a name="256"></a>     *   directory traversal, it might be easier to use forEachFile() with
<a name="257"></a>     *   the 'recurse' argument flag set to true.
<a name="258"></a>     */
<a name="259"></a>    listDir();
<a name="260"></a>
<a name="261"></a>    /*
<a name="262"></a>     *   Invoke a callback for each file in the directory named by this
<a name="263"></a>     *   object.  'func' is a callback function; for each file in the
<a name="264"></a>     *   directory, this is invoked as func(f), where 'f' is a FileName
<a name="265"></a>     *   object describing the file.  If 'recursive' is true, the method
<a name="266"></a>     *   recursively scans the contents of subdirectories; if 'recursive'
<a name="267"></a>     *   is nil or is omitted, only the direct contents of the directory
<a name="268"></a>     *   are scanned.
<a name="269"></a>     */
<a name="270"></a>    forEachFile(func, recursive?);
<a name="271"></a>
<a name="272"></a>    /* 
<a name="273"></a>     *   Create a directory with the name contained in this object.  The
<a name="274"></a>     *   file safety settings must allow write access to the parent folder.
<a name="275"></a>     *   
<a name="276"></a>     *   If 'createParents' is specified, it's a true or nil value
<a name="277"></a>     *   specifying whether or not to create intermediate parent
<a name="278"></a>     *   directories.  The default is nil if it's omitted.  If it's true,
<a name="279"></a>     *   and 'dirname' contains multiple path elements, any parents of the
<a name="280"></a>     *   named directory that don't already exist will be created as well.
<a name="281"></a>     *   For example, on Linux, if dirname is '/a/b/c', and directory '/a'
<a name="282"></a>     *   exists but not '/a/b', the routine will first create '/a/b' and
<a name="283"></a>     *   then create '/a/b/c'.
<a name="284"></a>     */
<a name="285"></a>    createDirectory(createParents?);
<a name="286"></a>
<a name="287"></a>    /* 
<a name="288"></a>     *   Remove the directory named by this object.  The file safety settings
<a name="289"></a>     *   must allow write access to the directory.
<a name="290"></a>     *   
<a name="291"></a>     *   If 'removeContents' is provided, it's a true or nil value specifying
<a name="292"></a>     *   whether or not to delete the contents of the directory before
<a name="293"></a>     *   deleting the directory itself.  If this is true, and the directory
<a name="294"></a>     *   contains any files or subdirectories, the routine will attempt to
<a name="295"></a>     *   delete those contents before deleting the directory itself.  Any
<a name="296"></a>     *   subdirectories will be recursively emptied and removed.  For obvious
<a name="297"></a>     *   reasons, use caution when using this flag.  If any of the contents
<a name="298"></a>     *   can't be deleted, the function will stop and throw an error.  Note
<a name="299"></a>     *   that if this occurs, the function might have successfully deleted
<a name="300"></a>     *   some of the contents of the directory before encountering the error;
<a name="301"></a>     *   those deletions won't be undone.
<a name="302"></a>     *   
<a name="303"></a>     *   If 'removeContents' is omitted or nil, and the directory isn't
<a name="304"></a>     *   already empty, the method simply returns nil (indicating failure)
<a name="305"></a>     *   without deleting anything.  This is the default because it helps
<a name="306"></a>     *   avoid accidentally deleting contents that the application didn't
<a name="307"></a>     *   explicitly choose to remove.  (Special system files that are always
<a name="308"></a>     *   present, such as "." and ".." on Unix, don't count when determining
<a name="309"></a>     *   if the directory is empty.)
<a name="310"></a>     */
<a name="311"></a>    removeDirectory(removeContents?);
<a name="312"></a>}
<a name="313"></a>
<a name="314"></a>
<a name="315"></a>/* ------------------------------------------------------------------------ */
<a name="316"></a>/*
<a name="317"></a> *   File type constants.  These are returned from getFileType(), and from
<a name="318"></a> *   getFileInfo() in the fileType property.  These are bit flags, so test
<a name="319"></a> *   for them using (fileType &amp; FileTypeXxx).
<a name="320"></a> */
<a name="321"></a>
<a name="322"></a>/* ordinary file (on disk or similar storage device) */
<a name="323"></a>#define FileTypeFile   0x0001
<a name="324"></a>
<a name="325"></a>/* directory (folder) */
<a name="326"></a>#define FileTypeDir    0x0002
<a name="327"></a>
<a name="328"></a>/* character-mode device (e.g., console) */
<a name="329"></a>#define FileTypeChar   0x0004
<a name="330"></a>
<a name="331"></a>/* block-mode device (e.g., Linux raw disk device) */
<a name="332"></a>#define FileTypeBlock  0x0008
<a name="333"></a>
<a name="334"></a>/* pipe (sometimes called a FIFO) or similar interprocess channel */
<a name="335"></a>#define FileTypePipe   0x0010
<a name="336"></a>
<a name="337"></a>/* network socket */
<a name="338"></a>#define FileTypeSocket 0x0020
<a name="339"></a>
<a name="340"></a>/* symbolic link (a filename that links to another file or directory) */
<a name="341"></a>#define FileTypeLink   0x0040
<a name="342"></a>
<a name="343"></a>/* special system-defined directory link to self (such as Unix ".") */
<a name="344"></a>#define FileTypeSelfLink    0x0080
<a name="345"></a>
<a name="346"></a>/* special system-defined parent directory link (such as Unix "..") */
<a name="347"></a>#define FileTypeParentLink  0x0100
<a name="348"></a>
<a name="349"></a>
<a name="350"></a>
<a name="351"></a>/* ------------------------------------------------------------------------ */
<a name="352"></a>/*
<a name="353"></a> *   File attribute constants.  These are returned from getFileInfo() in the
<a name="354"></a> *   fileAttrs property.  These are bit flags, so test for them using
<a name="355"></a> *   (fileAttrs &amp; FileAttrXxx).
<a name="356"></a> */
<a name="357"></a>
<a name="358"></a>/* 
<a name="359"></a> *   Hidden file.  When this attribute is set, the file should be omitted
<a name="360"></a> *   from default views in the user interface and from wildcard matches in
<a name="361"></a> *   user commands (e.g., "rm *").  On some systems, a naming convention is
<a name="362"></a> *   used to mark files as hidden, such as ".xxx" files on Unix; on other
<a name="363"></a> *   systems, there's formal file system metadata corresponding to this
<a name="364"></a> *   attribute, such as on Windows.  Note that actually hiding files marked
<a name="365"></a> *   as hidden is up to the user interface; at a programmatic level, hidden
<a name="366"></a> *   files are treated the same as any other file, and in particular they're
<a name="367"></a> *   included in listDir() results.  It's up to the caller to decide whether
<a name="368"></a> *   or not to filter hidden files out of listDir() results, and if so to do
<a name="369"></a> *   the filtering.  The hidden attribute isn't enforced as a security or
<a name="370"></a> *   permissions mechanism in the file system; it doesn't prevent a user from
<a name="371"></a> *   explicitly viewing or deleting a file.  It's merely designed as a
<a name="372"></a> *   convenience for the user, to reduce clutter in normal directory listings
<a name="373"></a> *   by filtering out system or application files (such as preference files,
<a name="374"></a> *   caches, or indices) that the user doesn't normally access directly.
<a name="375"></a> */
<a name="376"></a>#define FileAttrHidden 0x0001
<a name="377"></a>
<a name="378"></a>/*
<a name="379"></a> *   System file.  This is a file system attribute on some systems (notably
<a name="380"></a> *   Windows) that marks a file as belonging to or being part of the
<a name="381"></a> *   operating system.  For practical purposes, system files should be
<a name="382"></a> *   treated the same as hidden files; the only reason we distinguish
<a name="383"></a> *   "system" as a separate attribute from "hidden" is to allow applications
<a name="384"></a> *   to display the two attributes separately when presenting file
<a name="385"></a> *   information to the user, who might expect to see both attributes on
<a name="386"></a> *   systems where both exist.  There's no equivalent of this attribute on
<a name="387"></a> *   most systems other than DOS and Windows; it won't ever appear in a
<a name="388"></a> *   file's attributes on systems where there's no equivalent.
<a name="389"></a> */
<a name="390"></a>#define FileAttrSystem 0x0002
<a name="391"></a>
<a name="392"></a>/*
<a name="393"></a> *   The file is readable by the current process.  If this is set, it means
<a name="394"></a> *   that the program has the necessary ownership and access privileges to
<a name="395"></a> *   read the file.  It's not guaranteed that a given attempt to read the
<a name="396"></a> *   file will actually succeed, since other conditions could arise, such as
<a name="397"></a> *   physical media errors or locking by another process that prevents
<a name="398"></a> *   concurrent access.
<a name="399"></a> */
<a name="400"></a>#define FileAttrRead   0x0004
<a name="401"></a>
<a name="402"></a>/*
<a name="403"></a> *   The file is writable by the current process.  If this is set, it means
<a name="404"></a> *   that the program has the necessary ownership and access privileges to
<a name="405"></a> *   write to the file.  It's not guaranteed that a given attempt to write to
<a name="406"></a> *   the file will actually succeed, since other conditions could arise, such
<a name="407"></a> *   as insufficient disk space, physical media errors, or locking by another
<a name="408"></a> *   process that prevents concurrent access.
<a name="409"></a> */
<a name="410"></a>#define FileAttrWrite  0x0008
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 08/12/2025 from adv3Lite version 2.2.2</div>
</body>
</html>

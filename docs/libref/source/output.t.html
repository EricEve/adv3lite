<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>output.t</title></head><body>
<table class=ban><tr><td><h1>output.t</h1><td align=right><a href="../file/output.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   ***************************************************************************
<a name="6"></a> *   output.t
<a name="7"></a> *
<a name="8"></a> *   This module forms part of the adv3Lite library (c) 2012-24 Eric Eve, based
<a name="9"></a> *   heavily in parts on the equivalent code in adv3 (c) Micheal J. Roberts.
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>/* ------------------------------------------------------------------------ */
<a name="13"></a>/*
<a name="14"></a> *   The standard library output function.  We set this up as the default
<a name="15"></a> *   display function (for double-quoted strings and for "&lt;&lt; &gt;&gt;"
<a name="16"></a> *   embeddings).  Code can also call this directly to display items.  
<a name="17"></a> */
<a name="18"></a>say(val)
<a name="19"></a>{
<a name="20"></a>    /* 
<a name="21"></a>     *   Use the dmsg() function to pass a string value through the message substitution parameter
<a name="22"></a>     *   filter and the enumTabObj to translate an enum into its string equivalent, otherwise output
<a name="23"></a>     *   the value directly.
<a name="24"></a>     */
<a name="25"></a>    switch(dataType(val))
<a name="26"></a>    {
<a name="27"></a>    case TypeSString:
<a name="28"></a>        dmsg(val);
<a name="29"></a>        break;
<a name="30"></a>    case TypeEnum:
<a name="31"></a>        local str = enumTabObj.enumTab[val];
<a name="32"></a>        if(str)
<a name="33"></a>        {
<a name="34"></a>            oSay(str);
<a name="35"></a>            break;
<a name="36"></a>        }
<a name="37"></a>        /* Otherwise deliberate fall-through */
<a name="38"></a>    default:
<a name="39"></a>        oSay(val);
<a name="40"></a>    }
<a name="41"></a>           
<a name="42"></a>           
<a name="43"></a>    
<a name="44"></a>    
<a name="45"></a>//    if(dataType(val) == TypeSString)   
<a name="46"></a>//    {       
<a name="47"></a>//        dmsg(val);           
<a name="48"></a>//    }    
<a name="49"></a>//    else
<a name="50"></a>//        oSay(val);
<a name="51"></a>//
<a name="52"></a>}
<a name="53"></a>
<a name="54"></a>/* 
<a name="55"></a> *   Send a value straight to the output stream without any further message
<a name="56"></a> *   filtering.
<a name="57"></a> */
<a name="58"></a>oSay(val)
<a name="59"></a>{    
<a name="60"></a>      outputManager.curOutputStream.writeToStream(val);
<a name="61"></a>}
<a name="62"></a>
<a name="63"></a>/* 
<a name="64"></a> *   A version of say() that avoids the cquote filter that can make havoc of
<a name="65"></a> *   some HTML strings, especially those generated by HRef (the cquote filter
<a name="66"></a> *   turns straight quotes into typographical ones, which is undesirable when
<a name="67"></a> *   straight quotes are used as part of HTML markup).
<a name="68"></a> */
<a name="69"></a>htmlSay(val)
<a name="70"></a>{
<a name="71"></a>    try
<a name="72"></a>    {
<a name="73"></a>        
<a name="74"></a>        /* Deactivate the cquote filter. */
<a name="75"></a>        cquoteOutputFilter.deactivate();
<a name="76"></a>        
<a name="77"></a>        /* Display the text */
<a name="78"></a>        oSay(val);
<a name="79"></a>    }
<a name="80"></a>    finally        
<a name="81"></a>    {
<a name="82"></a>        /* reactivate the cquote filter */
<a name="83"></a>        cquoteOutputFilter.activate();
<a name="84"></a>    }
<a name="85"></a>}
<a name="86"></a>
<a name="87"></a>/*  
<a name="88"></a> *   A version of say() that only produces output if the player can see obj (or,
<a name="89"></a> *   optionally, sense obj by some other sense passed as a canXXX method of the
<a name="90"></a> *   Query object via the prop parameter) */
<a name="91"></a>
<a name="92"></a>senseSay(val, obj, prop = &amp;canSee)
<a name="93"></a>{
<a name="94"></a>    if(Q.(prop)(gPlayerChar, obj))
<a name="95"></a>        say(val);    
<a name="96"></a>}
<a name="97"></a>
<a name="98"></a>
<a name="99"></a>/* ------------------------------------------------------------------------ */
<a name="100"></a>/*
<a name="101"></a> *   Generate a string for showing quoted text.  We simply enclose the
<a name="102"></a> *   text in a &lt;Q&gt;...&lt;/Q&gt; tag sequence and return the result.  
<a name="103"></a> */
<a name="104"></a>withQuotes(txt)
<a name="105"></a>{
<a name="106"></a>    return '&lt;q&gt;&lt;&lt;txt&gt;&gt;&lt;/q&gt;';
<a name="107"></a>}
<a name="108"></a>
<a name="109"></a>/* ------------------------------------------------------------------------ */
<a name="110"></a>/*
<a name="111"></a> *   Output Manager.  This object contains global code for displaying text
<a name="112"></a> *   on the console.
<a name="113"></a> *   
<a name="114"></a> *   The output manager is transient because we don't want its state to be
<a name="115"></a> *   saved and restored; the output manager state is essentially part of
<a name="116"></a> *   the intepreter user interface, which is not affected by save and
<a name="117"></a> *   restore.  
<a name="118"></a> */
<a name="119"></a>transient outputManager: object
<a name="120"></a>    /*
<a name="121"></a>     *   Switch to a new active output stream.  Returns the previously
<a name="122"></a>     *   active output stream, so that the caller can easily restore the
<a name="123"></a>     *   old output stream if the new output stream is to be established
<a name="124"></a>     *   only for a specific duration.  
<a name="125"></a>     */
<a name="126"></a>    setOutputStream(ostr)
<a name="127"></a>    {
<a name="128"></a>        local oldStr;
<a name="129"></a>
<a name="130"></a>        /* remember the old stream for a moment */
<a name="131"></a>        oldStr = curOutputStream;
<a name="132"></a>
<a name="133"></a>        /* set the new output stream */
<a name="134"></a>        curOutputStream = ostr;
<a name="135"></a>
<a name="136"></a>        /* 
<a name="137"></a>         *   return the old stream, so the caller can restore it later if
<a name="138"></a>         *   desired 
<a name="139"></a>         */
<a name="140"></a>        return oldStr;
<a name="141"></a>    }
<a name="142"></a>
<a name="143"></a>    /* 
<a name="144"></a>     *   run the given function, using the given output stream as the
<a name="145"></a>     *   active default output stream 
<a name="146"></a>     */
<a name="147"></a>    withOutputStream(ostr, func)
<a name="148"></a>    {
<a name="149"></a>        /* establish the new stream */
<a name="150"></a>        local oldStr = setOutputStream(ostr);
<a name="151"></a>
<a name="152"></a>        /* make sure we restore the old active stream on the way out */
<a name="153"></a>        try
<a name="154"></a>        {
<a name="155"></a>            /* invoke the callback */
<a name="156"></a>            (func)();
<a name="157"></a>        }
<a name="158"></a>        finally
<a name="159"></a>        {
<a name="160"></a>            /* restore the old output stream */
<a name="161"></a>            setOutputStream(oldStr);
<a name="162"></a>        }
<a name="163"></a>    }
<a name="164"></a>
<a name="165"></a>    /* the current output stream - start with the main text stream */
<a name="166"></a>    curOutputStream = mainOutputStream
<a name="167"></a>
<a name="168"></a>    /* 
<a name="169"></a>     *   Is the UI running in HTML mode?  This tells us if we have a full
<a name="170"></a>     *   HTML UI or a text-only UI.  Full HTML mode applies if we're
<a name="171"></a>     *   running on a Multimedia TADS interpreter, or we're using the Web
<a name="172"></a>     *   UI, which runs in a separate browser and is thus inherently
<a name="173"></a>     *   HTML-capable.
<a name="174"></a>     *   
<a name="175"></a>     *   (The result can't change during a session, since it's a function
<a name="176"></a>     *   of the game and interpreter capabilities, so we store the result
<a name="177"></a>     *   on the first evaluation to avoid having to recompute it on each
<a name="178"></a>     *   query.  Since 'self' is a static object, we'll recompute this each
<a name="179"></a>     *   time we run the program, which is important because we could save
<a name="180"></a>     *   the game on one interpreter and resume the session on a different
<a name="181"></a>     *   interpreter with different capabilities.)  
<a name="182"></a>     */
<a name="183"></a>    htmlMode = (self.htmlMode = checkHtmlMode())
<a name="184"></a>;
<a name="185"></a>
<a name="186"></a>/* ------------------------------------------------------------------------ */
<a name="187"></a>/*
<a name="188"></a> *   Output Stream.  This class provides a stream-oriented interface to
<a name="189"></a> *   displaying text on the console.  "Stream-oriented" means that we write
<a name="190"></a> *   text as a sequential string of characters.
<a name="191"></a> *   
<a name="192"></a> *   Output streams are always transient, since they track the system user
<a name="193"></a> *   interface in the interpreter.  The interpreter does not save its UI
<a name="194"></a> *   state with a saved position, so objects such as output streams that
<a name="195"></a> *   track the UI state should not be saved either.  
<a name="196"></a> */
<a name="197"></a>class OutputStream: PreinitObject
<a name="198"></a>    /*
<a name="199"></a>     *   Write a value to the stream.  If the value is a string, we'll
<a name="200"></a>     *   display the text of the string; if it's nil, we'll ignore it; if
<a name="201"></a>     *   it's anything else, we'll try to convert it to a string (with the
<a name="202"></a>     *   toString() function) and display the resulting text.  
<a name="203"></a>     */
<a name="204"></a>    writeToStream(val)
<a name="205"></a>    {
<a name="206"></a>        
<a name="207"></a>        /* if we have any prefix text, output it first */
<a name="208"></a>        if(prefix != nil)
<a name="209"></a>        {
<a name="210"></a>            writeFromStream(prefix);
<a name="211"></a>            prefix = nil;
<a name="212"></a>        }
<a name="213"></a>        
<a name="214"></a>        /* convert the value to a string */
<a name="215"></a>        switch(dataType(val))
<a name="216"></a>        {
<a name="217"></a>        case TypeSString:
<a name="218"></a>            /* 
<a name="219"></a>             *   it's a string - no conversion is needed, but if it's
<a name="220"></a>             *   empty, it doesn't count as real output (so don't notify
<a name="221"></a>             *   anyone, and don't set any output flags) 
<a name="222"></a>             */
<a name="223"></a>            if (val == '')
<a name="224"></a>                return;
<a name="225"></a>            break;
<a name="226"></a>            
<a name="227"></a>        case TypeNil:
<a name="228"></a>        case TypeTrue:    
<a name="229"></a>            /* nil or true - don't display anything for this */
<a name="230"></a>            return;
<a name="231"></a>            
<a name="232"></a>        case TypeInt:
<a name="233"></a>        case TypeObject:
<a name="234"></a>            /* convert integers and objects to strings */
<a name="235"></a>            val = toString(val);
<a name="236"></a>            break;
<a name="237"></a>        }
<a name="238"></a>
<a name="239"></a>        /* run it through our output filters */
<a name="240"></a>        val = applyFilters(val);
<a name="241"></a>
<a name="242"></a>        /* 
<a name="243"></a>         *   if, after filtering, we're not writing anything at all,
<a name="244"></a>         *   there's nothing left to do 
<a name="245"></a>         */
<a name="246"></a>        if (val == nil || val == '')
<a name="247"></a>            return;
<a name="248"></a>
<a name="249"></a>        /* write the text to our underlying system stream */
<a name="250"></a>        writeFromStream(val);
<a name="251"></a>    }
<a name="252"></a>
<a name="253"></a>    /*
<a name="254"></a>     *   Watch the stream for output.  It's sometimes useful to be able to
<a name="255"></a>     *   call out to some code and determine whether or not the code
<a name="256"></a>     *   generated any text output.  This routine invokes the given
<a name="257"></a>     *   callback function, monitoring the stream for output; if any
<a name="258"></a>     *   occurs, we'll return true, otherwise we'll return nil.  
<a name="259"></a>     */
<a name="260"></a>    watchForOutput(func)
<a name="261"></a>    {
<a name="262"></a>        local mon;
<a name="263"></a>        
<a name="264"></a>        /* set up a monitor filter on the stream */
<a name="265"></a>        addOutputFilter(mon = new MonitorFilter());
<a name="266"></a>
<a name="267"></a>        /* catch any exceptions so we can remove our filter before leaving */
<a name="268"></a>        try
<a name="269"></a>        {
<a name="270"></a>            /* invoke the callback */
<a name="271"></a>            (func)();
<a name="272"></a>
<a name="273"></a>            /* return the monitor's status, indicating if output occurred */
<a name="274"></a>            return mon.outputFlag;
<a name="275"></a>        }
<a name="276"></a>        
<a name="277"></a>        catch(ExitSignal ex)
<a name="278"></a>        {
<a name="279"></a>            return mon.outputFlag;
<a name="280"></a>        }
<a name="281"></a>        
<a name="282"></a>        catch(ExitActionSignal ex)
<a name="283"></a>        {
<a name="284"></a>            return mon.outputFlag;
<a name="285"></a>        }
<a name="286"></a>        
<a name="287"></a>        catch(AbortActionSignal ex)
<a name="288"></a>        {
<a name="289"></a>            return mon.outputFlag;
<a name="290"></a>        }
<a name="291"></a>        
<a name="292"></a>        catch(SkipSignal ex)
<a name="293"></a>        {
<a name="294"></a>            return mon.outputFlag ? 2 : nil;
<a name="295"></a>        }
<a name="296"></a>                
<a name="297"></a>        finally
<a name="298"></a>        {
<a name="299"></a>            /* remove our monitor filter */
<a name="300"></a>            removeOutputFilter(mon);
<a name="301"></a>        }
<a name="302"></a>    }
<a name="303"></a>
<a name="304"></a>    /*
<a name="305"></a>     *   Call the given function, capturing all text output to this stream
<a name="306"></a>     *   in the course of the function call.  Return a string containing
<a name="307"></a>     *   the captured text.  
<a name="308"></a>     */
<a name="309"></a>    captureOutput(func, [args])
<a name="310"></a>    {
<a name="311"></a>        /* install a string capture filter */
<a name="312"></a>        local filter = new StringCaptureFilter();
<a name="313"></a>        addOutputFilter(filter);
<a name="314"></a>
<a name="315"></a>        /* make sure we don't leave without removing our capturer */
<a name="316"></a>        try
<a name="317"></a>        {
<a name="318"></a>            /* invoke the function */
<a name="319"></a>            (func)(args...);
<a name="320"></a>
<a name="321"></a>            /* return the text that we captured */
<a name="322"></a>            return filter.txt_;
<a name="323"></a>        }
<a name="324"></a>                     
<a name="325"></a>        
<a name="326"></a>        finally
<a name="327"></a>        {
<a name="328"></a>            /* we're done with our filter, so remove it */
<a name="329"></a>            removeOutputFilter(filter);
<a name="330"></a>        }
<a name="331"></a>    }
<a name="332"></a>    
<a name="333"></a>    /* 
<a name="334"></a>     *   A Version of captureOutput that ignores an Exit Exception. This can be
<a name="335"></a>     *   used to attempt to retrieve the string value of an output filter that
<a name="336"></a>     *   threw an exit exeption.
<a name="337"></a>     */
<a name="338"></a>    captureOutputIgnoreExit(func, [args])    
<a name="339"></a>    {
<a name="340"></a>        /* install a string capture filter */
<a name="341"></a>        local filter = new StringCaptureFilter();
<a name="342"></a>        addOutputFilter(filter);
<a name="343"></a>
<a name="344"></a>        /* make sure we don't leave without removing our capturer */
<a name="345"></a>        try
<a name="346"></a>        {
<a name="347"></a>            /* invoke the function */
<a name="348"></a>            (func)(args...);
<a name="349"></a>
<a name="350"></a>            /* return the text that we captured */
<a name="351"></a>            return filter.txt_;
<a name="352"></a>        }
<a name="353"></a>              
<a name="354"></a>        catch(ExitSignal ex)
<a name="355"></a>        {
<a name="356"></a>            return filter.txt_;
<a name="357"></a>        }
<a name="358"></a>        
<a name="359"></a>        catch(ExitActionSignal ex)
<a name="360"></a>        {
<a name="361"></a>            return filter.txt_;
<a name="362"></a>        }
<a name="363"></a>        
<a name="364"></a>        catch(AbortActionSignal ex)
<a name="365"></a>        {
<a name="366"></a>            return filter.txt_;
<a name="367"></a>        }
<a name="368"></a>        
<a name="369"></a>        catch(SkipSignal ex)
<a name="370"></a>        {
<a name="371"></a>            return filter.txt_ = '' ? 2 : filter.txt_;
<a name="372"></a>        }
<a name="373"></a>        
<a name="374"></a>        finally
<a name="375"></a>        {
<a name="376"></a>            /* we're done with our filter, so remove it */
<a name="377"></a>            removeOutputFilter(filter);
<a name="378"></a>        }
<a name="379"></a>    }
<a name="380"></a>    
<a name="381"></a>    
<a name="382"></a>
<a name="383"></a>    /* my associated input manager, if I have one */
<a name="384"></a>    myInputManager = nil
<a name="385"></a>
<a name="386"></a>    /* dynamic construction */
<a name="387"></a>    construct()
<a name="388"></a>    {
<a name="389"></a>        /* 
<a name="390"></a>         *   Set up filter list.  Output streams are always transient, so
<a name="391"></a>         *   make our filter list transient as well.  
<a name="392"></a>         */
<a name="393"></a>        filterList_ = new transient Vector(10);
<a name="394"></a>    }
<a name="395"></a>
<a name="396"></a>    /* execute pre-initialization */
<a name="397"></a>    execute()
<a name="398"></a>    {
<a name="399"></a>        /* do the same set-up we would do for dynamic construction */
<a name="400"></a>        construct();
<a name="401"></a>    }
<a name="402"></a>
<a name="403"></a>    /*
<a name="404"></a>     *   Write text out from this stream; this writes to the lower-level
<a name="405"></a>     *   stream underlying this stream.  This routine is intended to be
<a name="406"></a>     *   called only from within this class.
<a name="407"></a>     *   
<a name="408"></a>     *   Each output stream is conceptually "stacked" on top of another,
<a name="409"></a>     *   lower-level stream.  At the bottom of the stack is usually some
<a name="410"></a>     *   kind of physical device, such as the display, or a file on disk.
<a name="411"></a>     *   
<a name="412"></a>     *   This method must be defined in each subclass to write to the
<a name="413"></a>     *   appropriate underlying stream.  Most subclasses are specifically
<a name="414"></a>     *   designed to sit atop a system-level stream, such as the display
<a name="415"></a>     *   output stream, so most implementations of this method will call
<a name="416"></a>     *   directly to a system-level output function.
<a name="417"></a>     */
<a name="418"></a>    writeFromStream(txt) { }
<a name="419"></a>
<a name="420"></a>    /* 
<a name="421"></a>     *   The list of active filters on this stream, in the order in which
<a name="422"></a>     *   they are to be called.  This should normally be initialized to a
<a name="423"></a>     *   Vector in each instance.  
<a name="424"></a>     */
<a name="425"></a>    filterList_ = []
<a name="426"></a>
<a name="427"></a>    /*
<a name="428"></a>     *   Add an output filter.  The argument is an object of class
<a name="429"></a>     *   OutputFilter, or any object implementing the filterText() method.
<a name="430"></a>     *   
<a name="431"></a>     *   Filters are always arranged in a "stack": the last output filter
<a name="432"></a>     *   added is the first one called during output.  This method thus
<a name="433"></a>     *   adds the new filter at the "top" of the stack.  
<a name="434"></a>     */
<a name="435"></a>    addOutputFilter(filter)
<a name="436"></a>    {
<a name="437"></a>        /* add the filter to the end of our list */
<a name="438"></a>        filterList_.append(filter);
<a name="439"></a>    }
<a name="440"></a>
<a name="441"></a>    /*
<a name="442"></a>     *   Add an output filter at a given point in the filter stack: add
<a name="443"></a>     *   the filter so that it is "below" the given existing filter in the
<a name="444"></a>     *   stack.  This means that the new filter will be called just after
<a name="445"></a>     *   the existing filter during output.
<a name="446"></a>     *   
<a name="447"></a>     *   If 'existingFilter' isn't in the stack of existing filters, we'll
<a name="448"></a>     *   add the new filter at the "top" of the stack.
<a name="449"></a>     */
<a name="450"></a>    addOutputFilterBelow(newFilter, existingFilter)
<a name="451"></a>    {
<a name="452"></a>        /* find the existing filter in our list */
<a name="453"></a>        local idx = filterList_.indexOf(existingFilter);
<a name="454"></a>
<a name="455"></a>        /* 
<a name="456"></a>         *   If we found the old filter, add the new filter below the
<a name="457"></a>         *   existing filter in the stack, which is to say just before the
<a name="458"></a>         *   old filter in our vector of filters (since we call the
<a name="459"></a>         *   filters in reverse order of the list).
<a name="460"></a>         *   
<a name="461"></a>         *   If we didn't find the existing filter, simply add the new
<a name="462"></a>         *   filter at the top of the stack, by appending the new filter
<a name="463"></a>         *   at the end of the list.  
<a name="464"></a>         */
<a name="465"></a>        if (idx != nil)
<a name="466"></a>            filterList_.insertAt(idx, newFilter);
<a name="467"></a>        else
<a name="468"></a>            filterList_.append(newFilter);
<a name="469"></a>    }
<a name="470"></a>
<a name="471"></a>    /*
<a name="472"></a>     *   Remove an output filter.  Since filters are arranged in a stack,
<a name="473"></a>     *   only the LAST output filter added may be removed.  It's an error
<a name="474"></a>     *   to remove a filter other than the last one.  
<a name="475"></a>     */
<a name="476"></a>    removeOutputFilter(filter)
<a name="477"></a>    {
<a name="478"></a>        /* get the filter count */
<a name="479"></a>        local len = filterList_.length();
<a name="480"></a>
<a name="481"></a>        /* make sure it's the last filter */
<a name="482"></a>        if (len == 0 || filterList_[len] != filter)
<a name="483"></a>            t3DebugTrace(T3DebugBreak);
<a name="484"></a>
<a name="485"></a>        /* remove the filter from my list */
<a name="486"></a>        filterList_.removeElementAt(len);
<a name="487"></a>    }
<a name="488"></a>
<a name="489"></a>    /* call the filters */
<a name="490"></a>    applyFilters(val)
<a name="491"></a>    {
<a name="492"></a>        /* 
<a name="493"></a>         *   Run through the list, applying each filter in turn.  We work
<a name="494"></a>         *   backwards through the list from the last element, because the
<a name="495"></a>         *   filter list is a stack: the last element added is the topmost
<a name="496"></a>         *   element of the stack, so it must be called first.  
<a name="497"></a>         */
<a name="498"></a>        for (local i in filterList_.length()..1 step -1 ; val != nil ; )
<a name="499"></a>            val = filterList_[i].filterText(self, val);
<a name="500"></a>
<a name="501"></a>        /* return the result of all of the filters */
<a name="502"></a>        return val;
<a name="503"></a>    }
<a name="504"></a>
<a name="505"></a>    /* 
<a name="506"></a>     *   Apply the current set of text transformation filters to a string.
<a name="507"></a>     *   This applies only the non-capturing filters; we skip any capture
<a name="508"></a>     *   filters.  
<a name="509"></a>     */
<a name="510"></a>    applyTextFilters(val)
<a name="511"></a>    {
<a name="512"></a>        /* run through the filter stack from top to bottom */
<a name="513"></a>        for (local i in filterList_.length()..1 step -1 ; val != nil ; )
<a name="514"></a>        {
<a name="515"></a>            /* skip capturing filters */
<a name="516"></a>            local f = filterList_[i];
<a name="517"></a>            if (f.ofKind(CaptureFilter))
<a name="518"></a>                continue;
<a name="519"></a>
<a name="520"></a>            /* apply the filter */
<a name="521"></a>            val = f.filterText(self, val);
<a name="522"></a>        }
<a name="523"></a>
<a name="524"></a>        /* return the result */
<a name="525"></a>        return val;
<a name="526"></a>    }
<a name="527"></a>        
<a name="528"></a>
<a name="529"></a>    /*
<a name="530"></a>     *   Receive notification from the input manager that we have just
<a name="531"></a>     *   ended reading a line of input from the keyboard.
<a name="532"></a>     */
<a name="533"></a>    inputLineEnd()
<a name="534"></a>    {
<a name="535"></a>        /* an input line ending doesn't look like a paragraph */
<a name="536"></a>        justDidPara = nil;
<a name="537"></a>    }
<a name="538"></a>
<a name="539"></a>    /* 
<a name="540"></a>     *   Internal state: we just wrote a paragraph break, and there has
<a name="541"></a>     *   not yet been any intervening text.  By default, we set this to
<a name="542"></a>     *   true initially, so that we suppress any paragraph breaks at the
<a name="543"></a>     *   very start of the text.  
<a name="544"></a>     */
<a name="545"></a>    justDidPara = true
<a name="546"></a>
<a name="547"></a>    /*
<a name="548"></a>     *   Internal state: we just wrote a character that suppresses
<a name="549"></a>     *   paragraph breaks that immediately follow.  In this state, we'll
<a name="550"></a>     *   suppress any paragraph marker that immediately follows, but we
<a name="551"></a>     *   won't suppress any other characters.  
<a name="552"></a>     */
<a name="553"></a>    justDidParaSuppressor = nil
<a name="554"></a>    
<a name="555"></a>    /*  Text to be output before anything else */
<a name="556"></a>    prefix = nil
<a name="557"></a>    
<a name="558"></a>    /* Set the prefix to txt */
<a name="559"></a>    setPrefix(txt)
<a name="560"></a>    {
<a name="561"></a>        prefix = txt;
<a name="562"></a>    }
<a name="563"></a>;
<a name="564"></a>
<a name="565"></a>/*
<a name="566"></a> *   The OutputStream for the main text area.
<a name="567"></a> *   
<a name="568"></a> *   This object is transient because the output stream state is
<a name="569"></a> *   effectively part of the interpreter user interface, which is not
<a name="570"></a> *   affected by save and restore.  
<a name="571"></a> */
<a name="572"></a>transient mainOutputStream: OutputStream
<a name="573"></a>    /* 
<a name="574"></a>     *   The main text area is the same place where we normally read
<a name="575"></a>     *   command lines from the keyboard, so associate this output stream
<a name="576"></a>     *   with the primary input manager. 
<a name="577"></a>     */
<a name="578"></a>    myInputManager = inputManager
<a name="579"></a>
<a name="580"></a>    /* the current command transcript */
<a name="581"></a>    curTranscript = nil
<a name="582"></a>
<a name="583"></a>    /* we sit atop the system-level main console output stream */
<a name="584"></a>    writeFromStream(txt)
<a name="585"></a>    {
<a name="586"></a>        /* write the text to the console */
<a name="587"></a>        aioSay(txt);
<a name="588"></a>    }
<a name="589"></a>;
<a name="590"></a>
<a name="591"></a>/* ------------------------------------------------------------------------ */
<a name="592"></a>/*
<a name="593"></a> *   Paragraph manager.  We filter strings as they're about to be sent to
<a name="594"></a> *   the console to convert paragraph markers (represented in the source
<a name="595"></a> *   text using the "style tag" format, &lt;.P&gt;) into a configurable display
<a name="596"></a> *   rendering.
<a name="597"></a> *   
<a name="598"></a> *   We also process the zero-spacing paragraph, &lt;.P0&gt;.  This doesn't
<a name="599"></a> *   generate any output, but otherwise acts like a paragraph break in that
<a name="600"></a> *   it suppresses any paragraph breaks that immediately follow.
<a name="601"></a> *   
<a name="602"></a> *   The special marker &lt;./P0&gt; cancels the effect of a &lt;.P0&gt;.  This can be
<a name="603"></a> *   used if you want to ensure that a newline or paragraph break is
<a name="604"></a> *   displayed, even if a &lt;.P0&gt; was just displayed.
<a name="605"></a> *   
<a name="606"></a> *   Our special processing ensures that paragraph tags interact with one
<a name="607"></a> *   another and with other display elements specially:
<a name="608"></a> *   
<a name="609"></a> *   - A run of multiple consecutive paragraph tags is treated as a single
<a name="610"></a> *   paragraph tag.  This property is particularly important because it
<a name="611"></a> *   allows code to write out a paragraph marker without having to worry
<a name="612"></a> *   about whether preceding code or following code add paragraph markers
<a name="613"></a> *   of their own; if redundant markers are found, we'll filter them out
<a name="614"></a> *   automatically.
<a name="615"></a> *   
<a name="616"></a> *   - We can suppress paragraph markers following other specific
<a name="617"></a> *   sequences.  For example, if the paragraph break is rendered as a blank
<a name="618"></a> *   line, we might want to suppress an extra blank line for a paragraph
<a name="619"></a> *   break after an explicit blank line.
<a name="620"></a> *   
<a name="621"></a> *   - We can suppress other specific sequences following a paragraph
<a name="622"></a> *   marker.  For example, if the paragraph break is rendered as a newline
<a name="623"></a> *   plus a tab, we could suppress whitespace following the paragraph
<a name="624"></a> *   break.
<a name="625"></a> *   
<a name="626"></a> *   The paragraph manager should always be instantiated with transient
<a name="627"></a> *   instances, because this object's state is effectively part of the
<a name="628"></a> *   interpreter user interface, which doesn't participate in save and
<a name="629"></a> *   restore.  
<a name="630"></a> */
<a name="631"></a>class ParagraphManager: OutputFilter
<a name="632"></a>    /* 
<a name="633"></a>     *   Rendering - this is what we display on the console to represent a
<a name="634"></a>     *   paragraph break.  By default, we'll display a blank line.  
<a name="635"></a>     */
<a name="636"></a>    renderText = '\b'
<a name="637"></a>
<a name="638"></a>    /*
<a name="639"></a>     *   Flag: show or hide paragraph breaks immediately after input.  By
<a name="640"></a>     *   default, we do not show paragraph breaks after an input line.  
<a name="641"></a>     */
<a name="642"></a>    renderAfterInput = nil
<a name="643"></a>
<a name="644"></a>    /*
<a name="645"></a>     *   Preceding suppression.  This is a regular expression that we
<a name="646"></a>     *   match to individual characters.  If the character immediately
<a name="647"></a>     *   preceding a paragraph marker matches this expression, we'll
<a name="648"></a>     *   suppress the paragraph marker in the output.  By default, we'll
<a name="649"></a>     *   suppress a paragraph break following a blank line, because the
<a name="650"></a>     *   default rendering would add a redundant blank line.  
<a name="651"></a>     */
<a name="652"></a>    suppressBefore = static new RexPattern('\b')
<a name="653"></a>
<a name="654"></a>    /*
<a name="655"></a>     *   Following suppression.  This is a regular expression that we
<a name="656"></a>     *   match to individual characters.  If the character immediately
<a name="657"></a>     *   following a paragraph marker matches this expression, we'll
<a name="658"></a>     *   suppress the character.  We'll apply this to each character
<a name="659"></a>     *   following a paragraph marker in turn until we find one that does
<a name="660"></a>     *   not match; we'll suppress all of the characters that do match.
<a name="661"></a>     *   By default, we suppress additional blank lines after a paragraph
<a name="662"></a>     *   break.  
<a name="663"></a>     */
<a name="664"></a>    suppressAfter = static new RexPattern('[\b\n]')
<a name="665"></a>
<a name="666"></a>    /* pre-compile some regular expression patterns we use a lot */
<a name="667"></a>    leadingMultiPat = static new RexPattern('(&lt;langle&gt;&lt;dot&gt;[pP]0?&lt;rangle&gt;)+')
<a name="668"></a>    leadingSinglePat = static new RexPattern(
<a name="669"></a>        '&lt;langle&gt;&lt;dot&gt;([pP]0?|/[pP]0)&lt;rangle&gt;')
<a name="670"></a>
<a name="671"></a>    /* process a string that's about to be written to the console */
<a name="672"></a>    filterText(ostr, txt)
<a name="673"></a>    {
<a name="674"></a>        local ret;
<a name="675"></a>        
<a name="676"></a>        /* we don't have anything in our translated string yet */
<a name="677"></a>        ret = '';
<a name="678"></a>
<a name="679"></a>        /* keep going until we run out of string to process */
<a name="680"></a>        while (txt != '')
<a name="681"></a>        {
<a name="682"></a>            local len;
<a name="683"></a>            local match;
<a name="684"></a>            local p0;
<a name="685"></a>            local unp0;
<a name="686"></a>            
<a name="687"></a>            /* 
<a name="688"></a>             *   if we just wrote a paragraph break, suppress any
<a name="689"></a>             *   character that matches 'suppressAfter', and suppress any
<a name="690"></a>             *   paragraph markers that immediately follow 
<a name="691"></a>             */
<a name="692"></a>            if (ostr.justDidPara)
<a name="693"></a>            {
<a name="694"></a>                /* check for any consecutive paragraph markers */
<a name="695"></a>                if ((len = rexMatch(leadingMultiPat, txt)) != nil)
<a name="696"></a>                {
<a name="697"></a>                    /* discard the consecutive &lt;.P&gt;'s, and keep going */
<a name="698"></a>                    txt = txt.substr(len + 1);
<a name="699"></a>                    continue;
<a name="700"></a>                }
<a name="701"></a>
<a name="702"></a>                /* check for a match to the suppressAfter pattern */
<a name="703"></a>                if (rexMatch(suppressAfter, txt) != nil)
<a name="704"></a>                {
<a name="705"></a>                    /* discard the suppressed character and keep going */
<a name="706"></a>                    txt = txt.substr(2);
<a name="707"></a>                    continue;
<a name="708"></a>                }
<a name="709"></a>            }
<a name="710"></a>
<a name="711"></a>            /* 
<a name="712"></a>             *   we have a character other than a paragraph marker, so we
<a name="713"></a>             *   didn't just scan a paragraph marker 
<a name="714"></a>             */
<a name="715"></a>            ostr.justDidPara = nil;
<a name="716"></a>
<a name="717"></a>            /*
<a name="718"></a>             *   if we just wrote a suppressBefore character, discard any
<a name="719"></a>             *   leading paragraph markers 
<a name="720"></a>             */
<a name="721"></a>            if (ostr.justDidParaSuppressor
<a name="722"></a>                &amp;&amp; (len = rexMatch(leadingMultiPat, txt)) != nil)
<a name="723"></a>            {
<a name="724"></a>                /* remove the paragraph markers */
<a name="725"></a>                txt = txt.substr(len + 1);
<a name="726"></a>
<a name="727"></a>                /* 
<a name="728"></a>                 *   even though we're not rendering the paragraph, note
<a name="729"></a>                 *   that a logical paragraph just started 
<a name="730"></a>                 */
<a name="731"></a>                ostr.justDidPara = true;
<a name="732"></a>
<a name="733"></a>                /* keep going */
<a name="734"></a>                continue;
<a name="735"></a>            }
<a name="736"></a>
<a name="737"></a>            /* presume we won't find a &lt;.p0&gt; or &lt;./p0&gt; */
<a name="738"></a>            p0 = unp0 = nil;
<a name="739"></a>
<a name="740"></a>            /* find the next paragraph marker */
<a name="741"></a>            match = rexSearch(leadingSinglePat, txt);
<a name="742"></a>            if (match == nil)
<a name="743"></a>            {
<a name="744"></a>                /* 
<a name="745"></a>                 *   there are no more paragraph markers - copy the
<a name="746"></a>                 *   remainder of the input string to the output
<a name="747"></a>                 */
<a name="748"></a>                ret += txt;
<a name="749"></a>                txt = '';
<a name="750"></a>
<a name="751"></a>                /* we just did something other than a paragraph */
<a name="752"></a>                ostr.justDidPara = nil;
<a name="753"></a>            }
<a name="754"></a>            else
<a name="755"></a>            {
<a name="756"></a>                /* add everything up to the paragraph break to the output */
<a name="757"></a>                ret += txt.substr(1, match[1] - 1);
<a name="758"></a>
<a name="759"></a>                /* get the rest of the string following the paragraph mark */
<a name="760"></a>                txt = txt.substr(match[1] + match[2]);
<a name="761"></a>
<a name="762"></a>                /* note if we found a &lt;.p0&gt; or &lt;./p0&gt; */
<a name="763"></a>                p0 = (match[3] is in ('&lt;.p0&gt;', '&lt;.P0&gt;'));
<a name="764"></a>                unp0 = (match[3] is in ('&lt;./p0&gt;', '&lt;./P0&gt;'));
<a name="765"></a>
<a name="766"></a>                /* 
<a name="767"></a>                 *   note that we just found a paragraph marker, unless
<a name="768"></a>                 *   this is a &lt;./p0&gt; 
<a name="769"></a>                 */
<a name="770"></a>                ostr.justDidPara = !unp0;
<a name="771"></a>            }
<a name="772"></a>
<a name="773"></a>            /* 
<a name="774"></a>             *   If the last character we copied out is a suppressBefore
<a name="775"></a>             *   character, note for next time that we have a suppressor
<a name="776"></a>             *   pending.  Likewise, if we found a &lt;.p0&gt; rather than a
<a name="777"></a>             *   &lt;.p&gt;, this counts as a suppressor.  
<a name="778"></a>             */
<a name="779"></a>            ostr.justDidParaSuppressor =
<a name="780"></a>                (p0 || rexMatch(suppressBefore,
<a name="781"></a>                                ret.substr(ret.length(), 1)) != nil);
<a name="782"></a>
<a name="783"></a>            /* 
<a name="784"></a>             *   if we found a paragraph marker, and we didn't find a
<a name="785"></a>             *   leading suppressor character just before it, add the
<a name="786"></a>             *   paragraph rendering 
<a name="787"></a>             */
<a name="788"></a>            if (ostr.justDidPara &amp;&amp; !ostr.justDidParaSuppressor)
<a name="789"></a>                ret += renderText;
<a name="790"></a>        }
<a name="791"></a>
<a name="792"></a>        /* return the translated string */
<a name="793"></a>        return ret;
<a name="794"></a>    }
<a name="795"></a>;
<a name="796"></a>
<a name="797"></a>/* the paragraph manager for the main output stream */
<a name="798"></a>transient mainParagraphManager: ParagraphManager
<a name="799"></a>;
<a name="800"></a>
<a name="801"></a>/* ------------------------------------------------------------------------ */
<a name="802"></a>/*
<a name="803"></a> *   Output Filter
<a name="804"></a> */
<a name="805"></a>class OutputFilter: object
<a name="806"></a>    /* 
<a name="807"></a>     *   Apply the filter - this should be overridden in each filter.  The
<a name="808"></a>     *   return value is the result of filtering the string.
<a name="809"></a>     *   
<a name="810"></a>     *   'ostr' is the OutputStream to which the text is being written,
<a name="811"></a>     *   and 'txt' is the original text to be displayed.  
<a name="812"></a>     */
<a name="813"></a>    filterText(ostr, txt) { return txt; }
<a name="814"></a>    
<a name="815"></a>    isActive = true
<a name="816"></a>;
<a name="817"></a>
<a name="818"></a>
<a name="819"></a>/* ------------------------------------------------------------------------ */
<a name="820"></a>/*
<a name="821"></a> *   Output monitor filter.  This is a filter that leaves the filtered
<a name="822"></a> *   text unchanged, but keeps track of whether any text was seen at all.
<a name="823"></a> *   Our 'outputFlag' is true if we've seen any output, nil if not.
<a name="824"></a> */
<a name="825"></a>class MonitorFilter: OutputFilter
<a name="826"></a>    /* filter text */
<a name="827"></a>    filterText(ostr, val)
<a name="828"></a>    {
<a name="829"></a>        /* if the value is non-empty, note the output */
<a name="830"></a>        if (val != nil &amp;&amp; val != '')
<a name="831"></a>            outputFlag = true;
<a name="832"></a>
<a name="833"></a>        /* return the input value unchanged */
<a name="834"></a>        return val;
<a name="835"></a>    }
<a name="836"></a>
<a name="837"></a>    /* flag: has any output occurred for this monitor yet? */
<a name="838"></a>    outputFlag = nil
<a name="839"></a>;
<a name="840"></a>
<a name="841"></a>
<a name="842"></a>/* ------------------------------------------------------------------------ */
<a name="843"></a>/*
<a name="844"></a> *   Capture Filter.  This is an output filter that simply captures all of
<a name="845"></a> *   the text sent through the filter, sending nothing out to the
<a name="846"></a> *   underlying stream.
<a name="847"></a> *   
<a name="848"></a> *   The default implementation simply discards the incoming text.
<a name="849"></a> *   Subclasses can keep track of the text in memory, in a file, or
<a name="850"></a> *   wherever desired.  
<a name="851"></a> */
<a name="852"></a>class CaptureFilter: OutputFilter
<a name="853"></a>    /*
<a name="854"></a>     *   Filter the text.  We simply discard the text, passing nothing
<a name="855"></a>     *   through to the underlying stream. 
<a name="856"></a>     */
<a name="857"></a>    filterText(ostr, txt)
<a name="858"></a>    {
<a name="859"></a>        /* leave nothing for the underlying stream */
<a name="860"></a>        return nil;
<a name="861"></a>    }
<a name="862"></a>;
<a name="863"></a>
<a name="864"></a>/*
<a name="865"></a> *   "Switchable" capture filter.  This filter can have its blocking
<a name="866"></a> *   enabled or disabled.  When blocking is enabled, we capture
<a name="867"></a> *   everything, leaving nothing to the underlying stream; when disabled,
<a name="868"></a> *   we pass everything through to the underyling stream unchanged.  
<a name="869"></a> */
<a name="870"></a>class SwitchableCaptureFilter: CaptureFilter
<a name="871"></a>    /* filter the text */
<a name="872"></a>    filterText(ostr, txt)
<a name="873"></a>    {
<a name="874"></a>        /* 
<a name="875"></a>         *   if we're blocking output, return nothing to the underlying
<a name="876"></a>         *   stream; if we're disabled, return the input unchanged 
<a name="877"></a>         */
<a name="878"></a>        return (isBlocking ? nil : txt);
<a name="879"></a>    }
<a name="880"></a>
<a name="881"></a>    /*
<a name="882"></a>     *   Blocking enabled: if this is true, we'll capture all text passed
<a name="883"></a>     *   through us, leaving nothing to the underyling stream.  Blocking
<a name="884"></a>     *   is enabled by default.  
<a name="885"></a>     */
<a name="886"></a>    isBlocking = true
<a name="887"></a>;
<a name="888"></a>
<a name="889"></a>/*
<a name="890"></a> *   String capturer.  This is an implementation of CaptureFilter that
<a name="891"></a> *   saves the captured text to a string.  
<a name="892"></a> */
<a name="893"></a>class StringCaptureFilter: CaptureFilter
<a name="894"></a>    /* filter text */
<a name="895"></a>    filterText(ostr, txt)
<a name="896"></a>    {        
<a name="897"></a>        /* add the text to my captured text so far */
<a name="898"></a>        addText(txt);
<a name="899"></a>    }
<a name="900"></a>
<a name="901"></a>    /* add to my captured text */
<a name="902"></a>    addText(txt)
<a name="903"></a>    {
<a name="904"></a>        /* append the text to my string of captured text */
<a name="905"></a>        txt_ += txt;
<a name="906"></a>    }
<a name="907"></a>
<a name="908"></a>    /* my captured text so far */
<a name="909"></a>    txt_ = ''
<a name="910"></a>;
<a name="911"></a>
<a name="912"></a>/* 
<a name="913"></a> *   ImplicitAction announcement filter. This is applied just before text from
<a name="914"></a> *   an action routine is output to ensure than any pending implicit action
<a name="915"></a> *   reports are output before any text from the action routine itself.
<a name="916"></a> */
<a name="917"></a>class ImplicitActionFilter: OutputFilter
<a name="918"></a>    
<a name="919"></a>    filterText(ostr, txt)    
<a name="920"></a>    {      
<a name="921"></a>        /* 
<a name="922"></a>         *   This method should never be called if we don't have a current
<a name="923"></a>         *   action, but just in case we return the text unchanged if there is
<a name="924"></a>         *   no gAction.
<a name="925"></a>         */
<a name="926"></a>//        if(gAction == nil)
<a name="927"></a>            return txt;
<a name="928"></a>        
<a name="929"></a>        /* 
<a name="930"></a>         *   If we do have have a gAction, prepend any pending implicit action
<a name="931"></a>         *   announcements to the text we output.
<a name="932"></a>         */
<a name="933"></a>//        return gAction.buildImplicitActionAnnouncement(true, !gAction.isImplicit)
<a name="934"></a>//            + txt;
<a name="935"></a>    }   
<a name="936"></a>;
<a name="937"></a>
<a name="938"></a>
<a name="939"></a>/* ------------------------------------------------------------------------ */
<a name="940"></a>/*
<a name="941"></a> *   Style tag.  This defines an HTML-like tag that can be used in output
<a name="942"></a> *   text to display an author-customizable substitution string.
<a name="943"></a> *   
<a name="944"></a> *   Each StyleTag object defines the name of the tag, which can be
<a name="945"></a> *   invoked in output text using the syntax "&lt;.name&gt;" - we require the
<a name="946"></a> *   period after the opening angle-bracket to plainly distinguish the
<a name="947"></a> *   sequence as a style tag, not a regular HTML tag.
<a name="948"></a> *   
<a name="949"></a> *   Each StyleTag also defines the text string that should be substituted
<a name="950"></a> *   for each occurrence of the "&lt;.name&gt;" sequence in output text, and,
<a name="951"></a> *   optionally, another string that is substituted for occurrences of the
<a name="952"></a> *   "closing" version of the tag, invoked with the syntax "&lt;./name&gt;".  
<a name="953"></a> */
<a name="954"></a>class StyleTag: object
<a name="955"></a>    /* name of the tag - the tag appears in source text in &lt;.xxx&gt; notation */
<a name="956"></a>    tagName = ''
<a name="957"></a>
<a name="958"></a>    /* 
<a name="959"></a>     *   opening text - this is substituted for each instance of the tag
<a name="960"></a>     *   without a '/' prefix 
<a name="961"></a>     */
<a name="962"></a>    openText = ''
<a name="963"></a>
<a name="964"></a>    /* 
<a name="965"></a>     *   Closing text - this is substituted for each instance of the tag
<a name="966"></a>     *   with a '/' prefix (&lt;./xxx&gt;).  Note that non-container tags don't
<a name="967"></a>     *   have closing text at all.  
<a name="968"></a>     */
<a name="969"></a>    closeText = ''
<a name="970"></a>;
<a name="971"></a>
<a name="972"></a>/*
<a name="973"></a> *   HtmlStyleTag - this is a subclass of StyleTag that provides different
<a name="974"></a> *   rendering depending on whether the interpreter is in HTML mode or not.
<a name="975"></a> *   In HTML mode, we display our htmlOpenText and htmlCloseText; when not
<a name="976"></a> *   in HTML mode, we display our plainOpenText and plainCloseText.
<a name="977"></a> */
<a name="978"></a>class HtmlStyleTag: StyleTag
<a name="979"></a>    openText = (outputManager.htmlMode ? htmlOpenText : plainOpenText)
<a name="980"></a>
<a name="981"></a>    closeText = (outputManager.htmlMode ? htmlCloseText : plainCloseText)
<a name="982"></a>
<a name="983"></a>    /* our HTML-mode opening and closing text */
<a name="984"></a>    htmlOpenText = ''
<a name="985"></a>    htmlCloseText = ''
<a name="986"></a>
<a name="987"></a>    /* our plain (non-HTML) opening and closing text */
<a name="988"></a>    plainOpenText = ''
<a name="989"></a>    plainCloseText = ''
<a name="990"></a>;
<a name="991"></a>
<a name="992"></a>/*
<a name="993"></a> *   Define our default style tags.  We name all of these StyleTag objects
<a name="994"></a> *   so that authors can easily change the expansion text strings at
<a name="995"></a> *   compile-time with the 'modify' syntax, or dynamically at run-time by
<a name="996"></a> *   assigning new strings to the appropriate properties of these objects.
<a name="997"></a> */
<a name="998"></a>
<a name="999"></a>/* 
<a name="1000"></a> *   &lt;.roomname&gt; - we use this to display the room's name in the
<a name="1001"></a> *   description of a room (such as in a LOOK AROUND command, or when
<a name="1002"></a> *   entering a new location).  By default, we display the room name in
<a name="1003"></a> *   boldface on a line by itself.  
<a name="1004"></a> */
<a name="1005"></a>roomnameStyleTag: StyleTag 'roomname' '\n&lt;b&gt;' '&lt;/b&gt;&lt;br&gt;\n';
<a name="1006"></a>
<a name="1007"></a>/* &lt;.roomdesc&gt; - we use this to display a room's long description */
<a name="1008"></a>roomdescStyleTag: StyleTag 'roomdesc' '' '';
<a name="1009"></a>
<a name="1010"></a>/* &lt;.roomcontents&gt; - we use this to display a room's contents */
<a name="1011"></a>roomcontentsStyleTag: StyleTag 'roomcontents' '' '';
<a name="1012"></a>
<a name="1013"></a>/* 
<a name="1014"></a> *   &lt;.roompara&gt; - we use this to separate paragraphs within a room's long
<a name="1015"></a> *   description 
<a name="1016"></a> */
<a name="1017"></a>roomparaStyleTag: StyleTag 'roompara' '&lt;.p&gt;\n';
<a name="1018"></a>
<a name="1019"></a>/* 
<a name="1020"></a> *   &lt;.inputline&gt; - we use this to display the text actually entered by the
<a name="1021"></a> *   user on a command line.  Note that this isn't used for the prompt text
<a name="1022"></a> *   - it's used only for the command-line text itself.  
<a name="1023"></a> */
<a name="1024"></a>inputlineStyleTag: HtmlStyleTag 'inputline'
<a name="1025"></a>    /* in HTML mode, switch in and out of TADS-Input font */
<a name="1026"></a>    htmlOpenText = '&lt;font face="tads-input"&gt;'
<a name="1027"></a>    htmlCloseText = '&lt;/font&gt;'
<a name="1028"></a>
<a name="1029"></a>    /* in plain mode, do nothing */
<a name="1030"></a>    plainOpenText = ''
<a name="1031"></a>    plainCloseText = ''
<a name="1032"></a>;
<a name="1033"></a>
<a name="1034"></a>/*
<a name="1035"></a> *   &lt;.a&gt; (named in analogy to the HTML &lt;a&gt; tag) - we use this to display
<a name="1036"></a> *   hyperlinked text.  Note that this goes *inside* an HTML &lt;a&gt; tag - this
<a name="1037"></a> *   doesn't do the actual linking (the true &lt;a&gt; tag does that), but rather
<a name="1038"></a> *   allows customized text formatting for hyperlinked text.  
<a name="1039"></a> */
<a name="1040"></a>hyperlinkStyleTag: HtmlStyleTag 'a'
<a name="1041"></a>;
<a name="1042"></a>
<a name="1043"></a>/* &lt;.statusroom&gt; - style for the room name in a status line */
<a name="1044"></a>statusroomStyleTag: HtmlStyleTag 'statusroom'
<a name="1045"></a>    htmlOpenText = '&lt;b&gt;'
<a name="1046"></a>    htmlCloseText = '&lt;/b&gt;'
<a name="1047"></a>;
<a name="1048"></a>
<a name="1049"></a>/* &lt;.statusscore&gt; - style for the score in a status line */
<a name="1050"></a>statusscoreStyleTag: HtmlStyleTag 'statusscore'
<a name="1051"></a>    htmlOpenText = '&lt;i&gt;'
<a name="1052"></a>    htmlCloseText = '&lt;/i&gt;'
<a name="1053"></a>;
<a name="1054"></a>
<a name="1055"></a>/* 
<a name="1056"></a> *   &lt;.parser&gt; - style for messages explicitly from the parser.
<a name="1057"></a> *   
<a name="1058"></a> *   By default, we do nothing special with these messages.  Many games
<a name="1059"></a> *   like to use a distinctive notation for parser messages, to make it
<a name="1060"></a> *   clear that the messages are "meta" text that's not part of the story
<a name="1061"></a> *   but rather specific to the game mechanics; one common convention is
<a name="1062"></a> *   to put parser messages in [square brackets].
<a name="1063"></a> *   
<a name="1064"></a> *   If the game defines a special appearance for parser messages, for
<a name="1065"></a> *   consistency it might want to use the same appearance for notification
<a name="1066"></a> *   messages displayed with the &lt;.notification&gt; tag (see
<a name="1067"></a> *   notificationStyleTag).  
<a name="1068"></a> */
<a name="1069"></a>parserStyleTag: StyleTag 'parser'
<a name="1070"></a>    openText = ''
<a name="1071"></a>    closeText = ''
<a name="1072"></a>;
<a name="1073"></a>
<a name="1074"></a>/* 
<a name="1075"></a> *   &lt;.notification&gt; - style for "notification" messages, such as score
<a name="1076"></a> *   changes and messages explaining how facilities (footnotes, exit
<a name="1077"></a> *   lists) work the first time they come up.
<a name="1078"></a> *   
<a name="1079"></a> *   By default, we'll put notifications in parentheses.  Games that use
<a name="1080"></a> *   [square brackets] for parser messages (i.e., for the &lt;.parser&gt; tag)
<a name="1081"></a> *   might want to use the same notation here for consistency.  
<a name="1082"></a> */
<a name="1083"></a>notificationStyleTag: StyleTag 'notification'
<a name="1084"></a>    openText = '('
<a name="1085"></a>    closeText = ')'
<a name="1086"></a>;
<a name="1087"></a>
<a name="1088"></a>/*
<a name="1089"></a> *   &lt;.assume&gt; - style for "assumption" messages, showing an assumption
<a name="1090"></a> *   the parser is making.  This style is used for showing objects used by
<a name="1091"></a> *   default when not specified in a command, objects that the parser
<a name="1092"></a> *   chose despite some ambiguity, and implied commands.  
<a name="1093"></a> */
<a name="1094"></a>assumeStyleTag: StyleTag 'assume'
<a name="1095"></a>    openText = '('
<a name="1096"></a>    closeText = ')'
<a name="1097"></a>;
<a name="1098"></a>
<a name="1099"></a>/*  
<a name="1100"></a> *   &lt;.tip&gt; - style for displaying the text (desc) of tips. The opening and closing tip tags are
<a name="1101"></a> *   automatically added before and after desc by the showTip() method.
<a name="1102"></a> */
<a name="1103"></a>tipStyleTag: StyleTag 'tip'
<a name="1104"></a>   openText = '('
<a name="1105"></a>   closeText = ')'    
<a name="1106"></a>;
<a name="1107"></a>
<a name="1108"></a>/*
<a name="1109"></a> *   &lt;.announceObj&gt; - style for object announcement messages.  The parser
<a name="1110"></a> *   shows an object announcement for each object when a command is applied
<a name="1111"></a> *   to multiple objects (TAKE ALL, DROP KEYS AND WALLET).  The
<a name="1112"></a> *   announcement simply shows the object's name and a colon, to let the
<a name="1113"></a> *   player know that the response text that follows applies to the
<a name="1114"></a> *   announced object.  
<a name="1115"></a> */
<a name="1116"></a>announceObjStyleTag: StyleTag 'announceObj'
<a name="1117"></a>    openText = '&lt;b&gt;'
<a name="1118"></a>    closeText = '&lt;/b&gt;'
<a name="1119"></a>;
<a name="1120"></a>
<a name="1121"></a>singleTypographicalQuoteTag: StyleTag 'sq'
<a name="1122"></a>    openText = '&amp;lsquo;'
<a name="1123"></a>    closeText = '&amp;rsquo';
<a name="1124"></a>;
<a name="1125"></a>
<a name="1126"></a>doubleTypographicalQuoteTag: StyleTag 'dq'
<a name="1127"></a>    openText = '&amp;ldquo;'
<a name="1128"></a>    closeText = '&amp;rdquo';
<a name="1129"></a>;
<a name="1130"></a>
<a name="1131"></a>
<a name="1132"></a>/* ------------------------------------------------------------------------ */
<a name="1133"></a>/*
<a name="1134"></a> *   "Style tag" filter.  This is an output filter that expands our
<a name="1135"></a> *   special style tags in output text.  
<a name="1136"></a> */
<a name="1137"></a>styleTagFilter: OutputFilter, PreinitObject
<a name="1138"></a>    /* pre-compile our frequently-used tag search pattern */
<a name="1139"></a>    tagPattern = static new RexPattern(
<a name="1140"></a>        '&lt;nocase&gt;&lt;langle&gt;%.(/?[a-z][a-z0-9]*)&lt;rangle&gt;')
<a name="1141"></a>
<a name="1142"></a>    /* filter for a style tag */
<a name="1143"></a>    filterText(ostr, val)
<a name="1144"></a>    {
<a name="1145"></a>        local idx;
<a name="1146"></a>        
<a name="1147"></a>        /* search for our special '&lt;.xxx&gt;' tags, and expand any we find */
<a name="1148"></a>        idx = rexSearch(tagPattern, val);
<a name="1149"></a>        while (idx != nil)
<a name="1150"></a>        {
<a name="1151"></a>            local xlat;
<a name="1152"></a>            local afterOfs;
<a name="1153"></a>            local afterStr;
<a name="1154"></a>            
<a name="1155"></a>            /* ask the formatter to translate it */
<a name="1156"></a>            xlat = translateTag(rexGroup(1)[3]);
<a name="1157"></a>
<a name="1158"></a>            /* get the part of the string that follows the tag */
<a name="1159"></a>            afterOfs = idx[1] + idx[2];
<a name="1160"></a>            afterStr = val.substr(idx[1] + idx[2]);
<a name="1161"></a>
<a name="1162"></a>            /* 
<a name="1163"></a>             *   if we got a translation, replace it; otherwise, leave the
<a name="1164"></a>             *   original text intact 
<a name="1165"></a>             */
<a name="1166"></a>            if (xlat != nil)
<a name="1167"></a>            {
<a name="1168"></a>                /* replace the tag with its translation */
<a name="1169"></a>                val = val.substr(1, idx[1] - 1) + xlat + afterStr;
<a name="1170"></a>
<a name="1171"></a>                /* 
<a name="1172"></a>                 *   figure the offset of the remainder of the string in
<a name="1173"></a>                 *   the replaced version of the string - this is the
<a name="1174"></a>                 *   length of the original part up to the replacement
<a name="1175"></a>                 *   text plus the length of the replacement text 
<a name="1176"></a>                 */
<a name="1177"></a>                afterOfs = idx[1] + xlat.length();
<a name="1178"></a>            }
<a name="1179"></a>
<a name="1180"></a>            /* 
<a name="1181"></a>             *   search for the next tag, considering only the part of
<a name="1182"></a>             *   the string following the replacement text - we do not
<a name="1183"></a>             *   want to re-scan the replacement text for tags 
<a name="1184"></a>             */
<a name="1185"></a>            idx = rexSearch(tagPattern, afterStr);
<a name="1186"></a>                
<a name="1187"></a>            /* 
<a name="1188"></a>             *   If we found it, adjust the starting index of the match to
<a name="1189"></a>             *   its position in the actual string.  Note that we do this
<a name="1190"></a>             *   by adding the OFFSET of the remainder of the string,
<a name="1191"></a>             *   which is 1 less than its INDEX, because idx[1] is already
<a name="1192"></a>             *   a string index.  (An offset is one less than an index
<a name="1193"></a>             *   because the index of the first character is 1.)  
<a name="1194"></a>             */
<a name="1195"></a>            if (idx != nil)
<a name="1196"></a>                idx[1] += afterOfs - 1;
<a name="1197"></a>        }
<a name="1198"></a>
<a name="1199"></a>        /* return the filtered value */
<a name="1200"></a>        return val;
<a name="1201"></a>    }
<a name="1202"></a>
<a name="1203"></a>    /*
<a name="1204"></a>     *   Translate a tag 
<a name="1205"></a>     */
<a name="1206"></a>    translateTag(tag)
<a name="1207"></a>    {
<a name="1208"></a>        local isClose;
<a name="1209"></a>        local styleTag;
<a name="1210"></a>        
<a name="1211"></a>        /* if it's a close tag, so note and remove the leading slash */
<a name="1212"></a>        isClose = tag.startsWith('/');
<a name="1213"></a>        if (isClose)
<a name="1214"></a>            tag = tag.substr(2);
<a name="1215"></a>
<a name="1216"></a>        /* look up the tag object in our table */
<a name="1217"></a>        styleTag = tagTable[tag];
<a name="1218"></a>
<a name="1219"></a>        /* 
<a name="1220"></a>         *   if we found it, return the open or close text, as
<a name="1221"></a>         *   appropriate; otherwise return nil 
<a name="1222"></a>         */
<a name="1223"></a>        return (styleTag != nil
<a name="1224"></a>                ? (isClose ? styleTag.closeText : styleTag.openText)
<a name="1225"></a>                : nil);
<a name="1226"></a>    }
<a name="1227"></a>
<a name="1228"></a>    /* preinitialization */
<a name="1229"></a>    execute()
<a name="1230"></a>    {
<a name="1231"></a>        /* create a lookup table for our style table */
<a name="1232"></a>        tagTable = new LookupTable();
<a name="1233"></a>        
<a name="1234"></a>        /* 
<a name="1235"></a>         *   Populate the table with all of the StyleTag instances.  Key
<a name="1236"></a>         *   by tag name, storing the tag object as the value for each
<a name="1237"></a>         *   key.  This will let us efficiently look up the StyleTag
<a name="1238"></a>         *   object given a tag name string.
<a name="1239"></a>         */
<a name="1240"></a>        forEachInstance(StyleTag, { tag: tagTable[tag.tagName] = tag });
<a name="1241"></a>    }
<a name="1242"></a>
<a name="1243"></a>    /*
<a name="1244"></a>     *   Our tag translation table.  We'll initialize this during preinit
<a name="1245"></a>     *   to a lookup table with all of the defined StyleTag objects.  
<a name="1246"></a>     */
<a name="1247"></a>    tagTable = nil
<a name="1248"></a>;
<a name="1249"></a>
<a name="1250"></a>
<a name="1251"></a>/* ------------------------------------------------------------------------ */
<a name="1252"></a>/*
<a name="1253"></a> *   Command Sequencer Filter.  This is an output filter that handles the
<a name="1254"></a> *   special &lt;.commandsep&gt; tag for visual command separation.  This tag has
<a name="1255"></a> *   the form of a style tag, but must be processed specially.
<a name="1256"></a> *   
<a name="1257"></a> *   &lt;.commandsep&gt; shows an appropriate separator between commands.  Before
<a name="1258"></a> *   the first command output or after the last command output, this has no
<a name="1259"></a> *   effect.  A run of multiple consecutive &lt;.commandsep&gt; tags is treated
<a name="1260"></a> *   as a single tag.
<a name="1261"></a> *   
<a name="1262"></a> *   Between commands, we show gLibMessages.commandResultsSeparator.  After
<a name="1263"></a> *   an input line and before the first command result text, we show
<a name="1264"></a> *   gLibMessages.commandResultsPrefix.  After the last command result text
<a name="1265"></a> *   before a new input line, we show gLibMessages.commandResultsSuffix.
<a name="1266"></a> *   If we read two input lines, and there is no intervening text output at
<a name="1267"></a> *   all, we show gLibMessages.commandResultsEmpty.
<a name="1268"></a> *   
<a name="1269"></a> *   The input manager should write a &lt;.commandbefore&gt; tag whenever it
<a name="1270"></a> *   starts reading a command line, and a &lt;.commandafter&gt; tag whenever it
<a name="1271"></a> *   finishes reading a command line.  
<a name="1272"></a> */
<a name="1273"></a>enum stateReadingCommand, stateBeforeCommand, stateBeforeInterruption,
<a name="1274"></a>    stateInCommand, stateBetweenCommands, stateWriteThrough,
<a name="1275"></a>    stateNoCommand;
<a name="1276"></a>
<a name="1277"></a>transient commandSequencer: OutputFilter
<a name="1278"></a>    /*
<a name="1279"></a>     *   Force the sequencer into mid-command mode.  This can be used to
<a name="1280"></a>     *   defeat the resequencing into before-results mode that occurs if
<a name="1281"></a>     *   any interactive command-line input must be read in the course of
<a name="1282"></a>     *   a command's execution.  
<a name="1283"></a>     */
<a name="1284"></a>    setCommandMode() { state_ = stateInCommand; }
<a name="1285"></a>
<a name="1286"></a>    /*
<a name="1287"></a>     *   Internal routine: write the given text directly through us,
<a name="1288"></a>     *   skipping any filtering we'd otherwise apply. 
<a name="1289"></a>     */
<a name="1290"></a>    writeThrough(txt)
<a name="1291"></a>    {
<a name="1292"></a>        local oldState;
<a name="1293"></a>
<a name="1294"></a>        /* remember our old state */
<a name="1295"></a>        oldState = state_;
<a name="1296"></a>
<a name="1297"></a>        /* set our state to write-through */
<a name="1298"></a>        state_ = stateWriteThrough;
<a name="1299"></a>
<a name="1300"></a>        /* make sure we reset things on the way out */
<a name="1301"></a>        try
<a name="1302"></a>        {
<a name="1303"></a>            /* write the text */
<a name="1304"></a>            say(txt);
<a name="1305"></a>        }
<a name="1306"></a>        finally
<a name="1307"></a>        {
<a name="1308"></a>            /* restore our old state */
<a name="1309"></a>            state_ = oldState;
<a name="1310"></a>        }
<a name="1311"></a>    }
<a name="1312"></a>
<a name="1313"></a>    /* pre-compile our tag sequence pattern */
<a name="1314"></a>    patNextTag = static new RexPattern(
<a name="1315"></a>        '&lt;nocase&gt;&lt;langle&gt;&lt;dot&gt;'
<a name="1316"></a>        + 'command(sep|int|before|after|none|mid)'
<a name="1317"></a>        + '&lt;rangle&gt;')
<a name="1318"></a>
<a name="1319"></a>    /*
<a name="1320"></a>     *   Apply our filter 
<a name="1321"></a>     */
<a name="1322"></a>    filterText(ostr, txt)
<a name="1323"></a>    {
<a name="1324"></a>        local ret;
<a name="1325"></a>        
<a name="1326"></a>        /* 
<a name="1327"></a>         *   if we're in write-through mode, simply pass the text through
<a name="1328"></a>         *   unchanged 
<a name="1329"></a>         */
<a name="1330"></a>        if (state_ == stateWriteThrough)
<a name="1331"></a>            return txt;
<a name="1332"></a>
<a name="1333"></a>        /* scan for tags */
<a name="1334"></a>        for (ret = '' ; txt != '' ; )
<a name="1335"></a>        {
<a name="1336"></a>            local match;
<a name="1337"></a>            local cur;
<a name="1338"></a>            local tag;
<a name="1339"></a>            
<a name="1340"></a>            /* search for our next special tag sequence */
<a name="1341"></a>            match = rexSearch(patNextTag, txt);
<a name="1342"></a>
<a name="1343"></a>            /* check to see if we found a tag */
<a name="1344"></a>            if (match == nil)
<a name="1345"></a>            {
<a name="1346"></a>                /* no more tags - the rest of the text is plain text */
<a name="1347"></a>                cur = txt;
<a name="1348"></a>                txt = '';
<a name="1349"></a>                tag = nil;
<a name="1350"></a>            }
<a name="1351"></a>            else
<a name="1352"></a>            {
<a name="1353"></a>                /* found a tag - get the plain text up to the tag */
<a name="1354"></a>                cur = txt.substr(1, match[1] - 1);
<a name="1355"></a>                txt = txt.substr(match[1] + match[2]);
<a name="1356"></a>
<a name="1357"></a>                /* get the tag name */
<a name="1358"></a>                tag = rexGroup(1)[3];
<a name="1359"></a>            }
<a name="1360"></a>
<a name="1361"></a>            /* process the plain text up to the tag, if any */
<a name="1362"></a>            if (cur != '')
<a name="1363"></a>            {
<a name="1364"></a>                /* check our state */
<a name="1365"></a>                switch(state_)
<a name="1366"></a>                {
<a name="1367"></a>                case stateReadingCommand:
<a name="1368"></a>                case stateWriteThrough:
<a name="1369"></a>                case stateInCommand:
<a name="1370"></a>                case stateNoCommand:
<a name="1371"></a>                    /* we don't need to add anything in these states */
<a name="1372"></a>                    break;
<a name="1373"></a>
<a name="1374"></a>                case stateBeforeCommand:
<a name="1375"></a>                    /* 
<a name="1376"></a>                     *   We're waiting for the first command output, and we've
<a name="1377"></a>                     *   now found it.  Write the command results prefix
<a name="1378"></a>                     *   separator.
<a name="1379"></a>                     */
<a name="1380"></a>                    
<a name="1381"></a>                    /*
<a name="1382"></a>                     *   Command group prefix - this is displayed after a
<a name="1383"></a>                     *   command line and before the first command results shown
<a name="1384"></a>                     *   after the command line.
<a name="1385"></a>                     *
<a name="1386"></a>                     *   By default, we'll show the "zero-space paragraph"
<a name="1387"></a>                     *   marker, which acts like a paragraph break in that it
<a name="1388"></a>                     *   swallows up immediately following paragraph breaks, but
<a name="1389"></a>                     *   doesn't actually add any space. This will ensure that
<a name="1390"></a>                     *   we don't add any space between the command input line
<a name="1391"></a>                     *   and the next text.
<a name="1392"></a>                     */
<a name="1393"></a>                    
<a name="1394"></a>                    ret += BMsg(command results prefix, '&lt;.p0&gt;');
<a name="1395"></a>
<a name="1396"></a>                    /* we're now inside some command result text */
<a name="1397"></a>                    state_ = stateInCommand;
<a name="1398"></a>                    break;
<a name="1399"></a>
<a name="1400"></a>                case stateBeforeInterruption:
<a name="1401"></a>                    /*
<a name="1402"></a>                     *   An editing session has been interrupted, and we're
<a name="1403"></a>                     *   showing new output.  First, switch to normal
<a name="1404"></a>                     *   in-command mode - do this before doing anything
<a name="1405"></a>                     *   else, since we might recursively show some more
<a name="1406"></a>                     *   text in the course of canceling the input line.  
<a name="1407"></a>                     */
<a name="1408"></a>                    state_ = stateInCommand;
<a name="1409"></a>
<a name="1410"></a>                    /*
<a name="1411"></a>                     *   Now tell the input manager that we're canceling
<a name="1412"></a>                     *   the input line that was under construction.  Don't
<a name="1413"></a>                     *   reset the input editor state, though, since we
<a name="1414"></a>                     *   might be able to resume editing the same line
<a name="1415"></a>                     *   later.  
<a name="1416"></a>                     */
<a name="1417"></a>                    inputManager.cancelInputInProgress(nil);
<a name="1418"></a>
<a name="1419"></a>                    /* insert the command interruption prefix */
<a name="1420"></a>                    
<a name="1421"></a>                    /*
<a name="1422"></a>                     *   Command "interruption" group prefix.  This is displayed
<a name="1423"></a>                     *   after an interrupted command line - a command line
<a name="1424"></a>                     *   editing session that was interrupted by a timeout event
<a name="1425"></a>                     *   - just before the text that interrupted the command
<a name="1426"></a>                     *   line.
<a name="1427"></a>                     *
<a name="1428"></a>                     *   By default, we'll show a paragraph break here, to set
<a name="1429"></a>                     *   off the interrupting text from the command line under
<a name="1430"></a>                     *   construction.
<a name="1431"></a>                     */
<a name="1432"></a>                    
<a name="1433"></a>                    ret += BMsg(command interuption prefix, '&lt;.p&gt;');
<a name="1434"></a>                    break;
<a name="1435"></a>
<a name="1436"></a>                case stateBetweenCommands:
<a name="1437"></a>                    /* 
<a name="1438"></a>                     *   We've been waiting for a new command to start
<a name="1439"></a>                     *   after seeing a &lt;.commandsep&gt; tag.  We now have
<a name="1440"></a>                     *   some text for the new command, so show a command
<a name="1441"></a>                     *   separator. 
<a name="1442"></a>                     */
<a name="1443"></a>                    
<a name="1444"></a>                    /*
<a name="1445"></a>                     *   Command separator - this is displayed after the results
<a name="1446"></a>                     *   from a command when another command is about to be
<a name="1447"></a>                     *   executed without any more user input.  That is, when a
<a name="1448"></a>                     *   command line contains more than one command, this
<a name="1449"></a>                     *   message is displayed between each successive command,
<a name="1450"></a>                     *   to separate the results visually.
<a name="1451"></a>                     *
<a name="1452"></a>                     *   This is not shown before the first command results
<a name="1453"></a>                     *   after a command input line, and is not shown after the
<a name="1454"></a>                     *   last results before a new input line.  Furthermore,
<a name="1455"></a>                     *   this is shown only between adjacent commands for which
<a name="1456"></a>                     *   output actually occurs; if a series of commands
<a name="1457"></a>                     *   executes without any output, we won't show any
<a name="1458"></a>                     *   separators between the silent commands.
<a name="1459"></a>                     *
<a name="1460"></a>                     *   By default, we'll just start a new paragraph.
<a name="1461"></a>                     */
<a name="1462"></a>                    
<a name="1463"></a>                    ret += BMsg(command results separator, '&lt;.p&gt;');
<a name="1464"></a>
<a name="1465"></a>                    /* we're now inside some command result text */
<a name="1466"></a>                    state_ = stateInCommand;
<a name="1467"></a>                    break;
<a name="1468"></a>                }
<a name="1469"></a>
<a name="1470"></a>                /* add the plain text */
<a name="1471"></a>                ret += cur;
<a name="1472"></a>            }
<a name="1473"></a>
<a name="1474"></a>            /* if we found the tag, process it */
<a name="1475"></a>            switch(tag)
<a name="1476"></a>            {
<a name="1477"></a>            case 'none':
<a name="1478"></a>                /* switching to no-command mode */
<a name="1479"></a>                state_ = stateNoCommand;
<a name="1480"></a>                break;
<a name="1481"></a>
<a name="1482"></a>            case 'mid':
<a name="1483"></a>                /* switching back to mid-command mode */
<a name="1484"></a>                state_ = stateInCommand;
<a name="1485"></a>                break;
<a name="1486"></a>                
<a name="1487"></a>            case 'sep':
<a name="1488"></a>                /* command separation - check our state */
<a name="1489"></a>                switch(state_)
<a name="1490"></a>                {
<a name="1491"></a>                case stateReadingCommand:
<a name="1492"></a>                case stateBeforeCommand:
<a name="1493"></a>                case stateBetweenCommands:
<a name="1494"></a>                case stateWriteThrough:
<a name="1495"></a>                    /* in these states, &lt;.commandsep&gt; has no effect */
<a name="1496"></a>                    break;
<a name="1497"></a>
<a name="1498"></a>                case stateInCommand:
<a name="1499"></a>                    /* 
<a name="1500"></a>                     *   We're inside some command text.  &lt;.commandsep&gt;
<a name="1501"></a>                     *   tells us that we've reached the end of one
<a name="1502"></a>                     *   command's output, so any subsequent output text
<a name="1503"></a>                     *   belongs to a new command and thus must be visually
<a name="1504"></a>                     *   separated from the preceding text.  Don't add any
<a name="1505"></a>                     *   separation text yet, because we don't know for
<a name="1506"></a>                     *   sure that there will ever be any more output text;
<a name="1507"></a>                     *   instead, switch our state to between-commands, so
<a name="1508"></a>                     *   that any subsequent text will trigger addition of
<a name="1509"></a>                     *   a separator.  
<a name="1510"></a>                     */
<a name="1511"></a>                    state_ = stateBetweenCommands;
<a name="1512"></a>                    break;
<a name="1513"></a>                }
<a name="1514"></a>                break;
<a name="1515"></a>
<a name="1516"></a>            case 'int':
<a name="1517"></a>                /* 
<a name="1518"></a>                 *   we've just interrupted reading a command line, due to
<a name="1519"></a>                 *   an expired timeout event - switch to the
<a name="1520"></a>                 *   before-interruption state 
<a name="1521"></a>                 */
<a name="1522"></a>                state_ = stateBeforeInterruption;
<a name="1523"></a>                break;
<a name="1524"></a>
<a name="1525"></a>            case 'before':
<a name="1526"></a>                /* we're about to start reading a command */
<a name="1527"></a>                switch (state_)
<a name="1528"></a>                {
<a name="1529"></a>                case stateBeforeCommand:
<a name="1530"></a>                    /* 
<a name="1531"></a>                     *   we've shown nothing since the last command; show
<a name="1532"></a>                     *   the empty command separator 
<a name="1533"></a>                     */
<a name="1534"></a>                    
<a name="1535"></a>                    /*
<a name="1536"></a>                     *   Empty command results - this is shown when we read a
<a name="1537"></a>                     *   command line and then go back and read another without
<a name="1538"></a>                     *   having displaying anything.
<a name="1539"></a>                     *
<a name="1540"></a>                     *   By default, we'll return a message indicating that
<a name="1541"></a>                     *   nothing happened.
<a name="1542"></a>                     */
<a name="1543"></a>                    writeThrough(BMsg(command results empty, 
<a name="1544"></a>                                      'Nothing obvious {dummy}{happens}.&lt;.p&gt;'));
<a name="1545"></a>                    break;
<a name="1546"></a>
<a name="1547"></a>                case stateBetweenCommands:
<a name="1548"></a>                case stateInCommand:
<a name="1549"></a>                    /* 
<a name="1550"></a>                     *   we've written at least one command result, so
<a name="1551"></a>                     *   show the after-command separator 
<a name="1552"></a>                     */
<a name="1553"></a>                    
<a name="1554"></a>                    /*
<a name="1555"></a>                     *   Command results suffix - this is displayed just before
<a name="1556"></a>                     *   a new command line is about to be read if any command
<a name="1557"></a>                     *   results have been shown since the last command line.
<a name="1558"></a>                     *
<a name="1559"></a>                     *   By default, we'll show nothing extra.
<a name="1560"></a>                     */
<a name="1561"></a>                    writeThrough(BMsg(command results suffix, ''));
<a name="1562"></a>                    break;
<a name="1563"></a>
<a name="1564"></a>                default:
<a name="1565"></a>                    /* do nothing in other modes */
<a name="1566"></a>                    break;
<a name="1567"></a>                }
<a name="1568"></a>
<a name="1569"></a>                /* switch to reading-command mode */
<a name="1570"></a>                state_ = stateReadingCommand;
<a name="1571"></a>                break;
<a name="1572"></a>
<a name="1573"></a>            case 'after':
<a name="1574"></a>                /* 
<a name="1575"></a>                 *   We've just finished reading a command.  If we're
<a name="1576"></a>                 *   still in reading-command mode, switch to
<a name="1577"></a>                 *   before-command-results mode.  Don't switch if we're
<a name="1578"></a>                 *   in another state, since we must have switched to
<a name="1579"></a>                 *   another state already by a different route, in which
<a name="1580"></a>                 *   case we can ignore this notification.  
<a name="1581"></a>                 */
<a name="1582"></a>                if (state_ == stateReadingCommand)
<a name="1583"></a>                    state_ = stateBeforeCommand;
<a name="1584"></a>                break;
<a name="1585"></a>            }
<a name="1586"></a>        }
<a name="1587"></a>
<a name="1588"></a>        /* return the results */
<a name="1589"></a>        return ret;
<a name="1590"></a>    }
<a name="1591"></a>
<a name="1592"></a>    /* our current state - start out in before-command mode */
<a name="1593"></a>    state_ = stateBeforeCommand
<a name="1594"></a>;
<a name="1595"></a>
<a name="1596"></a>
<a name="1597"></a>/* ------------------------------------------------------------------------ */ 
<a name="1598"></a> /* 
<a name="1599"></a>  *   quoteFilter: this loooks for smart quotes in the output and checks that
<a name="1600"></a>  *   they are balanced.
<a name="1601"></a>  *
<a name="1602"></a>  *   The problem with the smart quotes &lt;q&gt; &lt;/q&gt; is that if one is missing, or a
<a name="1603"></a>  *   spurious one is added, the error is perpetrated throughout the rest of the
<a name="1604"></a>  *   game (or until a compensating error is located). The purpose of
<a name="1605"></a>  *   quoteFilter is (a) to report such errors (to make them easier to fix) and
<a name="1606"></a>  *   (b) to prevent them being propagated beyond a single turn. In the main
<a name="1607"></a>  *   this works by having quoteFilter take over responsibility for turning the
<a name="1608"></a>  *   &lt;q&gt; and &lt;/q&gt; tags into the appropriate HTML entities rather than leaving
<a name="1609"></a>  *   it to the HTML rendering engine in the interpreter. The quoteFilter
<a name="1610"></a>  *   OutputFilter keeps its own track of whether a double quote or a single
<a name="1611"></a>  *   quote is rquired next, and resets this count at the start of each turn.
<a name="1612"></a>  */
<a name="1613"></a>quoteFilter: OutputFilter, InitObject
<a name="1614"></a>    filterText(ostr, txt) 
<a name="1615"></a>    { 
<a name="1616"></a>        local quoteRes, quoteStr;
<a name="1617"></a>        do
<a name="1618"></a>        {
<a name="1619"></a>            /* Look for &lt;q&gt; and &lt;/q&gt; in the output */
<a name="1620"></a>            quoteRes = rexSearch(quotePat, txt);
<a name="1621"></a>            
<a name="1622"></a>            /* If we found &lt;q&gt; or &lt;/q&gt;...*/
<a name="1623"></a>            if(quoteRes)
<a name="1624"></a>            {   
<a name="1625"></a>                /* 
<a name="1626"></a>                 *   Note whether it was an opening or a closing smart quote we
<a name="1627"></a>                 *   found.
<a name="1628"></a>                 */
<a name="1629"></a>                quoteStr = quoteRes[3].toLower();
<a name="1630"></a>                
<a name="1631"></a>                /* 
<a name="1632"></a>                 *   If it was an opening smart quote then replace it with an
<a name="1633"></a>                 *   opening double quote mark if we've had a net even number of
<a name="1634"></a>                 *   (or zero) opening quote marks this turn, otherwise replace
<a name="1635"></a>                 *   it with an opening single quote mark.
<a name="1636"></a>                 */
<a name="1637"></a>                
<a name="1638"></a>                switch(quoteStr)
<a name="1639"></a>                {    
<a name="1640"></a>                    
<a name="1641"></a>                case '&lt;q&gt;':
<a name="1642"></a>                    
<a name="1643"></a>                    txt = txt.findReplace(quoteStr, quoteCount % 2 == 0 
<a name="1644"></a>                                          ? '&amp;ldquo;' : '&amp;lsquo;', ReplaceOnce);
<a name="1645"></a>                    
<a name="1646"></a>                    /* Increment our counter of opening quote marks */
<a name="1647"></a>                    quoteCount ++;                
<a name="1648"></a>                    break;
<a name="1649"></a>                    /* If it's a closing smart quote */
<a name="1650"></a>                case '&lt;/q&gt;':
<a name="1651"></a>                    
<a name="1652"></a>                    /* 
<a name="1653"></a>                     *   Replace it with a closing double quote mark if we've had a net even number
<a name="1654"></a>                     *   of opening quotes so far on this turn, otherwise replace it with a closing
<a name="1655"></a>                     *   single quote mark.
<a name="1656"></a>                     */
<a name="1657"></a>                    txt = txt.findReplace(quoteStr, quoteCount % 2 == 1 
<a name="1658"></a>                                          ? '&amp;rdquo;' : '&amp;rsquo;', ReplaceOnce);
<a name="1659"></a>                    
<a name="1660"></a>                    /* Decrement our net quote count */
<a name="1661"></a>                    quoteCount --;                   
<a name="1662"></a>                    break;
<a name="1663"></a>                case '&lt;sq&gt;':
<a name="1664"></a>                    txt = txt.findReplace(quoteStr, '&amp;lsquo;', ReplaceOnce);
<a name="1665"></a>                    break;
<a name="1666"></a>                case '&lt;/sq&gt;':
<a name="1667"></a>                    txt = txt.findReplace(quoteStr, '&amp;rsquo;', ReplaceOnce);
<a name="1668"></a>                    break;
<a name="1669"></a>                        
<a name="1670"></a>                case '&lt;dq&gt;':
<a name="1671"></a>                    txt = txt.findReplace(quoteStr, '&amp;ldquo;', ReplaceOnce);
<a name="1672"></a>                    break;
<a name="1673"></a>                case '&lt;/dq&gt;':
<a name="1674"></a>                    txt = txt.findReplace(quoteStr, '&amp;rdquo;', ReplaceOnce);
<a name="1675"></a>                    break;
<a name="1676"></a>                }      
<a name="1677"></a>            }
<a name="1678"></a>                
<a name="1679"></a>        } while(quoteRes);
<a name="1680"></a>
<a name="1681"></a>        /* 
<a name="1682"></a>         *   Return the filtered string, with &lt;q&gt; and &lt;/q&gt; replaced with opening
<a name="1683"></a>         *   and closing quote marks.
<a name="1684"></a>         */
<a name="1685"></a>        return txt; 
<a name="1686"></a>    }
<a name="1687"></a>    
<a name="1688"></a>    /* 
<a name="1689"></a>     *   Our quoteCount is the net number of quote marks we've output this turn,
<a name="1690"></a>     *   i.e. the number of opening quote marks less the number of closing quote
<a name="1691"></a>     *   marks.
<a name="1692"></a>     */
<a name="1693"></a>    quoteCount = 0 
<a name="1694"></a>    
<a name="1695"></a>    /* Our rex pattern to match &lt;q&gt; and &lt;/q&gt; */
<a name="1696"></a>    quotePat = static new RexPattern('&lt;NoCase&gt;&lt;langle&gt;(&lt;s|d&gt;?q|/&lt;s|d&gt;?q)&lt;rangle&gt;')
<a name="1697"></a>    
<a name="1698"></a>    
<a name="1699"></a>    /* In Initialize this filter */
<a name="1700"></a>    execute()
<a name="1701"></a>    {
<a name="1702"></a>        /* Add this filter to the main output stream */
<a name="1703"></a>        mainOutputStream.addOutputFilter(self);
<a name="1704"></a>        
<a name="1705"></a>       /* 
<a name="1706"></a>        *   Set up a new prompt daemon to display a warning message about any
<a name="1707"></a>        *   unmatched quotes and zeroize our quoteCount each turn.
<a name="1708"></a>        */        
<a name="1709"></a>        if(defined(PromptDaemon) &amp;&amp; new PromptDaemon(self, &amp;quoteCheck));
<a name="1710"></a>       
<a name="1711"></a>    }
<a name="1712"></a>    
<a name="1713"></a>    /* 
<a name="1714"></a>     *   Should I show a warning when I find unmatched smart quotes over the 
<a name="1715"></a>     *   course of a turn? Displaying such a warning would probably look 
<a name="1716"></a>     *   intrusive in a released version, but might well be useful in a 
<a name="1717"></a>     *   version sent out to beta-testers (so it shouldn't be tied to a 
<a name="1718"></a>     *   version compiled for debugging). The showWarnings flag thus allows 
<a name="1719"></a>     *   the warning messages to be turned on and off as desired.
<a name="1720"></a>     */    
<a name="1721"></a>    showWarnings = true
<a name="1722"></a>    
<a name="1723"></a>    /* 
<a name="1724"></a>     *   The PromptDaemon set up in our execute() method at Initialization runs
<a name="1725"></a>     *   this method at the end of each turn. It checks to see if the number of
<a name="1726"></a>     *   opening smart quotes over the course of the turn just completed is the
<a name="1727"></a>     *   same as the number of closing smart quotes, and optionally prints a
<a name="1728"></a>     *   warning message if it is not.
<a name="1729"></a>     */    
<a name="1730"></a>    quoteCheck()
<a name="1731"></a>    {
<a name="1732"></a>       /* 
<a name="1733"></a>        *   If we have a non-zero quoteCount at the start of a turn, this means
<a name="1734"></a>        *   that the number of opening quotes output on the previous turn didn't
<a name="1735"></a>        *   match the number of closing quotes, so if our showWarnings property
<a name="1736"></a>        *   is true, display a message calling attention to the unmatched quotes
<a name="1737"></a>        *   (to enable the game author to fix them or beta-testers to report
<a name="1738"></a>        *   them)
<a name="1739"></a>        */
<a name="1740"></a>        if(quoteCount != 0 &amp;&amp; showWarnings)
<a name="1741"></a>            "&lt;FONT COLOR=RED&gt;&lt;b&gt;WARNING!!&lt;/b&gt;&lt;/FONT&gt; Unmatched quotes on
<a name="1742"></a>            this turn; quoteCount = &lt;&lt;quoteCount&gt;&gt;. ";      
<a name="1743"></a>        
<a name="1744"></a>        /* 
<a name="1745"></a>         *   In any case we want to zeroize the quoteCount at the start of 
<a name="1746"></a>         *   each turn so that the first smart quote we encounter on the 
<a name="1747"></a>         *   turn will display correctly no matter what went before.
<a name="1748"></a>         */
<a name="1749"></a>        quoteCount = 0;
<a name="1750"></a>    }
<a name="1751"></a>    
<a name="1752"></a>;
<a name="1753"></a>
<a name="1754"></a>
<a name="1755"></a>/* ------------------------------------------------------------------------ */
<a name="1756"></a>/*
<a name="1757"></a> *   Log Console output stream.  This is a simple wrapper for the system
<a name="1758"></a> *   log console, which allows console-style output to be captured to a
<a name="1759"></a> *   file, with full processing (HTML expansion, word wrapping, etc) but
<a name="1760"></a> *   without displaying anything to the game window.
<a name="1761"></a> *   
<a name="1762"></a> *   This class should always be instantiated with transient instances,
<a name="1763"></a> *   since the underlying system object doesn't participate in save/restore
<a name="1764"></a> *   operations.  
<a name="1765"></a> */
<a name="1766"></a>class LogConsole: OutputStream
<a name="1767"></a>    /*
<a name="1768"></a>     *   Utility method: create a log file, set up to capture all console
<a name="1769"></a>     *   output to the log file, run the given callback function, and then
<a name="1770"></a>     *   close the log file and restore the console output.  This can be
<a name="1771"></a>     *   used as a simple means of creating a file that captures the output
<a name="1772"></a>     *   of a command.  
<a name="1773"></a>     */
<a name="1774"></a>    captureToFile(filename, charset, width, func)
<a name="1775"></a>    {
<a name="1776"></a>        local con;
<a name="1777"></a>            
<a name="1778"></a>        /* set up a log console to do the capturing */
<a name="1779"></a>        con = new LogConsole(filename, charset, width);
<a name="1780"></a>
<a name="1781"></a>        /* capture to the console and run our command */
<a name="1782"></a>        outputManager.withOutputStream(con, func);
<a name="1783"></a>
<a name="1784"></a>        /* done with the console */
<a name="1785"></a>        con.closeConsole();
<a name="1786"></a>    }
<a name="1787"></a>
<a name="1788"></a>    /* create a log console */
<a name="1789"></a>    construct(filename, charset, width)
<a name="1790"></a>    {
<a name="1791"></a>        /* inherit base class handling */
<a name="1792"></a>        inherited();
<a name="1793"></a>        
<a name="1794"></a>        /* create the system log console object */
<a name="1795"></a>        handle_ = logConsoleCreate(filename, charset, width);
<a name="1796"></a>
<a name="1797"></a>        /* install the standard output filters */
<a name="1798"></a>        addOutputFilter(typographicalOutputFilter);
<a name="1799"></a>        addOutputFilter(new transient ParagraphManager());
<a name="1800"></a>        addOutputFilter(styleTagFilter);
<a name="1801"></a>
<a name="1802"></a>    }
<a name="1803"></a>
<a name="1804"></a>    /* 
<a name="1805"></a>     *   Close the console.  This closes the underlying system log console,
<a name="1806"></a>     *   which closes the operating system file.  No further text can be
<a name="1807"></a>     *   written to the console after it's closed.  
<a name="1808"></a>     */
<a name="1809"></a>    closeConsole()
<a name="1810"></a>    {
<a name="1811"></a>        /* close our underlying system console */
<a name="1812"></a>        logConsoleClose(handle_);
<a name="1813"></a>
<a name="1814"></a>        /* 
<a name="1815"></a>         *   forget our handle, since it's no longer valid; setting the
<a name="1816"></a>         *   handle to nil will make it more obvious what's going on if
<a name="1817"></a>         *   someone tries to write more text after we've been closed 
<a name="1818"></a>         */
<a name="1819"></a>        handle_ = nil;
<a name="1820"></a>    }
<a name="1821"></a>
<a name="1822"></a>    /* low-level stream writer - write to our system log console */
<a name="1823"></a>    writeFromStream(txt) { logConsoleSay(handle_, txt); }
<a name="1824"></a>
<a name="1825"></a>    /* our system log console handle */
<a name="1826"></a>    handle_ = nil
<a name="1827"></a>;
<a name="1828"></a>
<a name="1829"></a>/* ------------------------------------------------------------------------ */
<a name="1830"></a>/*
<a name="1831"></a> *   Output stream window.
<a name="1832"></a> *   
<a name="1833"></a> *   This is an abstract base class for UI widgets that have output
<a name="1834"></a> *   streams, such as Banner Windows and Web UI windows.  This base class
<a name="1835"></a> *   essentially handles the interior of the window, and leaves the details
<a name="1836"></a> *   of the window's layout in the broader UI to subclasses.  
<a name="1837"></a> */
<a name="1838"></a>class OutputStreamWindow: object
<a name="1839"></a>    /* 
<a name="1840"></a>     *   Invoke the given callback function, setting the default output
<a name="1841"></a>     *   stream to the window's output stream for the duration of the call.
<a name="1842"></a>     *   This allows invoking any code that writes to the current default
<a name="1843"></a>     *   output stream and displaying the result in the window.  
<a name="1844"></a>     */
<a name="1845"></a>    captureOutput(func)
<a name="1846"></a>    {
<a name="1847"></a>        /* make my output stream the global default */
<a name="1848"></a>        local oldStr = outputManager.setOutputStream(outputStream_);
<a name="1849"></a>
<a name="1850"></a>        /* make sure we restore the default output stream on the way out */
<a name="1851"></a>        try
<a name="1852"></a>        {
<a name="1853"></a>            /* invoke the callback function */
<a name="1854"></a>            (func)();
<a name="1855"></a>        }
<a name="1856"></a>        finally
<a name="1857"></a>        {
<a name="1858"></a>            /* restore the original default output stream */
<a name="1859"></a>            outputManager.setOutputStream(oldStr);
<a name="1860"></a>        }
<a name="1861"></a>    }
<a name="1862"></a>
<a name="1863"></a>    /* 
<a name="1864"></a>     *   Make my output stream the default in the output manager.  Returns
<a name="1865"></a>     *   the previous default output stream; the caller can note the return
<a name="1866"></a>     *   value and use it later to restore the original output stream via a
<a name="1867"></a>     *   call to outputManager.setOutputStream(), if desired.  
<a name="1868"></a>     */
<a name="1869"></a>    setOutputStream()
<a name="1870"></a>    {
<a name="1871"></a>        /* set my stream as the default */
<a name="1872"></a>        return outputManager.setOutputStream(outputStream_);
<a name="1873"></a>    }
<a name="1874"></a>
<a name="1875"></a>    /*
<a name="1876"></a>     *   Create our output stream.  We'll create the appropriate output
<a name="1877"></a>     *   stream subclass and set it up with our default output filters.
<a name="1878"></a>     *   Subclasses can override this as needed to customize the filters.  
<a name="1879"></a>     */
<a name="1880"></a>    createOutputStream()
<a name="1881"></a>    {
<a name="1882"></a>        /* create a banner output stream */
<a name="1883"></a>        outputStream_ = createOutputStreamObj();
<a name="1884"></a>
<a name="1885"></a>        /* set up the default filters */
<a name="1886"></a>        outputStream_.addOutputFilter(typographicalOutputFilter);
<a name="1887"></a>        outputStream_.addOutputFilter(new transient ParagraphManager());
<a name="1888"></a>        outputStream_.addOutputFilter(styleTagFilter);
<a name="1889"></a>    }
<a name="1890"></a>
<a name="1891"></a>    /*
<a name="1892"></a>     *   Create the output stream object.  Subclasses can override this to
<a name="1893"></a>     *   create the appropriate stream subclass.  Note that the stream
<a name="1894"></a>     *   should always be created as a transient object.  
<a name="1895"></a>     */
<a name="1896"></a>    createOutputStreamObj() { return new transient OutputStream(); }
<a name="1897"></a>
<a name="1898"></a>    /*
<a name="1899"></a>     *   My output stream - this is a transient OutputStream instance.
<a name="1900"></a>     *   Subclasses must create this explicitly by calling
<a name="1901"></a>     *   createOutputStream() when the underlying UI window is first
<a name="1902"></a>     *   created.  
<a name="1903"></a>     */
<a name="1904"></a>    outputStream_ = nil
<a name="1905"></a>;
<a name="1906"></a>
<a name="1907"></a>
<a name="1908"></a>/* ------------------------------------------------------------------------ */
<a name="1909"></a>/*
<a name="1910"></a> *   Typographical effects output filter.  This filter looks for certain
<a name="1911"></a> *   sequences in the text and converts them to typographical equivalents.
<a name="1912"></a> *   Authors could simply write the HTML for the typographical markups in
<a name="1913"></a> *   the first place, but it's easier to write the typewriter-like
<a name="1914"></a> *   sequences and let this filter convert to HTML.
<a name="1915"></a> *
<a name="1916"></a> *   We perform the following conversions:
<a name="1917"></a> *
<a name="1918"></a> *   '---' -&gt; &amp;zwnbsp;&amp;mdash;
<a name="1919"></a> *.  '--' -&gt; &amp;zwnbsp;&amp;ndash;
<a name="1920"></a> *.  sentence-ending punctuation -&gt; same + &amp;ensp;
<a name="1921"></a> *
<a name="1922"></a> *   Since this routine is called so frequently, we hard-code the
<a name="1923"></a> *   replacement strings, rather than using properties, for slightly faster
<a name="1924"></a> *   performance.  Since this routine is so simple, games that want to
<a name="1925"></a> *   customize the replacement style should simply replace this entire
<a name="1926"></a> *   routine with a new routine that applies the customizations.
<a name="1927"></a> *
<a name="1928"></a> *   Note that we define this filter in the English-specific part of the
<a name="1929"></a> *   library, because it seems almost certain that each language will want
<a name="1930"></a> *   to customize it for local conventions.
<a name="1931"></a> */
<a name="1932"></a>typographicalOutputFilter: OutputFilter
<a name="1933"></a>    filterText(ostr, val)
<a name="1934"></a>    {
<a name="1935"></a>        /* If we're not active, simply return val unchanged. */
<a name="1936"></a>        if(!isActive)
<a name="1937"></a>            return val;
<a name="1938"></a>        
<a name="1939"></a>        /*
<a name="1940"></a>         *   Look for sentence-ending punctuation, and put an 'en' space after each occurrence.
<a name="1941"></a>         *   Recognize ends of sentences even if we have closing quotes, parentheses, or other
<a name="1942"></a>         *   grouping characters following the punctuation.  Do this before the hyphen substitutions
<a name="1943"></a>         *   so that we can look for ordinary hyphens rather than all of the expanded versions. We
<a name="1944"></a>         *   don't do this if sentenceSpacer has been overridden to a single normal space.
<a name="1945"></a>         */
<a name="1946"></a>        if(sentenceSpacer != ' ')
<a name="1947"></a>            val = rexReplace(eosPattern, val, '%1'+sentenceSpacer, ReplaceAll);
<a name="1948"></a>
<a name="1949"></a>        /* undo any abbreviations we mistook for sentence endings */
<a name="1950"></a>        val = rexReplace(abbrevPat, val, '%1. ', ReplaceAll);
<a name="1951"></a>
<a name="1952"></a>        /*
<a name="1953"></a>         *   Replace dashes with typographical hyphens.  Three hyphens in a
<a name="1954"></a>         *   row become an em-dash, and two in a row become an en-dash.
<a name="1955"></a>         *   Note that we look for the three-hyphen sequence first, because
<a name="1956"></a>         *   if we did it the other way around, we'd incorrectly find the
<a name="1957"></a>         *   first two hyphens of each '---' sequence and replace them with
<a name="1958"></a>         *   an en-dash, causing us to miss the '---' sequences entirely.
<a name="1959"></a>         *   
<a name="1960"></a>         *   We put a no-break marker (\uFEFF) just before each hyphen, and
<a name="1961"></a>         *   an okay-to-break marker (\u200B) just after, to ensure that we
<a name="1962"></a>         *   won't have a line break between the preceding text and the
<a name="1963"></a>         *   hyphen, and to indicate that a line break is specifically
<a name="1964"></a>         *   allowed if needed to the right of the hyphen.  
<a name="1965"></a>         */
<a name="1966"></a>        val = val.findReplace(['---', '--'],
<a name="1967"></a>                              ['\uFEFF&amp;mdash;\u200B', '\uFEFF&amp;ndash;\u200B']);
<a name="1968"></a>
<a name="1969"></a>        /* return the result */
<a name="1970"></a>        return val;
<a name="1971"></a>    }
<a name="1972"></a>    
<a name="1973"></a>    /* 
<a name="1974"></a>     *   The character to use between a full stop and the start of the next sentence. By
<a name="1975"></a>     *   default we use an n-space.
<a name="1976"></a>     */        
<a name="1977"></a>    sentenceSpacer = '\u2002'
<a name="1978"></a>
<a name="1979"></a>    /*
<a name="1980"></a>     *   The end-of-sentence pattern.  This looks a bit complicated, but
<a name="1981"></a>     *   all we're looking for is a period, exclamation point, or question
<a name="1982"></a>     *   mark, optionally followed by any number of closing group marks
<a name="1983"></a>     *   (right parentheses or square brackets, closing HTML tags, or
<a name="1984"></a>     *   double or single quotes in either straight or curly styles), all
<a name="1985"></a>     *   followed by an ordinary space.
<a name="1986"></a>     *
<a name="1987"></a>     *   If a lower-case letter follows the space, though, we won't
<a name="1988"></a>     *   consider it a sentence ending.  This applies most commonly after
<a name="1989"></a>     *   quoted passages ending with what would normally be sentence-ending
<a name="1990"></a>     *   punctuation: "'Who are you?' he asked."  In these cases, the
<a name="1991"></a>     *   enclosing sentence isn't ending, so we don't want the extra space.
<a name="1992"></a>     *   We can tell the enclosing sentence isn't ending because a
<a name="1993"></a>     *   non-capital letter follows.
<a name="1994"></a>     *
<a name="1995"></a>     *   Note that we specifically look only for ordinary spaces.  Any
<a name="1996"></a>     *   sentence-ending punctuation that's followed by a quoted space or
<a name="1997"></a>     *   any typographical space overrides this substitution.
<a name="1998"></a>     */
<a name="1999"></a>    eosPattern = static new RexPattern(
<a name="2000"></a>        '&lt;case&gt;'
<a name="2001"></a>        + '('
<a name="2002"></a>        +   '[.!?]'
<a name="2003"></a>        +   '('
<a name="2004"></a>        +     '&lt;rparen|rsquare|dquote|squote|\u2019|\u201D&gt;'
<a name="2005"></a>        +     '|&lt;langle&gt;&lt;^rangle&gt;*&lt;rangle&gt;'
<a name="2006"></a>        +   ')*'
<a name="2007"></a>        + ')'
<a name="2008"></a>        + ' +(?![-a-z])'
<a name="2009"></a>        )
<a name="2010"></a>
<a name="2011"></a>    /* pattern for abbreviations that were mistaken for sentence endings */
<a name="2012"></a>    abbrevPat = static new RexPattern(
<a name="2013"></a>        '&lt;nocase&gt;%&lt;(' + abbreviations + ')&lt;dot&gt;\u2002')
<a name="2014"></a>
<a name="2015"></a>    /* 
<a name="2016"></a>     *   Common abbreviations.  These are excluded from being treated as
<a name="2017"></a>     *   sentence endings when they appear with a trailing period.
<a name="2018"></a>     *   
<a name="2019"></a>     *   Note that abbrevPat must be rebuilt manually if you change this on
<a name="2020"></a>     *   the fly - abbrevPat is static, so it picks up the initial value of
<a name="2021"></a>     *   this property at start-up, and doesn't re-evaluate it while the
<a name="2022"></a>     *   game is running.  
<a name="2023"></a>     */
<a name="2024"></a>    abbreviations = 'mr|mrs|ms|dr|prof'  
<a name="2025"></a>    
<a name="2026"></a>    isActive = true
<a name="2027"></a>;
<a name="2028"></a>
<a name="2029"></a>/* 
<a name="2030"></a> *   Display a list of strings supplied in the lst parameter as preformatted text, i.e. in a fixed
<a name="2031"></a> *   width font with all spaces preserved and no intervention from the typographical output filter.
<a name="2032"></a> *   This is intended to facilitate the display of diagrams or pictures composed of ASCII
<a name="2033"></a> *   characters. For example:
<a name="2034"></a> *
<a name="2035"></a> *.     local diag = [
<a name="2036"></a> *.    '+---   -----------',
<a name="2037"></a> *.    '|    *         +  \',
<a name="2038"></a> *.    '|    *     |   |   \',
<a name="2039"></a> *.    '+-------------------'
<a name="2040"></a> *.    ];
<a name="2041"></a> *
<a name="2042"></a> *.    showPreformatted(diag);
<a name="2043"></a> */
<a name="2044"></a>
<a name="2045"></a>showPreformatted(lst)
<a name="2046"></a>{
<a name="2047"></a>    /* If lst is supplied as a single-quoted string, convert it to a single-element list. */
<a name="2048"></a>    if(dataType(lst) == TypeSString)
<a name="2049"></a>        lst = [lst];
<a name="2050"></a>    
<a name="2051"></a>    
<a name="2052"></a>    "&lt;pre&gt;";
<a name="2053"></a>    foreach(local txt in lst)
<a name="2054"></a>    {
<a name="2055"></a>        txt = txt.findReplace(' ', '\ ', ReplaceAll);
<a name="2056"></a>        aioSay(txt);       
<a name="2057"></a>        "\n";
<a name="2058"></a>    }
<a name="2059"></a>    "&lt;/pre&gt;";  
<a name="2060"></a>}
<a name="2061"></a>
<a name="2062"></a>/* 
<a name="2063"></a> *   cquoteOutputFilter; this turns straight quotes into typographical quotes
<a name="2064"></a> *   (and is based on an extension by Stephen Grsnade).
<a name="2065"></a> */
<a name="2066"></a>cquoteOutputFilter: OutputFilter
<a name="2067"></a>    aggressive = true
<a name="2068"></a>
<a name="2069"></a>    // Patterns for our searches
<a name="2070"></a>    patIsHTMLTag = static new RexPattern('&lt;langle&gt;&lt;^rangle&gt;+&lt;squote|dquote&gt;&lt;^rangle&gt;*&lt;rangle&gt;')
<a name="2071"></a>    patIsFormatTag = static new RexPattern('{[^}]+&lt;squote&gt;[^}]*}')
<a name="2072"></a>    patAggressive = static new RexPattern('(&lt;alphanum|punct&gt;)&lt;squote&gt;')
<a name="2073"></a>    patIsCont1Tag = static new RexPattern('(&lt;alpha&gt;)&lt;squote&gt;(s|m|d|ve|re|ll)')
<a name="2074"></a>    patIsCont2Tag = static new RexPattern('(&lt;alpha&gt;)n&lt;squote&gt;t')
<a name="2075"></a>    patIsPossTag = static new RexPattern('(&lt;alpha&gt;)s&lt;squote&gt;')
<a name="2076"></a>    
<a name="2077"></a>    filterText(ostr, val) {
<a name="2078"></a>	local ret;
<a name="2079"></a>        
<a name="2080"></a>        if(!isActive)
<a name="2081"></a>            return val;
<a name="2082"></a>
<a name="2083"></a>	// Look for an HTML tag. We only need to find the first one,
<a name="2084"></a>	// because we'll be recursing through the string
<a name="2085"></a>	ret = rexSearch(patIsHTMLTag, val);
<a name="2086"></a>	if (ret == nil) {
<a name="2087"></a>	    // Look for a formatting tag
<a name="2088"></a>	    ret = rexSearch(patIsFormatTag, val);
<a name="2089"></a>	}
<a name="2090"></a>            
<a name="2091"></a>        
<a name="2092"></a>	// If we got a match either from the HTML or the formatting
<a name="2093"></a>	// tag, ignore that match recursively; that is, run the output
<a name="2094"></a>	// filter on the text before and after the match. This is
<a name="2095"></a>	// assuming that the whole start wasn't prefixed by a backslash
<a name="2096"></a>	// (since e.g. "\&lt;font face='courier&gt;" isn't really an HTML tag)
<a name="2097"></a>	if (ret != nil &amp;&amp; (ret[1] == 1 ||
<a name="2098"></a>			   val.substr(ret[1] - 1, 1) != '\\')) {
<a name="2099"></a>	    return filterText(ostr, val.substr(1, ret[1] - 1)) + ret[3] +
<a name="2100"></a>		filterText(ostr, val.substr(ret[1] + ret[2],
<a name="2101"></a>					    val.length() - (ret[1]+ret[2])
<a name="2102"></a>					    + 1));
<a name="2103"></a>	}
<a name="2104"></a>
<a name="2105"></a>	// Do the appropriate replacements. First, aggressive
<a name="2106"></a>	if (aggressive) {
<a name="2107"></a>	    val = rexReplace(patAggressive, val, '%1&amp;rsquo;',
<a name="2108"></a>			     ReplaceAll);
<a name="2109"></a>            
<a name="2110"></a>            /* Also replace double quotes with curly quotes */
<a name="2111"></a>            val = val.findReplace([R'(^|%&lt;|&lt;space&gt;)"', R'(&lt;^space&gt;)"'], 
<a name="2112"></a>                                  ['%1&amp;ldquo;','%1&amp;rdquo;']);
<a name="2113"></a>	}
<a name="2114"></a>	else {
<a name="2115"></a>	    // We recognize the contractions 's, 'm, 'd, 've, 're,
<a name="2116"></a>	    // 'll, and n't, as well as the plural possessive s'.
<a name="2117"></a>	    // (Possessive 's is handled by the contraction.) All
<a name="2118"></a>	    // must be preceeded by a letter.
<a name="2119"></a>	    val = rexReplace(patIsCont1Tag,
<a name="2120"></a>			     val, '%1&amp;rsquo;%2', ReplaceAll);
<a name="2121"></a>	    val = rexReplace(patIsCont2Tag, val, '%1n&amp;rsquo;t',
<a name="2122"></a>			     ReplaceAll);
<a name="2123"></a>	    val = rexReplace(patIsPossTag, val, '%1s&amp;rsquo;',
<a name="2124"></a>			     ReplaceAll);
<a name="2125"></a>	}
<a name="2126"></a>
<a name="2127"></a>	return val;
<a name="2128"></a>    }
<a name="2129"></a>    
<a name="2130"></a>    isActive = true
<a name="2131"></a>    
<a name="2132"></a>    activate() { isActive = true; }
<a name="2133"></a>    deactivate() { isActive = nil; }
<a name="2134"></a>;
<a name="2135"></a>
<a name="2136"></a>
<a name="2137"></a>/* ------------------------------------------------------------------------ */
<a name="2138"></a>/*
<a name="2139"></a> *   Temporarily override the current narrative tense and invoke a callback
<a name="2140"></a> *   function.
<a name="2141"></a> */
<a name="2142"></a>withTense(usePastTense, callback)
<a name="2143"></a>{
<a name="2144"></a>    /*
<a name="2145"></a>     *   Remember the old value of the usePastTense flag.
<a name="2146"></a>     */
<a name="2147"></a>    local oldUsePastTense = gameMain.usePastTense;
<a name="2148"></a>    
<a name="2149"></a>    /* But if Narrator.tense is an object, we need to take the old tense from there. */
<a name="2150"></a>    if(Narrator.propType(&amp;tense) == TypeObject)
<a name="2151"></a>        oldUsePastTense = Narrator.tense;
<a name="2152"></a>    /*
<a name="2153"></a>     *   Set the new value.
<a name="2154"></a>     */
<a name="2155"></a>    gameMain.usePastTense = usePastTense;
<a name="2156"></a>    /*
<a name="2157"></a>     *   Invoke the callback (remembering the return value) and restore the
<a name="2158"></a>     *   usePastTense flag on our way out.
<a name="2159"></a>     */
<a name="2160"></a>    local ret;
<a name="2161"></a>    try { ret = callback(); }
<a name="2162"></a>    finally         
<a name="2163"></a>    { 
<a name="2164"></a>        /* if useOldPastTense is an object, it was taken from Narrator.tense. */
<a name="2165"></a>        if(dataType(oldUsePastTense == TypeObject))
<a name="2166"></a>            Narrator.tense = oldUsePastTense;
<a name="2167"></a>        /* Otherwise we needs to restore the value on gameMain, */
<a name="2168"></a>        else            
<a name="2169"></a>            gameMain.usePastTense = oldUsePastTense; 
<a name="2170"></a>    }
<a name="2171"></a>    /*
<a name="2172"></a>     *   Return the result.
<a name="2173"></a>     */
<a name="2174"></a>    return ret;
<a name="2175"></a>}
<a name="2176"></a>
<a name="2177"></a>/* 
<a name="2178"></a> *   Display msg bypassing all filters except for the message parameter and style tag
<a name="2179"></a> *   substitutions; these may also be bypassed if the second (optional)
<a name="2180"></a> *   parameter is nil.
<a name="2181"></a> */
<a name="2182"></a>
<a name="2183"></a>extraReport(msg, expandParam = true)
<a name="2184"></a>{
<a name="2185"></a>    if(expandParam)
<a name="2186"></a>    {
<a name="2187"></a>        msg = buildMessage(nil, msg);
<a name="2188"></a>        
<a name="2189"></a>        /* Apply the style tag filter */
<a name="2190"></a>        msg = styleTagFilter.filterText(gOutStream, msg);
<a name="2191"></a>    }
<a name="2192"></a>    
<a name="2193"></a>    gOutStream.writeFromStream(msg);
<a name="2194"></a>}
<a name="2195"></a>
<a name="2196"></a>
<a name="2197"></a>/*
<a name="2198"></a> *   Basic conversation manager for use in adv3Liter and adv3Litest(when actor.t is not present) We
<a name="2199"></a> *   just provide handling for &lt;.reveal&gt; and &lt;.unreveal&gt; in case game code uses them.
<a name="2200"></a> */
<a name="2201"></a>
<a name="2202"></a>conversationManager: OutputFilter, PreinitObject
<a name="2203"></a>    /*
<a name="2204"></a>     *   Custom extended tags.  Games and library extensions can add their
<a name="2205"></a>     *   own tag processing as needed, by using 'modify' to extend this
<a name="2206"></a>     *   object.  There are two things you have to do to add your own tags:
<a name="2207"></a>     *   
<a name="2208"></a>     *   First, add a 'customTags' property that defines a regular
<a name="2209"></a>     *   expression for your added tags.  This will be incorporated into
<a name="2210"></a>     *   the main pattern we use to look for tags.  Simply specify a
<a name="2211"></a>     *   string that lists your tags separated by "|" characters, like
<a name="2212"></a>     *   this:
<a name="2213"></a>     *   
<a name="2214"></a>     *   customTags = 'foo|bar'
<a name="2215"></a>     *   
<a name="2216"></a>     *   Second, define a doCustomTag() method to process the tags.  The
<a name="2217"></a>     *   filter routine will call your doCustomTag() method whenever it
<a name="2218"></a>     *   finds one of your custom tags in the output stream.  
<a name="2219"></a>     */
<a name="2220"></a>    customTags = nil
<a name="2221"></a>    doCustomTag(tag, arg) { /* do nothing by default */ }
<a name="2222"></a>    
<a name="2223"></a>    filterText(ostr, txt)
<a name="2224"></a>    {
<a name="2225"></a>        local start;
<a name="2226"></a>        
<a name="2227"></a>        
<a name="2228"></a>        /* scan for our special tags */
<a name="2229"></a>        for (start = 1 ; ; )
<a name="2230"></a>        {
<a name="2231"></a>            local match;
<a name="2232"></a>            local arg;
<a name="2233"></a>            local tag;
<a name="2234"></a>            local nxtOfs;           
<a name="2235"></a>            local args;
<a name="2236"></a>            
<a name="2237"></a>            /* scan for the next tag */
<a name="2238"></a>            match = rexSearch(tagPat, txt, start);
<a name="2239"></a>            
<a name="2240"></a>            /* if we didn't find it, we're done */
<a name="2241"></a>            if (match == nil)
<a name="2242"></a>                break;
<a name="2243"></a>            
<a name="2244"></a>            /* note the next offset */
<a name="2245"></a>            nxtOfs = match[1] + match[2];
<a name="2246"></a>            
<a name="2247"></a>            /* get the argument (the third group from the match) */
<a name="2248"></a>            arg = rexGroup(3);
<a name="2249"></a>            if (arg != nil)
<a name="2250"></a>                arg = arg[3];
<a name="2251"></a>            
<a name="2252"></a>            /* pick out the tag */
<a name="2253"></a>            tag = rexGroup(1)[3].toLower(); 
<a name="2254"></a>            
<a name="2255"></a>            
<a name="2256"></a>            /* check which tag we have */
<a name="2257"></a>            switch (tag)
<a name="2258"></a>            {
<a name="2259"></a>                
<a name="2260"></a>            case 'reveal':
<a name="2261"></a>                /* reveal the key by adding it to our database */
<a name="2262"></a>                
<a name="2263"></a>                args = arg.split('=');
<a name="2264"></a>                if(args.length &gt; 1)
<a name="2265"></a>                {
<a name="2266"></a>                    arg = enumTabObj.getEnum(args[2]) ?? args[2];
<a name="2267"></a>                    
<a name="2268"></a>                    setRevealed(args[1], arg);
<a name="2269"></a>                }
<a name="2270"></a>                else                
<a name="2271"></a>                    setRevealed(arg);
<a name="2272"></a>                break;
<a name="2273"></a>                
<a name="2274"></a>                /* unreveal the key by removing it from our database */
<a name="2275"></a>            case 'unreveal':
<a name="2276"></a>                               
<a name="2277"></a>                setUnrevealed(arg);
<a name="2278"></a>                break;
<a name="2279"></a>                
<a name="2280"></a>                
<a name="2281"></a>            default:
<a name="2282"></a>                /* check for an extended tag */
<a name="2283"></a>                doCustomTag(tag, arg);
<a name="2284"></a>                break;
<a name="2285"></a>            }
<a name="2286"></a>            
<a name="2287"></a>            /* continue the search after this match */
<a name="2288"></a>            start = nxtOfs;
<a name="2289"></a>        }
<a name="2290"></a>        
<a name="2291"></a>        /* 
<a name="2292"></a>         *   remove the tags from the text by replacing every occurrence with an empty string, and
<a name="2293"></a>         *   return the result
<a name="2294"></a>         */
<a name="2295"></a>        return rexReplace(tagPat, txt, '', ReplaceAll);
<a name="2296"></a>    }
<a name="2297"></a>    
<a name="2298"></a>    tagPat = static new RexPattern(
<a name="2299"></a>        '&lt;nocase&gt;&lt;langle&gt;&lt;dot&gt;'
<a name="2300"></a>        + '(reveal|unreveal'
<a name="2301"></a>        + (customTags != nil ? '|' + customTags : '')        
<a name="2302"></a>        + ')(&lt;space&gt;+(&lt;^rangle&gt;+))?'
<a name="2303"></a>        + '&lt;rangle&gt;')
<a name="2304"></a>    
<a name="2305"></a>    setRevealed(tag, val?)
<a name="2306"></a>    {
<a name="2307"></a>        /* Note that our tag has been revealed */
<a name="2308"></a>        libGlobal.setRevealed(tag, val);
<a name="2309"></a>    }
<a name="2310"></a>    
<a name="2311"></a>;
<a name="2312"></a>
<a name="2313"></a>class SkipSignal: Exception
<a name="2314"></a>    
<a name="2315"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 03/03/2025 from adv3Lite version 2.2.0.3</div>
</body>
</html>

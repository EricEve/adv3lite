<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>strbuf.h</title></head><body>
<table class=ban><tr><td><h1>strbuf.h</h1><td align=right><a href="../file/strbuf.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   Copyright 2009 Michael J. Roberts.
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This module defines the StringBuffer intrinsic class.  StringBuffer is
<a name="10"></a> *   essentialy a mutable version of String: you can append, insert, replace,
<a name="11"></a> *   and delete characters in place, without creating new objects as a
<a name="12"></a> *   result.  This is useful for complex string constructions that involve
<a name="13"></a> *   many incremental steps, since it avoids the repeated memory allocation
<a name="14"></a> *   and string copying operations that would be involved if the intermediate
<a name="15"></a> *   steps were performed with ordinary String objects.  
<a name="16"></a> */
<a name="17"></a>
<a name="18"></a>/*
<a name="19"></a> *   A StringBuffer is a mutable character string object.  You can insert,
<a name="20"></a> *   append, delete, and replace characters in the buffer in place.  These
<a name="21"></a> *   operations don't create new objects as they do with ordinary strings,
<a name="22"></a> *   but simply modify the existing StringBuffer object's contents.
<a name="23"></a> *   
<a name="24"></a> *   The object manages memory automatically.  When you first create the
<a name="25"></a> *   object, it allocates an initial buffer to hold its character contents.
<a name="26"></a> *   You can specify the initial buffer size with a constructor argument, or
<a name="27"></a> *   simply let the object pick a default.  As you add text to the buffer,
<a name="28"></a> *   the object automatically allocates more memory as needed to accommodate
<a name="29"></a> *   the added text.  The maximum size for the string contained in the buffer
<a name="30"></a> *   is about 32000 characters.
<a name="31"></a> *   
<a name="32"></a> *   Construction: new StringBuffer() creates a buffer with default initial
<a name="33"></a> *   size values.  new StringBuffer(length, increment) specifies the initial
<a name="34"></a> *   buffer size in characters ('length'), and the minimum number of
<a name="35"></a> *   characters to add to the buffer each time it's automatically expanded
<a name="36"></a> *   ('increment').
<a name="37"></a> *   
<a name="38"></a> *   Passing a StringBuffer to an internal function or method that takes a
<a name="39"></a> *   String argument, such as tadsSay(), will automatically convert the
<a name="40"></a> *   object to a string.  To explicitly convert a StringBuffer to an ordinary
<a name="41"></a> *   String, use the toString() function.  You can also create an ordinary
<a name="42"></a> *   string from a section of the buffer using the substr() method.  
<a name="43"></a> */
<a name="44"></a>intrinsic class StringBuffer 'stringbuffer/030000'
<a name="45"></a>{
<a name="46"></a>    /*
<a name="47"></a>     *   Get the length in characters of the current text in the buffer. 
<a name="48"></a>     */
<a name="49"></a>    length();
<a name="50"></a>
<a name="51"></a>    /*
<a name="52"></a>     *   Retrieve the Unicode character value of the character at the given
<a name="53"></a>     *   index.  Returns an integer with the Unicode value.  If idx is
<a name="54"></a>     *   negative, it's an index from the end of the string: -1 is the last
<a name="55"></a>     *   character, -2 is the second to last, etc.  
<a name="56"></a>     */
<a name="57"></a>    charAt(idx);
<a name="58"></a>    
<a name="59"></a>    /*
<a name="60"></a>     *   Append text to the current contents of the buffer.  This adds the
<a name="61"></a>     *   new text at the end of the current text.  The value is automatically
<a name="62"></a>     *   converted to a string if possible; this includes numbers and
<a name="63"></a>     *   true and nil values.  
<a name="64"></a>     */
<a name="65"></a>    append(str);
<a name="66"></a>
<a name="67"></a>    /*
<a name="68"></a>     *   Insert text into the buffer just before the character at the given
<a name="69"></a>     *   index.  The first character is at index 1, so to insert the new text
<a name="70"></a>     *   before the first current character, insert at index 1.  If the index
<a name="71"></a>     *   is past the end of the current text, this has the same effect as
<a name="72"></a>     *   append().  A negative value indexes from the end of the string.  The
<a name="73"></a>     *   text is automatically converted to a string if possible.  
<a name="74"></a>     */
<a name="75"></a>    insert(txt, idx);
<a name="76"></a>
<a name="77"></a>    /*
<a name="78"></a>     *   Copy text into the buffer, starting at the given index (the first
<a name="79"></a>     *   character in the buffer is at index 1).  Overwrites any text
<a name="80"></a>     *   currently in the buffer at this point.  
<a name="81"></a>     */
<a name="82"></a>    copyChars(txt, idx);
<a name="83"></a>
<a name="84"></a>    /*
<a name="85"></a>     *   Delete the given text.  This deletes 'len' characters starting at
<a name="86"></a>     *   the given index (the first character is at index 1).  If the length
<a name="87"></a>     *   is omitted, the portion from idx to the end of the string is
<a name="88"></a>     *   deleted.  A negative idx value indexes from the end of the string.
<a name="89"></a>     */
<a name="90"></a>    deleteChars(idx, len?);
<a name="91"></a>
<a name="92"></a>    /*
<a name="93"></a>     *   Splice text.  This deletes 'len' characters starting at the given
<a name="94"></a>     *   index (the first character is at index 1), and replaces them with
<a name="95"></a>     *   the given new text.  If the new text is nil, this simply deletes the
<a name="96"></a>     *   old characters without inserting anything new.  If 'len' is zero,
<a name="97"></a>     *   simply inserts the new text without deleting any old text.  A
<a name="98"></a>     *   negative idx value indexes from the end of the string.  The 'str'
<a name="99"></a>     *   value is automatically converted to a string if possible.  
<a name="100"></a>     */
<a name="101"></a>    splice(idx, len, str);
<a name="102"></a>
<a name="103"></a>    /*
<a name="104"></a>     *   Retrieve the substring of the buffer starting at the given index and
<a name="105"></a>     *   running for the given character length.  If the length is omitted,
<a name="106"></a>     *   everything from the starting index to the end of the buffer is
<a name="107"></a>     *   included in the result string.  A negative value for 'idx' indexes
<a name="108"></a>     *   from the end of the string.  
<a name="109"></a>     */
<a name="110"></a>    substr(idx, len?);
<a name="111"></a>}
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>senseRegion.t</title></head><body>
<table class=ban><tr><td><h1>senseRegion.t</h1><td align=right><a href="../file/senseRegion.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/*----------------------------------------------------------------------------*/
<a name="5"></a>/*  
<a name="6"></a> *   senseRegion.t
<a name="7"></a> *
<a name="8"></a> *   This file defines the senseRegion class and the modifications to other
<a name="9"></a> *   classes needed to support it. It can be omitted from games that don't need
<a name="10"></a> *   the functionality it provides.
<a name="11"></a> *
<a name="12"></a> *   This file forms part of the adv3Lite library by Eric Eve (c) 2012, 2013
<a name="13"></a> *
<a name="14"></a> */
<a name="15"></a>
<a name="16"></a>
<a name="17"></a>/* 
<a name="18"></a> *   A SenseRegion is a special kind of Region allowing sensory connection
<a name="19"></a> *   between rooms
<a name="20"></a> */
<a name="21"></a>class SenseRegion: Region
<a name="22"></a>    
<a name="23"></a>    /* Is it possible to see from one room to another in this SenseRegion? */
<a name="24"></a>    canSeeAcross = true
<a name="25"></a>    
<a name="26"></a>    /* 
<a name="27"></a>     *   Is it possible to hear sounds (but not necessarily converse) in one
<a name="28"></a>     *   room from another in this SenseRegion?
<a name="29"></a>     */
<a name="30"></a>    canHearAcross = true
<a name="31"></a>    
<a name="32"></a>    /*   Do smells travel from one room to another in this SenseRegion? */
<a name="33"></a>    canSmellAcross = true  
<a name="34"></a>    
<a name="35"></a>    /* 
<a name="36"></a>     *   By default actors have to be in the same room to be able to converse.
<a name="37"></a>     *   Even if sound can travel from one location to another that doesn't
<a name="38"></a>     *   necessarily mean that one could converse over that distance. The only
<a name="39"></a>     *   exception might be where a senseRegion models a relatively small area,
<a name="40"></a>     *   like two ends of a room.
<a name="41"></a>     *
<a name="42"></a>     *   Note that if canHearAcross is nil setting canTalkAcross to true will
<a name="43"></a>     *   have no effect.
<a name="44"></a>     */
<a name="45"></a>    canTalkAcross = nil
<a name="46"></a>    
<a name="47"></a>    
<a name="48"></a>    /*   
<a name="49"></a>     *   Are rooms in this SenseRegion close enough together to allow objects to
<a name="50"></a>     *   be thrown from one room to another; by default we'll assume not.
<a name="51"></a>     */    
<a name="52"></a>    canThrowAcross = nil
<a name="53"></a>    
<a name="54"></a>    /*  
<a name="55"></a>     *   Use this method to carry out some additional initialization useful to
<a name="56"></a>     *   SenseRegions
<a name="57"></a>     */
<a name="58"></a>    setFamiliarRooms()
<a name="59"></a>    {
<a name="60"></a>        /* Carry out the inherited handling. */
<a name="61"></a>        inherited();
<a name="62"></a>                
<a name="63"></a>        /* 
<a name="64"></a>         *   Also take the opportunity to build each room's list of
<a name="65"></a>         *   sensory-connected rooms.
<a name="66"></a>         */        
<a name="67"></a>        
<a name="68"></a>        /* Go through each room in our room list */
<a name="69"></a>        foreach(local rm in roomList)
<a name="70"></a>        {
<a name="71"></a>            /* 
<a name="72"></a>             *   If we can see into remote rooms from here, append our list of
<a name="73"></a>             *   visible rooms to the other room's list of visible rooms,
<a name="74"></a>             *   excluding itself.
<a name="75"></a>             */
<a name="76"></a>            if(canSeeAcross)
<a name="77"></a>                rm.visibleRooms = rm.visibleRooms.appendUnique(roomList - rm);
<a name="78"></a>            
<a name="79"></a>            /* And so on for the other senses */
<a name="80"></a>            if(canHearAcross)
<a name="81"></a>                rm.audibleRooms = rm.audibleRooms.appendUnique(roomList - rm);
<a name="82"></a>            
<a name="83"></a>            if(canSmellAcross)
<a name="84"></a>                rm.smellableRooms = rm.smellableRooms.appendUnique(roomList - rm);
<a name="85"></a>            
<a name="86"></a>            if(canTalkAcross)
<a name="87"></a>                rm.talkableRooms = rm.talkableRooms.appendUnique(roomList - rm);
<a name="88"></a>            
<a name="89"></a>            if(canThrowAcross)
<a name="90"></a>                rm.throwableRooms = rm.throwableRooms.appendUnique(roomList - rm);
<a name="91"></a>            
<a name="92"></a>            rm.linkedRooms = rm.linkedRooms.appendUnique(roomList - rm);      
<a name="93"></a>            
<a name="94"></a>            /* 
<a name="95"></a>             *   Sort each room's sensory room lists in ascending orfer of their
<a name="96"></a>             *   remoteRoomListOrder(pov) from the pov of that room.
<a name="97"></a>             */
<a name="98"></a>            rm.visibleRooms = rm.sortRoomSublist(rm.visibleRooms, rm);
<a name="99"></a>            rm.audibleRooms = rm.sortRoomSublist(rm.audibleRooms, rm);
<a name="100"></a>            rm.smellableRooms = rm.sortRoomSublist(rm.smellableRooms, rm);
<a name="101"></a>            
<a name="102"></a>            
<a name="103"></a>        }
<a name="104"></a>        
<a name="105"></a>    }      
<a name="106"></a>    
<a name="107"></a>    /* 
<a name="108"></a>     *   Add everything to scope for all the rooms that belong to this
<a name="109"></a>     *   SenseRegion. We do this by sending a senseProbe into each of the rooms
<a name="110"></a>     *   and adding what would be in scope for that probe.
<a name="111"></a>     */    
<a name="112"></a>    addExtraScopeItems(action)
<a name="113"></a>    {
<a name="114"></a>        /* Carry out the inherited handling */
<a name="115"></a>        inherited(action);
<a name="116"></a>        
<a name="117"></a>        /* Initialize a new vector for our extra scope items */
<a name="118"></a>        local extraScope = new Vector(30);
<a name="119"></a>        
<a name="120"></a>        /* Go through every room in our list */
<a name="121"></a>        foreach(local rm in roomList)
<a name="122"></a>        {
<a name="123"></a>            /* Move the scopeProbe_ object into the room */
<a name="124"></a>            scopeProbe_.moveInto(rm);
<a name="125"></a>            
<a name="126"></a>            /* 
<a name="127"></a>             *   Add to our scope everything that's in scope for our scopeProbe_
<a name="128"></a>             *   while it's in the other room.
<a name="129"></a>             */
<a name="130"></a>            extraScope.appendAll(Q.scopeList(scopeProbe_).toList);
<a name="131"></a>        }
<a name="132"></a>        
<a name="133"></a>        /*  
<a name="134"></a>         *   Restrict the extra scope items to those that the actor knows about.
<a name="135"></a>         */
<a name="136"></a>        extraScope = extraScope.subset({o: gActor.knowsAbout(o)} );
<a name="137"></a>              
<a name="138"></a>        
<a name="139"></a>        /* 
<a name="140"></a>         *   Append our list of extra scope items to the action's scope list,
<a name="141"></a>         *   removing any duplicates.
<a name="142"></a>         */
<a name="143"></a>        action.scopeList = action.scopeList.appendUnique(extraScope.toList -
<a name="144"></a>            scopeProbe_);
<a name="145"></a>        
<a name="146"></a>        /* Remove the scopeProbe_ from the map */
<a name="147"></a>        scopeProbe_.moveInto(nil);
<a name="148"></a>    }   
<a name="149"></a>    
<a name="150"></a>    /* 
<a name="151"></a>     *   Since the PC should be able to see round the whole of a SenseRegion,
<a name="152"></a>     *   presumably the PC should also be able to find their way around a
<a name="153"></a>     *   SenseRegion once any of its rooms has been visited, even if the PC is
<a name="154"></a>     *   yet to visit the other rooms. We can achieve this effect by making the
<a name="155"></a>     *   SenseRegion familiar once any of its rooms has been visited, provided
<a name="156"></a>     *   there's line of sight across the rooms in the SenseRegion and the PC is
<a name="157"></a>     *   in a room in the SenseRegion which has light.
<a name="158"></a>     */
<a name="159"></a>    familiar()
<a name="160"></a>    {
<a name="161"></a>        local fam = nil;
<a name="162"></a>        local loc = gPlayerChar.getOutermostRoom;
<a name="163"></a>        
<a name="164"></a>        if(canSeeAcross &amp;&amp; loc.isIn(self) &amp;&amp; loc.isIlluminated)
<a name="165"></a>            fam = true;
<a name="166"></a>        
<a name="167"></a>        /* 
<a name="168"></a>         *   Once our familiar property becomes true it should never become nil
<a name="169"></a>         *   again, so we can simply convert familiar to the constant value true
<a name="170"></a>         *   and avoid the need to keep recalculating it.
<a name="171"></a>         */
<a name="172"></a>        if(fam)
<a name="173"></a>            familiar = fam;
<a name="174"></a>        
<a name="175"></a>        return fam;
<a name="176"></a>    }
<a name="177"></a>    
<a name="178"></a>    /* 
<a name="179"></a>     *   Flag: do we want the touchObj PreCondition to move the actor from one
<a name="180"></a>     *   Room in the SenseRegion to another by implicit action to allow an actio
<a name="181"></a>     *   to proceed? By default we set this to the value of contSpace, since if
<a name="182"></a>     *   contSpace is true (i.e. we're using this SenseRegion to model a fairly
<a name="183"></a>     *   small continuous space, such as a room) it probably makes sense for
<a name="184"></a>     *   autoGoTo to be true as well, but it's nonetheless perfectly all right
<a name="185"></a>     *   to override the values of autoGoTo and contSpace independently.
<a name="186"></a>     */
<a name="187"></a>    autoGoTo = contSpace
<a name="188"></a>    
<a name="189"></a>    /*   
<a name="190"></a>     *   If our autoGoTo flag is set, our fastGoTo flag should normally also be
<a name="191"></a>     *   set so that autoGoTo works smoothly without breaks for CONTINUE
<a name="192"></a>     *   commands impeding the workings of an implicit GoTo. Note, however, that
<a name="193"></a>     *   it's perfectly okay to override fastGoTo to true on a SenseRegion for
<a name="194"></a>     *   which autoGoTo is nil; it just may not be such a good idea to do it the
<a name="195"></a>     *   other way round.
<a name="196"></a>     */
<a name="197"></a>    fastGoTo = autoGoTo
<a name="198"></a>    
<a name="199"></a>    
<a name="200"></a>    /* 
<a name="201"></a>     *   Flag, do we want this SenseRegion to act as a continuous space (e.g.
<a name="202"></a>     *   representing parts of the same room, so that moving from one room to
<a name="203"></a>     *   another within this SenseRegion does not trigger a new room
<a name="204"></a>     *   description, thereby creating the impression that we have moved within
<a name="205"></a>     *   the same room rather than to another. This should probably be used
<a name="206"></a>     *   sparingly and only for SenseRegions representing a relatively small
<a name="207"></a>     *   area, otherwise the lack of a new room description (i.e. a LOOK AROUND)
<a name="208"></a>     *   could be confusing to the player.
<a name="209"></a>     */
<a name="210"></a>    contSpace = nil
<a name="211"></a>    
<a name="212"></a>    
<a name="213"></a>    
<a name="214"></a>;
<a name="215"></a>    
<a name="216"></a>
<a name="217"></a>/* 
<a name="218"></a> *   modifications to Room to allow SenseRegions to work.
<a name="219"></a> */
<a name="220"></a>modify Room
<a name="221"></a>    
<a name="222"></a>    /* 
<a name="223"></a>     *   The list of rooms that are visible from this room. Ordinarily this list
<a name="224"></a>     *   is constructed at Preinit by any Sense Regions this room belongs to, so
<a name="225"></a>     *   shouldn't normally be manually adjusted by game code. It's conceivable
<a name="226"></a>     *   that game code could tweak these lists after Preinit, though, perhaps
<a name="227"></a>     *   to create a one-way connection (e.g. to model a high room that
<a name="228"></a>     *   overlooks lower ones)
<a name="229"></a>     */         
<a name="230"></a>    visibleRooms = []
<a name="231"></a>    
<a name="232"></a>    /* 
<a name="233"></a>     *   The lists of rooms we can smell, hear, talk or throw from/into from
<a name="234"></a>     *   this room.
<a name="235"></a>     */
<a name="236"></a>    audibleRooms = []
<a name="237"></a>    smellableRooms = []
<a name="238"></a>    talkableRooms = []
<a name="239"></a>    throwableRooms = []
<a name="240"></a>
<a name="241"></a>    /*  
<a name="242"></a>     *   The list of rooms to which we're linked by virtue of being in the same
<a name="243"></a>     *   SenseRegion.
<a name="244"></a>     */
<a name="245"></a>    linkedRooms = []
<a name="246"></a>    
<a name="247"></a>    /* 
<a name="248"></a>     *   Show the specialDescs of any items in the other rooms in our
<a name="249"></a>     *   SenseRegions, where specialDescBeforeContents is true
<a name="250"></a>     */
<a name="251"></a>    showFirstConnectedSpecials(pov)
<a name="252"></a>    {
<a name="253"></a>        foreach(local rm in visibleRooms)
<a name="254"></a>            rm.showFirstRemoteSpecials(pov);
<a name="255"></a>    }
<a name="256"></a>    
<a name="257"></a>    
<a name="258"></a>    /* 
<a name="259"></a>     *   Show the specialDescs of any items in the other rooms in our
<a name="260"></a>     *   SenseRegions, where specialDescBeforeContents is nil
<a name="261"></a>     */
<a name="262"></a>    showSecondConnectedSpecials(pov)    
<a name="263"></a>    {
<a name="264"></a>        foreach(local rm in visibleRooms)
<a name="265"></a>            rm.showSecondRemoteSpecials(pov);        
<a name="266"></a>    }
<a name="267"></a>    
<a name="268"></a>    /* List the miscellaneous contents of a remote room */     
<a name="269"></a>    showConnectedMiscContents(pov)
<a name="270"></a>    {
<a name="271"></a>        foreach(local rm in visibleRooms)
<a name="272"></a>            rm.showRemoteMiscContents(pov);
<a name="273"></a>    }
<a name="274"></a>    
<a name="275"></a>    /* 
<a name="276"></a>     *   These properties are for the internal use of the remote listing
<a name="277"></a>     *   routines, and should normally be left alone by game code.
<a name="278"></a>     */
<a name="279"></a>    remoteSecondSpecialList = nil
<a name="280"></a>    remoteMiscContentsList = nil
<a name="281"></a>    
<a name="282"></a>    /* 
<a name="283"></a>     *   In additional to showing the first (i.e. pre-miscellaneous) list of
<a name="284"></a>     *   items with specialDescs in remote locations, the
<a name="285"></a>     *   showFirstRemoteSpecials() method builds the other lists of objects for
<a name="286"></a>     *   the subsequent methods to use. pov is the point of view object
<a name="287"></a>     *   (typically the player character) from whose point of view the list is
<a name="288"></a>     *   being constructed.
<a name="289"></a>     */
<a name="290"></a>    showFirstRemoteSpecials(pov)
<a name="291"></a>    {
<a name="292"></a>        /* 
<a name="293"></a>         *   The list of items whose specialDescs are to be displayed before the
<a name="294"></a>         *   list of miscellaneous items.
<a name="295"></a>         */
<a name="296"></a>        local specialVec1 = new Vector(10);
<a name="297"></a>        
<a name="298"></a>        /* 
<a name="299"></a>         *   The list of items whose specialDescs are to be displayed after the
<a name="300"></a>         *   list of miscellaneous items.
<a name="301"></a>         */
<a name="302"></a>        local specialVec2 = new Vector(10);
<a name="303"></a>        
<a name="304"></a>        /*   The list of miscellaneous items */
<a name="305"></a>        local miscVec = new Vector(10);
<a name="306"></a>        
<a name="307"></a>        /* 
<a name="308"></a>         *   Reduce our list to that subset of the list that is visible to the
<a name="309"></a>         *   pov object.
<a name="310"></a>         */
<a name="311"></a>        local lst = contents.subset({o: o.isVisibleFrom(pov) &amp;&amp; !o.isHidden});
<a name="312"></a>        
<a name="313"></a>        /* 
<a name="314"></a>         *   Sort the objects to be listed into three separate lists: those with
<a name="315"></a>         *   specialDescs to be shown before the lists of miscellaneous items,
<a name="316"></a>         *   the list of miscellaneous items, and the list of objects with
<a name="317"></a>         *   specialDescs to be listed after the miscellaneous items.
<a name="318"></a>         */
<a name="319"></a>        foreach(local obj in lst)
<a name="320"></a>        {            
<a name="321"></a>            /* 
<a name="322"></a>             *   See if obj defines an initSpecialDesc property or specialDesc
<a name="323"></a>             *   property that is currently in use.
<a name="324"></a>             */
<a name="325"></a>            if((obj.propType(&amp;initSpecialDesc) != TypeNil &amp;&amp;
<a name="326"></a>               obj.useInitSpecialDesc()) ||
<a name="327"></a>               (obj.propType(&amp;specialDesc) != TypeNil &amp;&amp; obj.useSpecialDesc()))
<a name="328"></a>            {
<a name="329"></a>                /* 
<a name="330"></a>                 *   If so, and obj's specialDesc is to be shown before any
<a name="331"></a>                 *   miscellaneous contents, add obj to the first specials list
<a name="332"></a>                 */
<a name="333"></a>                if(obj.specialDescBeforeContents)
<a name="334"></a>                    specialVec1.append(obj);
<a name="335"></a>                /* 
<a name="336"></a>                 *   If obj's specialDesc is to be shown after this list of
<a name="337"></a>                 *   miscellaneous context, add obj to the second list of
<a name="338"></a>                 *   specials.
<a name="339"></a>                 */
<a name="340"></a>                else
<a name="341"></a>                    specialVec2.append(obj);
<a name="342"></a>            }
<a name="343"></a>            /* 
<a name="344"></a>             *   Otherwise, if obj doesn't define a currently usable specialDesc
<a name="345"></a>             *   or initSpecialDesc, add it to the list of miscellaneous items.
<a name="346"></a>             */
<a name="347"></a>            else 
<a name="348"></a>                miscVec.append(obj);
<a name="349"></a>        }
<a name="350"></a>        
<a name="351"></a>        /* Sort the first list of specials in specialDescOrder */        
<a name="352"></a>        specialVec1.sort(nil, {a, b: a.specialDescOrder - b.specialDescOrder});
<a name="353"></a>        
<a name="354"></a>        /* Sort the second list of specials in specialDescOrder */
<a name="355"></a>        specialVec2.sort(nil, {a, b: a.specialDescOrder - b.specialDescOrder});
<a name="356"></a>                       
<a name="357"></a>        /* 
<a name="358"></a>         *   Show the items in the first list, i.e. the list of items with
<a name="359"></a>         *   specialDescs to be shown before the miscellaneous items.
<a name="360"></a>         */
<a name="361"></a>        foreach(local obj in specialVec1)        
<a name="362"></a>        {
<a name="363"></a>            obj.showRemoteSpecialDesc(pov);      
<a name="364"></a>            listRemoteContents(obj.contents, remoteSubContentsLister, pov);
<a name="365"></a>        }
<a name="366"></a>        
<a name="367"></a>        
<a name="368"></a>        
<a name="369"></a>        /* Store the other two lists for later use by other methods. */
<a name="370"></a>        remoteSecondSpecialList = specialVec2.toList();
<a name="371"></a>        remoteMiscContentsList = miscVec.toList().subset({o:
<a name="372"></a>            o.location.ofKind(Room)});
<a name="373"></a>    }
<a name="374"></a>    
<a name="375"></a>    /* Show the removeSpecialDesc of each item in the second list of specials */
<a name="376"></a>    showSecondRemoteSpecials(pov)
<a name="377"></a>    {
<a name="378"></a>        foreach(local obj in remoteSecondSpecialList)
<a name="379"></a>        {
<a name="380"></a>            obj.showRemoteSpecialDesc(pov); 
<a name="381"></a>            listRemoteContents(obj.contents, remoteSubContentsLister, pov);
<a name="382"></a>        }
<a name="383"></a>    }
<a name="384"></a>    
<a name="385"></a>    /* List the miscellaneous list of items in this remote location */
<a name="386"></a>    showRemoteMiscContents(pov)
<a name="387"></a>    {        
<a name="388"></a>        remoteContentsLister.show(remoteMiscContentsList, inRoomName(pov));  
<a name="389"></a>        listRemoteContents(remoteMiscContentsList, remoteSubContentsLister,
<a name="390"></a>                           pov);
<a name="391"></a>    }
<a name="392"></a>    
<a name="393"></a>    /* 
<a name="394"></a>     *   The contents lister to use to list this room's miscellaneous contents
<a name="395"></a>     *   when viewed from a remote location.
<a name="396"></a>     */
<a name="397"></a>    remoteContentsLister = remoteRoomContentsLister
<a name="398"></a>    
<a name="399"></a>    /* 
<a name="400"></a>     *   Reset the contents of all the remote rooms visible from this room to
<a name="401"></a>     *   not having been mentioned.
<a name="402"></a>     */
<a name="403"></a>    unmentionRemoteContents()
<a name="404"></a>    {
<a name="405"></a>        foreach(local rm in visibleRooms)
<a name="406"></a>            unmention(rm.allContents);
<a name="407"></a>    }
<a name="408"></a>    
<a name="409"></a>    /* 
<a name="410"></a>     *   The name that's used to introduce a list of miscellaneous objects in
<a name="411"></a>     *   this room when viewed from a remote location containing the pov object
<a name="412"></a>     *   (normally the player character).
<a name="413"></a>     */
<a name="414"></a>    inRoomName(pov)
<a name="415"></a>    {
<a name="416"></a>        return BMsg(in room name, 'in {1}', theName);
<a name="417"></a>    }   
<a name="418"></a>    
<a name="419"></a>    /* 
<a name="420"></a>     *   The following six methods take effect only if there would otherwise be
<a name="421"></a>     *   a sensory connection between the current room and loc due to their
<a name="422"></a>     *   being in the same SenseRegion.
<a name="423"></a>     *
<a name="424"></a>     *   Can we see into this room from loc?
<a name="425"></a>     */    
<a name="426"></a>    canSeeInFrom(loc) { return canSeeOutTo(loc); }
<a name="427"></a>    
<a name="428"></a>    /*   Can we see out of this room to loc? */
<a name="429"></a>    canSeeOutTo(loc) { return true; }
<a name="430"></a>    
<a name="431"></a>    /*   
<a name="432"></a>     *   Can we hear into this room from loc (i.e. can an actor in loc hear
<a name="433"></a>     *   something in this room?
<a name="434"></a>     */
<a name="435"></a>    canHearInFrom(loc) { return canHearOutTo(loc); }
<a name="436"></a>    
<a name="437"></a>    /*   
<a name="438"></a>     *   Can we hear out from this room to loc (i.e. can an actor in this room
<a name="439"></a>     *   hear something in loc)?
<a name="440"></a>     */
<a name="441"></a>    canHearOutTo(loc) { return true; }
<a name="442"></a>    
<a name="443"></a>    /*   
<a name="444"></a>     *   Can we smell into this room from loc (i.e. can an actor in loc smell
<a name="445"></a>     *   something in this room?
<a name="446"></a>     */
<a name="447"></a>    canSmellInFrom(loc) { return canSmellOutTo(loc); }
<a name="448"></a>    
<a name="449"></a>    /*   
<a name="450"></a>     *   Can we hear out from this room to loc (i.e. can an actor in this room
<a name="451"></a>     *   hear something in loc)?
<a name="452"></a>     */
<a name="453"></a>    canSmellOutTo(loc) { return true; }    
<a name="454"></a>    
<a name="455"></a>    /* 
<a name="456"></a>     *   Should we look around on entering this room? Normally we should, unless
<a name="457"></a>     *   both the room obj is travelling from and the room it's travelling to
<a name="458"></a>     *   (normally this room) both belong in a SenseRegion whose contSpace
<a name="459"></a>     *   property is true.
<a name="460"></a>     */
<a name="461"></a>    lookOnEnter(obj)
<a name="462"></a>    {
<a name="463"></a>        return obj.getOutermostRoom.regionsInCommonWith(destination).indexWhich(
<a name="464"></a>            { reg: reg.contSpace } ) == nil;
<a name="465"></a>    }
<a name="466"></a>    
<a name="467"></a>    /* 
<a name="468"></a>     *   listOrder is inherited from Thing with a default value of 100. For a Room in a SenseRegion
<a name="469"></a>     *   it can control the order in which other rooms in the SenseRegion have their contents
<a name="470"></a>     *   described (higher = later), although this can be adjusted via the remoteRoomListOrder(pov)
<a name="471"></a>     *   method.
<a name="472"></a>     */
<a name="473"></a>    // listOrder = 100
<a name="474"></a>    
<a name="475"></a>    
<a name="476"></a>    /*   
<a name="477"></a>     *   For a Room in a SenseRegion return the order in which other rooms in the SenseRegion have
<a name="478"></a>     *   their contents described (higher = later) from the point of view of the pov object, which
<a name="479"></a>     *   will normally be the room from which the viewing, smelling or listening is being performed.
<a name="480"></a>     *   By default we just return the Room's listOrder.
<a name="481"></a>     */
<a name="482"></a>    remoteRoomListOrder(pov)
<a name="483"></a>    {
<a name="484"></a>        return listOrder;
<a name="485"></a>    }
<a name="486"></a>    
<a name="487"></a>    /* 
<a name="488"></a>     *   Sort a sublist of rooms in ascending order of their remoteRoomListOrder(pov) and return the
<a name="489"></a>     *   result.
<a name="490"></a>     */
<a name="491"></a>    sortRoomSublist(sublist, pov)
<a name="492"></a>    {
<a name="493"></a>        /* 
<a name="494"></a>         *   If our sublist contains less than two elements return our sublist unchanged.
<a name="495"></a>         */
<a name="496"></a>        if(sublist.length &lt; 2)
<a name="497"></a>            return sublist;
<a name="498"></a>               
<a name="499"></a>        
<a name="500"></a>        return sublist.sort(nil, {a, b: a.remoteRoomListOrder(pov) - b.remoteRoomListOrder(pov) });
<a name="501"></a>    }
<a name="502"></a>    
<a name="503"></a>    /* 
<a name="504"></a>     *   Our description when we're examined by an actor in a remote location. By default we just
<a name="505"></a>     *   display our description.
<a name="506"></a>     */
<a name="507"></a>    remoteDesc(pov)
<a name="508"></a>    {
<a name="509"></a>        desc;
<a name="510"></a>    }
<a name="511"></a>    
<a name="512"></a>    /* 
<a name="513"></a>     *   If we're ezamined from a remote location, display our remoteDesc rather than look around
<a name="514"></a>     *   within us.
<a name="515"></a>     */
<a name="516"></a>    dobjFor(Examine)
<a name="517"></a>    {
<a name="518"></a>        action()
<a name="519"></a>        {
<a name="520"></a>            if(gActor.isIn(self))
<a name="521"></a>                inherited();
<a name="522"></a>            else
<a name="523"></a>                remoteDesc(gActor);
<a name="524"></a>                
<a name="525"></a>        }
<a name="526"></a>    }
<a name="527"></a>          
<a name="528"></a>;
<a name="529"></a>
<a name="530"></a>    
<a name="531"></a>/* 
<a name="532"></a> *   The default Lister for listing miscellaneous objects in a remote location.
<a name="533"></a> */
<a name="534"></a>remoteRoomContentsLister: ItemLister
<a name="535"></a>    /* is the object listed in a LOOK AROUND description? */
<a name="536"></a>    listed(obj) { return obj.lookListed &amp;&amp; !obj.isHidden; }    
<a name="537"></a>    
<a name="538"></a>    /* 
<a name="539"></a>     *   Show the list prefix. The irName parameter is the inRoomName(pov)
<a name="540"></a>     *   passed from Room.showRemoteMiscContents(pov).
<a name="541"></a>     */
<a name="542"></a>    showListPrefix(lst, pl, irName)  
<a name="543"></a>    { 
<a name="544"></a>        DMsg(remote contents prefix, '&lt;.p&gt;\^{1} {i} {see} ', irName); 
<a name="545"></a>    }
<a name="546"></a>    
<a name="547"></a>    showListSuffix(lst, pl, irName)  
<a name="548"></a>    { 
<a name="549"></a>        DMsg(remote contents suffix, '. '); 
<a name="550"></a>    }
<a name="551"></a>    
<a name="552"></a>    contentsListedProp = &amp;contentsListedInLook
<a name="553"></a>;
<a name="554"></a>
<a name="555"></a>/* 
<a name="556"></a> *   The default Lister for listing the miscellaneous contents of objects in a
<a name="557"></a> *   remote location.
<a name="558"></a> */
<a name="559"></a>remoteSubContentsLister: ItemLister
<a name="560"></a>    /* is the object listed in a LOOK AROUND description? */
<a name="561"></a>    listed(obj) { return obj.lookListed &amp;&amp; !obj.isHidden; }    
<a name="562"></a>    
<a name="563"></a>    /* 
<a name="564"></a>     *   Show the list prefix. The irName parameter is the inRoomName(pov)
<a name="565"></a>     *   passed from Room.showRemoteMiscContents(pov).
<a name="566"></a>     */
<a name="567"></a>    showListPrefix(lst, pl, inParentName)  
<a name="568"></a>    {        
<a name="569"></a>        DMsg(remote subcontents prefix, '&lt;.p&gt;\^{1} &lt;&lt;pl ? '{plural}
<a name="570"></a>                {is}' : '{dummy} {is}'&gt;&gt; ', inParentName); 
<a name="571"></a>    }
<a name="572"></a>    
<a name="573"></a>    showListSuffix(lst, pl, irName)  
<a name="574"></a>    { 
<a name="575"></a>        DMsg(remote subcontents suffix, '. '); 
<a name="576"></a>    }
<a name="577"></a>    
<a name="578"></a>    contentsListedProp = &amp;contentsListedInLook
<a name="579"></a>;
<a name="580"></a>
<a name="581"></a>
<a name="582"></a>/* 
<a name="583"></a> *   Modifications to Thing to support the other mods required for use with
<a name="584"></a> *   SenseRegion.
<a name="585"></a> */
<a name="586"></a>modify Thing
<a name="587"></a>       
<a name="588"></a>   /* 
<a name="589"></a>    *   Show our remoteSpecialDesc, i.e. the version of our specialDesc that
<a name="590"></a>    *   should be seen when this item is viewed from a remote location.
<a name="591"></a>    */     
<a name="592"></a>    showRemoteSpecialDesc(pov)
<a name="593"></a>    {
<a name="594"></a>        /* If we've already been mentioned, don't do anything */
<a name="595"></a>        if(mentioned)
<a name="596"></a>            return;
<a name="597"></a>        /* 
<a name="598"></a>         *   Otherwise note that we've now been mentioned before doing anything
<a name="599"></a>         *   else.
<a name="600"></a>         */
<a name="601"></a>        else
<a name="602"></a>            mentioned = true;
<a name="603"></a>        
<a name="604"></a>        /* 
<a name="605"></a>         *   If we have a non-nil initSpecialDesc and our useInitSpecialDesc
<a name="606"></a>         *   property is true, show our remoteInitSpecialDesc from pov's point
<a name="607"></a>         *   of view.
<a name="608"></a>         */
<a name="609"></a>        if(propType(&amp;initSpecialDesc) != TypeNil &amp;&amp; useInitSpecialDesc)
<a name="610"></a>            remoteInitSpecialDesc(pov);
<a name="611"></a>        
<a name="612"></a>        /* Otherwise show our remoteSpecialDesc() */
<a name="613"></a>        else
<a name="614"></a>            remoteSpecialDesc(pov);
<a name="615"></a>           
<a name="616"></a>        /* Then add a paragraph break */
<a name="617"></a>        "&lt;.p&gt;";
<a name="618"></a>        
<a name="619"></a>        /* Note that we've been seen */
<a name="620"></a>        noteSeen();
<a name="621"></a>    }
<a name="622"></a>    
<a name="623"></a>    /* List contents as seen from a remote location */
<a name="624"></a>    listRemoteContents(lst, lister, pov)
<a name="625"></a>    {
<a name="626"></a>        local contList = lst.subset({o: o.isVisibleFrom(pov) &amp;&amp; !o.isHidden});
<a name="627"></a>        
<a name="628"></a>        /* 
<a name="629"></a>         *   Sort the contList in listOrder. Although we're listing the contents
<a name="630"></a>         *   of each item in the contList, it seems good to mention each item's
<a name="631"></a>         *   contents in the listOrder order of the item. Amongst other things
<a name="632"></a>         *   this helps give a consistent ordering for the listing of 
<a name="633"></a>         *   SubComponents.
<a name="634"></a>         */
<a name="635"></a>        contList = contList.sort(nil, {a, b: a.listOrder - b.listOrder});
<a name="636"></a>                     
<a name="637"></a>        
<a name="638"></a>        foreach(local obj in contList)           
<a name="639"></a>        {
<a name="640"></a>             /* Note that the object has been seen by the pc. */
<a name="641"></a>            obj.noteSeen();
<a name="642"></a>            
<a name="643"></a>            /* 
<a name="644"></a>             *   Don't list the inventory of any actors, or of any items that don't want their
<a name="645"></a>             *   contents listed, or any items we can't see in, or of any items that don't have any
<a name="646"></a>             *   contents to list, or of any items whose contents isn't visible remotely from pov.
<a name="647"></a>             */
<a name="648"></a>            if(obj.contType == Carrier 
<a name="649"></a>               || obj.(lister.contentsListedProp) == nil
<a name="650"></a>               || obj.canSeeIn() == nil
<a name="651"></a>               || obj.contents.length == 0
<a name="652"></a>               || obj.contentsVisibleFrom(pov)  == nil)
<a name="653"></a>                continue;
<a name="654"></a>            
<a name="655"></a>                      
<a name="656"></a>            /* 
<a name="657"></a>             *   Don't list any items that have already been mentioned or which
<a name="658"></a>             *   aren't visible from the pov.
<a name="659"></a>             */ 
<a name="660"></a>            local objList = obj.contents.subset({x: x.mentioned == nil &amp;&amp;
<a name="661"></a>                                                x.isVisibleFrom(pov)});
<a name="662"></a>            
<a name="663"></a>            
<a name="664"></a>            /* 
<a name="665"></a>             *   Extract the list of items that have active specialDescs or
<a name="666"></a>             *   initSpecial Descs
<a name="667"></a>             */
<a name="668"></a>            local firstSpecialList = objList.subset(
<a name="669"></a>                {o: (o.propType(&amp;specialDesc) != TypeNil &amp;&amp; o.useSpecialDesc())
<a name="670"></a>                || (o.propType(&amp;initSpecialDesc) != TypeNil &amp;&amp;
<a name="671"></a>                    o.useInitSpecialDesc() )
<a name="672"></a>                }
<a name="673"></a>                );
<a name="674"></a>            
<a name="675"></a>            
<a name="676"></a>            /* 
<a name="677"></a>             *   Remove items with specialDescs or initSpecialDescs from the
<a name="678"></a>             *   list of miscellaneous items.
<a name="679"></a>             */
<a name="680"></a>            objList = objList - firstSpecialList;
<a name="681"></a>            
<a name="682"></a>            
<a name="683"></a>            /*   
<a name="684"></a>             *   From the list of items with specialDescs, extract those whose
<a name="685"></a>             *   specialDescs should be listed after any miscellaneous items
<a name="686"></a>             */
<a name="687"></a>            local secondSpecialList = firstSpecialList.subset(
<a name="688"></a>                { o: o.specialDescBeforeContents == nil });
<a name="689"></a>            
<a name="690"></a>            
<a name="691"></a>            /* 
<a name="692"></a>             *   Remove the items whose specialDescs should be listed after the
<a name="693"></a>             *   miscellaneous items from the list of all items with
<a name="694"></a>             *   specialDescs to give the list of items with specialDescs that
<a name="695"></a>             *   should be listed before the miscellaneous items.
<a name="696"></a>             */
<a name="697"></a>            firstSpecialList = firstSpecialList - secondSpecialList;
<a name="698"></a>            
<a name="699"></a>            /*   
<a name="700"></a>             *   Sort the list of items with specialDescs to be displayed before
<a name="701"></a>             *   miscellaneous items by specialDescOrder
<a name="702"></a>             */
<a name="703"></a>            firstSpecialList = firstSpecialList.sort(nil, {a, b: a.specialDescOrder -
<a name="704"></a>                b.specialDescOrder});
<a name="705"></a>            
<a name="706"></a>            /*   
<a name="707"></a>             *   Sort the list of items with specialDescs to be displayed after
<a name="708"></a>             *   miscellaneous items by specialDescOrder
<a name="709"></a>             */
<a name="710"></a>            secondSpecialList = secondSpecialList.sort(nil, {a, b: a.specialDescOrder -
<a name="711"></a>                b.specialDescOrder});
<a name="712"></a>            
<a name="713"></a>            
<a name="714"></a>            /*  
<a name="715"></a>             *   Show the specialDescs of items whose specialDescs should be
<a name="716"></a>             *   shown before the list of miscellaneous items.
<a name="717"></a>             */
<a name="718"></a>            foreach(local cur in firstSpecialList)                    
<a name="719"></a>                cur.showRemoteSpecialDesc(pov); 
<a name="720"></a>            
<a name="721"></a>            
<a name="722"></a>            /*   List the miscellaneous items */
<a name="723"></a>            if(objList.length &gt; 0)   
<a name="724"></a>            {
<a name="725"></a>                lister.show(objList, obj.remoteObjInName(pov),
<a name="726"></a>                            paraBrksBtwnSubcontents);                      
<a name="727"></a>                objList.forEach({o: o.mentioned = true });
<a name="728"></a>            }
<a name="729"></a>            
<a name="730"></a>            /* 
<a name="731"></a>             *   If we're not putting paragraph breaks between each subcontents
<a name="732"></a>             *   listing sentence, insert a space instead.
<a name="733"></a>             */
<a name="734"></a>            if(!paraBrksBtwnSubcontents)
<a name="735"></a>                " ";
<a name="736"></a>            
<a name="737"></a>            
<a name="738"></a>            /*  
<a name="739"></a>             *   Show the specialDescs of items whose specialDescs should be
<a name="740"></a>             *   shown after the list of miscellaneous items.
<a name="741"></a>             */
<a name="742"></a>            foreach(local cur in secondSpecialList)        
<a name="743"></a>                cur.showRemoteSpecialDesc(pov); 
<a name="744"></a>            
<a name="745"></a>            
<a name="746"></a>            /* 
<a name="747"></a>             *   Recursively list the contents of each item in this object's
<a name="748"></a>             *   contents, if it has any; but don't list recursively for an
<a name="749"></a>             *   object that's just been opened.
<a name="750"></a>             */
<a name="751"></a>            if(obj.contents.length &gt; 0 &amp;&amp; lister != openingContentsLister)
<a name="752"></a>                listRemoteContents(obj.contents, lister, pov);     
<a name="753"></a>            
<a name="754"></a>           
<a name="755"></a>            
<a name="756"></a>        }
<a name="757"></a>        
<a name="758"></a>         
<a name="759"></a>    }
<a name="760"></a>        
<a name="761"></a>        
<a name="762"></a> 
<a name="763"></a>    
<a name="764"></a>    
<a name="765"></a>    /* 
<a name="766"></a>     *   Our remoteSpecialDesc is the paragraph describing this item in a room
<a name="767"></a>     *   description when viewed from a remote location containing the pov
<a name="768"></a>     *   object. By default we just show our ordinary specialDesc, but in
<a name="769"></a>     *   practice we'll normally want to override this.
<a name="770"></a>     */    
<a name="771"></a>    remoteSpecialDesc(pov) { specialDesc; }
<a name="772"></a>    
<a name="773"></a>    /*  
<a name="774"></a>     *   Our remoteInitSpecialDesc, used when viewing this item from a remote
<a name="775"></a>     *   location.By default we just show our ordinary initSpecialDesc, but in
<a name="776"></a>     *   practice we'll normally want to override this.
<a name="777"></a>     */    
<a name="778"></a>    remoteInitSpecialDesc(pov) { initSpecialDesc; }
<a name="779"></a>    
<a name="780"></a>    /* 
<a name="781"></a>     *   Is this item visible from the remote location containing pov? By
<a name="782"></a>     *   default it is if it's sightSize is not small, but this can be
<a name="783"></a>     *   overridden, for example to vary with the pov.
<a name="784"></a>     */
<a name="785"></a>    isVisibleFrom(pov) { return sightSize != small; }
<a name="786"></a>    
<a name="787"></a>    
<a name="788"></a>    /* 
<a name="789"></a>     *   Is this item audible from the remote location containing pov? By
<a name="790"></a>     *   default it is if it's soundSize is not small, but this can be
<a name="791"></a>     *   overridden, for example to vary with the pov.
<a name="792"></a>     */
<a name="793"></a>    isAudibleFrom(pov) { return soundSize != small; }
<a name="794"></a>    
<a name="795"></a>    /* 
<a name="796"></a>     *   Is this item smellable from the remote location containing pov? By
<a name="797"></a>     *   default it is if it's smellSize is not small, but this can be
<a name="798"></a>     *   overridden, for example to vary with the pov.
<a name="799"></a>     */
<a name="800"></a>    isSmellableFrom(pov) { return smellSize != small; }
<a name="801"></a>    
<a name="802"></a>    
<a name="803"></a>    /* 
<a name="804"></a>     *   Assuming this item is readable at all, is it readable from the remote
<a name="805"></a>     *   location containing pov? By default we assume this is the case if and
<a name="806"></a>     *   only if the item's sightSize is large, but this can be overridden, for
<a name="807"></a>     *   example for a large item with small lettering.
<a name="808"></a>     */
<a name="809"></a>    isReadableFrom(pov) { return sightSize == large; }
<a name="810"></a>           
<a name="811"></a>    /*   
<a name="812"></a>     *   The sightSize can be small, medium or large and controls how visible
<a name="813"></a>     *   this object is from a remote location. If it's small, it can't be seen
<a name="814"></a>     *   from a remote location at all. It it's medium, the object can be seen,
<a name="815"></a>     *   but it's not possible to discern any detail. If it's large, it can be
<a name="816"></a>     *   seen and described. Note that this behaviour is only the default,
<a name="817"></a>     *   however, since it can be changed by overriding the isVisibleFrom() and
<a name="818"></a>     *   remoteDesc() methods. Note also that sightSize is not related to the
<a name="819"></a>     *   bulk property (unless you override sightSize to make it so).
<a name="820"></a>     */
<a name="821"></a>    sightSize = medium
<a name="822"></a>    
<a name="823"></a>    /* 
<a name="824"></a>     *   The soundSize can be small, medium or large. By default something is
<a name="825"></a>     *   audible from a remote location either if its soundSize is large or if
<a name="826"></a>     *   it soundSize is not small and its remoteListenDesc() method has been
<a name="827"></a>     *   defined. Overriding isAudibleFrom(pov) may change these rules.
<a name="828"></a>     */         
<a name="829"></a>    soundSize = medium
<a name="830"></a>    
<a name="831"></a>    /* 
<a name="832"></a>     *   The smellSize can be small, medium or large. By default something is
<a name="833"></a>     *   smellable from a remote location either if its smellSize is large or if
<a name="834"></a>     *   it smellSize is not small and its remoteSmellDesc() method has been
<a name="835"></a>     *   defined. Overriding isSmellableFrom(pov) may change these rules.
<a name="836"></a>     */
<a name="837"></a>    smellSize = medium
<a name="838"></a>    
<a name="839"></a>    
<a name="840"></a>    /* 
<a name="841"></a>     *   The following three properties only take effect on objects on which
<a name="842"></a>     *   they're explicitly defined.
<a name="843"></a>     */
<a name="844"></a>    
<a name="845"></a>    /*  
<a name="846"></a>     *   Define the remoteDesc() property to define the description of this item
<a name="847"></a>     *   as it should be displayed when the item is examined from the remote
<a name="848"></a>     *   location containing the pov object. Note that defining this property
<a name="849"></a>     *   nullifies the distinction between a medium and a large sightSize, since
<a name="850"></a>     *   the remoteDesc will be used in either case.
<a name="851"></a>     */
<a name="852"></a>// remoteDesc(pov) { desc; }
<a name="853"></a>    
<a name="854"></a>    
<a name="855"></a>    
<a name="856"></a>    /*  
<a name="857"></a>     *   Define the remoteListenDesc() property to define the description of
<a name="858"></a>     *   this item as it should be displayed when the item is listened to from
<a name="859"></a>     *   the remote location containing the pov object. Note that defining this
<a name="860"></a>     *   property nullifies the distinction between a medium and a large
<a name="861"></a>     *   soundSize, since the remoteListenDesc will be used in either case.
<a name="862"></a>     */
<a name="863"></a>// remoteListenDesc(pov) { listenDesc; }
<a name="864"></a>    
<a name="865"></a>    
<a name="866"></a>    /*  
<a name="867"></a>     *   Define the remoteSmellDesc() property to define the description of this
<a name="868"></a>     *   item as it should be displayed when the item is smelled from the remote
<a name="869"></a>     *   location containing the pov object. Note that defining this property
<a name="870"></a>     *   nullifies the distinction between a medium and a large smellSize, since
<a name="871"></a>     *   the remoteSmellDesc will be used in either case.
<a name="872"></a>     */
<a name="873"></a>// remoteSmellDesc(pov) { smellDesc; }
<a name="874"></a>    
<a name="875"></a>    /*   
<a name="876"></a>     *   The name given to this object when it's the container for another
<a name="877"></a>     *   object viewed remotely, e.g. 'in the distant bucket' as opposed to just
<a name="878"></a>     *   'in the bucket'. By default we just use the objInName.
<a name="879"></a>     */
<a name="880"></a>    remoteObjInName(pov) { return objInName; }
<a name="881"></a>    
<a name="882"></a>    
<a name="883"></a>    /* 
<a name="884"></a>     *   Modify the effect of Examine to show the remoteDesc if appropriate, or
<a name="885"></a>     *   else our regular desc if our sightSize is large, or else a message to
<a name="886"></a>     *   say we're too far away to see any detail. If we're in the same room as
<a name="887"></a>     *   the actor, simply carry out the regular (inherited) method.
<a name="888"></a>     */
<a name="889"></a>    dobjFor(Examine)
<a name="890"></a>    {
<a name="891"></a>        action()
<a name="892"></a>        {
<a name="893"></a>            /* 
<a name="894"></a>             *   If the actor doing the examining is in the same room as this
<a name="895"></a>             *   object, simply carry out the inherited handling.
<a name="896"></a>             */
<a name="897"></a>            if(isIn(gActor.getOutermostRoom))
<a name="898"></a>                inherited;
<a name="899"></a>            
<a name="900"></a>            /* Otherwise, if we're being examined from a remote location... */
<a name="901"></a>            else
<a name="902"></a>            {
<a name="903"></a>                /* 
<a name="904"></a>                 *   If this Thing defines the remoteDesc() property, display
<a name="905"></a>                 *   our remoteDesc() from the pov of the examining actor.
<a name="906"></a>                 */
<a name="907"></a>                if(propDefined(&amp;remoteDesc))
<a name="908"></a>                {
<a name="909"></a>                    remoteDesc(gActor);
<a name="910"></a>                    "&lt;.p&gt;";
<a name="911"></a>                }
<a name="912"></a>                
<a name="913"></a>                /* 
<a name="914"></a>                 *   Otherwise if our sightSize is large, carry out the standard
<a name="915"></a>                 *   (inherited) handling
<a name="916"></a>                 */
<a name="917"></a>                else if(sightSize == large)
<a name="918"></a>                    inherited;
<a name="919"></a>                
<a name="920"></a>                /* 
<a name="921"></a>                 *   Otherwise say this object is too far away for the actor to
<a name="922"></a>                 *   see any detail.
<a name="923"></a>                 */
<a name="924"></a>                else
<a name="925"></a>                {
<a name="926"></a>                    say(tooFarAwayToSeeDetailMsg);
<a name="927"></a>                    "&lt;.p&gt;";
<a name="928"></a>                }
<a name="929"></a>            }
<a name="930"></a>        }
<a name="931"></a>    }
<a name="932"></a>    
<a name="933"></a>    tooFarAwayToSeeDetailMsg = BMsg(too far away to see detail, '{The subj dobj}
<a name="934"></a>        {is} too far away to make out any detail. ')
<a name="935"></a>    
<a name="936"></a>    /* 
<a name="937"></a>     *   Modify the effect of ListenTo to show the remoteListenDesc if
<a name="938"></a>     *   appropriate, or else our regular listenDesc if our soundSize is large,
<a name="939"></a>     *   or else a message to say we're too far away to hear. If we're in the
<a name="940"></a>     *   same room as the actor, simply carry out the regular (inherited)
<a name="941"></a>     *   method.
<a name="942"></a>     */
<a name="943"></a>    dobjFor(ListenTo)
<a name="944"></a>    {
<a name="945"></a>        action()
<a name="946"></a>        {
<a name="947"></a>            /* 
<a name="948"></a>             *   If the actor doing the listening is in the same room as this
<a name="949"></a>             *   object, simply carry out the inherited handling.
<a name="950"></a>             */
<a name="951"></a>            if(isIn(gActor.getOutermostRoom))
<a name="952"></a>                inherited;
<a name="953"></a>            
<a name="954"></a>            /* Otherwise, if we're being listened to from a remote location... */
<a name="955"></a>            else
<a name="956"></a>            {
<a name="957"></a>                /* 
<a name="958"></a>                 *   If this Thing defines the remoteListenDesc() property,
<a name="959"></a>                 *   display our remoteListenDesc() from the pov of the
<a name="960"></a>                 *   examining actor.
<a name="961"></a>                 */
<a name="962"></a>                if(propDefined(&amp;remoteListenDesc))
<a name="963"></a>                {
<a name="964"></a>                    remoteListenDesc(gActor);
<a name="965"></a>                    "&lt;.p&gt;";                   
<a name="966"></a>                }
<a name="967"></a>                
<a name="968"></a>                /* 
<a name="969"></a>                 *   Otherwise if our soundSize is large, carry out the standard
<a name="970"></a>                 *   (inherited) handling
<a name="971"></a>                 */
<a name="972"></a>                else if(soundSize == large)
<a name="973"></a>                    inherited;
<a name="974"></a>                
<a name="975"></a>                /* 
<a name="976"></a>                 *   Otherwise say this object is too far away for the actor to
<a name="977"></a>                 *   hear.
<a name="978"></a>                 */
<a name="979"></a>                else
<a name="980"></a>                {
<a name="981"></a>                    say(tooFarAwayToHearMsg);
<a name="982"></a>                    "&lt;.p&gt;";
<a name="983"></a>                }
<a name="984"></a>            }
<a name="985"></a>        }
<a name="986"></a>    }
<a name="987"></a>
<a name="988"></a>    tooFarAwayToHearMsg = BMsg(too far away to hear, '{The subj dobj} {is} too
<a name="989"></a>        far away to hear distinctly. ')
<a name="990"></a>
<a name="991"></a>    
<a name="992"></a>    /* 
<a name="993"></a>     *   Modify the effect of a Read action to prevent this item being read from
<a name="994"></a>     *   a remote location unless isReadableFrom(gActor) is true.
<a name="995"></a>     */    
<a name="996"></a>    dobjFor(Read)
<a name="997"></a>    {
<a name="998"></a>        verify()
<a name="999"></a>        {
<a name="1000"></a>            inherited;
<a name="1001"></a>            
<a name="1002"></a>            if(!isIn(gActor.getOutermostRoom) &amp;&amp; !isReadableFrom(gActor))
<a name="1003"></a>                illogicalNow(tooFarAwayToReadMsg);
<a name="1004"></a>        }
<a name="1005"></a>    }
<a name="1006"></a>    
<a name="1007"></a>    tooFarAwayToReadMsg = BMsg(too far away to read, '{The subj dobj} {is} too
<a name="1008"></a>        far away to read. ')
<a name="1009"></a>
<a name="1010"></a>    /* 
<a name="1011"></a>     *   Modify the effect of SmellSomething to show the remoteSmellDesc if
<a name="1012"></a>     *   appropriate, or else our regular smellDesc if our smellSize is large,
<a name="1013"></a>     *   or else a message to say we're too far away to smell. If we're in the
<a name="1014"></a>     *   same room as the actor, simply carry out the regular (inherited)
<a name="1015"></a>     *   method.
<a name="1016"></a>     */
<a name="1017"></a>    dobjFor(SmellSomething)
<a name="1018"></a>    {
<a name="1019"></a>        action()
<a name="1020"></a>        {
<a name="1021"></a>            /* 
<a name="1022"></a>             *   If the actor doing the smelling is in the same room as this
<a name="1023"></a>             *   object, simply carry out the inherited handling.
<a name="1024"></a>             */
<a name="1025"></a>            if(isIn(gActor.getOutermostRoom))
<a name="1026"></a>                inherited;
<a name="1027"></a>            
<a name="1028"></a>            /* Otherwise, if we're being smelled from a remote location... */
<a name="1029"></a>            else
<a name="1030"></a>            {
<a name="1031"></a>                /* 
<a name="1032"></a>                 *   If this Thing defines the remoteSmellDesc() property,
<a name="1033"></a>                 *   display our remoteSmellDesc() from the pov of the
<a name="1034"></a>                 *   examining actor.
<a name="1035"></a>                 */                
<a name="1036"></a>                if(propDefined(&amp;remoteSmellDesc))
<a name="1037"></a>                {
<a name="1038"></a>                    remoteSmellDesc(gActor);
<a name="1039"></a>                    "&lt;.p&gt;";
<a name="1040"></a>                }
<a name="1041"></a>                
<a name="1042"></a>                /* 
<a name="1043"></a>                 *   Otherwise if our smellSize is large, carry out the standard
<a name="1044"></a>                 *   (inherited) handling
<a name="1045"></a>                 */
<a name="1046"></a>                else if(smellSize == large)
<a name="1047"></a>                    inherited;
<a name="1048"></a>                
<a name="1049"></a>                /* 
<a name="1050"></a>                 *   Otherwise say this object is too far away for the actor to
<a name="1051"></a>                 *   smell.
<a name="1052"></a>                 */
<a name="1053"></a>                else
<a name="1054"></a>                {
<a name="1055"></a>                    say(tooFarAwayToSmellMsg);
<a name="1056"></a>                    "&lt;.p&gt;";
<a name="1057"></a>                }
<a name="1058"></a>            }
<a name="1059"></a>        }
<a name="1060"></a>    }
<a name="1061"></a>    
<a name="1062"></a>    tooFarAwayToSmellMsg = BMsg(too far away to smell, '{The subj dobj} {is} too
<a name="1063"></a>        far away to smell distinctly. ')
<a name="1064"></a>    
<a name="1065"></a>    /* Modify the effects of throwing something at this object */
<a name="1066"></a>    iobjFor(ThrowAt)
<a name="1067"></a>    {
<a name="1068"></a>        action()
<a name="1069"></a>        {
<a name="1070"></a>            /* 
<a name="1071"></a>             *   If the Query object reckons that the throw is possible, carry
<a name="1072"></a>             *   out the inherited handling.
<a name="1073"></a>             */
<a name="1074"></a>            if(Q.canThrowTo(gActor, self))
<a name="1075"></a>                inherited;
<a name="1076"></a>            
<a name="1077"></a>            /* 
<a name="1078"></a>             *   Otherwise move the direct object to the throwing actor's room
<a name="1079"></a>             *   and display a message saying it fell short of its target.
<a name="1080"></a>             */
<a name="1081"></a>            else
<a name="1082"></a>            {
<a name="1083"></a>                gDobj.moveInto(gActor.getOutermostRoom);
<a name="1084"></a>                say(throwFallsShortMsg);
<a name="1085"></a>            }
<a name="1086"></a>        }
<a name="1087"></a>    }    
<a name="1088"></a>    
<a name="1089"></a>    /*         
<a name="1090"></a>     *   For certain actions like EXAMINE there's no point trying to carry them
<a name="1091"></a>     *   out on something that can't be seen (remotely) if there are other
<a name="1092"></a>     *   things that can be seen that matched the player's command.
<a name="1093"></a>     */
<a name="1094"></a>    filterResolveList(np, cmd, mode) 
<a name="1095"></a>    { 
<a name="1096"></a>        inherited(np, cmd, mode);
<a name="1097"></a>        
<a name="1098"></a>        local loc = gActor.getOutermostRoom, prop;
<a name="1099"></a>        
<a name="1100"></a>        /* 
<a name="1101"></a>         *   If we haven't been picked up by a general command that may not have
<a name="1102"></a>         *   been intended to apply specifically to us, or we're in the same
<a name="1103"></a>         *   room as the actor, we don'd need to do any filtering, so stop here.
<a name="1104"></a>         */
<a name="1105"></a>        if(mode != All || isIn(loc))
<a name="1106"></a>            return;        
<a name="1107"></a>        
<a name="1108"></a>        /*   
<a name="1109"></a>         *   Determine which precondition property we need to look at according
<a name="1110"></a>         *   to our object role.
<a name="1111"></a>         */
<a name="1112"></a>        switch(np.role)
<a name="1113"></a>        {
<a name="1114"></a>        case DirectObject:
<a name="1115"></a>            prop = cmd.action.preCondDobjProp;
<a name="1116"></a>            break;
<a name="1117"></a>        case IndirectObject:
<a name="1118"></a>            prop = cmd.action.preCondIobjProp;
<a name="1119"></a>            break;
<a name="1120"></a>        case AccessoryObject:
<a name="1121"></a>            prop = cmd.action.preCondIobjProp;
<a name="1122"></a>            break;
<a name="1123"></a>        default:
<a name="1124"></a>            prop = cmd.action.preCondDobjProp;
<a name="1125"></a>        }
<a name="1126"></a>            
<a name="1127"></a>            
<a name="1128"></a>        /* 
<a name="1129"></a>         *   If the current action requires the object to be visible, and we're
<a name="1130"></a>         *   not in the same room as the actor, and the actor can't see us, but
<a name="1131"></a>         *   the actor can see something else among the possible matches, remove
<a name="1132"></a>         *   us from the list of matches.
<a name="1133"></a>         */
<a name="1134"></a>        if(valToList(self.(prop)).indexOf(objVisible)             
<a name="1135"></a>           &amp;&amp; !gActor.canSee(self)
<a name="1136"></a>           &amp;&amp; np.matches.indexWhich({m: gActor.canSee(m.obj)}))
<a name="1137"></a>           np.matches = np.matches.subset({m: m.obj != self});   
<a name="1138"></a>        
<a name="1139"></a>        
<a name="1140"></a>        /* 
<a name="1141"></a>         *   If the current action requires the object to be touchabble, and
<a name="1142"></a>         *   we're not in the same room as the actor, and the actor can't reach
<a name="1143"></a>         *   us, but the actor can reach something else among the possible
<a name="1144"></a>         *   matches, remove us from the list of matches.
<a name="1145"></a>         */
<a name="1146"></a>        if(valToList(self.(prop)).indexOf(touchObj)
<a name="1147"></a>           &amp;&amp; np.matches.indexWhich({m: m.obj.isIn(loc)}))
<a name="1148"></a>           np.matches = np.matches.subset({m: m.obj != self}); 
<a name="1149"></a>        
<a name="1150"></a>    }
<a name="1151"></a>    
<a name="1152"></a>    /* 
<a name="1153"></a>     *   Are our contents visible remotely from pov? By default we'll assume they are, but in some
<a name="1154"></a>     *   case they mignt not be, for example if the remote viewing location is too far away or the
<a name="1155"></a>     *   viewing angle from the remote location wouldn't allow seeing into us.
<a name="1156"></a>     */
<a name="1157"></a>    contentsVisibleFrom(pov) { return true; }
<a name="1158"></a>    
<a name="1159"></a>    /* 
<a name="1160"></a>     *   Should our contents be listed in an examine command from a remote location? They should be
<a name="1161"></a>     *   if we meet the inherited conditions (normally contentsListedInExamine == true) and our
<a name="1162"></a>     *   contents are visible remotely from the actor's POV or the actor is in the same room as us.
<a name="1163"></a>     */
<a name="1164"></a>    areContentsListedInExamine()
<a name="1165"></a>    {
<a name="1166"></a>        return inherited &amp;&amp; (contentsVisibleFrom(gActor) || getOutermostRoom ==
<a name="1167"></a>                             gActor.getOutermostRoom);
<a name="1168"></a>    }
<a name="1169"></a>     
<a name="1170"></a>    dobjFor(LookIn)
<a name="1171"></a>    {
<a name="1172"></a>        check()
<a name="1173"></a>        {
<a name="1174"></a>            inherited();
<a name="1175"></a>            
<a name="1176"></a>            /* 
<a name="1177"></a>             *   The actor can't look into us from a remote location if our contents aren't visible
<a name="1178"></a>             *   from their POV.
<a name="1179"></a>             */
<a name="1180"></a>            if(gActor.getOutermostRoom != getOutermostRoom &amp;&amp;
<a name="1181"></a>               ! contentsVisibleFrom(gActor))
<a name="1182"></a>                DMsg(cant see in from here, '{I} {can\'t} see in {the dobj} from {here}.');
<a name="1183"></a>        }
<a name="1184"></a>    }
<a name="1185"></a>    
<a name="1186"></a>    
<a name="1187"></a>;
<a name="1188"></a>
<a name="1189"></a>
<a name="1190"></a>/* 
<a name="1191"></a> *   The scopeProbe_ is a dummy object used by the SenseRegion class to add
<a name="1192"></a> *   items from Pther rooms in the SenseRegion to scope.
<a name="1193"></a> */
<a name="1194"></a>scopeProbe_: Thing
<a name="1195"></a>;
<a name="1196"></a>
<a name="1197"></a>/* 
<a name="1198"></a> *   Modifications to the (intransitive) Smell and Listen actions to list remote
<a name="1199"></a> *   smells and sounds
<a name="1200"></a> */
<a name="1201"></a>modify Smell
<a name="1202"></a>    /* 
<a name="1203"></a>     *   Return a list of items in remote locations that can be smelt from the
<a name="1204"></a>     *   current actor's location.
<a name="1205"></a>     */
<a name="1206"></a>    getRemoteSmellList() 
<a name="1207"></a>    { 
<a name="1208"></a>        /* Note the actor's location */
<a name="1209"></a>        local loc = gActor.getOutermostRoom;
<a name="1210"></a>        
<a name="1211"></a>        /* Create a new vector */
<a name="1212"></a>        local vec = new Vector(10);
<a name="1213"></a>        
<a name="1214"></a>        /* 
<a name="1215"></a>         *   Go through all the rooms that can be smelled from the actor's
<a name="1216"></a>         *   location
<a name="1217"></a>         */
<a name="1218"></a>        foreach(local rm in loc.smellableRooms)
<a name="1219"></a>        {
<a name="1220"></a>            
<a name="1221"></a>            /* 
<a name="1222"></a>             *   Create a list of objects that are in rm that can be smelt by
<a name="1223"></a>             *   the actor.
<a name="1224"></a>             */
<a name="1225"></a>            local sList = rm.allContents.subset({o: Q.canSmell(gActor, o)});
<a name="1226"></a>            
<a name="1227"></a>            /* 
<a name="1228"></a>             *   Create a sublist of that list containing all the items with a
<a name="1229"></a>             *   large smellSize that also define a non-nil smellDesc, plus all
<a name="1230"></a>             *   the items that define a remoteSmellDesc, in each case provided
<a name="1231"></a>             *   that the item's isProminentSmell is true. Remove any item (i.e.
<a name="1232"></a>             *   MultiLoc) that's also in the actor's location, so that it's not
<a name="1233"></a>             *   duplicated. Then append this sublist to our vector.
<a name="1234"></a>             */
<a name="1235"></a>            vec.appendUnique(sList.subset({o: ((o.smellSize == large &amp;&amp;
<a name="1236"></a>                                            o.checkDisplay(&amp;smellDesc) != nil) ||
<a name="1237"></a>                                       o.propDefined(&amp;remoteSmellDesc))
<a name="1238"></a>                                       &amp;&amp; o.isProminentSmell
<a name="1239"></a>                                          &amp;&amp; !o.isOrIsIn(loc)} ));
<a name="1240"></a>        }
<a name="1241"></a>        
<a name="1242"></a>        
<a name="1243"></a>        /* Convert the vector to a list and return it. */
<a name="1244"></a>        return vec.toList();
<a name="1245"></a>    }
<a name="1246"></a>    
<a name="1247"></a>    /* List smells in remote locations */
<a name="1248"></a>    listRemoteSmells(lst) 
<a name="1249"></a>    { 
<a name="1250"></a>        local somethingDisplayed = nil;
<a name="1251"></a>        local remoteDisplayed = nil;
<a name="1252"></a>        
<a name="1253"></a>        /* For each item in lst */
<a name="1254"></a>        foreach(local cur in lst)
<a name="1255"></a>        {
<a name="1256"></a>            /* If the item defined a remoteSmellDesc property, display it */
<a name="1257"></a>            if(cur.propDefined(&amp;remoteSmellDesc))
<a name="1258"></a>            {
<a name="1259"></a>                remoteDisplayed = gOutStream.watchForOutput(
<a name="1260"></a>                    {:
<a name="1261"></a>                    cur.remoteSmellDesc(gActor)
<a name="1262"></a>                    });
<a name="1263"></a>                
<a name="1264"></a>                if(remoteDisplayed)
<a name="1265"></a>                {
<a name="1266"></a>                    somethingDisplayed = true;
<a name="1267"></a>                    
<a name="1268"></a>                    /* 
<a name="1269"></a>                     *   If the actor is the player character, the player
<a name="1270"></a>                     *   character now knows of the existence of this object.
<a name="1271"></a>                     */
<a name="1272"></a>                    if(gActor == gPlayerChar)
<a name="1273"></a>                        setKnown(cur);
<a name="1274"></a>                }
<a name="1275"></a>                
<a name="1276"></a>            }
<a name="1277"></a>            
<a name="1278"></a>            /* Othewise display its smellDesc */
<a name="1279"></a>            else
<a name="1280"></a>            {
<a name="1281"></a>                if(cur.display(&amp;smellDesc))
<a name="1282"></a>                {
<a name="1283"></a>                    somethingDisplayed = true;
<a name="1284"></a>                    
<a name="1285"></a>                    /* 
<a name="1286"></a>                     *   If the actor is the player character, the player
<a name="1287"></a>                     *   character now knows of the existence of this object.
<a name="1288"></a>                     */
<a name="1289"></a>                    if(gActor == gPlayerChar)
<a name="1290"></a>                        setKnown(cur);
<a name="1291"></a>                }
<a name="1292"></a>            }
<a name="1293"></a>        }
<a name="1294"></a>        
<a name="1295"></a>        /* Tell our caller whether we actually displayed anything */
<a name="1296"></a>        return somethingDisplayed;
<a name="1297"></a>    }
<a name="1298"></a>    
<a name="1299"></a>    
<a name="1300"></a>;
<a name="1301"></a>
<a name="1302"></a>    /* 
<a name="1303"></a>     *   Return a list of items in remote locations that can be heard from the
<a name="1304"></a>     *   current actor's location.
<a name="1305"></a>     */
<a name="1306"></a>
<a name="1307"></a>modify Listen
<a name="1308"></a>    /* 
<a name="1309"></a>     *   Return a list of items in remote locations that can be heard from the
<a name="1310"></a>     *   current actor's location.
<a name="1311"></a>     */    
<a name="1312"></a>    getRemoteSoundList() 
<a name="1313"></a>    { 
<a name="1314"></a>        /* Note the actor's location */
<a name="1315"></a>        local loc = gActor.getOutermostRoom;
<a name="1316"></a>        
<a name="1317"></a>        /* Create a new vector */
<a name="1318"></a>        local vec = new Vector(10);
<a name="1319"></a>        
<a name="1320"></a>        /* 
<a name="1321"></a>         *   Go through all the rooms that can be heard from the actor's
<a name="1322"></a>         *   location
<a name="1323"></a>         */
<a name="1324"></a>        foreach(local rm in loc.audibleRooms)
<a name="1325"></a>        {
<a name="1326"></a>           
<a name="1327"></a>            /* 
<a name="1328"></a>             *   Create a list of objects in the room that can be heard by the
<a name="1329"></a>             *   actor.
<a name="1330"></a>             */
<a name="1331"></a>            local sList = rm.allContents.subset({o: Q.canHear(gActor, o)});
<a name="1332"></a>            
<a name="1333"></a>            /* 
<a name="1334"></a>             *   Create a sublist of that list containing all the items with a
<a name="1335"></a>             *   large soundSize that also define a non-nil listenDesc, plus all
<a name="1336"></a>             *   the items that define a remoteListenDesc, in each case provided
<a name="1337"></a>             *   that the item's isProminentNoise is true. Remove any item (i.e.
<a name="1338"></a>             *   MultiLoc) that's also in the actor's location, so that it's not
<a name="1339"></a>             *   duplicated. Then append this sublist to our vector.
<a name="1340"></a>             */
<a name="1341"></a>            vec.appendUnique(sList.subset({o: ((o.soundSize == large &amp;&amp;
<a name="1342"></a>                                       o.checkDisplay(&amp;listenDesc) != nil) ||
<a name="1343"></a>                                       o.propDefined(&amp;remoteListenDesc))
<a name="1344"></a>                                       &amp;&amp; o.isProminentNoise
<a name="1345"></a>                                          &amp;&amp; !o.isOrIsIn(loc)} ));
<a name="1346"></a>        }
<a name="1347"></a>        
<a name="1348"></a>       
<a name="1349"></a>        /* Convert the vector to a list and return it. */
<a name="1350"></a>        return vec.toList();
<a name="1351"></a>    }
<a name="1352"></a>    
<a name="1353"></a>    
<a name="1354"></a>    
<a name="1355"></a>    /* List smells in remote locations */
<a name="1356"></a>    listRemoteSounds(lst) 
<a name="1357"></a>    { 
<a name="1358"></a>        local somethingDisplayed = nil;
<a name="1359"></a>        local remoteDisplayed = nil;
<a name="1360"></a>        
<a name="1361"></a>         /* For each item in lst */
<a name="1362"></a>        foreach(local cur in lst)
<a name="1363"></a>        {
<a name="1364"></a>            /* If the item defined a remoteListenDesc property, display it */
<a name="1365"></a>            if(cur.propDefined(&amp;remoteListenDesc))
<a name="1366"></a>            {
<a name="1367"></a>                remoteDisplayed = gOutStream.watchForOutput(
<a name="1368"></a>                    {:
<a name="1369"></a>                    cur.remoteListenDesc(gActor)
<a name="1370"></a>                    });
<a name="1371"></a>                
<a name="1372"></a>                if(remoteDisplayed)
<a name="1373"></a>                {
<a name="1374"></a>                    somethingDisplayed = true;
<a name="1375"></a>                    
<a name="1376"></a>                    /* 
<a name="1377"></a>                     *   If the actor is the player character, the player
<a name="1378"></a>                     *   character now knows of the existence of this object.
<a name="1379"></a>                     */
<a name="1380"></a>                    if(gActor == gPlayerChar)
<a name="1381"></a>                        setKnown(cur);
<a name="1382"></a>                }
<a name="1383"></a>            }
<a name="1384"></a>            
<a name="1385"></a>            /* Othewise display its listenDesc */
<a name="1386"></a>            else
<a name="1387"></a>            {
<a name="1388"></a>                if(cur.displayAlt(&amp;listenDesc))
<a name="1389"></a>                {
<a name="1390"></a>                    somethingDisplayed = true;
<a name="1391"></a>                    
<a name="1392"></a>                    /* 
<a name="1393"></a>                     *   If the actor is the player character, the player
<a name="1394"></a>                     *   character now knows of the existence of this object.
<a name="1395"></a>                     */
<a name="1396"></a>                    if(gActor == gPlayerChar)
<a name="1397"></a>                        setKnown(cur);
<a name="1398"></a>                }
<a name="1399"></a>            }
<a name="1400"></a>        }
<a name="1401"></a>        
<a name="1402"></a>        /* Tell our caller whether we actually displayed anything */
<a name="1403"></a>        return somethingDisplayed;
<a name="1404"></a>    }      
<a name="1405"></a>;
<a name="1406"></a>
<a name="1407"></a>modify SmellSomething
<a name="1408"></a>    /* Add any Odors the actor can smell */
<a name="1409"></a>    addExtraScopeItems(whichRole?)
<a name="1410"></a>    {
<a name="1411"></a>        inherited(whichRole);
<a name="1412"></a>        
<a name="1413"></a>        local odorList = [];
<a name="1414"></a>        for(local rm in gActor.getOutermostRoom.smellableRooms)            
<a name="1415"></a>            odorList += rm.allContents.subset(
<a name="1416"></a>            { o: o.ofKind(Odor) &amp;&amp; Q.canSmell(gActor, o) } );
<a name="1417"></a>        
<a name="1418"></a>        scopeList = scopeList.appendUnique(odorList);
<a name="1419"></a>    }
<a name="1420"></a>;
<a name="1421"></a>
<a name="1422"></a>modify ListenTo
<a name="1423"></a>    /* Add any Noises the actor can hear */
<a name="1424"></a>    addExtraScopeItems(whichRole?)
<a name="1425"></a>    {
<a name="1426"></a>        inherited(whichRole);
<a name="1427"></a>        
<a name="1428"></a>        local noiseList = [];
<a name="1429"></a>        for(local rm in gActor.getOutermostRoom.audibleRooms)            
<a name="1430"></a>            noiseList += rm.allContents.subset(
<a name="1431"></a>            { o: o.ofKind(Noise) &amp;&amp; Q.canHear(gActor, o) } );
<a name="1432"></a>        
<a name="1433"></a>        scopeList = scopeList.appendUnique(noiseList);
<a name="1434"></a>    }
<a name="1435"></a>;
<a name="1436"></a>
<a name="1437"></a>/* 
<a name="1438"></a> *   This Special redefines canHear, canSee, canSmell, canTalkTo and canThrowTo
<a name="1439"></a> *   to take account of possible sensory connections across rooms in a
<a name="1440"></a> *   SenseRegion
<a name="1441"></a> */
<a name="1442"></a>QSenseRegion: Special
<a name="1443"></a>    
<a name="1444"></a>    /* 
<a name="1445"></a>     *   Gives this Special a slightly higher priority than QDefaults, so that
<a name="1446"></a>     *   it takes priority.
<a name="1447"></a>     */
<a name="1448"></a>    priority = 2
<a name="1449"></a>
<a name="1450"></a>    /* This Special should be active whenever this module is included. */
<a name="1451"></a>    active = true
<a name="1452"></a>
<a name="1453"></a>     
<a name="1454"></a>    /*
<a name="1455"></a>     *   Can A see B?  We return true if and only if B is in light and
<a name="1456"></a>     *   there's a clear sight path from A to B.  
<a name="1457"></a>     */
<a name="1458"></a>    canSee(a, b)
<a name="1459"></a>    {
<a name="1460"></a>        /* 
<a name="1461"></a>         *   If either a or b is not on the map, assume we can't see from A to
<a name="1462"></a>         *   B and return nil (otherwise we'd probably get a run-time error
<a name="1463"></a>         *   further down the line). Also A can't see B if B is hidden.
<a name="1464"></a>         */
<a name="1465"></a>        if(a.isIn(nil) || b.isIn(nil) || b.isHidden)
<a name="1466"></a>            return nil;
<a name="1467"></a>        
<a name="1468"></a>        /* 
<a name="1469"></a>         *   Construct a list of objects that might block the sight path from A
<a name="1470"></a>         *   to B.
<a name="1471"></a>         */
<a name="1472"></a>        local blockList = Q.sightBlocker(a, b);
<a name="1473"></a>        
<a name="1474"></a>        /* 
<a name="1475"></a>         *   A can't see B if B isn't in the light or there's something other
<a name="1476"></a>         *   than a room or A or B blocking the sight path between them
<a name="1477"></a>         */
<a name="1478"></a>        if(!(inLightFor(a, b))
<a name="1479"></a>           || blockList.indexWhich({x: x not in (a, b) &amp;&amp; !x.ofKind(Room)} ) != nil)            
<a name="1480"></a>            return nil;
<a name="1481"></a>        
<a name="1482"></a>              
<a name="1483"></a>        /* 
<a name="1484"></a>         *   A can see B if A and B are in the same room or if B is in one of
<a name="1485"></a>         *   the rooms in A's room's visibleRoom's list and B can be seen
<a name="1486"></a>         *   remotely from A's pov.
<a name="1487"></a>         */           
<a name="1488"></a>        local ar = a.getOutermostRoom(), br = b.getOutermostRoom();    
<a name="1489"></a>       
<a name="1490"></a>        /* 
<a name="1491"></a>         *   If a and b are in different rooms and b is in a container whose contents can't be seen
<a name="1492"></a>         *   remotely, then a can't see b.
<a name="1493"></a>         */
<a name="1494"></a>        if(ar != br &amp;&amp; sightBlockingContainer(a, b))
<a name="1495"></a>            return nil;
<a name="1496"></a>        
<a name="1497"></a>        
<a name="1498"></a>        return b.isOrIsIn(ar) || (b.isVisibleFrom(a) &amp;&amp;
<a name="1499"></a>                             ar.visibleRooms.indexOf(br)
<a name="1500"></a>                                  &amp;&amp; ar.canSeeOutTo(br)
<a name="1501"></a>                                  &amp;&amp; br.canSeeInFrom(ar));
<a name="1502"></a>               
<a name="1503"></a>        
<a name="1504"></a>    }
<a name="1505"></a>
<a name="1506"></a>    /* Is b in a container whose contents can't be viewed remotely from a's location? */
<a name="1507"></a>    sightBlockingContainer(a, b)
<a name="1508"></a>    {
<a name="1509"></a>        local loc = b.location;
<a name="1510"></a>        
<a name="1511"></a>        while(loc &amp;&amp; !loc.ofKind(Room))        
<a name="1512"></a>        {
<a name="1513"></a>            if(!loc.contentsVisibleFrom(a))
<a name="1514"></a>                return loc;
<a name="1515"></a>            
<a name="1516"></a>            loc = loc.location;
<a name="1517"></a>        }
<a name="1518"></a>        
<a name="1519"></a>        return nil;
<a name="1520"></a>    }
<a name="1521"></a>    
<a name="1522"></a>    inLight(a) { return next(); }
<a name="1523"></a>    
<a name="1524"></a>    
<a name="1525"></a>    /* is B lit from the perspect of A, who may be inside B. */
<a name="1526"></a>    inLightFor(a, b)
<a name="1527"></a>    {
<a name="1528"></a>        return next();
<a name="1529"></a>    }
<a name="1530"></a>    
<a name="1531"></a>    /*
<a name="1532"></a>     *   Can A hear B?  We return true if there's a clear sound path from A
<a name="1533"></a>     *   to B.  
<a name="1534"></a>     */
<a name="1535"></a>    canHear(a, b)
<a name="1536"></a>    {
<a name="1537"></a>        /* 
<a name="1538"></a>         *   If either a or b is not on the map, assume A can't hear B and
<a name="1539"></a>         *   return nil (otherwise we'd probably get a run-time error further
<a name="1540"></a>         *   down the line.
<a name="1541"></a>         */
<a name="1542"></a>         if(a.isIn(nil) || b.isIn(nil))
<a name="1543"></a>            return nil;        
<a name="1544"></a>        
<a name="1545"></a>        /* 
<a name="1546"></a>         *   Construct a list of objects that might block the sound path from A
<a name="1547"></a>         *   to B.
<a name="1548"></a>         */
<a name="1549"></a>        local blockList = Q.soundBlocker(a, b);      
<a name="1550"></a>        
<a name="1551"></a>        
<a name="1552"></a>        /* 
<a name="1553"></a>         *   A can't hear B if B there's something other than a room  or A or B blocking
<a name="1554"></a>         *   the sound path between them
<a name="1555"></a>         */
<a name="1556"></a>        if(blockList.indexWhich({x: !x.ofKind(Room) &amp;&amp; x not in (a, b)} ) != nil)            
<a name="1557"></a>            return nil;
<a name="1558"></a>        
<a name="1559"></a>        
<a name="1560"></a>        /* 
<a name="1561"></a>         *   A can hear B if A and B are in the same room or if B is in one of
<a name="1562"></a>         *   the rooms in A's room's audibleRoom's list and B can be heard
<a name="1563"></a>         *   remotely from A's pov.
<a name="1564"></a>         */           
<a name="1565"></a>        local ar = a.getOutermostRoom(), br = b.getOutermostRoom();    
<a name="1566"></a>             
<a name="1567"></a>        
<a name="1568"></a>        return b.isOrIsIn(ar) || (b.isAudibleFrom(a) &amp;&amp;
<a name="1569"></a>                             ar.audibleRooms.indexOf(br)
<a name="1570"></a>                                  &amp;&amp; ar.canHearOutTo(br)
<a name="1571"></a>                                  &amp;&amp; br.canHearInFrom(ar));
<a name="1572"></a>    }
<a name="1573"></a>
<a name="1574"></a>    
<a name="1575"></a>
<a name="1576"></a>    /*
<a name="1577"></a>     *   Can A smell B?  We return true if there's a clear scent path from
<a name="1578"></a>     *   A to B.  
<a name="1579"></a>     */
<a name="1580"></a>    canSmell(a, b)
<a name="1581"></a>    {
<a name="1582"></a>        /* 
<a name="1583"></a>         *   If either a or b is not on the map, assume A can't smell B and
<a name="1584"></a>         *   return nil (otherwise we'd probably get a run-time error further
<a name="1585"></a>         *   down the line.
<a name="1586"></a>         */
<a name="1587"></a>         if(a.isIn(nil) || b.isIn(nil))
<a name="1588"></a>            return nil;
<a name="1589"></a>        
<a name="1590"></a>        /* 
<a name="1591"></a>         *   Construct a list of objects that might block the scent path from A
<a name="1592"></a>         *   to B.
<a name="1593"></a>         */
<a name="1594"></a>         local blockList = Q.scentBlocker(a, b);
<a name="1595"></a>        
<a name="1596"></a>        /* 
<a name="1597"></a>         *   A can't smell B if B there's something other
<a name="1598"></a>         *   than a room blocking the scent path between them
<a name="1599"></a>         */
<a name="1600"></a>        if(blockList.indexWhich({x: !x.ofKind(Room) &amp;&amp; x not in (a, b)}) != nil)            
<a name="1601"></a>            return nil;
<a name="1602"></a>        
<a name="1603"></a>        
<a name="1604"></a>        /* 
<a name="1605"></a>         *   A can smell B if A and B are in the same room or if B is in one of
<a name="1606"></a>         *   the rooms in A's room's smelablelRoom's list and B can be seen
<a name="1607"></a>         *   remotely from A's pov.
<a name="1608"></a>         */           
<a name="1609"></a>        local ar = a.getOutermostRoom(), br = b.getOutermostRoom();    
<a name="1610"></a>             
<a name="1611"></a>        
<a name="1612"></a>        return b.isOrIsIn(ar) || (b.isSmellableFrom(a) &amp;&amp;
<a name="1613"></a>                             ar.smellableRooms.indexOf(br)
<a name="1614"></a>                                  &amp;&amp; ar.canSmellOutTo(br)
<a name="1615"></a>                                  &amp;&amp; br.canSmellInFrom(ar));
<a name="1616"></a>        
<a name="1617"></a>        
<a name="1618"></a>    }
<a name="1619"></a>
<a name="1620"></a>    /* 
<a name="1621"></a>     *   For A to be able to talk to B, A must both be able to hear B and either
<a name="1622"></a>     *   be in the same room as B or in a room that's close enough to be able to
<a name="1623"></a>     *   converse with B
<a name="1624"></a>     */
<a name="1625"></a>    
<a name="1626"></a>    canTalkTo(a, b)
<a name="1627"></a>    {
<a name="1628"></a>        /* 
<a name="1629"></a>         *   If either a or b is not on the map, assume A can't talk to B and
<a name="1630"></a>         *   return nil (otherwise we'd probably get a run-time error further
<a name="1631"></a>         *   down the line.
<a name="1632"></a>         */
<a name="1633"></a>        if(a.isIn(nil) || b.isIn(nil))
<a name="1634"></a>            return nil;
<a name="1635"></a>        
<a name="1636"></a>        /* Note which room A is in */
<a name="1637"></a>        local c = a.getOutermostRoom();
<a name="1638"></a>        
<a name="1639"></a>        /* 
<a name="1640"></a>         *   A can talk to B if A can hear B and B's location is in C's list of
<a name="1641"></a>         *   rooms where conversation can take place from C, or if B is in C.
<a name="1642"></a>         */
<a name="1643"></a>        return Q.canHear(a, b) 
<a name="1644"></a>            &amp;&amp; (b.isIn(c) 
<a name="1645"></a>                || c.talkableRooms.indexOf(b.getOutermostRoom) != nil);
<a name="1646"></a>    }
<a name="1647"></a>   
<a name="1648"></a>    /* Can A throw an object to B? */
<a name="1649"></a>    canThrowTo(a, b)
<a name="1650"></a>    {        
<a name="1651"></a>        /* 
<a name="1652"></a>         *   If either a or b is not on the map, assume A can't throw anything
<a name="1653"></a>         *   to B and return nil (otherwise we'd probably get a run-time error
<a name="1654"></a>         *   further down the line.
<a name="1655"></a>         */
<a name="1656"></a>        if(a.isIn(nil) || b.isIn(nil))
<a name="1657"></a>            return nil;
<a name="1658"></a>        
<a name="1659"></a>        /* Note which room A is in */
<a name="1660"></a>        local c = a.getOutermostRoom();
<a name="1661"></a>        
<a name="1662"></a>        /* 
<a name="1663"></a>         *   A can throw something to B if B's location is in C's list of rooms
<a name="1664"></a>         *   into which objects can be thrown from C, or if B is in C.
<a name="1665"></a>         */
<a name="1666"></a>        return b.isOrIsIn(c) 
<a name="1667"></a>            || c.throwableRooms.indexOf(b.getOutermostRoom) != nil; 
<a name="1668"></a>    }
<a name="1669"></a>    
<a name="1670"></a>    /*
<a name="1671"></a>     *   Determine if A can reach B, and if not, what stands in the way. Returns
<a name="1672"></a>     *   a list of containers along the path between A and B that obstruct the
<a name="1673"></a>     *   reach.  If the two objects are in separate rooms, the top-level room
<a name="1674"></a>     *   containing A is in the list to represent the room separation.  If
<a name="1675"></a>     *   there's no obstruction, we return an empty list.
<a name="1676"></a>     */
<a name="1677"></a>    reachBlocker(a, b)
<a name="1678"></a>    {
<a name="1679"></a>        local blockList = a.containerPathBlock(b, &amp;canReachOut, &amp;canReachIn);
<a name="1680"></a>        
<a name="1681"></a>        /* 
<a name="1682"></a>         *   ignore any blocking objects that are Rooms in the same SenseRegion
<a name="1683"></a>         *   where the SenseRegion's autoGoTo property is true.
<a name="1684"></a>         */
<a name="1685"></a>        blockList = blockList.subset({o: nonBlocker(o, b) == nil });
<a name="1686"></a>        
<a name="1687"></a>        
<a name="1688"></a>        return blockList;
<a name="1689"></a>    }
<a name="1690"></a>     
<a name="1691"></a>    /* 
<a name="1692"></a>     *   Is o the kind of object that would block movement from one room to the
<a name="1693"></a>     *   room containing b? It is unless o is a room and the room and b are both
<a name="1694"></a>     *   in a SenseRegion for which autoGoTo is true.
<a name="1695"></a>     */
<a name="1696"></a>    nonBlocker(o, b)
<a name="1697"></a>    {
<a name="1698"></a>        /* If o isn't a Room, it's something that blocks movement */
<a name="1699"></a>        if(!o.ofKind(Room))
<a name="1700"></a>            return nil;
<a name="1701"></a>        
<a name="1702"></a>        /* Get the Room in which b is located. */
<a name="1703"></a>        local bLoc = b.getOutermostRoom;
<a name="1704"></a>        
<a name="1705"></a>        /* Get the list of Regions containing both o and bLoc. */
<a name="1706"></a>        local regList = o.regionsInCommonWith(bLoc);
<a name="1707"></a>        
<a name="1708"></a>        /* Reduce it to the list of Regions for which autoToGo is true */
<a name="1709"></a>        regList = regList.subset({r: r.autoGoTo} );
<a name="1710"></a>        
<a name="1711"></a>        /* 
<a name="1712"></a>         *   If this list is not empty, we're a non-blocker so return true,
<a name="1713"></a>         *   otherwise return nil
<a name="1714"></a>         */
<a name="1715"></a>        return regList.length &gt; 0;
<a name="1716"></a>        
<a name="1717"></a>    }
<a name="1718"></a>    
<a name="1719"></a>    /* 
<a name="1720"></a>     *   Prepend a ReachProblemRemote to move the actor to the location of the
<a name="1721"></a>     *   target object if it's in a remote location, then add any issues we
<a name="1722"></a>     *   would have obtained from the next Special in line.
<a name="1723"></a>     */
<a name="1724"></a>//    reachProblemCheck(a, b)
<a name="1725"></a>//    {
<a name="1726"></a>//        local issues = [];
<a name="1727"></a>//        
<a name="1728"></a>//        if(a.getOutermostRoom != b.getOutermostRoom)
<a name="1729"></a>//            issues += new ReachProblemRemote(a, b);
<a name="1730"></a>//        
<a name="1731"></a>//        return issues + next();
<a name="1732"></a>//    }
<a name="1733"></a>;
<a name="1734"></a>
<a name="1735"></a>/* 
<a name="1736"></a> *   The ReachProblemRemote should only be brought into play when an actor in
<a name="1737"></a> *   one room in a SenseRegion tries to touch an object in another room in the
<a name="1738"></a> *   SenseRegion when the SenseRegion defines autoGoTo as true. The
<a name="1739"></a> *   ReachProblemRemote will then be responsible for trying to move the actor
<a name="1740"></a> *   into the room containing the target object.
<a name="1741"></a> */
<a name="1742"></a>class ReachProblemRemote: ReachProblem
<a name="1743"></a>    construct(a, b)
<a name="1744"></a>    {
<a name="1745"></a>        origRoom = a.getOutermostRoom;
<a name="1746"></a>        destRoom = b.getOutermostRoom;
<a name="1747"></a>        target = b;
<a name="1748"></a>    }
<a name="1749"></a>    
<a name="1750"></a>    origRoom = nil
<a name="1751"></a>    destRoom = nil
<a name="1752"></a>    target = nil
<a name="1753"></a>    
<a name="1754"></a>    /* 
<a name="1755"></a>     *   This check method may be called by the checkPreCondition method of the
<a name="1756"></a>     *   touchObj PreCondition. Its effect is to try to move the actor into the
<a name="1757"></a>     *   location of the object the actor is trying to touch.
<a name="1758"></a>     */
<a name="1759"></a>    check(allowImplicit)   
<a name="1760"></a>    {
<a name="1761"></a>        /* 
<a name="1762"></a>         *   If the actor is already in the location of the target object,
<a name="1763"></a>         *   there's nothing to do here. This should never be the case when this
<a name="1764"></a>         *   method is called, but we include the check just to be sure.
<a name="1765"></a>         */
<a name="1766"></a>        if(origRoom == destRoom)
<a name="1767"></a>            return true;    
<a name="1768"></a>        
<a name="1769"></a>        
<a name="1770"></a>        
<a name="1771"></a>        /* 
<a name="1772"></a>         *   If implicit actions are allowed, try moving the actor to the
<a name="1773"></a>         *   destination room (the room containing the object to be touched).
<a name="1774"></a>         */
<a name="1775"></a>        if(allowImplicit &amp;&amp; sayGoTo(destRoom) &amp;&amp;
<a name="1776"></a>           tryImplicitAction(GoTo, destRoom))
<a name="1777"></a>        {
<a name="1778"></a>            /* 
<a name="1779"></a>             *   If the actor isn't in the destination room, return nil to tell
<a name="1780"></a>             *   our caller we failed.
<a name="1781"></a>             */
<a name="1782"></a>            if(!gActor.isIn(destRoom))
<a name="1783"></a>                return nil;               
<a name="1784"></a>        }
<a name="1785"></a>        else
<a name="1786"></a>        {
<a name="1787"></a>            /* 
<a name="1788"></a>             *   If the implicit GoTo action can't be attempted, simply display
<a name="1789"></a>             *   a message to say that the target object is too far away.
<a name="1790"></a>             */
<a name="1791"></a>            say(tooFarAwayMsg);
<a name="1792"></a>            
<a name="1793"></a>            /* Then return nil to tell our caller we failed. */
<a name="1794"></a>            return nil;
<a name="1795"></a>        }
<a name="1796"></a>        
<a name="1797"></a>        /* 
<a name="1798"></a>         *   If we reached this point, all is well, so return true to tell our
<a name="1799"></a>         *   caller we succeeded.
<a name="1800"></a>         */
<a name="1801"></a>        return true;
<a name="1802"></a>        
<a name="1803"></a>        
<a name="1804"></a>    }
<a name="1805"></a>    
<a name="1806"></a>    /* 
<a name="1807"></a>     *   The failure message to display if we can't attempt an implicit GoTo
<a name="1808"></a>     *   action to move the actor.
<a name="1809"></a>     */
<a name="1810"></a>    tooFarAwayMsg()
<a name="1811"></a>    {
<a name="1812"></a>        /* Let the actor's room provide the message. */
<a name="1813"></a>        return origRoom.cannotReachTargetMsg(target);              
<a name="1814"></a>    }
<a name="1815"></a>    
<a name="1816"></a>    /* 
<a name="1817"></a>     *   Report that we are trying to head to destRoom via an implicit action.
<a name="1818"></a>     *   We do this separately from the normal implicit action report mechanism
<a name="1819"></a>     *   so that this report is display before travel begins, not at the end of
<a name="1820"></a>     *   it as it otherwise would be.
<a name="1821"></a>     */
<a name="1822"></a>    sayGoTo(destRoom)
<a name="1823"></a>    {        
<a name="1824"></a>        DMsg(implicit go, '(first heading for {1})\n', destRoom.theName);
<a name="1825"></a>        return true;
<a name="1826"></a>    }
<a name="1827"></a>;
<a name="1828"></a>
<a name="1829"></a>modify touchObj
<a name="1830"></a>    checkPreCondition(obj, allowImplicit)
<a name="1831"></a>    {
<a name="1832"></a>        /* 
<a name="1833"></a>         *   We first try moving to a new room as a separate exercise before
<a name="1834"></a>         *   checking for any other obstacles, since if the move is successful
<a name="1835"></a>         *   it may change the status of other potential obstacles.
<a name="1836"></a>         */
<a name="1837"></a>        local remoteCheck = new ReachProblemRemote(gActor, obj);
<a name="1838"></a>        
<a name="1839"></a>        if(!remoteCheck.check(allowImplicit))
<a name="1840"></a>            return nil;
<a name="1841"></a>        
<a name="1842"></a>        return inherited(obj, allowImplicit);
<a name="1843"></a>    }
<a name="1844"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 07/01/2025 from adv3Lite version 2.1.1.8</div>
</body>
</html>

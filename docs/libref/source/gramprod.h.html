<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>gramprod.h</title></head><body>
<table class=ban><tr><td><h1>gramprod.h</h1><td align=right><a href="../file/gramprod.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   The header defines the GrammarProd intrinsic class and some associated
<a name="10"></a> *   properties and constants.  
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>
<a name="14"></a>/* include our base class definition */
<a name="15"></a>#include "systype.h"
<a name="16"></a>
<a name="17"></a>/*
<a name="18"></a> *   The GrammarProd intrinsic class is a specialized type that's designed
<a name="19"></a> *   for creating parsers.  An object of this type is created automatically
<a name="20"></a> *   by the TADS 3 compiler for each 'grammar' statement.  This class
<a name="21"></a> *   encapsulates the prototype token list and mapping information defined in
<a name="22"></a> *   a 'grammar' statement, and provides a method to match its prototype to
<a name="23"></a> *   an input token string.
<a name="24"></a> *   
<a name="25"></a> *   GrammarProd implements a "parser" in a limited computerese sense, which
<a name="26"></a> *   is essentially a program that produces "sentence diagrams" a la
<a name="27"></a> *   elementary school grammar lessons.  GrammarProd is thus only a small
<a name="28"></a> *   part of what we think of as "the parser" in an IF context.  The broader
<a name="29"></a> *   parser starts with the sentence diagrams that GrammarProd produces, and
<a name="30"></a> *   must then interpret their meanings and carry out the intentions they
<a name="31"></a> *   express.
<a name="32"></a> *   
<a name="33"></a> *   Parsers built with GrammarProd trees can handle grammars with left or
<a name="34"></a> *   right recursion, and can handle ambiguous grammars (meaning that a
<a name="35"></a> *   single input can have multiple ways of matching the grammar).  This is
<a name="36"></a> *   especially important for natural language parsing, since virtually all
<a name="37"></a> *   natural languages have ambiguous grammars.  When a match is ambiguous, a
<a name="38"></a> *   GrammarProd parser builds all of the possible match trees, allowing you
<a name="39"></a> *   to choose the best match based on context and semantic content.
<a name="40"></a> *   
<a name="41"></a> *   You can also create new productions dynamically with new GrammarProd().
<a name="42"></a> *   Use addAlt() to populate a new production with token matching rules.  
<a name="43"></a> */
<a name="44"></a>intrinsic class GrammarProd 'grammar-production/030002': Object
<a name="45"></a>{
<a name="46"></a>    /*
<a name="47"></a>     *   Parse the token list, starting at this production, using the given
<a name="48"></a>     *   dictionary to look up tokens.  Returns a list of match objects.  If
<a name="49"></a>     *   there are no matches to the grammar, simply returns an empty list.  
<a name="50"></a>     */
<a name="51"></a>    parseTokens(tokenList, dict);
<a name="52"></a>
<a name="53"></a>    /*
<a name="54"></a>     *   Retrieve a detailed description of the production.  This returns a
<a name="55"></a>     *   list of GrammarAltInfo objects that describe the rule alternatives
<a name="56"></a>     *   that make up this production.  
<a name="57"></a>     */
<a name="58"></a>    getGrammarInfo();
<a name="59"></a>
<a name="60"></a>    /*
<a name="61"></a>     *   Add a new alternative set of alternatives to the rule list for this
<a name="62"></a>     *   grammar production.
<a name="63"></a>     *   
<a name="64"></a>     *   'alt' is a string with the token list specifying the alternative(s)
<a name="65"></a>     *   to add.  This uses the same syntax as the rule list in a static
<a name="66"></a>     *   'grammar' statement.  You can use '|' symbols to add multiple
<a name="67"></a>     *   alternatives.
<a name="68"></a>     *   
<a name="69"></a>     *   'matchObj' is the match object class, which is the class of the
<a name="70"></a>     *   object that parseTokens() reutrns in the match list to represent a
<a name="71"></a>     *   match to this production.  This corresponds to the base class
<a name="72"></a>     *   defined in a static 'grammar' statement.
<a name="73"></a>     *   
<a name="74"></a>     *   'dict' is an optional Dictionary object.  Literal tokens used in the
<a name="75"></a>     *   token list will be automatically added to the dictionary if they're
<a name="76"></a>     *   not already defined.
<a name="77"></a>     *   
<a name="78"></a>     *   'symtab' is an optional LookupTable with the global symbol table.
<a name="79"></a>     *   This must be provided if any symbolic tokens are used in the rule
<a name="80"></a>     *   list (property names, sub-production names, etc).  In most cases
<a name="81"></a>     *   this is simply the symbol table that t3GetGlobalSymbols() returns
<a name="82"></a>     *   during preinit.  
<a name="83"></a>     */
<a name="84"></a>    addAlt(alt, matchObj, dict?, symtab?);
<a name="85"></a>
<a name="86"></a>    /*
<a name="87"></a>     *   Delete onen or more alternatives from the rule list for this grammar
<a name="88"></a>     *   production.  'id' identifies the rule(s) to delete:
<a name="89"></a>     *   
<a name="90"></a>     *   - By tag: if 'id' is a string, the method deletes each alternative
<a name="91"></a>     *   whose match object's grammarTag property equals 'id'.  For static
<a name="92"></a>     *   rules defined with 'grammar' statements, the compiler sets
<a name="93"></a>     *   grammarTag to the tag used in the statement defining the rule.  This
<a name="94"></a>     *   makes it easy to delete all of the rules defined by a given
<a name="95"></a>     *   'grammar' statement.  
<a name="96"></a>     *   
<a name="97"></a>     *   - By match object class: if 'id' is an object, the method deletes
<a name="98"></a>     *   every alternative whose match object equals 'id' or is a subclass of
<a name="99"></a>     *   'id'.  This makes it easy to delete a group of dynamically added
<a name="100"></a>     *   rules that share a match object.
<a name="101"></a>     *   
<a name="102"></a>     *   - By index: if 'id' is an integer, it gives the index of the rule to
<a name="103"></a>     *   delete.  This corresponds to an index in the list returned by
<a name="104"></a>     *   getGrammarInfo().
<a name="105"></a>     *   
<a name="106"></a>     *   'dict' is an optional Dictionary object to adjust for the deletion.
<a name="107"></a>     *   If a non-nil 'dict' is given, we'll remove literals from the
<a name="108"></a>     *   dictionary that were defined by the alternative and no longer used
<a name="109"></a>     *   in the production.  
<a name="110"></a>     */
<a name="111"></a>    deleteAlt(id, dict?);
<a name="112"></a>
<a name="113"></a>    /* 
<a name="114"></a>     *   Delete all alternatives from the rule list for this grammar
<a name="115"></a>     *   production.  This resets the rule to an empty production with no
<a name="116"></a>     *   alternatives to match, which is convenient if you want to redefine
<a name="117"></a>     *   the entire rule set with a subsequent addAlt() call.
<a name="118"></a>     *   
<a name="119"></a>     *   'dict' is an optional Dictionary object to adjust for the deletion.
<a name="120"></a>     *   If a non-nil 'dict' is given, we'll remove all of the production's
<a name="121"></a>     *   literals from the dictionary.  
<a name="122"></a>     */
<a name="123"></a>    clearAlts(dict?);
<a name="124"></a>}
<a name="125"></a>
<a name="126"></a>/*
<a name="127"></a> *   Token slot types.  Each token slot in an alternative has a type, which
<a name="128"></a> *   determines what it matches in an input token list.  getGrammarInfo()
<a name="129"></a> *   returns these type codes in the GrammarAltTokInfo objects.  
<a name="130"></a> */
<a name="131"></a>
<a name="132"></a>#define GramTokTypeProd    1              /* token matches a sub-production */
<a name="133"></a>#define GramTokTypeSpeech  2     /* token matches a specific part of speech */
<a name="134"></a>#define GramTokTypeLiteral 3              /* token matches a literal string */
<a name="135"></a>#define GramTokTypeTokEnum 4            /* token matches a token class enum */
<a name="136"></a>#define GramTokTypeStar    5    /* token matches all remaining input tokens */
<a name="137"></a>#define GramTokTypeNSpeech 6      /* matches any of several parts of speech */
<a name="138"></a>
<a name="139"></a>
<a name="140"></a>/* 
<a name="141"></a> *   Properties for the first and last token indices, and the complete
<a name="142"></a> *   original token list.
<a name="143"></a> *   
<a name="144"></a> *   Each match tree object will have the firstTokenIndex and lastTokenIndex
<a name="145"></a> *   properties set to the bounding token indices for its subtree.  Each
<a name="146"></a> *   match tree object will also have tokenList set to the original token
<a name="147"></a> *   list passed to the parseTokens() that created the match tree, and
<a name="148"></a> *   tokenMatchList set to a list of the Dictionary's comparator's
<a name="149"></a> *   matchValues() result for each token match.  
<a name="150"></a> */
<a name="151"></a>property firstTokenIndex, lastTokenIndex, tokenList, tokenMatchList;
<a name="152"></a>export firstTokenIndex 'GrammarProd.firstTokenIndex';
<a name="153"></a>export lastTokenIndex  'GrammarProd.lastTokenIndex';
<a name="154"></a>export tokenList       'GrammarProd.tokenList';
<a name="155"></a>export tokenMatchList  'GrammarProd.tokenMatchList';
<a name="156"></a>
<a name="157"></a>/*
<a name="158"></a> *   For alternatives created at run-time with addAlt(), the system maintains
<a name="159"></a> *   a list of all of the properties used in "-&gt;" expressions in all
<a name="160"></a> *   alternatives associated with a match object.  This list of properties is
<a name="161"></a> *   stored in the grammarAltProps of the match object.
<a name="162"></a> */
<a name="163"></a>property grammarAltProps;
<a name="164"></a>export grammarAltProps 'GrammarProd.altProps';
<a name="165"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 07/01/2025 from adv3Lite version 2.1.1.8</div>
</body>
</html>

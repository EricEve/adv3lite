<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>customBanner.t</title></head><body>
<table class=ban><tr><td><h1>customBanner.t</h1><td align=right><a href="../file/customBanner.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>#include &lt;tads.h&gt;
<a name="4"></a>#include "advlite.h"
<a name="5"></a>
<a name="6"></a>  /*
<a name="7"></a>   *    Custom Banner version 1.2
<a name="8"></a>   *     by Eric Eve
<a name="9"></a>   *  
<a name="10"></a>   *     Version date: 13-Sep-06
<a name="11"></a>   *    Adapted for adv3Lite: 28-Dec-24
<a name="12"></a>   *
<a name="13"></a>   *     This file implements a CustomBannerWindow class that vastly eases
<a name="14"></a>   *     the process of setting up banners and displaying material in them.
<a name="15"></a>   *     e.g. to set up a graphics banner to display pictures, starting with
<a name="16"></a>   *     pic1.jpg at startup, but not appearing at all on an interpreter that
<a name="17"></a>   *     can't display JPEGs you could define:
<a name="18"></a>   *
<a name="19"></a>   *     pictureWindow: CustomBannerWindow
<a name="20"></a>   *       canDisplay = (systemInfo(SysInfoJpeg))
<a name="21"></a>   *       bannerArgs = [nil, BannerAfter,  statuslineBanner, BannerTypeText, 
<a name="22"></a>   *             BannerAlignTop, 10, BannerSizeAbsolute, BannerStyleBorder]
<a name="23"></a>   *       currentContents = '&lt;img src="pic1.jpg"&gt;'
<a name="24"></a>   *    ;
<a name="25"></a>   *
<a name="26"></a>   *    Then to change the picture dislayed at a later point, call:
<a name="27"></a>   *
<a name="28"></a>   *       pictureWindow.updateContents('&lt;img src="pic2.jpg"&gt;');
<a name="29"></a>   *
<a name="30"></a>   *    And everything else, including getting everything right on RESTART, UNDO
<a name="31"></a>   *    and RESTORE should be taken care of.
<a name="32"></a>   */
<a name="33"></a>
<a name="34"></a>  /* ------------------------------------------------------------------------ */
<a name="35"></a>  /* 
<a name="36"></a>   *  A CustomBannerWindow, like a BannerWindow, corrsponds to an on-screen
<a name="37"></a>   *  banner. The purpose of CustomBannerWindow is to eliminate most of the
<a name="38"></a>   *  busy-work that a game author would otherwise have to take care of in
<a name="39"></a>   *  displaying and manipulating banners.
<a name="40"></a>   *
<a name="41"></a>   *  As with BannerWinnow, merely creating a CustomBannerWindow does not
<a name="42"></a>   *  display the banner. However, any CustomBannerWindows in existence at
<a name="43"></a>   *  the start of the game will be added to the screen display, unless the
<a name="44"></a>   *  condition specified in their shouldDisplay() method prevents initialization.
<a name="45"></a>   *
<a name="46"></a>   *  The one property that must be defined on each instance of a CustomBannerWindow
<a name="47"></a>   *  is bannerArgs, which takes the form:
<a name="48"></a>   *
<a name="49"></a>   *     bannerArgs = [parent, where, other, windowType, align, 
<a name="50"></a>   *                     size, sizeUnits, styleFlags]
<a name="51"></a>   *
<a name="52"></a>   *  where each list element has the same meaning at the corresponding argument
<a name="53"></a>   *  to BannerWindow.showBanner()
<a name="54"></a>   *
<a name="55"></a>   *  This merely ensures that the CustomBannerWindow is added to the screen's
<a name="56"></a>   *  banner window layout. To have the CustomBannerWindow display some content
<a name="57"></a>   *  when first added to the screen layout, override its current contents property:
<a name="58"></a>   *
<a name="59"></a>   *     currentContents = 'My initial contents'
<a name="60"></a>   *
<a name="61"></a>   *  To change what's displayed in a CustomBannerWindow from game code, call its
<a name="62"></a>   *  updateContents() method, e.g.:
<a name="63"></a>   *
<a name="64"></a>   *     pictureWindow.updateContents('&lt;img src="pics/troll.jpg"&gt;');
<a name="65"></a>   *
<a name="66"></a>   *  To redisplay the current contents, call the showCurrentContents() method.
<a name="67"></a>   *  By default a call to updateContents() or showCurrentContents() clears the
<a name="68"></a>   *  window before displaying the new content. To have the additional content
<a name="69"></a>   *  added to the existing content, change the clearBeforeUpdate property to nil.
<a name="70"></a>   *
<a name="71"></a>   *  You can control whether the game uses this banner at all by overriding
<a name="72"></a>   *  the canDisplay property. The main purpose of this property is to easily allow
<a name="73"></a>   *  a game to run on different types of interpreter. For example, if your banner is
<a name="74"></a>   *  meant to display pictures in the JPEG format, there's no point having it included
<a name="75"></a>   *  in the screen layout of an interpreter that can't display JPEGs, and attempts to
<a name="76"></a>   *  update its contents with a new picture should do nothing. In which case we could
<a name="77"></a>   *  define:
<a name="78"></a>   *
<a name="79"></a>   *     canDisplay = (systemInfo(SysInfoJpeg))
<a name="80"></a>   *
<a name="81"></a>   *  Calls to CustomBannerWindow methods like updateContents() and clearWindow()
<a name="82"></a>   *  should be safe on an interpreter for which shouldDisplay returns nil, since
<a name="83"></a>   *  by default these will do nothing beyond updating the banner's currentContents
<a name="84"></a>   *  property. This makes it easier to write game code that is suitable for all 
<a name="85"></a>   *  classes of interpreter
<a name="86"></a>   *
<a name="87"></a>   *  To have a CustomBannerWindow resize to contents each time its contents are
<a name="88"></a>   *  displayed, set its autoSize property to true.   
<a name="89"></a>   *
<a name="90"></a>   *  If you do not want a CustomBannerWindow you have defined not to be dispayed
<a name="91"></a>   *  at game startup, set its isActive property to nil. Call the activate()
<a name="92"></a>   *  method to add it to the screen layout and the deactivate() method to remove
<a name="93"></a>   *  it, or any other CustomBannerWindow, from the screen display.    
<a name="94"></a>   *    
<a name="95"></a>   *  Obviously, it is then the game author's responsibility to ensure that no
<a name="96"></a>   *  other banner window that's meant to persist after pictureWindow is deactivated
<a name="97"></a>   *  depends on pictureWindow for its existence; i.e. that we're not deactivating
<a name="98"></a>   *  the parent of some other banner window(s) we want to keep or subsequently
<a name="99"></a>   *  activate, or the sibling of any banner window that's subsequently going to
<a name="100"></a>   *  defined in relation to us.    
<a name="101"></a>   */
<a name="102"></a>
<a name="103"></a>class CustomBannerWindow: BannerWindow
<a name="104"></a>
<a name="105"></a> /*
<a name="106"></a>  *  The list of any banner windows that must be set up before me,
<a name="107"></a>  *  either one of them is my parent, or because I'm going
<a name="108"></a>  *  to be placed before or after them with BannerBefore or BannerAfter.
<a name="109"></a>  *
<a name="110"></a>  *  If bannerArgs has been set up with the list of showBanner arguments, 
<a name="111"></a>  *  then we can derive this information automatically
<a name="112"></a>  */
<a name="113"></a>  initBeforeMe()
<a name="114"></a>  {
<a name="115"></a>    /*
<a name="116"></a>     *  If our bannerArgs property contains a list of the right length, i.e. 8
<a name="117"></a>     *  elements, then the first and third elements of the list (our parent, and
<a name="118"></a>     *  the sibling we're to be placed before or after) must be initialized before
<a name="119"></a>     *  we are. If either of these is nil, no harm is done, since initBannerWindow()
<a name="120"></a>     *  will simply skip the nil value.     
<a name="121"></a>     *
<a name="122"></a>     *  Moreover, if our sibling is in the list, we don't need our parent as well,
<a name="123"></a>     *  since either our sibling or one of its siblings will initialize our parent.
<a name="124"></a>     */
<a name="125"></a>     
<a name="126"></a>    local lst = [];
<a name="127"></a>    
<a name="128"></a>    if (propType(&amp;bannerArgs) == TypeList &amp;&amp; bannerArgs.length() == 8) 
<a name="129"></a>      lst = bannerArgs[3] ? [bannerArgs[3]] : [bannerArgs[1]];
<a name="130"></a>        
<a name="131"></a>    initBeforeMe = lst;
<a name="132"></a>    
<a name="133"></a>    return lst;    
<a name="134"></a>  }   
<a name="135"></a>
<a name="136"></a>  
<a name="137"></a>  /*
<a name="138"></a>   * A condition to test whether this banner window should actually display.
<a name="139"></a>   * Normally this would test for the interpreter class if this would
<a name="140"></a>   * affect whether we wanted this banner to be created. For example, if
<a name="141"></a>   * we were going to use this banner window to display a JPEG picture, we
<a name="142"></a>   * might not this window to display at all if the interpreter we're running
<a name="143"></a>   * on can't display JPEGS, so we might write:
<a name="144"></a>   *
<a name="145"></a>   *    canDisplay = (systemInfo(SysInfoJpeg))
<a name="146"></a>   *
<a name="147"></a>   *   If your complete system of CustomBanners depends on the same condition
<a name="148"></a>   *   (e.g. you don't want any CustomBanners if the interpreter we're running
<a name="149"></a>   *   on can't display JPEGs, then it's probably easiest to modify CustomBanner
<a name="150"></a>   *   and override scanDisplay on the modified class.
<a name="151"></a>   *
<a name="152"></a>   *  By default, we simply check that the interpreter we're running on
<a name="153"></a>   *  can display banners.
<a name="154"></a>   */
<a name="155"></a>  canDisplay = (systemInfo(SysInfoBanners))  
<a name="156"></a>  
<a name="157"></a>  shouldDisplay = (canDisplay &amp;&amp; isActive)
<a name="158"></a>   
<a name="159"></a>   /*
<a name="160"></a>    *  The standard use of initBannerWindow is first to ensure that any
<a name="161"></a>    *  banner windows whose existence we presuppose have themselves been
<a name="162"></a>    *  initialized, and then to set up our own window on screen.
<a name="163"></a>    *  This function should be used for initializing banner window *layout*,
<a name="164"></a>    *  not content.
<a name="165"></a>    */
<a name="166"></a>   
<a name="167"></a>   
<a name="168"></a>  initBannerWindow()
<a name="169"></a>  {
<a name="170"></a>     /*
<a name="171"></a>      *  If we shouldn't display on this class of interpreter, don't
<a name="172"></a>      *  initialize us.
<a name="173"></a>      */
<a name="174"></a>     if(!shouldDisplay)
<a name="175"></a>       return nil;
<a name="176"></a>       
<a name="177"></a>     /*
<a name="178"></a>      *  If we've already been initialized, there's nothing left to do.
<a name="179"></a>      */
<a name="180"></a>        
<a name="181"></a>     if(inited_)
<a name="182"></a>       return true;  
<a name="183"></a>       
<a name="184"></a>     /*  
<a name="185"></a>      *  Initialize all the bannner windows on whose existence our own
<a name="186"></a>      *  depends. If one of them can't be initialized, neither can we,
<a name="187"></a>      *  in which case return nil to show that our initialization failed. 
<a name="188"></a>      *  If, however, the parent or sibling banner window we want initialized
<a name="189"></a>      *  before us is not a CustomBannerWindow, then its initBannerWindow()
<a name="190"></a>      *  won't have a return value, in which case we ignore the fact that
<a name="191"></a>      *  it returns nil 
<a name="192"></a>      */
<a name="193"></a>       
<a name="194"></a>     foreach(local ban in initBeforeMe)
<a name="195"></a>       if(ban &amp;&amp; !ban.initBannerWindow() &amp;&amp; ban.ofKind(CustomBannerWindow))
<a name="196"></a>         return nil;
<a name="197"></a>        
<a name="198"></a>     /*  
<a name="199"></a>      * Create my banner window on screen; if this fails return nil
<a name="200"></a>      * to indicate that the window could not be created
<a name="201"></a>      */       
<a name="202"></a>      
<a name="203"></a>      return (inited_ = initBannerLayout());
<a name="204"></a>
<a name="205"></a>  }
<a name="206"></a>  
<a name="207"></a>  /*
<a name="208"></a>   *  Initialize my onscreen layout, normally through a call to showBanner(),
<a name="209"></a>   *  whose return value this method should return, e.g.:
<a name="210"></a>   *
<a name="211"></a>   *     initBannerLayout()
<a name="212"></a>   *     {
<a name="213"></a>   *         return showBanner(nil, BannerAfter,  statuslineBanner,
<a name="214"></a>   *           BannerTypeText, BannerAlignTop, 1, BannerSizeAbsolute,
<a name="215"></a>   *           BannerStyleBorder); 
<a name="216"></a>   *     }
<a name="217"></a>   *
<a name="218"></a>   *    By default we simply call initBannerLayout() using our bannerArgs.
<a name="219"></a>   */
<a name="220"></a>  
<a name="221"></a>  initBannerLayout()
<a name="222"></a>  {
<a name="223"></a>     return showBanner(bannerArgs...);
<a name="224"></a>  }
<a name="225"></a>  
<a name="226"></a>   
<a name="227"></a>  
<a name="228"></a>  /* 
<a name="229"></a>   * The list of args used to define our screen layout, as they would be passed
<a name="230"></a>   * to showBanner. This is used both by initBannerLayout and initBeforeMe.
<a name="231"></a>   *
<a name="232"></a>   *  The args should be listed in the form
<a name="233"></a>   *
<a name="234"></a>   *  bannerArgs = [parent, where, other, windowType, align, size, sizeUnits, styleFlags]
<a name="235"></a>   *
<a name="236"></a>   *  e.g.
<a name="237"></a>   *    bannerArgs = [nil, BannerAfter,  statuslineBanner,
<a name="238"></a>   *           BannerTypeText, BannerAlignTop, 1, BannerSizeAbsolute,
<a name="239"></a>   *           BannerStyleBorder]
<a name="240"></a>   *   
<a name="241"></a>   */
<a name="242"></a>    
<a name="243"></a>  bannerArgs = nil
<a name="244"></a>  
<a name="245"></a>  /*
<a name="246"></a>   *  The current contents to be displayed in this window, which could be 
<a name="247"></a>   *  a string of text, or the HTML string to display a picture.
<a name="248"></a>   *
<a name="249"></a>   *  currentContents can be overridden to hold the initial contents
<a name="250"></a>   *  we want this banner to display, but it should not otherwise be
<a name="251"></a>   *  directly written to in game code. To display new contents in the
<a name="252"></a>   *  banner, use updateContents() instead.  
<a name="253"></a>   */
<a name="254"></a>  currentContents = ''
<a name="255"></a>  
<a name="256"></a>  /*
<a name="257"></a>   *  Is this banner currently active? Set to nil if you don't want to this
<a name="258"></a>   *  CustomBannerWindow to be active at startup; thereafter use the deactivate()
<a name="259"></a>   *  and activate() methods   
<a name="260"></a>   */
<a name="261"></a>   
<a name="262"></a>  isActive = true
<a name="263"></a>  
<a name="264"></a>  /*
<a name="265"></a>   *  deactivate a currently active banner; this removes it from the screen
<a name="266"></a>   *  and prevents writing anything further to it. Be careful to respect the
<a name="267"></a>   *  dependency order of banner windows when activating and deactivating
<a name="268"></a>   *
<a name="269"></a>   *  The argument is optional. If it is the constant true then the currentContents
<a name="270"></a>   *  will be set to an empty string (''). If it is a string, then the currentContents
<a name="271"></a>   *  will be set to that string (ready to be displayed when the banner is reactivated).
<a name="272"></a>   */
<a name="273"></a>   
<a name="274"></a>  deactivate([args])  
<a name="275"></a>  {     
<a name="276"></a>     removeBanner();
<a name="277"></a>     isActive = nil;
<a name="278"></a>     
<a name="279"></a>     if(args.length &gt; 0)
<a name="280"></a>     {
<a name="281"></a>        local arg = args[1];
<a name="282"></a>        switch(dataType(arg))
<a name="283"></a>        {
<a name="284"></a>           case TypeTrue:
<a name="285"></a>             currentContents = '';
<a name="286"></a>             break;
<a name="287"></a>           case TypeSString:
<a name="288"></a>             currentContents = arg;
<a name="289"></a>             break;
<a name="290"></a>        }
<a name="291"></a>     }
<a name="292"></a>     
<a name="293"></a>  }
<a name="294"></a>   
<a name="295"></a>  /* 
<a name="296"></a>   *  Activate a currently inactive banner; this restores it to the screen. 
<a name="297"></a>   *  The argument is optional; if present and true then activate(true)
<a name="298"></a>   *  displays the current contents of the banner window after activating it.
<a name="299"></a>   *  If the first argument is a string then the string is displayed in the banner.   
<a name="300"></a>   */ 
<a name="301"></a>  activate([args])
<a name="302"></a>  {
<a name="303"></a>      if(isActive)
<a name="304"></a>         return;
<a name="305"></a>         
<a name="306"></a>      isActive = true;
<a name="307"></a>      initBannerWindow();
<a name="308"></a>      
<a name="309"></a>      if(args.length() &gt; 0 &amp;&amp; args[1] != nil)
<a name="310"></a>      {
<a name="311"></a>         if(dataType(args[1]) == TypeSString)
<a name="312"></a>            updateContents(args...);
<a name="313"></a>         else  
<a name="314"></a>            showCurrentContents();
<a name="315"></a>      }
<a name="316"></a>  }
<a name="317"></a>   
<a name="318"></a>  removeBanner()
<a name="319"></a>  {
<a name="320"></a>    /*
<a name="321"></a>     *  If I'm removed I can't be inited_ any more, and I'll need to be regarded
<a name="322"></a>     *  as not inited_ in the event of being redisplayed in the future.
<a name="323"></a>     */
<a name="324"></a>  
<a name="325"></a>    inited_ = nil;
<a name="326"></a>    
<a name="327"></a>    inherited;
<a name="328"></a>  } 
<a name="329"></a>   
<a name="330"></a>   
<a name="331"></a>  /*
<a name="332"></a>   * Set this flag to true to clear the contents of the window before displaying
<a name="333"></a>   * the new contents, e.g. to display a new picture that replaces the old one.
<a name="334"></a>   */
<a name="335"></a>  clearBeforeUpdate =  true
<a name="336"></a>  
<a name="337"></a>  /* 
<a name="338"></a>   *  Set this to true to have this banner size to contents each time its
<a name="339"></a>   *  contents are displayed. Note that not all interpreters support the size to
<a name="340"></a>   *  contents so you should still set an appropriate initial size, and, where
<a name="341"></a>   *  appropriate, call setSize() with the isAdvisory flag set.
<a name="342"></a>   */
<a name="343"></a>    
<a name="344"></a>  autoSize = nil
<a name="345"></a>  
<a name="346"></a>  
<a name="347"></a>  /*
<a name="348"></a>   *  Update the contents of this banner window. This is the method to
<a name="349"></a>   *  call to change what a banner displays.   
<a name="350"></a>   *
<a name="351"></a>   *  The second argument is optional. If present it overrides the 
<a name="352"></a>   *  setting of clearBeforeUpdate: updateContents(cont, true) will
<a name="353"></a>   *  clear the banner before the update, whereas updateContents(cont, nil)
<a name="354"></a>   *  will not, whatever the value of clearBeforeUpdate. 
<a name="355"></a>   */
<a name="356"></a>   
<a name="357"></a>  updateContents(cont, [args])
<a name="358"></a>  {
<a name="359"></a>    /*
<a name="360"></a>     *  Update our current contents. Note that this takes place even if
<a name="361"></a>     *  shouldDisplay is nil, so that if, for example, we are updated on
<a name="362"></a>     *  a text-only interpreter on which this banner is not displayed, 
<a name="363"></a>     *  and the game is saved there and subsequently restored on a full HTML 
<a name="364"></a>     *  interpreter in which we are displayed, the HTML interpreter will know 
<a name="365"></a>     *  what contents it needs to display in us.
<a name="366"></a>     */
<a name="367"></a>    currentContents = cont;
<a name="368"></a>    
<a name="369"></a>    showCurrentContents(args...);
<a name="370"></a>  }
<a name="371"></a>  
<a name="372"></a>  /* Show the current contents of this banner window */  
<a name="373"></a>  
<a name="374"></a>  showCurrentContents([args])
<a name="375"></a>  { 
<a name="376"></a>    local clr;
<a name="377"></a>    if(args.length &gt; 0)
<a name="378"></a>      clr = (args[1] != nil);
<a name="379"></a>    else
<a name="380"></a>      clr = clearBeforeUpdate;
<a name="381"></a>     
<a name="382"></a>    if(clr)    
<a name="383"></a>       clearWindow();
<a name="384"></a>          
<a name="385"></a>     writeToBanner(currentContents);      
<a name="386"></a>     
<a name="387"></a>     if(autoSize)
<a name="388"></a>       sizeToContents();
<a name="389"></a>  }
<a name="390"></a>  
<a name="391"></a>  
<a name="392"></a>   /*  This is called on each CustomBannerWindow after a Restore. */   
<a name="393"></a>   
<a name="394"></a>  restoreBannerDisplay()
<a name="395"></a>  {
<a name="396"></a>        /* 
<a name="397"></a>         * It's possible a game was saved in a text-mode terp and
<a name="398"></a>         * restored in an HTML one. In which case we need to initialize
<a name="399"></a>         * this banner before attempting to display anything
<a name="400"></a>         */
<a name="401"></a>         
<a name="402"></a>         if(shouldDisplay &amp;&amp; handle_ == nil)
<a name="403"></a>         {
<a name="404"></a>            if(!initBannerWindow())
<a name="405"></a>              return;
<a name="406"></a>         }
<a name="407"></a>                  
<a name="408"></a>        
<a name="409"></a>        /* redisplay my contents after a restore */        
<a name="410"></a>        showCurrentContents(); 
<a name="411"></a>  }  
<a name="412"></a>  
<a name="413"></a>  /*
<a name="414"></a>   *  Alternatively we might have been saved in a terp that does
<a name="415"></a>   *  use this banner and restored in one that doesn't, in which
<a name="416"></a>   *  case we should remove ourselves. This is called on each BannerWindow
<a name="417"></a>   *  after a restore, but before bannerTracker.restoreDisplayState().
<a name="418"></a>   */
<a name="419"></a>     
<a name="420"></a>  restoreRemove()
<a name="421"></a>  {
<a name="422"></a>     if(!shouldDisplay)        
<a name="423"></a>        removeBanner();     
<a name="424"></a>  }
<a name="425"></a>  
<a name="426"></a>  
<a name="427"></a>  /* show my initial contents on startup */
<a name="428"></a>       
<a name="429"></a>  initBannerDisplay()  {  showCurrentContents();   }
<a name="430"></a>  
<a name="431"></a>  /*
<a name="432"></a>   *   We provide overrides for all the various banner manipulation methods
<a name="433"></a>   *   that game code might call, in order to make it safe to call them even
<a name="434"></a>   *   our shouldDisplay method returns nil and we don't - or shouldn't - exist.
<a name="435"></a>   *   For each of these xxxYyy methods we provide an altXxxyyy method that is
<a name="436"></a>   *   called when shouldDisplay is nil (e.g. because we're using a window to
<a name="437"></a>   *   display graphics on an interpreter that doesn't have graphics capablities).
<a name="438"></a>   *   By default these altXxxYyy methods do nothing, which in many cases will
<a name="439"></a>   *   be fine, but if you do want something else to happen you can override
<a name="440"></a>   *   the appropriate altXxxYyy method accordingly (e.g. to show a message in
<a name="441"></a>   *   the main game window instead of this banner). This should make it easier
<a name="442"></a>   *   to structure the rest of your game code without needing to worry about
<a name="443"></a>   *   what happens on interpreters which don't display your banners.
<a name="444"></a>   */
<a name="445"></a>   
<a name="446"></a>  clearWindow()
<a name="447"></a>  {
<a name="448"></a>    if(shouldDisplay)
<a name="449"></a>      inherited();
<a name="450"></a>    else
<a name="451"></a>      altClearWindow();
<a name="452"></a>  }
<a name="453"></a>  
<a name="454"></a>  altClearWindow() { }
<a name="455"></a>    
<a name="456"></a>  /* write to me, but only if I should display */ 
<a name="457"></a>   
<a name="458"></a>  writeToBanner(txt)
<a name="459"></a>  {  
<a name="460"></a>    if(shouldDisplay)
<a name="461"></a>      inherited(txt);
<a name="462"></a>    else
<a name="463"></a>      altWriteToBanner(txt);
<a name="464"></a>  }
<a name="465"></a>  
<a name="466"></a>  /*
<a name="467"></a>   *  altWriteToBanner(txt) is called when our game code tries to display
<a name="468"></a>   *  something in this banner, but our shouldDisplay method has ruled out
<a name="469"></a>   *  displaying this banner. In this case we might want to write something
<a name="470"></a>   *  to the main display instead. By default we do nothing here, but
<a name="471"></a>   *  individual instances and/or subclasses can override this method as
<a name="472"></a>   *  required.
<a name="473"></a>   */
<a name="474"></a>  
<a name="475"></a>  altWriteToBanner(txt) { }
<a name="476"></a>  
<a name="477"></a>  
<a name="478"></a>  /* 
<a name="479"></a>   *  We don't provide alternative methods for the setSize and sizeToContents
<a name="480"></a>   *  methods, since there would almost certainly be nothing for them to do.
<a name="481"></a>   *  We simply do nothing if shouldDisplay is nil.
<a name="482"></a>   */
<a name="483"></a>  
<a name="484"></a>  setSize(size, sizeUnits, isAdvisory)
<a name="485"></a>  {
<a name="486"></a>       if(shouldDisplay)
<a name="487"></a>         inherited(size, sizeUnits, isAdvisory);
<a name="488"></a>  }
<a name="489"></a>     
<a name="490"></a>  sizeToContents()
<a name="491"></a>  {
<a name="492"></a>        /* size our system-level window to our contents */
<a name="493"></a>       if(shouldDisplay)  
<a name="494"></a>         bannerSizeToContents(handle_);
<a name="495"></a>  }
<a name="496"></a>
<a name="497"></a>  captureOutput(func)
<a name="498"></a>  {
<a name="499"></a>     if(shouldDisplay)
<a name="500"></a>       inherited(func);
<a name="501"></a>     else
<a name="502"></a>       altCaptureOutput(func);  
<a name="503"></a>  }
<a name="504"></a>  
<a name="505"></a>  /* Simply execute the callback without changing the output stream */
<a name="506"></a>  
<a name="507"></a>  altCaptureOutput(func) { (func)(); }
<a name="508"></a>           
<a name="509"></a>  setOutputStream()
<a name="510"></a>     {
<a name="511"></a>        if(shouldDisplay)
<a name="512"></a>           /* set my stream as the default */
<a name="513"></a>           return outputManager.setOutputStream(outputStream_);
<a name="514"></a>        else
<a name="515"></a>           return altSetOutputStream();          
<a name="516"></a>     }
<a name="517"></a>     
<a name="518"></a>  /* 
<a name="519"></a>   *  Our caller, or rather our caller's caller, will expect us to return
<a name="520"></a>   *  the current output stream, which means we must be sure to do this
<a name="521"></a>   *  whatever else we do.  
<a name="522"></a>   */
<a name="523"></a>         
<a name="524"></a>  altSetOutputStream() { return outputManager.curOutputStream; }         
<a name="525"></a>  
<a name="526"></a>  flushBanner() 
<a name="527"></a>  { 
<a name="528"></a>    if(shouldDisplay)
<a name="529"></a>      inherited();
<a name="530"></a>    else  
<a name="531"></a>      altFlushBanner();
<a name="532"></a>  }
<a name="533"></a>         
<a name="534"></a>  altFlushBanner() { }       
<a name="535"></a>           
<a name="536"></a>  setTextColor(fg, bg)
<a name="537"></a>  {
<a name="538"></a>    if(shouldDisplay)
<a name="539"></a>      inherited(fg, bg);
<a name="540"></a>    else
<a name="541"></a>      altSetTextColor(fg, bg);
<a name="542"></a>  }         
<a name="543"></a>          
<a name="544"></a>  altSetTextColor(fg, bg) { }
<a name="545"></a>  
<a name="546"></a>  setScreenColor(color)
<a name="547"></a>  {
<a name="548"></a>    if(shouldDisplay)
<a name="549"></a>      inherited(color);
<a name="550"></a>    else
<a name="551"></a>      altSetScreenColor(color);
<a name="552"></a>  }
<a name="553"></a>  
<a name="554"></a>  altSetScreenColor(color) { }
<a name="555"></a>  
<a name="556"></a>  cursorTo(row, col)
<a name="557"></a>  {
<a name="558"></a>    if(shouldDisplay)
<a name="559"></a>      inherited(row, col);
<a name="560"></a>    else
<a name="561"></a>      altCursorTo(row, col);
<a name="562"></a>  }             
<a name="563"></a>           
<a name="564"></a>  /* 
<a name="565"></a>   *  If this banner isn't displaying we can't do anything directly comparable
<a name="566"></a>   *  to setting the cursot to a particular column and row in it, but we might
<a name="567"></a>   *  want to do something else instead, like inserting so many blank lines in 
<a name="568"></a>   *  the main window.            
<a name="569"></a>   */       
<a name="570"></a>  altCursorTo(row, col) { }         
<a name="571"></a>;
<a name="572"></a>
<a name="573"></a>
<a name="574"></a>
<a name="575"></a> /*
<a name="576"></a>  *  Initialize or reinitialize what all CustomBanners display at startup or
<a name="577"></a>  *  after an UNDO
<a name="578"></a>  */
<a name="579"></a>
<a name="580"></a>customBannerInit: InitObject, PostUndoObject
<a name="581"></a>  execBeforeMe =  [bannerInit]
<a name="582"></a>  
<a name="583"></a>  execute()
<a name="584"></a>  {
<a name="585"></a>     /* first ensure that all banner windows that need to exist do exist */
<a name="586"></a>     
<a name="587"></a>     forEachInstance(CustomBannerWindow, new function(win) {
<a name="588"></a>        if(win.shouldDisplay &amp;&amp; win.handle_ == nil)
<a name="589"></a>          win.initBannerWindow(); 
<a name="590"></a>     } );
<a name="591"></a>  
<a name="592"></a>     /* then show the current contents of every active banner */
<a name="593"></a>  
<a name="594"></a>     forEachInstance(CustomBannerWindow, {win: win.showCurrentContents() } );
<a name="595"></a>  }
<a name="596"></a>;
<a name="597"></a>
<a name="598"></a>  /*
<a name="599"></a>   *  Reinitialize what all the CustomBanners display on restoring. This requires
<a name="600"></a>   *  a different procedure since we can't be sure that we're being restored on
<a name="601"></a>   *  the same class of interpreter as we were saved on.
<a name="602"></a>   */
<a name="603"></a>
<a name="604"></a>customBannerRestore: PostRestoreObject
<a name="605"></a>   execBeforeMe = [bannerTracker] 
<a name="606"></a>
<a name="607"></a>   execute()
<a name="608"></a>   {
<a name="609"></a>   
<a name="610"></a>     /*
<a name="611"></a>      *  If we save in one terp, restore in the second terp, save in the second
<a name="612"></a>      *  terp, then restore in the first terp, when different rules apply about
<a name="613"></a>      *  displaying banners in the two terps, then windows removed in the second
<a name="614"></a>      *  terp could still be marked as inited_ in the restore file that comes
<a name="615"></a>      *  back to the first terp. To get round this, on restoration we ensure
<a name="616"></a>      *  that each CustomBanner's inited_ property in fact corresponds to whether
<a name="617"></a>      *  it has an active handle_, otherwise the attempt to reinitialize missing
<a name="618"></a>      *  banners might fail.
<a name="619"></a>      */
<a name="620"></a>     forEachInstance(CustomBannerWindow, {win: win.inited_ = (win.handle_ != nil) } );
<a name="621"></a>       
<a name="622"></a>     forEachInstance(CustomBannerWindow, {win: win.restoreBannerDisplay() } );
<a name="623"></a>   }
<a name="624"></a>
<a name="625"></a>;
<a name="626"></a>
<a name="627"></a>customBannerRestoreRemove: PostRestoreObject
<a name="628"></a>  execAfterMe = [bannerTracker]
<a name="629"></a>
<a name="630"></a>  execute()
<a name="631"></a>  {
<a name="632"></a>      forEachInstance(CustomBannerWindow, {win: win.restoreRemove() } );
<a name="633"></a>  }
<a name="634"></a>;
<a name="635"></a>
<a name="636"></a> /*
<a name="637"></a>  *  If we display a menu then we need to remove any active banners from the
<a name="638"></a>  *  screen before the menu displays and restore them to the screen on exiting
<a name="639"></a>  *  from the menu
<a name="640"></a>  */
<a name="641"></a>modify MenuItem
<a name="642"></a>  display()
<a name="643"></a>  {
<a name="644"></a>    /*
<a name="645"></a>     *  First we store a list of all the banners that are currently
<a name="646"></a>     *  displaying
<a name="647"></a>     */
<a name="648"></a>    local vec = new Vector(10);
<a name="649"></a>     
<a name="650"></a>    forEachInstance(CustomBannerWindow, new function(ban) {
<a name="651"></a>        if(ban.shouldDisplay)
<a name="652"></a>          vec.append(ban);  } );    
<a name="653"></a>          
<a name="654"></a>    /* deactive all active banners */      
<a name="655"></a>          
<a name="656"></a>    foreach(local ban in vec)
<a name="657"></a>       ban.deactivate();
<a name="658"></a>        
<a name="659"></a>    try
<a name="660"></a>    {
<a name="661"></a>       /* carry out the inherited menu display */
<a name="662"></a>       inherited();
<a name="663"></a>    }  
<a name="664"></a>      
<a name="665"></a>   /* 
<a name="666"></a>    *  Restore all the banners in our list of banners that were previously
<a name="667"></a>    *  displayed. To ensure that they are activated in the right order
<a name="668"></a>    *  we make what may be several passes through the list. On each pass
<a name="669"></a>    *  we activate only those banners that don't depend on any inactive
<a name="670"></a>    *  banners for their activation. Each time we activate a banner, we
<a name="671"></a>    *  remove it from the list. On the next pass through the list any
<a name="672"></a>    *  banners that depended on banners we have just activated may now themselves
<a name="673"></a>    *  be activated, so we can carry on until every banner has been activated
<a name="674"></a>    *  and removed from the list.  
<a name="675"></a>    */  
<a name="676"></a>   finally
<a name="677"></a>   {
<a name="678"></a>     while(vec.length())
<a name="679"></a>     {
<a name="680"></a>       local bannerRemoved = nil;
<a name="681"></a>       
<a name="682"></a>       foreach(local ban in vec)
<a name="683"></a>       {
<a name="684"></a>
<a name="685"></a>       
<a name="686"></a>         if(ban.bannerArgs[1] != nil &amp;&amp; ban.bannerArgs[1].handle_ == nil)
<a name="687"></a>            continue;
<a name="688"></a>           
<a name="689"></a>         if(ban.bannerArgs[3] != nil &amp;&amp; ban.bannerArgs[3].handle_ == nil)
<a name="690"></a>            continue; 
<a name="691"></a>                      
<a name="692"></a>         ban.activate(true);
<a name="693"></a>         vec.removeElement(ban);
<a name="694"></a>         bannerRemoved = true;      
<a name="695"></a>       }  
<a name="696"></a>       
<a name="697"></a>       /*
<a name="698"></a>        *  If we didn't remove any banners on this pass through, we're
<a name="699"></a>        *  potentially in an infinite loop, so we'd better break out
<a name="700"></a>        *  of it.
<a name="701"></a>        */
<a name="702"></a>       if(!bannerRemoved)
<a name="703"></a>         break;
<a name="704"></a>     }
<a name="705"></a>      
<a name="706"></a>    }            
<a name="707"></a>  }
<a name="708"></a>; 
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>date.h</title></head><body>
<table class=ban><tr><td><h1>date.h</h1><td align=right><a href="../file/date.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   Copyright (c) 2001, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This header defines the Date and TimeZone intrinsic classes.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>/* include our base class definition */
<a name="13"></a>#include "systype.h"
<a name="14"></a>
<a name="15"></a>
<a name="16"></a>/* ------------------------------------------------------------------------ */
<a name="17"></a>/*
<a name="18"></a> *   The Date intrinsic class stores a date-and-time value representing a
<a name="19"></a> *   particular point in time, and provides methods and operators for date
<a name="20"></a> *   arithmetic, formatting, and parsing.
<a name="21"></a> *   
<a name="22"></a> *   The date/time value is stored internally in terms of universal time
<a name="23"></a> *   (UTC).  This makes it independent of locations and time zones.  When a
<a name="24"></a> *   new Date object is created for a given calendar day or clock time, that
<a name="25"></a> *   source value is assumed to be in terms of the local wall clock time of
<a name="26"></a> *   the machine it's running on, but a different time zone can be explicitly
<a name="27"></a> *   specified instead; the Date object automatically translates that local
<a name="28"></a> *   time value to UTC for storage.  Likewise, when a Date is formatted to a
<a name="29"></a> *   string representation, or when calendar or clock components are
<a name="30"></a> *   extracted from it, the formatted or extracted value is translated by
<a name="31"></a> *   default to the local time zone, but a different time zone can be
<a name="32"></a> *   specified.
<a name="33"></a> *   
<a name="34"></a> *   You can create a Date object from a number of other representations for
<a name="35"></a> *   date values:
<a name="36"></a> *   
<a name="37"></a> *.   new Date() - creates a Date representing the current date and time.
<a name="38"></a> *   
<a name="39"></a> *.   new Date('string', refTZ?, refDate?) - parses the string as a date
<a name="40"></a> *.          value.  'refTZ' is an optional TimeZone object; if provided,
<a name="41"></a> *.          the date string will be interpreted as a local time in that
<a name="42"></a> *.          zone, unless the string contains a timezone specifier.  The
<a name="43"></a> *.          default timezone if 'refTZ' is missing is the local system's
<a name="44"></a> *.          time zone.  'refDate' is an optional Date object that's used
<a name="45"></a> *.          to fill in certain missing date elements in the string.  If
<a name="46"></a> *.          the string doesn't specify the year (e.g., 'March 1'), the
<a name="47"></a> *.          year is taken from refDate; if the string only specifies only
<a name="48"></a> *.          a time, the date is taken from refDate.  If the date uses a
<a name="49"></a> *.          two-digit year number ('5/15/92'), the century is inferred
<a name="50"></a> *.          from the reference date by finding the year closest to the
<a name="51"></a> *.          reference year (for example, if it's currently 2012, '92' is
<a name="52"></a> *.          interpreted as 1992, since that's closer to 2012 than is
<a name="53"></a> *.          2092).  The date parser accepts numerous common human-readable
<a name="54"></a> *.          formats and several standard computer formats.  For a full
<a name="55"></a> *.          list of, see the System Manual.  The parser uses the locale
<a name="56"></a> *.          settings from setLocaleInfo() to match month names, weekday
<a name="57"></a> *.          names, etc; the default settings are for US English format.
<a name="58"></a> *
<a name="59"></a> *.   new Date(number, 'J') - 'number' can be an integer or a BigNumber.
<a name="60"></a> *.          This creates a Date object representing the given number of
<a name="61"></a> *.          days after January 1, 4713 BCE on the Julian calendar, at
<a name="62"></a> *.          noon UTC.  The fractional part is the fraction of a day
<a name="63"></a> *.          past noon; for example, a fractional portion of 0.25
<a name="64"></a> *.          represents 1/4 of a day, or 6 hours, so it represents a
<a name="65"></a> *.          clock time of 18:00 UTC (6 hours past noon).
<a name="66"></a> *   
<a name="67"></a> *.   new Date(number, 'U') - 'number' can be an integer or a BigNumber.
<a name="68"></a> *.          This creates a Date object representing the given number of
<a name="69"></a> *.          seconds after standard Unix Epoch (1/1/1970 00:00:00 UTC),
<a name="70"></a> *.          or before the Epoch if the value is negative.  If 'number'
<a name="71"></a> *.          is a BigNumber, it can specify fractions of a second, which
<a name="72"></a> *.          the Date object will round to the nearest milliseconds.
<a name="73"></a> *.          This constructor format is provided because "seconds since
<a name="74"></a> *.          1/1/1970" is the standard representation of time on Unix-like
<a name="75"></a> *.          systems, and as a result it's also common in file formats.
<a name="76"></a> *   
<a name="77"></a> *.   new Date(year, month, day, tz?) - midnight on year/month/day (all
<a name="78"></a> *.          given as integers), in the given local time zone 'tz' (given
<a name="79"></a> *.          as a TimeZone object or a string giving a time zone name).
<a name="80"></a> *.          The default time zone if 'tz' is omitted is the system's
<a name="81"></a> *.          local time zone.  The year must be given as the full year
<a name="82"></a> *.          with century, e.g., 2012, not just 12; the latter is valid
<a name="83"></a> *.          but is taken literally as the first-century year 12.  The
<a name="84"></a> *.          month is 1-12 for January to December.  The day is simply
<a name="85"></a> *.          the calendar day of the month (e.g., 5 for January 5).  The
<a name="86"></a> *.          year can zero or negative.  Note that because year 0 is a
<a name="87"></a> *.          valid year in Date's calendar system, negative years are off
<a name="88"></a> *.          by one from the "BC" convention: in the AD/BC convention,
<a name="89"></a> *.          the year before AD 1 is 1 BC, not AD 0; so on our calendar,
<a name="90"></a> *.          year 0 corresponds to 1 BC, -1 is 2 BC, etc.
<a name="91"></a> *   
<a name="92"></a> *.   new Date(year, month, day, hour, minute, seconds, ms, tz?) - the
<a name="93"></a> *.          given date and time value, with each element as an integer.
<a name="94"></a> *.          The value is in terms of the given local time zone 'tz',
<a name="95"></a> *.          or the system's local time zone if 'tz' is omitted.  'ms'
<a name="96"></a> *.          is the number of milliseconds (0-999).
<a name="97"></a> *   
<a name="98"></a> *   Date arithmetic: the following operators perform calendar calculations
<a name="99"></a> *   on the date value:
<a name="100"></a> *   
<a name="101"></a> *.   Date + integer   - add days to the date
<a name="102"></a> *.   Date - integer   - subtract days from date
<a name="103"></a> *.   Date + BigNumber - add days (which can include fractional days)
<a name="104"></a> *.   Date - BigNumber - subtract days (which can include fractional days)
<a name="105"></a> *.   Date - Date      - number of days between dates (with fractional days)
<a name="106"></a> *   
<a name="107"></a> *   Adding an integer or BigNumber returns a new Date object representing
<a name="108"></a> *   the result; Date objects are immutable, so the original Date value isn't
<a name="109"></a> *   changed by the operation.
<a name="110"></a> *   
<a name="111"></a> *   Subtracting one Date from another yields a BigNumber with the difference
<a name="112"></a> *   in days between the two dates.  Note that this might have a fractional
<a name="113"></a> *   part, because the difference might not be whole days; for example,
<a name="114"></a> *   subtracting 13:00 from 19:00 on the same day yields 0.25, which is 1/4
<a name="115"></a> *   of a 24-hour day, or 6 hours..  Like all Date arithmetic, subtraction
<a name="116"></a> *   works in universal time, so the subtraction yields the true time
<a name="117"></a> *   difference between the events even if they were created from times in
<a name="118"></a> *   different time zones.  For example, subtracting 1 PM Eastern Time from 1
<a name="119"></a> *   PM Pacific Time on the same day yields 0.125 (1/8 of a day, or 3 hours).
<a name="120"></a> *   
<a name="121"></a> *   The comparison operators (&lt; &gt; &lt;= &gt;=) compare two Date values by order of
<a name="122"></a> *   occurrence in time.  For example, a &gt; b is true if a is later than b.
<a name="123"></a> *   The comparison is done in universal time, so the comparison yields the
<a name="124"></a> *   actual event order, not the nominal local time order.  For example, 2 PM
<a name="125"></a> *   Eastern Time is earlier than 1 PM Pacific Time on any given day.
<a name="126"></a> *   
<a name="127"></a> *   Time zone specifications: when a time zone is specified in a constructor
<a name="128"></a> *   or method argument, you can supply a TimeZone object, or a string with
<a name="129"></a> *   the name of a time zone, using the same formats that the TimeZone
<a name="130"></a> *   constructor accepts.  See the TimeZone object for more information.  The
<a name="131"></a> *   default if you don't specify a time zone is 
<a name="132"></a> *   
<a name="133"></a> */
<a name="134"></a>intrinsic class Date 'date/030000': Object
<a name="135"></a>{
<a name="136"></a>    /*
<a name="137"></a>     *   Parse a date.  This is similar to the new Date('date string')
<a name="138"></a>     *   constructor, but lets you specify your own custom format templates,
<a name="139"></a>     *   and returns a detailed breakdown of the source string elements that
<a name="140"></a>     *   were matched in the various fields.  'str' is the source string to
<a name="141"></a>     *   be parsed.  'format' is an optional format string, or a list of
<a name="142"></a>     *   format strings used to parse the date, or be nil if you simply want
<a name="143"></a>     *   to use the built-in formats.  See the System Manual for the syntax
<a name="144"></a>     *   of these strings.  If you want to specify one or more custom formats
<a name="145"></a>     *   and also use the built-in formats, use a list for 'format', and
<a name="146"></a>     *   include a nil element to include the standard formats.  'refDate' is
<a name="147"></a>     *   the reference date, which is used to fill in certain missing fields;
<a name="148"></a>     *   this works the same way as in the new Date('str', refDate)
<a name="149"></a>     *   constructor, and defaults to the current time if omitted or nil.
<a name="150"></a>     *   'refTZ' is the reference time zone, and defaults to the host
<a name="151"></a>     *   system's local time zone if omitted or nil.
<a name="152"></a>     *   
<a name="153"></a>     *   The return value on success is a list: [date, tzobj, format, era,
<a name="154"></a>     *   year, month, day, yearDay, weekDay, ampm, hour, minute, second, ms,
<a name="155"></a>     *   unix, tz].  'date' is the parsed Date object.  'tzobj' is a TimeZone
<a name="156"></a>     *   object if a timezone is specified in the date string, otherwise nil
<a name="157"></a>     *   (in which case the date is implicitly in terms of 'refTZ', or the
<a name="158"></a>     *   host system's local timezone if 'refTZ' is omitted).  'format' is
<a name="159"></a>     *   the actual format string(s) that was/were matched, which can come
<a name="160"></a>     *   from the custom format strings you supplied and/or the built-in
<a name="161"></a>     *   formats; if multiple formats were matched, they'll be concatenated
<a name="162"></a>     *   together to form this string.  The remaining fields are strings
<a name="163"></a>     *   giving the literal source text matched for the individual date
<a name="164"></a>     *   components, or nil for components not matched.
<a name="165"></a>     *   
<a name="166"></a>     *   If the date string can't be parsed, the return value is nil.
<a name="167"></a>     */
<a name="168"></a>    static parseDate(str, format?, refDate?, refTZ?);
<a name="169"></a>
<a name="170"></a>    /*
<a name="171"></a>     *   Parse a Julian date.  This works like parseDate(), except that the
<a name="172"></a>     *   date is interpreted on the Julian calendar.  Julian dates have the
<a name="173"></a>     *   same form as Gregorian dates, but a given day will have different
<a name="174"></a>     *   nominal dates on the two calendars, except for most of the third
<a name="175"></a>     *   century, where they happen to align.  The further in time a day is
<a name="176"></a>     *   from the overlap in the third century, the more the dates will
<a name="177"></a>     *   diverge on the two calendars; in the 21st century, the difference is
<a name="178"></a>     *   about 13 days.
<a name="179"></a>     */
<a name="180"></a>    static parseJulianDate(str, format?, refDate?, refTZ?);
<a name="181"></a>
<a name="182"></a>    /*
<a name="183"></a>     *   Format the date/time value as a Gregorian calendar date, using the
<a name="184"></a>     *   given format template string.  Returns a string with the formatted
<a name="185"></a>     *   date/time.  The date/time is displayed in the given time zone (or
<a name="186"></a>     *   the system's local time zone if 'tz' isn't specified).
<a name="187"></a>     */
<a name="188"></a>    formatDate(format, tz?);
<a name="189"></a>
<a name="190"></a>    /*
<a name="191"></a>     *   Format the date/time value as a Julian calendar date, using the
<a name="192"></a>     *   given format template string. 
<a name="193"></a>     */
<a name="194"></a>    formatJulianDate(format, tz?);
<a name="195"></a>
<a name="196"></a>    /*
<a name="197"></a>     *   Compare to another Date object; returns an integer less than zero if
<a name="198"></a>     *   this Date is before the other Date, zero if they refer to the same
<a name="199"></a>     *   date, greater than zero if this Date is after the other Date.  The
<a name="200"></a>     *   same comparisons can be done with the ordinary comparison operators
<a name="201"></a>     *   (&lt;, &gt;, &lt;=, &gt;=, ==, !=), but this is convenient for sorting callbacks
<a name="202"></a>     *   since it lets you get the greater/equal/less result in one shot.
<a name="203"></a>     */
<a name="204"></a>    compareTo(date);
<a name="205"></a>
<a name="206"></a>    /* 
<a name="207"></a>     *   Get the Gregorian calendar date represented by this Date object, in
<a name="208"></a>     *   terms of local time in the given time zone (or the system's local
<a name="209"></a>     *   time zone if 'tz' isn't specified).  Returns a list consisting of
<a name="210"></a>     *   [year, month, day, weekday], each value represented as an integer.
<a name="211"></a>     *   The weekday is 1 for Sunday, 2 for Monday, etc.  For example, June
<a name="212"></a>     *   21, 2012 (a Thursday) is represented as [2012,6,21,5].
<a name="213"></a>     */
<a name="214"></a>    getDate(tz?);
<a name="215"></a>
<a name="216"></a>    /*
<a name="217"></a>     *   Get the Julian day number.  This is the number of days since January
<a name="218"></a>     *   1, 4713 BCE on the (proleptic) Julian calendar, at noon UTC.  This
<a name="219"></a>     *   is an important figure in astronomy.  It's also often useful as a
<a name="220"></a>     *   common currency for converting between arbitrary calendars: you
<a name="221"></a>     *   might not be able to find a published formula for converting between
<a name="222"></a>     *   calendar X and calendar Y, but you can almost always find a formula
<a name="223"></a>     *   for converting between any given calendar and the Julian day system.
<a name="224"></a>     *   
<a name="225"></a>     *   The return value is a BigNumber value giving the Julian day
<a name="226"></a>     *   corresponding to this Date value, including a fractional part for
<a name="227"></a>     *   the time past noon UTC on that date.
<a name="228"></a>     *   
<a name="229"></a>     *   Note that there's no local time zone involved in this calculation,
<a name="230"></a>     *   since the Julian day number is specifically defined in terms of
<a name="231"></a>     *   universal time.
<a name="232"></a>     */
<a name="233"></a>    getJulianDay();
<a name="234"></a>
<a name="235"></a>    /*
<a name="236"></a>     *   Get the Julian calendar date for this Date object, in terms of the
<a name="237"></a>     *   local time in the given time zone (or the system's local time zone
<a name="238"></a>     *   if 'tz' isn't specified).  Returns a list consisting of [year,
<a name="239"></a>     *   month, day, weekday].  (The weekday on the Julian calendar is always
<a name="240"></a>     *   the same as the weekday on the Gregorian calendar for a given Date
<a name="241"></a>     *   value.)
<a name="242"></a>     */
<a name="243"></a>    getJulianDate(tz?);
<a name="244"></a>
<a name="245"></a>    /*
<a name="246"></a>     *   Get the ISO 8601 week date.  This returns a list with three
<a name="247"></a>     *   elements, [year, week, day], where 'year' is the ISO year number
<a name="248"></a>     *   containing the date, 'week' is the week number (1 to 53), and 'day'
<a name="249"></a>     *   is the day of the week (1-7, Monday to Sunday, per the ISO 8601
<a name="250"></a>     *   conventions).  The year on the ISO week calendar can differ from the
<a name="251"></a>     *   year on the Gregorian calendar for dates during the first and last
<a name="252"></a>     *   week of a year on Gregorian calendar, because year boundaries on the
<a name="253"></a>     *   ISO calendar always occur on week boundaries.  For example, Jan 1,
<a name="254"></a>     *   2005 has the ISO week date 2004-W53-6 - it's part of 2004 on the ISO
<a name="255"></a>     *   week calendar because weeks can't be split across years, so the
<a name="256"></a>     *   entire week belongs to 2004 on the ISO calendar.  This can work in
<a name="257"></a>     *   both directions: Dec 31, 2007 has the ISO week date 2008-W01-1.
<a name="258"></a>     */
<a name="259"></a>    getISOWeekDate(tz?);
<a name="260"></a>
<a name="261"></a>    /* 
<a name="262"></a>     *   Get the wall clock time represented by this Date object, in terms of
<a name="263"></a>     *   local time in the given time zone (or the system's local time zone
<a name="264"></a>     *   is 'tz' isn't specified).  Returns a list of integers: [hour,
<a name="265"></a>     *   minute, second, ms].  The hour is on a 24-hour clock, with 0 hours
<a name="266"></a>     *   representing midnight and 23 representing 11 PM.  The 'ms' value is
<a name="267"></a>     *   a value from 0 to 999 giving the milliseconds portion of the time.
<a name="268"></a>     */
<a name="269"></a>    getClockTime(tz?);
<a name="270"></a>
<a name="271"></a>    /*
<a name="272"></a>     *   Add an interval to this date, returning a new date object.  The
<a name="273"></a>     *   interval is given as a list of integers: [years, months, days,
<a name="274"></a>     *   hours, minutes, seconds].  The 'seconds' value can be a BigNumber
<a name="275"></a>     *   with a fractional part (but anything smaller than milliseconds is
<a name="276"></a>     *   discarded).  Elements can be omitted from the end of the list; for
<a name="277"></a>     *   example, [0, 2] adds two months.  An element can be negative: [-1]
<a name="278"></a>     *   subtracts one year.
<a name="279"></a>     */
<a name="280"></a>    addInterval(interval);
<a name="281"></a>
<a name="282"></a>    /*
<a name="283"></a>     *   Find a given day of the week relative to this date, in its local
<a name="284"></a>     *   time zone.  'weekday' is the target weekday to find, as an integer:
<a name="285"></a>     *   1 for Sunday, 2 for Monday, ..., 7 for Saturday.  'which' is an
<a name="286"></a>     *   integer specifying which relative day to find: 1 means to find the
<a name="287"></a>     *   next occurrence of the given weekday on or after this date, 2 means
<a name="288"></a>     *   the second occurrence on or after this date, and so on.  -1 means
<a name="289"></a>     *   the first occurrence on or before this date; -2 is the second
<a name="290"></a>     *   occurrence on or before this date; etc.
<a name="291"></a>     */
<a name="292"></a>    findWeekday(weekday, which, tz?);
<a name="293"></a>
<a name="294"></a>
<a name="295"></a>    /*
<a name="296"></a>     *   Set a locale string.  This sets localized versions of the string
<a name="297"></a>     *   values used for parsing and formatting date values.  By default,
<a name="298"></a>     *   suitable English strings are used.  See the DateXxx index values for
<a name="299"></a>     *   the individual locale strings that can be customized.
<a name="300"></a>     *   
<a name="301"></a>     *   Note that this is a static method that you call on the Date class
<a name="302"></a>     *   object (e.g., Date.setLocaleInfo(DateMonthNames,
<a name="303"></a>     *   'Sunday,Monday,...').
<a name="304"></a>     *   
<a name="305"></a>     *   There are two ways to call this method:
<a name="306"></a>     *   
<a name="307"></a>     *.  1. Date.setLocaleInfo([monthNames, monthAbbrs, weekdayNames, ...])
<a name="308"></a>     *.  Each item in the list is a string.  This lets you set all of
<a name="309"></a>     *   the locale items in one shot; the items are listed in order of
<a name="310"></a>     *   the DateXxx index values.  You can omit items from the end of
<a name="311"></a>     *   the list; any omitted items won't be changed.
<a name="312"></a>     *   
<a name="313"></a>     *   2. Date.setLocaleInfo(DateXxx, 'value', ...);
<a name="314"></a>     *.  Specify DateXxx indices and the corresponding string values as
<a name="315"></a>     *   alternating arguments.  These have to be provided in pairs.
<a name="316"></a>     *   Any indices not listed won't be affected.
<a name="317"></a>     *   
<a name="318"></a>     *   All of the values are specified as strings.  Most are formatted as
<a name="319"></a>     *   lists of words, separated by commas:
<a name="320"></a>     *   
<a name="321"></a>     *.    Date.setLocaleInfo(DateWeekdayAbbrs, 'Sun,Mon,Tue,Wed,Thu,Fri,Sat');
<a name="322"></a>     *   
<a name="323"></a>     *   For input parsing, you can provide synonyms, separated by '='.  For
<a name="324"></a>     *   example, for month abbreviations, the English version accepts "Sep"
<a name="325"></a>     *   and "Sept" as synonyms, which you can specify like so:
<a name="326"></a>     *   
<a name="327"></a>     *.    Date.setLocaleInfo(DateMonthAbbrs, 'Jan,Feb,Mar,Apr,May,Jun,'
<a name="328"></a>     *.                       + 'Jul,Aug,Sep=Sept,Oct,Nov,Dec');
<a name="329"></a>     *   
<a name="330"></a>     *   When formatting output, the first item in a synonym list is the one
<a name="331"></a>     *   displayed.
<a name="332"></a>     */
<a name="333"></a>    static setLocaleInfo(...);
<a name="334"></a>}
<a name="335"></a>
<a name="336"></a>/*
<a name="337"></a> *   Locale indices for Date.setLocaleInfo()
<a name="338"></a> */
<a name="339"></a>
<a name="340"></a>/* full names of months - January,February,March,... */
<a name="341"></a>#define DateMonthNames     0
<a name="342"></a>
<a name="343"></a>/* month name abbreviations - Jan,Feb,Mar... */
<a name="344"></a>#define DateMonthAbbrs     1
<a name="345"></a>
<a name="346"></a>/* full names of weekdays - Sunday,Monday,Tuesday,... */
<a name="347"></a>#define DateWeekdayNames   2
<a name="348"></a>
<a name="349"></a>/* abbreviated weekday names - Sun,Mon,Tue,... */
<a name="350"></a>#define DateWeekdayAbbrs   3
<a name="351"></a>
<a name="352"></a>/* AM/PM indicators - AM,PM */
<a name="353"></a>#define DateAMPM           4
<a name="354"></a>
<a name="355"></a>/* "era" indicator - AD=CE,BC=BCE */
<a name="356"></a>#define DateEra            5
<a name="357"></a>
<a name="358"></a>/*
<a name="359"></a> *   Parsing filter for culture-specific date formats.  This can be 'us' to
<a name="360"></a> *   select the US-style formats, or 'eu' to select European-style formats.
<a name="361"></a> *   This controls day/month or month/day order when parsing numeric dates -
<a name="362"></a> *   the 'us' formats use the "month/day" style, as in 11/20 for November 20,
<a name="363"></a> *   and the 'eu' formats use "day/month", as in 20/11.
<a name="364"></a> */
<a name="365"></a>#define DateParseFilter    6
<a name="366"></a>
<a name="367"></a>/* 
<a name="368"></a> *   Ordinal suffixes for 1st, 2nd, 3rd, Nth, X1st, X2nd, Xrd.  'Nth' is the
<a name="369"></a> *   suffix for everything not otherwise enumerated.  'X1st' is the suffix
<a name="370"></a> *   for the 21st, 31st, 1041st, etc - this applies to all of the decades
<a name="371"></a> *   except the units and teens; likewise for 'X2nd' and 'X3rd'.  Specify
<a name="372"></a> *   only the suffix; e.g., for English, 'st,nd,rd,th,st,nd,rd'.  If all of
<a name="373"></a> *   the items after a given point are the same for the target language, you
<a name="374"></a> *   can omit them, and the last item in the list will be used for all
<a name="375"></a> *   missing items; e.g., French can specify simply 'er,e', and German can
<a name="376"></a> *   specify simply '.'.
<a name="377"></a> */
<a name="378"></a>#define DateOrdSuffixes    7
<a name="379"></a>
<a name="380"></a>/*
<a name="381"></a> *   Default local format for date/time stamps.  This is a format string
<a name="382"></a> *   suitable for use in formatDate().  The default is '%a %b %#d %T %Y'
<a name="383"></a> *   (which produces, e.g., 'Thu Feb 7 15:20:33 2009').
<a name="384"></a> */
<a name="385"></a>#define DateFmtTimestamp   8
<a name="386"></a>
<a name="387"></a>/* 
<a name="388"></a> *   Default local format for the time, without the date.  The default is
<a name="389"></a> *   '%H:%M:%S' ('18:44:39').
<a name="390"></a> */
<a name="391"></a>#define DateFmtTime        9
<a name="392"></a>
<a name="393"></a>/* 
<a name="394"></a> *   Default local format for the date, without the time.  The default is
<a name="395"></a> *   '%m/%d/%Y' (02/15/2012).
<a name="396"></a> */
<a name="397"></a>#define DateFmtDate       10
<a name="398"></a>
<a name="399"></a>/*
<a name="400"></a> *   Local short date format.  The default is '%m/%d/%y' (02/15/12). 
<a name="401"></a> */
<a name="402"></a>#define DateFmtShortDate  11
<a name="403"></a>
<a name="404"></a>/*
<a name="405"></a> *   12-hour clock format.  The default is '%#I:%M:%S %P' ('5:30:22 PM').
<a name="406"></a> */
<a name="407"></a>#define DateFmt12Hour     12
<a name="408"></a>
<a name="409"></a>/*
<a name="410"></a> *   24-hour clock format.  The default is '%H:%M' (17:30).
<a name="411"></a> */
<a name="412"></a>#define DateFmt24Hour     13
<a name="413"></a>
<a name="414"></a>/*
<a name="415"></a> *   24-hour clock format with seconds.  The default is '%H:%M:%S'
<a name="416"></a> *   (17:30:22). 
<a name="417"></a> */
<a name="418"></a>#define DateFmt24HourSecs 14
<a name="419"></a>
<a name="420"></a>
<a name="421"></a>
<a name="422"></a>/* ------------------------------------------------------------------------ */
<a name="423"></a>/*
<a name="424"></a> *   TimeZone intrinsic class.  A TimeZone object represents a location entry
<a name="425"></a> *   in the IANA zoneinfo database.  It contains information on the
<a name="426"></a> *   location's wall clock time settings relative to universal time (UTC),
<a name="427"></a> *   allowing translations between local wall clock time and UTC.  The object
<a name="428"></a> *   stores the current clock settings in the location, the current ongoing
<a name="429"></a> *   rules for future switches between standard and daylight time (if
<a name="430"></a> *   applicable in the zone), and a full history of the past changes to the
<a name="431"></a> *   location's time settings, including standard/daylight time changes,
<a name="432"></a> *   redefinitions of the time zone, and changes in the location from one
<a name="433"></a> *   time zone to another.  (For example, some US cities that lie near zone
<a name="434"></a> *   borders have switched their time zones at various points in their
<a name="435"></a> *   history.)  The historical information for most zones goes back to the
<a name="436"></a> *   original establishment of standard time zones, typically in the late
<a name="437"></a> *   19th century, and for dates before that, the history usually includes
<a name="438"></a> *   the Local Mean Time settings for the location.  The history information
<a name="439"></a> *   allows the accurate reconstruction of the local time representation for
<a name="440"></a> *   virtually any date and time in the past, present, or future.
<a name="441"></a> *   
<a name="442"></a> *   Construction: 
<a name="443"></a> *   
<a name="444"></a> *.    new TimeZone() - creates a TimeZone object representing the local
<a name="445"></a> *.        system time zone.  Note that a TimeZone object created this way
<a name="446"></a> *.        will always represent the local zone.  If the game is saved on
<a name="447"></a> *.        one machine and restored on another that uses a different local
<a name="448"></a> *.        time zone, the restored object will represent the new machine's
<a name="449"></a> *.        local time zone after the restore.
<a name="450"></a> *   
<a name="451"></a> *.   new TimeZone(integer) - creates a TimeZone object representing the
<a name="452"></a> *.        given offset from UTC, in seconds.  Positive values are east of
<a name="453"></a> *.        UTC, negative values are west; for example, Pacific Standard
<a name="454"></a> *.        Time is 8 hours west of UTC, so you'd use -8*60*60 as the offset.
<a name="455"></a> *.        This type of TimeZone represents a fixed offset
<a name="456"></a> *   
<a name="457"></a> *.   new TimeZone('name') - creates a TimeZone object for the given zone
<a name="458"></a> *.        name.  This can use a number of formats:
<a name="459"></a> *.  
<a name="460"></a> *.        'America/New_York' - a name from the IANA zoneinfo database.
<a name="461"></a> *.            This is the best way to specify a zone because it's
<a name="462"></a> *.            unambiguous.
<a name="463"></a> *.  
<a name="464"></a> *.        'Z', 'UTC' - UTC (Universal Time Coordinated, also sometimes
<a name="465"></a> *.            called GMT/Greenwich Mean Time, or Z/Zulu time)
<a name="466"></a> *   
<a name="467"></a> *.        'EST' - a colloquial English abbreviation for a local time
<a name="468"></a> *.            zone.  Many of these are ambiguous, since some zone names
<a name="469"></a> *.            are used in several different regions.  For example,
<a name="470"></a> *.            'CST' is used in the US, Brazil, Australia, and China,
<a name="471"></a> *.            for time zones at different offsets from UTC.  When the
<a name="472"></a> *.            name is ambiguous, we use a fixed mapping that tends to
<a name="473"></a> *.            favor zones in the US and Europe.  This format is mapped
<a name="474"></a> *.            to a zoneinfo entry, so the actual underlying zone will
<a name="475"></a> *.            be one of the location-based entries.  For example, 'EST'
<a name="476"></a> *.            is mapped to 'America/New_York'.  This is important
<a name="477"></a> *.            because it means that the TimeZone object uses the full
<a name="478"></a> *.            rule set and history for the mapped zone, which might
<a name="479"></a> *.            differ from the history of the same nominal zone in other
<a name="480"></a> *.            locations; e.g., 'America/New_York' and 'Canada/Montreal'
<a name="481"></a> *.            are both on Eastern Time, but they have some differences
<a name="482"></a> *.            in their historical daylight savings rules.
<a name="483"></a> *   
<a name="484"></a> *.        'PST8PDT' - a POSIX TZ-style string, with the standard time
<a name="485"></a> *.            abbreviation, the standard time offset in hours (and
<a name="486"></a> *.            optionally minutes and seconds, with colons), the daylight
<a name="487"></a> *.            time abbreviation, and optionally the daylight time
<a name="488"></a> *.            offset (which defaults to one hour ahead of standard
<a name="489"></a> *.            time when not specified).  This is somewhat less ambiguous
<a name="490"></a> *.            than using just the zone abbreviation, but is still
<a name="491"></a> *   
<a name="492"></a> *.        '+0430' or 'UTC+0430' - four hours thirty minutes east of UTC;
<a name="493"></a> *.            this can also be written as '+4:30' or '+4:30:00'.  For a
<a name="494"></a> *.            whole number of hours, you can write it as simply '+4', for
<a name="495"></a> *.            example.  A negative number is west of UTC; e.g., Pacific
<a name="496"></a> *.            Standard Time is '-8'.  When using this format, the zone
<a name="497"></a> *.            represents a fixed time offset from UTC; it's not tied to
<a name="498"></a> *.            any location or named time zone, and doesn't use daylight
<a name="499"></a> *.            savings time.
<a name="500"></a> *   
<a name="501"></a> *   Note that the commonly used time zone names (e.g., PST, or Pacific
<a name="502"></a> *   Standard Time) aren't allowed.  The standard time zone names are
<a name="503"></a> *   ambiguous; for example, CST refers to at least four different time zones
<a name="504"></a> *   (USA Central Standard Time, Australia Central Standard Time, China
<a name="505"></a> *   Standard Time, and Cuba Summer Time).
<a name="506"></a> *   
<a name="507"></a> */
<a name="508"></a>intrinsic class TimeZone 'timezone/030000' : Object
<a name="509"></a>{
<a name="510"></a>    /*
<a name="511"></a>     *   Get the name or names for this timezone.  This returns a list of
<a name="512"></a>     *   strings with the timezone's names, as defined in the IANA zoneinfo
<a name="513"></a>     *   database.  The zoneinfo database names zones by location, usually
<a name="514"></a>     *   using a combination of a continent major city, as in
<a name="515"></a>     *   'America/New_York'.  Some zones have multiple aliases as a matter of
<a name="516"></a>     *   convenience, such as when there are several major cities in a region
<a name="517"></a>     *   that share the same timezone rules.  When a zone has aliases, the
<a name="518"></a>     *   primary name is listed first, followed by the aliases.
<a name="519"></a>     */
<a name="520"></a>    getNames();
<a name="521"></a>
<a name="522"></a>    /*
<a name="523"></a>     *   Get the history item that applies to a given date, or the entire
<a name="524"></a>     *   enumerated history of clock changes in this timezone.
<a name="525"></a>     *   
<a name="526"></a>     *   If 'date' is supplied, it must be a Date object.  This returns a
<a name="527"></a>     *   list describing the single period in the timezone history that
<a name="528"></a>     *   applies to the given date.  The list contains [date, offset, save,
<a name="529"></a>     *   abbr], where 'date' is a Date object giving the starting date when
<a name="530"></a>     *   the history item took effect; 'offset' is the offset from UTC in
<a name="531"></a>     *   milliseconds of standard time in the zone during this period, using
<a name="532"></a>     *   the zoneinfo convention that positive values are east of GMT; 'save'
<a name="533"></a>     *   is the additional time added if daylight savings is in effect during
<a name="534"></a>     *   this period, in milliseconds, or zero if standard time is in effect;
<a name="535"></a>     *   and 'abbr' is a string giving the abbreviation for the zone during
<a name="536"></a>     *   this period ('PST', 'EDT', etc).  Each period in the history is
<a name="537"></a>     *   entirely in daylight or standard time; if 'save' is zero, standard
<a name="538"></a>     *   time is in effect, otherwise daylight time.
<a name="539"></a>     *   
<a name="540"></a>     *   If 'date' is omitted or nil, this returns a list of all of the
<a name="541"></a>     *   pre-computed changes in the timezone's history, including definition
<a name="542"></a>     *   changes and daylight time changes.  Each list entry is a sublist of
<a name="543"></a>     *   the form described above.
<a name="544"></a>     *   
<a name="545"></a>     *   In a full history, the first and last items are special.  The first
<a name="546"></a>     *   item represents the settings in the location prior to the
<a name="547"></a>     *   establishment of standard time zones; this is usually a "local mean
<a name="548"></a>     *   time" setting (with abbreviation LMT) for the mean solar time at the
<a name="549"></a>     *   location.  The last item represents the last pre-computed history
<a name="550"></a>     *   entry, which is sometimes in the future; further transitions after
<a name="551"></a>     *   this item might occur if the zone has ongoing rules.
<a name="552"></a>     *   
<a name="553"></a>     *   In many cases, the history list contains a number of periods that
<a name="554"></a>     *   could have been inferred from the ongoing rules, so strictly
<a name="555"></a>     *   speaking they don't need to be enumerated in the history.  When
<a name="556"></a>     *   they're included, it's for faster run-time lookup.  TADS
<a name="557"></a>     *   pre-computes rule-based transitions up to the present and a few
<a name="558"></a>     *   years into the future, since history-based lookups are much faster
<a name="559"></a>     *   than applying the rules.  We expect that the typical program will
<a name="560"></a>     *   mostly work with dates close to the present time, so we pre-compute
<a name="561"></a>     *   transitions for a few years into the future to speed things up for
<a name="562"></a>     *   the typical case.  For changes after the last enumerated entry, TADS
<a name="563"></a>     *   applies the rules, so transitions in the far future will be
<a name="564"></a>     *   correctly figured when needed.
<a name="565"></a>     */
<a name="566"></a>    getHistory(date?);
<a name="567"></a>
<a name="568"></a>    /*
<a name="569"></a>     *   Get the ongoing rules that are in effect after the last enumerated
<a name="570"></a>     *   history item.  This returns a list of the rules for future changes
<a name="571"></a>     *   to the zone; each rule fires once annually, and encodes the day of
<a name="572"></a>     *   year when the rule fires, and the new clock settings in effect after
<a name="573"></a>     *   the rule fires.  Virtually all zones that use ongoing rules have
<a name="574"></a>     *   exactly two: one for the annual change to daylight savings time in
<a name="575"></a>     *   the spring, and one for the return to standard time in the fall.
<a name="576"></a>     *   Each rule's firing date is specified in an abstract format designed
<a name="577"></a>     *   to handle the variety of regional daylight savings schemes: "last
<a name="578"></a>     *   Sunday in March", "second Sunday in November", "January 15", etc.
<a name="579"></a>     *   
<a name="580"></a>     *   Each rule in the list is described by a sublist: [abbr, offset,
<a name="581"></a>     *   save, when, mm, typ, dd, wkday, time, zone].  'abbr' is a string
<a name="582"></a>     *   with the time zone abbreviation while the rule is in effect; most
<a name="583"></a>     *   zones use one abbreviation for standard time and another for
<a name="584"></a>     *   daylight time, so each rule tells us the abbreviation to use while
<a name="585"></a>     *   the rule is in effect.  'offset' is the standard time GMT offset, in
<a name="586"></a>     *   milliseconds, while the rule is in effect, and 'save' is the
<a name="587"></a>     *   additional offset for daylight savings time - so the full offset
<a name="588"></a>     *   while the rule is in effect is offset+save.  'when' is a string with
<a name="589"></a>     *   a human-readable description of the firing date: this will be of the
<a name="590"></a>     *   form 'Mar last Sun' (for the last Sunday in March), 'Mar Sun&gt;=1' for
<a name="591"></a>     *   the first Sunday in March on or after March 1, 'Mar Sun&lt;=28' for the
<a name="592"></a>     *   last Sunday in March on or before March 28, 'Mar 7' for March 7, or
<a name="593"></a>     *   'DOY 72' for the 72nd day of the year.  Next we have the same firing
<a name="594"></a>     *   date information in a more computer-friendly format: 'mm' is the
<a name="595"></a>     *   month number, 1-12 for Jan-Dec; 'typ' is an integer giving the type
<a name="596"></a>     *   of date specification (0 for a fixed day of the month 'mm/dd', 1 for
<a name="597"></a>     *   the last &lt;weekday&gt; of month &lt;mm&gt;, 2 for the first &lt;weekday&gt; of month
<a name="598"></a>     *   &lt;mm&gt; on or after day &lt;dd&gt;, and 3 for the last &lt;weekday&gt; of month
<a name="599"></a>     *   &lt;mm&gt; on or before day &lt;dd&gt;), 'dd' is the day of the month (which is
<a name="600"></a>     *   ignored if 'typ' is 1), 'wkday' is the day of the week, 1-7 for
<a name="601"></a>     *   Sunday-Saturday (which is ignored if 'typ' is 0).  'time' is the
<a name="602"></a>     *   time of day the rule goes into effect, as milliseconds after
<a name="603"></a>     *   midnight.  'zone' is a code for the timezone used to interpret the
<a name="604"></a>     *   date and time; this is usually 'w' for local wall clock time (in
<a name="605"></a>     *   other words, the local time zone that was in effect up until the
<a name="606"></a>     *   moment this rule takes effect - so if this is a daylight savings
<a name="607"></a>     *   rule, the rule is stated in terms of local standard time, and vice
<a name="608"></a>     *   versa), but can also be 's' for local standard time (in other words,
<a name="609"></a>     *   if the previous period was in daylight time, ignore that and read
<a name="610"></a>     *   this rule's time in terms of local standard time instead), or 'u'
<a name="611"></a>     *   for UTC.  Note that the zone has to be applied to the full
<a name="612"></a>     *   date-and-time value, since an 's' or 'u' could conceivably cause the
<a name="613"></a>     *   local date and the date in the rule's zone to differ by a day at the
<a name="614"></a>     *   time of day of the rule.
<a name="615"></a>     */
<a name="616"></a>    getRules();
<a name="617"></a>
<a name="618"></a>    /*
<a name="619"></a>     *   Get the zone's location.  This returns a list: [country, lat, lon,
<a name="620"></a>     *   comment], where 'country' is a string with the country code (a
<a name="621"></a>     *   two-letter ISO 3166 code) for the country that contains the zone's
<a name="622"></a>     *   main city, 'lat' is a string giving the latitude in the format +ddmm
<a name="623"></a>     *   (degrees and minutes) or +ddmmss (and seconds), 'lon' is the
<a name="624"></a>     *   longitude as a string in the format +dddmm or +dddmmss, and
<a name="625"></a>     *   'comment' is a string with any comment text from the zoneinfo
<a name="626"></a>     *   database.
<a name="627"></a>     */
<a name="628"></a>    getLocation();
<a name="629"></a>}
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 08/12/2025 from adv3Lite version 2.2.2</div>
</body>
</html>

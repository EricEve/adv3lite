<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>t3.h</title></head><body>
<table class=ban><tr><td><h1>t3.h</h1><td align=right><a href="../file/t3.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 1999, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3
<a name="8"></a> *   
<a name="9"></a> *   This header defines the t3vm intrinsic function set.  These functions
<a name="10"></a> *   provide access to basic features of the Virtual Machine.  
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>/* 
<a name="14"></a> *   include the LookupTable intrinsic class, since t3GetGlobalSymbols()
<a name="15"></a> *   returns an instance of this class 
<a name="16"></a> */
<a name="17"></a>#include "lookup.h"
<a name="18"></a>
<a name="19"></a>
<a name="20"></a>/*
<a name="21"></a> *   T3 intrinsic function set definition
<a name="22"></a> */
<a name="23"></a>intrinsic 't3vm/010006'
<a name="24"></a>{
<a name="25"></a>    /* 
<a name="26"></a>     *   Explicitly run garbage collection.
<a name="27"></a>     */
<a name="28"></a>    t3RunGC();
<a name="29"></a>
<a name="30"></a>    /* 
<a name="31"></a>     *   Set the default output function or method.  The return value is the
<a name="32"></a>     *   old function pointer or method, depending on which one is being set
<a name="33"></a>     *   with this call.  (If 'val' is a function pointer, the return value
<a name="34"></a>     *   will be the old function; if 'val' is a property ID, the return
<a name="35"></a>     *   value is the old method.)
<a name="36"></a>     *   
<a name="37"></a>     *   The special values T3SetSayNoFunc and T3SetSayNoMethod can be passed
<a name="38"></a>     *   to the function to remove any existing function or method,
<a name="39"></a>     *   respectively, and are returned when appropriate to indicate that
<a name="40"></a>     *   there was no previous setting.  
<a name="41"></a>     */
<a name="42"></a>    t3SetSay(val);
<a name="43"></a>
<a name="44"></a>    /* 
<a name="45"></a>     *   Get the VM version number.  Returns the version number as an integer
<a name="46"></a>     *   value, with the major version in the high-order 16 bits, the minor
<a name="47"></a>     *   version number in the next 8 bits, and the patch number ("point
<a name="48"></a>     *   release" number) in the low-order 8 bits.  For example, version
<a name="49"></a>     *   3.0.10 is encoded as 0x0003000A.  
<a name="50"></a>     */
<a name="51"></a>    t3GetVMVsn();
<a name="52"></a>
<a name="53"></a>    /* 
<a name="54"></a>     *   Get the VM identifier string.  This returns the version number as a
<a name="55"></a>     *   string, as in '3.0.10'.
<a name="56"></a>     */
<a name="57"></a>    t3GetVMID();
<a name="58"></a>
<a name="59"></a>    /* 
<a name="60"></a>     *   Get the VM banner string.  This returns a string with the name of
<a name="61"></a>     *   the VM, the version number, and a copyright string, in a format
<a name="62"></a>     *   suitable for displaying to the user to identify the VM executable.  
<a name="63"></a>     */
<a name="64"></a>    t3GetVMBanner();
<a name="65"></a>
<a name="66"></a>    /* 
<a name="67"></a>     *   Get the preinitialization mode flag.  This returns true if the VM is
<a name="68"></a>     *   running as part of the compiler's pre-initialization phase, nil if
<a name="69"></a>     *   it's running as a normal interpreter.  
<a name="70"></a>     */
<a name="71"></a>    t3GetVMPreinitMode();
<a name="72"></a>
<a name="73"></a>    /* 
<a name="74"></a>     *   Debugger trace operations.  This provides access to the interactive
<a name="75"></a>     *   debugger subsystem, if the VM is running under a debugger.  The
<a name="76"></a>     *   'mode' argument determines what the function does and what the
<a name="77"></a>     *   additional arguments, if any, are for:
<a name="78"></a>     *   
<a name="79"></a>     *   T3DebugCheck - checks to see if an interactive debugger is present.
<a name="80"></a>     *   No additional arguments; returns true if a debugger is present, nil
<a name="81"></a>     *   if not.
<a name="82"></a>     *   
<a name="83"></a>     *   T3DebugBreak - breaks into the interactive debugger, pausing
<a name="84"></a>     *   execution at the current code location so that the user can inspect
<a name="85"></a>     *   the current machine state and determine how to proceed.  No
<a name="86"></a>     *   additional arguments; after the user proceeds with execution, the
<a name="87"></a>     *   function returns true to indicate that a debugger is present.  If no
<a name="88"></a>     *   debugger is present, the function simply returns nil, and has no
<a name="89"></a>     *   other effect.
<a name="90"></a>     *   
<a name="91"></a>     *   T3DebugLog - writes a message to the debug log.  The second argument
<a name="92"></a>     *   is a string with the text of the message to write.  When running
<a name="93"></a>     *   under an interactive debugger, the log is usually displayed as a
<a name="94"></a>     *   window in the UI, or something similar.  When running in a regular
<a name="95"></a>     *   interpreter, the log is stored as a text file called tadslog.txt, in
<a name="96"></a>     *   a directory location that varies by system.  When a log file is
<a name="97"></a>     *   used, the system automatically adds a timestamp to each message.
<a name="98"></a>     */
<a name="99"></a>    t3DebugTrace(mode, ...);
<a name="100"></a>
<a name="101"></a>    /*
<a name="102"></a>     *   Get the global symbol table or the global macro table.
<a name="103"></a>     *   
<a name="104"></a>     *   'which' specifies which table to retrieve:
<a name="105"></a>     *   
<a name="106"></a>     *.     T3GlobalSymbols - return the global symbol table
<a name="107"></a>     *.     T3PreprocMacros - return the preprocessor macro table
<a name="108"></a>     *   
<a name="109"></a>     *   If 'which' is omitted, the global symbol table is returned by
<a name="110"></a>     *   default.
<a name="111"></a>     *   
<a name="112"></a>     *   If the requested symbol table is available, this returns a
<a name="113"></a>     *   LookupTable object; otherwise, it returns nil.
<a name="114"></a>     *   
<a name="115"></a>     *   The symbol tables are available under two conditions.  First, while
<a name="116"></a>     *   pre-initialization is running during the program build (compiling)
<a name="117"></a>     *   process, regardless of the debug/release mode being used for
<a name="118"></a>     *   compilation.  Second, during normal "t3run" execution, but only when
<a name="119"></a>     *   the program has been compiled for debugging.  When you compile in
<a name="120"></a>     *   release mode, the compiler omits the debugging symbols from the .t3
<a name="121"></a>     *   image file to save space, so the symbol tables won't be available
<a name="122"></a>     *   when running a release build under the interpreter. 
<a name="123"></a>     *   
<a name="124"></a>     *   If you want to access the symbol tables under normal execution
<a name="125"></a>     *   (i.e., after preinit) in a release build, you can do it, but it
<a name="126"></a>     *   requires an extra manual step.  The trick is to call this function
<a name="127"></a>     *   during preinit, when the symbol tables are definitely available
<a name="128"></a>     *   regardless of the debug/release mode, and then save a reference to
<a name="129"></a>     *   each desired table in an object property.  This will ensure that the
<a name="130"></a>     *   final image file saved after preinit completes includes the tables,
<a name="131"></a>     *   because the object property reference ensures that the garbage
<a name="132"></a>     *   collector won't delete them.  Now, you *still* can't access the
<a name="133"></a>     *   tables again at run-time by calling t3GetGlobalSymbols(), but you
<a name="134"></a>     *   can instead get the same information from your saved object
<a name="135"></a>     *   property.  
<a name="136"></a>     */
<a name="137"></a>    t3GetGlobalSymbols(which?);
<a name="138"></a>
<a name="139"></a>    /*
<a name="140"></a>     *   Allocate a new property.  Returns a new property not yet used
<a name="141"></a>     *   anywhere in the program.  Note that property ID's are a somewhat
<a name="142"></a>     *   limited resource - only approximately 65,000 total are available,
<a name="143"></a>     *   including all of the properties that the program defines
<a name="144"></a>     *   statically.  
<a name="145"></a>     */
<a name="146"></a>    t3AllocProp();
<a name="147"></a>
<a name="148"></a>    /*
<a name="149"></a>     *   Get a stack trace.  This returns a list of T3StackInfo objects.
<a name="150"></a>     *   Each object represents a nesting level in the call stack.  The first
<a name="151"></a>     *   element in the list represents the currently active level (i.e., the
<a name="152"></a>     *   level that called this function), the second element represents the
<a name="153"></a>     *   caller of the first element, and so on.
<a name="154"></a>     *   
<a name="155"></a>     *   If 'level' is an integer, we'll return a single T3StackInfo object
<a name="156"></a>     *   giving the context at the given stack level - 1 is the active level,
<a name="157"></a>     *   2 is its caller, and so on, so 'level' would simply be the index in
<a name="158"></a>     *   the returned list when this argument is omitted.  If 'level' is
<a name="159"></a>     *   omitted or nil, we return a list of T3StackInfo objects giving the
<a name="160"></a>     *   entire stack trace.
<a name="161"></a>     *   
<a name="162"></a>     *   If 'flags' is specified, it's a combination of T3GetStackXxx flags
<a name="163"></a>     *   specifying additional options.  If this isn't included, the default
<a name="164"></a>     *   is 0 (i.e., all flags turned off).  
<a name="165"></a>     */
<a name="166"></a>    t3GetStackTrace(level?, flags?);
<a name="167"></a>
<a name="168"></a>    /*
<a name="169"></a>     *   Get a named argument.  This searches for the specified named
<a name="170"></a>     *   argument, and returns the value of the argument if it's defined.
<a name="171"></a>     *   
<a name="172"></a>     *   'name' is a string giving the name of the argument to search for.
<a name="173"></a>     *   This must exactly match the name of an argument passed by a caller
<a name="174"></a>     *   with the "name: value" syntax.  The match is case-sensitive.
<a name="175"></a>     *   
<a name="176"></a>     *   'defval' is an optional default value to return if the argument
<a name="177"></a>     *   doesn't exist.  If 'deval' is specified, and the argument doesn't
<a name="178"></a>     *   exist, the function returns 'defval'.  If 'defval' is omitted, and
<a name="179"></a>     *   the argument doesn't exist, the function throws an error.
<a name="180"></a>     */
<a name="181"></a>    t3GetNamedArg(name, defval?);
<a name="182"></a>
<a name="183"></a>    /*
<a name="184"></a>     *   Get a list of all named arguments currently in effect.  This returns
<a name="185"></a>     *   a list of strings, where each string is the name of a named argument
<a name="186"></a>     *   that's currently active.  
<a name="187"></a>     */
<a name="188"></a>    t3GetNamedArgList();
<a name="189"></a>}
<a name="190"></a>
<a name="191"></a>
<a name="192"></a>/*
<a name="193"></a> *   t3DebugTrace() mode flags 
<a name="194"></a> */
<a name="195"></a>
<a name="196"></a>/* check to see if the debugger is present */
<a name="197"></a>#define T3DebugCheck     1
<a name="198"></a>
<a name="199"></a>/* break into the debugger */
<a name="200"></a>#define T3DebugBreak     2
<a name="201"></a>
<a name="202"></a>/* log a message to the system/debug log */
<a name="203"></a>#define T3DebugLog       3
<a name="204"></a>
<a name="205"></a>/*
<a name="206"></a> *   t3SetSay() special values.  These can be passed in lieu of a function
<a name="207"></a> *   pointer or property ID when the caller wants to remove any existing
<a name="208"></a> *   function or method rather than install a new one.  
<a name="209"></a> */
<a name="210"></a>#define T3SetSayNoFunc    1
<a name="211"></a>#define T3SetSayNoMethod  2
<a name="212"></a>
<a name="213"></a>/*
<a name="214"></a> *   t3GetGlobalSymbols 'which' flag.  One of these values can be specified
<a name="215"></a> *   as the function argument to specify which type of table is to be
<a name="216"></a> *   retrieved.  
<a name="217"></a> */
<a name="218"></a>#define T3GlobalSymbols   1
<a name="219"></a>#define T3PreprocMacros   2
<a name="220"></a>
<a name="221"></a>/*
<a name="222"></a> *   t3GetStackTrace flags.  These can be combined with the bitwise '|'
<a name="223"></a> *   operator.
<a name="224"></a> */
<a name="225"></a>#define T3GetStackLocals  0x0001
<a name="226"></a>#define T3GetStackDesc    0x0002
<a name="227"></a>
<a name="228"></a>/*
<a name="229"></a> *   Macro information flags. 
<a name="230"></a> */
<a name="231"></a>#define T3MacroHasArgs     0x0001
<a name="232"></a>#define T3MacroHasVarargs  0x0002
<a name="233"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

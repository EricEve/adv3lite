<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>lookup.h</title></head><body>
<table class=ban><tr><td><h1>lookup.h</h1><td align=right><a href="../file/lookup.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   The header defines the LookupTable and WeakRefLookupTable intrinsic
<a name="10"></a> *   classes, as well as LookupTableIterator, the special Iterator type for
<a name="11"></a> *   these classes.  
<a name="12"></a> */
<a name="13"></a>
<a name="14"></a>
<a name="15"></a>/* include our base class definitions */
<a name="16"></a>#include "systype.h"
<a name="17"></a>
<a name="18"></a>/*
<a name="19"></a> *   The LookupTable intrinsic class provides a general-purpose hash table
<a name="20"></a> *   implementation.  LookupTable can be used syntactically as though it were
<a name="21"></a> *   a list, but the index values are arbitrary hash key values rather than
<a name="22"></a> *   being limited to sequential integers.  
<a name="23"></a> */
<a name="24"></a>intrinsic class LookupTable 'lookuptable/030003': Collection
<a name="25"></a>{
<a name="26"></a>    /* 
<a name="27"></a>     *   Determine if a given key is present in the table.  Returns true if
<a name="28"></a>     *   the key is present, nil if not. 
<a name="29"></a>     */
<a name="30"></a>    isKeyPresent(key);
<a name="31"></a>
<a name="32"></a>    /*
<a name="33"></a>     *   Remove an entry from the table.  Removes the key/value pair
<a name="34"></a>     *   associated with the given key, and returns the value that was
<a name="35"></a>     *   associated with the key.  If the key isn't present in the table,
<a name="36"></a>     *   the return value is nil, and the method has no other effect. 
<a name="37"></a>     */
<a name="38"></a>    removeElement(key);
<a name="39"></a>
<a name="40"></a>    /*
<a name="41"></a>     *   Apply the given function to each entry, and replace the value of
<a name="42"></a>     *   the entry with the return value of the function.  The callback is
<a name="43"></a>     *   invoked with the key and value as arguments for each entry:
<a name="44"></a>     *   func(key, value).  No return value.
<a name="45"></a>     */
<a name="46"></a>    applyAll(func);
<a name="47"></a>
<a name="48"></a>    /*
<a name="49"></a>     *   Invoke the given function with each entry in the table.  The
<a name="50"></a>     *   function is invoked with value of an entry as its argument:
<a name="51"></a>     *   func(value).  Any return value of the function is ignored.  No
<a name="52"></a>     *   return value.  
<a name="53"></a>     */
<a name="54"></a>    forEach(func);
<a name="55"></a>
<a name="56"></a>    /*
<a name="57"></a>     *   Get the number of buckets (i.e., slots for unique hash values).
<a name="58"></a>     *   The number of buckets doesn't vary over the life of the table, so
<a name="59"></a>     *   this simply returns the number of buckets that was specified in the
<a name="60"></a>     *   constructor when the table was created.  This can be used to create
<a name="61"></a>     *   a new table with the same parameters as an existing table.  
<a name="62"></a>     */
<a name="63"></a>    getBucketCount();
<a name="64"></a>
<a name="65"></a>    /*
<a name="66"></a>     *   Get the number of entries.  This returns the number of key/value
<a name="67"></a>     *   pairs stored in the table.  Note that this is not the same as the
<a name="68"></a>     *   initial capacity specified in the constructor when the table was
<a name="69"></a>     *   created; this is the number of entries actually stored in the
<a name="70"></a>     *   table.  
<a name="71"></a>     */
<a name="72"></a>    getEntryCount();
<a name="73"></a>
<a name="74"></a>    /*
<a name="75"></a>     *   Invoke the given function with each entry in the table, passing the
<a name="76"></a>     *   key and value to the callback.  The function is invoked with key
<a name="77"></a>     *   and value of an entry as its arguments: func(key, value).  Any
<a name="78"></a>     *   return value of the function is ignored.  No return value.  
<a name="79"></a>     */
<a name="80"></a>    forEachAssoc(func);
<a name="81"></a>
<a name="82"></a>    /*
<a name="83"></a>     *   Make a list of all of my keys.  The return value is a list, in
<a name="84"></a>     *   arbitrary order, of all of the keys in the table.  
<a name="85"></a>     */
<a name="86"></a>    keysToList();
<a name="87"></a>
<a name="88"></a>    /*
<a name="89"></a>     *   Make a list of all of my values.  The return value is a list, in
<a name="90"></a>     *   arbitrary order, of all of the values in the table. 
<a name="91"></a>     */
<a name="92"></a>    valsToList();
<a name="93"></a>
<a name="94"></a>    /*
<a name="95"></a>     *   Get the default value.  This returns the value previously set with
<a name="96"></a>     *   setDefaultValue(), or nil if no explicit default has been set on
<a name="97"></a>     *   this table.  
<a name="98"></a>     */
<a name="99"></a>    getDefaultValue();
<a name="100"></a>
<a name="101"></a>    /*
<a name="102"></a>     *   Set the default value.  This changes the value returned by the index
<a name="103"></a>     *   operator (self[key]) for a key that doesn't exist in the table.  The
<a name="104"></a>     *   default value is initially nil, but you can change this to a
<a name="105"></a>     *   different value of any type if desired.  
<a name="106"></a>     */
<a name="107"></a>    setDefaultValue(val);
<a name="108"></a>
<a name="109"></a>    /*
<a name="110"></a>     *   Get the nth key.  This returns the key that would appear at the
<a name="111"></a>     *   given index in the keysToList() result.  
<a name="112"></a>     */
<a name="113"></a>    nthKey(n);
<a name="114"></a>
<a name="115"></a>    /*
<a name="116"></a>     *   Get the enth value.  This returns the value that would appear at the
<a name="117"></a>     *   given index in the valsToList() result. 
<a name="118"></a>     */
<a name="119"></a>    nthVal(n);
<a name="120"></a>}
<a name="121"></a>
<a name="122"></a>/*
<a name="123"></a> *   WeakRefLookupTable is a "weak reference" version of the basic lookup
<a name="124"></a> *   table.  This is similar to the regular LookupTable, and has the same
<a name="125"></a> *   methods; the only difference is that this type of table references its
<a name="126"></a> *   values "weakly."  A value that is reachable only through weak references
<a name="127"></a> *   is subject to deletion by the garbage collector.  A weak-reference
<a name="128"></a> *   lookup table is useful when you don't want a value's presence in the
<a name="129"></a> *   table to force the value to stay active, such as when the lookup table
<a name="130"></a> *   is merely a fast index to a set of values that must be otherwise
<a name="131"></a> *   reachable to be useful.  When the garbage collector deletes one of our
<a name="132"></a> *   values, the key/value pair for the value is automatically deleted from
<a name="133"></a> *   the table.  
<a name="134"></a> */
<a name="135"></a>intrinsic class WeakRefLookupTable 'weakreflookuptable/030001': LookupTable
<a name="136"></a>{
<a name="137"></a>}
<a name="138"></a>
<a name="139"></a>/*
<a name="140"></a> *   LookupTable iterator - this type of iterator is used for LookupTable and
<a name="141"></a> *   WeakRefLookupTable instances.  
<a name="142"></a> */
<a name="143"></a>intrinsic class LookupTableIterator 'lookuptable-iterator/030000': Iterator
<a name="144"></a>{
<a name="145"></a>}
<a name="146"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 20/01/2025 from adv3Lite version 2.1.1.11</div>
</body>
</html>

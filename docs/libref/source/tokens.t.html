<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>tokens.t</title></head><body>
<table class=ban><tr><td><h1>tokens.t</h1><td align=right><a href="../file/tokens.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include &lt;dict.h&gt;
<a name="3"></a>#include &lt;strcomp.h&gt;
<a name="4"></a>#include &lt;tok.h&gt;
<a name="5"></a>#include "advlite.h"
<a name="6"></a>
<a name="7"></a>
<a name="8"></a>/* ------------------------------------------------------------------------ */
<a name="9"></a>/*
<a name="10"></a> *   Additional token types for US English.
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>/* special "apostrophe-s" token */
<a name="14"></a>enum token tokApostropheS;
<a name="15"></a>
<a name="16"></a>/* special abbreviation-period token */
<a name="17"></a>enum token tokAbbrPeriod;
<a name="18"></a>
<a name="19"></a>/* special "#nnn" numeric token */
<a name="20"></a>enum token tokPoundInt;
<a name="21"></a>
<a name="22"></a>/* ------------------------------------------------------------------------ */
<a name="23"></a>/*
<a name="24"></a> *   Is the given token a word?  This receives a token element in the same
<a name="25"></a> *   format returned by Tokenizer.tokenize().  Returns true if the token
<a name="26"></a> *   represents a word that could be looked up in the dictionary, nil if
<a name="27"></a> *   it's something else (such as punctuation, a number, or a quoted
<a name="28"></a> *   literal).
<a name="29"></a> *   
<a name="30"></a> *   [Required] 
<a name="31"></a> */
<a name="32"></a>isWordToken(tok)
<a name="33"></a>{
<a name="34"></a>    /* in English, the word tokens are of type tokWord and tokAbbrPeriod */
<a name="35"></a>    return getTokType(tok) is in (tokWord, tokAbbrPeriod);
<a name="36"></a>}
<a name="37"></a>
<a name="38"></a>/* ------------------------------------------------------------------------ */
<a name="39"></a>/*
<a name="40"></a> *   Concatenate two tokens.  This takes two token elements in the same
<a name="41"></a> *   format returned by Tokenizer.tokenize(), and returns a combined
<a name="42"></a> *   element in the same format.  The result should be as though the
<a name="43"></a> *   original pair of tokens had been concatenated in the input string.  
<a name="44"></a> */
<a name="45"></a>concatTokens(a, b)
<a name="46"></a>{
<a name="47"></a>    /* 
<a name="48"></a>     *   Return the concatenated token values and original text.  Use the
<a name="49"></a>     *   second token's type as the combined type.  In most cases, the two
<a name="50"></a>     *   types will be the same, since it usually only makes sense to
<a name="51"></a>     *   combine tokens of like kind.  
<a name="52"></a>     */
<a name="53"></a>    return [getTokVal(a) + getTokVal(b),
<a name="54"></a>            getTokType(b),
<a name="55"></a>            getTokOrig(a) + getTokOrig(b)];
<a name="56"></a>}
<a name="57"></a>
<a name="58"></a>/* ------------------------------------------------------------------------ */
<a name="59"></a>/*
<a name="60"></a> *   Command tokenizer for US English.  Other language modules should
<a name="61"></a> *   provide their own tokenizers to allow for differences in punctuation
<a name="62"></a> *   and other lexical elements.
<a name="63"></a> *   
<a name="64"></a> *   [Required] 
<a name="65"></a> */
<a name="66"></a>cmdTokenizer: Tokenizer
<a name="67"></a>    /*
<a name="68"></a>     *   The list of tokenizing rules.  This isn't actually required to be
<a name="69"></a>     *   defined by the language module, since you *could* just use the
<a name="70"></a>     *   default rules inherited from the base Tokenizer class, but it's
<a name="71"></a>     *   likely that each language will have some quirks that require
<a name="72"></a>     *   custom rules.  
<a name="73"></a>     */
<a name="74"></a>    rules_ = static
<a name="75"></a>    [
<a name="76"></a>        /* skip whitespace */
<a name="77"></a>        ['whitespace', new RexPattern('&lt;Space&gt;+'), nil, &amp;tokCvtSkip, nil],
<a name="78"></a>
<a name="79"></a>        /* certain punctuation marks */
<a name="80"></a>        ['punctuation', new RexPattern('&lt;' + punctChars + '&gt;'),
<a name="81"></a>         tokPunct, nil, nil],
<a name="82"></a>
<a name="83"></a>        /*
<a name="84"></a>         *   We have a special rule for spelled-out numbers from 21 to 99:
<a name="85"></a>         *   when we see a 'tens' word followed by a hyphen followed by a
<a name="86"></a>         *   digits word, we'll pull out the tens word, the hyphen, and
<a name="87"></a>         *   the digits word as separate tokens.
<a name="88"></a>         */
<a name="89"></a>        ['spelled number',
<a name="90"></a>         new RexPattern('&lt;NoCase&gt;(twenty|thirty|forty|fifty|sixty|'
<a name="91"></a>                        + 'seventy|eighty|ninety)-'
<a name="92"></a>                        + '(one|two|three|four|five|six|seven|eight|nine)'
<a name="93"></a>                        + '(?!&lt;AlphaNum&gt;)'),
<a name="94"></a>         tokWord, &amp;tokCvtSpelledNumber, nil],
<a name="95"></a>
<a name="96"></a>        /* integer numbers */
<a name="97"></a>        ['integer', new RexPattern('[0-9]+' + endAssert),
<a name="98"></a>         tokInt, nil, nil],
<a name="99"></a>        
<a name="100"></a>//        ['real', new RexPattern('[0-9]+&lt;period&gt;[0-9]+' + endAssert), tokReal,
<a name="101"></a>//            nil, nil],
<a name="102"></a>
<a name="103"></a>        /* numbers with a '#' preceding */
<a name="104"></a>        ['integer with #', new RexPattern('#[0-9]+' + endAssert),
<a name="105"></a>         tokPoundInt, nil, nil],
<a name="106"></a>
<a name="107"></a>        /*
<a name="108"></a>         *   Initials.  We'll look for strings of three or two initials,
<a name="109"></a>         *   set off by periods but without spaces.  We'll look for
<a name="110"></a>         *   three-letter initials first ("G.H.W. Billfold"), then
<a name="111"></a>         *   two-letter initials ("X.Y. Zed"), so that we find the longest
<a name="112"></a>         *   sequence that's actually in the dictionary.  Note that we
<a name="113"></a>         *   don't have a separate rule for individual initials, since
<a name="114"></a>         *   we'll pick that up with the regular abbreviated word rule
<a name="115"></a>         *   below.
<a name="116"></a>         *
<a name="117"></a>         *   Some games could conceivably extend this to allow strings of
<a name="118"></a>         *   initials of four letters or longer, but in practice people
<a name="119"></a>         *   tend to elide the periods in longer sets of initials, so that
<a name="120"></a>         *   the initials become an acronym, and thus would fit the
<a name="121"></a>         *   ordinary word token rule.
<a name="122"></a>         */
<a name="123"></a>        ['three initials',
<a name="124"></a>         new RexPattern('&lt;alpha&gt;&lt;period&gt;&lt;alpha&gt;&lt;period&gt;&lt;alpha&gt;&lt;period&gt;'),
<a name="125"></a>         tokWord, &amp;tokCvtAbbr, &amp;acceptAbbrTok],
<a name="126"></a>
<a name="127"></a>        ['two initials',
<a name="128"></a>         new RexPattern('&lt;alpha&gt;&lt;period&gt;&lt;alpha&gt;&lt;period&gt;'),
<a name="129"></a>         tokWord, &amp;tokCvtAbbr, &amp;acceptAbbrTok],
<a name="130"></a>
<a name="131"></a>        /*
<a name="132"></a>         *   Abbbreviated word - this is a word that ends in a period, such
<a name="133"></a>         *   as "Mr.".  This rule comes before the ordinary word rule
<a name="134"></a>         *   because we will only consider the period to be part of the
<a name="135"></a>         *   word (and not a separate token), but only if the entire string
<a name="136"></a>         *   including the period is in the dictionary.  
<a name="137"></a>         */
<a name="138"></a>        ['abbreviation',
<a name="139"></a>         new RexPattern('&lt;AlphaNum|' + wordPunct + '&gt;+&lt;period&gt;'),
<a name="140"></a>         tokWord, &amp;tokCvtAbbr, &amp;acceptAbbrTok],
<a name="141"></a>
<a name="142"></a>        /*
<a name="143"></a>         *   A word ending in an apostrophe-s.  We parse this as two
<a name="144"></a>         *   separate tokens: one for the word and one for the
<a name="145"></a>         *   apostrophe-s.
<a name="146"></a>         */
<a name="147"></a>        ['apostrophe-s word',
<a name="148"></a>         new RexPattern('&lt;AlphaNum|' + wordPunct + '&gt;+&lt;' + squote + '&gt;[sS]%&gt;'),
<a name="149"></a>         tokWord, &amp;tokCvtApostropheS, nil],
<a name="150"></a>
<a name="151"></a>        /*
<a name="152"></a>         *   Words - note that we convert everything to lower-case.  A word
<a name="153"></a>         *   must start with an alphabetic character, a hyphen, or an
<a name="154"></a>         *   ampersand; after the initial character, a word can contain
<a name="155"></a>         *   alphabetics, digits, hyphens, ampersands, and apostrophes.
<a name="156"></a>         */
<a name="157"></a>        ['word',
<a name="158"></a>         new RexPattern('&lt;AlphaNum|' + wordPunct + '|' + squote + '&gt;+'),
<a name="159"></a>         tokWord, nil, nil],
<a name="160"></a>
<a name="161"></a>        /* strings with ASCII "straight" quotes */
<a name="162"></a>        ['string ascii-quote',
<a name="163"></a>         new RexPattern('&lt;min&gt;([`\'"])(.*)%1' + endAssert),
<a name="164"></a>         tokString, nil, nil],
<a name="165"></a>
<a name="166"></a>        /* some people like to use single quotes like `this' */
<a name="167"></a>        ['string back-quote',
<a name="168"></a>         new RexPattern('&lt;min&gt;`(.*)\'' + endAssert), tokString, nil, nil],
<a name="169"></a>
<a name="170"></a>        /* strings with Latin-1 curly quotes (single and double) */
<a name="171"></a>        ['string curly single-quote',
<a name="172"></a>         new RexPattern('&lt;min&gt;\u2018(.*)\u2019'), tokString, nil, nil],
<a name="173"></a>        ['string curly double-quote',
<a name="174"></a>         new RexPattern('&lt;min&gt;\u201C(.*)\u201D'), tokString, nil, nil],
<a name="175"></a>
<a name="176"></a>        /*
<a name="177"></a>         *   unterminated string - if we didn't just match a terminated
<a name="178"></a>         *   string, but we have what looks like the start of a string,
<a name="179"></a>         *   match to the end of the line
<a name="180"></a>         */
<a name="181"></a>        ['string unterminated',
<a name="182"></a>         new RexPattern('([`\'"\u2018\u201C](.*)'), tokString, nil, nil],
<a name="183"></a>
<a name="184"></a>        /* 
<a name="185"></a>         *   Accept any other group of characters, barring spaces and
<a name="186"></a>         *   punctuation that we handle specially, as though they were
<a name="187"></a>         *   words.  This is a catch-all for anything that the other rules
<a name="188"></a>         *   don't handle, and will just make a basic word out of any group
<a name="189"></a>         *   of characters delimited by one of our normal delimiters.  
<a name="190"></a>         */
<a name="191"></a>        ['any characters', new RexPattern('&lt;^space|' + punctChars + '&gt;+'),
<a name="192"></a>         tokWord, nil, nil]
<a name="193"></a>    ]
<a name="194"></a>
<a name="195"></a>    /* token-separating punctuation marks, as an &lt;alpha|x|y&gt; pattern */
<a name="196"></a>    punctChars = '.|,|;|:|?|!'
<a name="197"></a>
<a name="198"></a>    /* end-of-token assertion */
<a name="199"></a>    endAssert = static ('(?=$|&lt;space|' + punctChars + '&gt;)')
<a name="200"></a>
<a name="201"></a>    /* 
<a name="202"></a>     *   List of characters consisting a single quote mark.  This includes
<a name="203"></a>     *   regular ASCII straight quotes as well as the unicode curly quotes.
<a name="204"></a>     *   This is for pasting into a &lt;alpha|x|y&gt; pattern.  
<a name="205"></a>     */
<a name="206"></a>    squote = 'squote|\u8216|\u8217'
<a name="207"></a>
<a name="208"></a>    /* 
<a name="209"></a>     *   list of acceptable punctuation marks within words; this is for
<a name="210"></a>     *   pasting into an &lt;alpha|x|y&gt; pattern 
<a name="211"></a>     */
<a name="212"></a>    wordPunct = static
<a name="213"></a>        '~|@|#|$|%|^|*|(|)|{|}|[|]|vbar|_|=|+|/|\\|langle|rangle|-|&amp;'
<a name="214"></a>
<a name="215"></a>    /*
<a name="216"></a>     *   Handle an apostrophe-s word.  We'll return this as two separate
<a name="217"></a>     *   tokens: one for the word preceding the apostrophe-s, and one for
<a name="218"></a>     *   the apostrophe-s itself.
<a name="219"></a>     */
<a name="220"></a>    tokCvtApostropheS(txt, typ, toks)
<a name="221"></a>    {
<a name="222"></a>        local w;
<a name="223"></a>        local s;
<a name="224"></a>
<a name="225"></a>        /*
<a name="226"></a>         *   pull out the part up to but not including the apostrophe, and
<a name="227"></a>         *   pull out the apostrophe-s part
<a name="228"></a>         */
<a name="229"></a>        w = txt.left(-2);
<a name="230"></a>        s = txt.right(2);
<a name="231"></a>
<a name="232"></a>        /* add the part before the apostrophe as the main token type */
<a name="233"></a>        toks.append([w, typ, w]);
<a name="234"></a>
<a name="235"></a>        /* add the apostrophe-s as a separate special token */
<a name="236"></a>        toks.append([s, tokApostropheS, s]);
<a name="237"></a>    }
<a name="238"></a>
<a name="239"></a>    /*
<a name="240"></a>     *   Handle a spelled-out hyphenated number from 21 to 99.  We'll
<a name="241"></a>     *   return this as three separate tokens: a word for the tens name, a
<a name="242"></a>     *   word for the hyphen, and a word for the units name.
<a name="243"></a>     */
<a name="244"></a>    tokCvtSpelledNumber(txt, typ, toks)
<a name="245"></a>    {
<a name="246"></a>        /* parse the number into its three parts with a regular expression */
<a name="247"></a>        rexMatch(patAlphaDashAlpha, txt);
<a name="248"></a>
<a name="249"></a>        /* add the part before the hyphen */
<a name="250"></a>        toks.append([rexGroup(1)[3], typ, rexGroup(1)[3]]);
<a name="251"></a>
<a name="252"></a>        /* add the hyphen */
<a name="253"></a>        toks.append(['-', typ, '-']);
<a name="254"></a>
<a name="255"></a>        /* add the part after the hyphen */
<a name="256"></a>        toks.append([rexGroup(2)[3], typ, rexGroup(2)[3]]);
<a name="257"></a>    }
<a name="258"></a>    patAlphaDashAlpha = static new RexPattern('(&lt;alpha&gt;+)-(&lt;alpha&gt;+)')
<a name="259"></a>
<a name="260"></a>    /*
<a name="261"></a>     *   Check to see if we want to accept an abbreviated token - this is
<a name="262"></a>     *   a token that ends in a period, which we use for abbreviated words
<a name="263"></a>     *   like "Mr." or "Ave."  We'll accept the token only if it appears
<a name="264"></a>     *   as given - including the period - in the dictionary.  Note that
<a name="265"></a>     *   we ignore truncated matches, since the only way we'll accept a
<a name="266"></a>     *   period in a word token is as the last character; there is thus no
<a name="267"></a>     *   way that a token ending in a period could be a truncation of any
<a name="268"></a>     *   longer valid token.
<a name="269"></a>     */
<a name="270"></a>    acceptAbbrTok(txt)
<a name="271"></a>    {
<a name="272"></a>        /* look up the word, filtering out truncated results */
<a name="273"></a>        return cmdDict.isWordDefined(
<a name="274"></a>            txt, {result: (result &amp; StrCompTrunc) == 0});
<a name="275"></a>    }
<a name="276"></a>
<a name="277"></a>    /*
<a name="278"></a>     *   Process an abbreviated token.
<a name="279"></a>     *
<a name="280"></a>     *   When we find an abbreviation, we'll enter it with the abbreviated
<a name="281"></a>     *   word minus the trailing period, plus the period as a separate
<a name="282"></a>     *   token.  We'll mark the period as an "abbreviation period" so that
<a name="283"></a>     *   grammar rules will be able to consider treating it as an
<a name="284"></a>     *   abbreviation -- but since it's also a regular period, grammar
<a name="285"></a>     *   rules that treat periods as regular punctuation will also be able
<a name="286"></a>     *   to try to match the result.  This will ensure that we try it both
<a name="287"></a>     *   ways - as abbreviation and as a word with punctuation - and pick
<a name="288"></a>     *   the one that gives us the best result.
<a name="289"></a>     */
<a name="290"></a>    tokCvtAbbr(txt, typ, toks)
<a name="291"></a>    {
<a name="292"></a>        local w;
<a name="293"></a>
<a name="294"></a>        /* add the part before the period as the ordinary token */
<a name="295"></a>        w = txt.left(-1);
<a name="296"></a>        toks.append([w, typ, w]);
<a name="297"></a>
<a name="298"></a>        /* add the token for the "abbreviation period" */
<a name="299"></a>        toks.append(['.', tokAbbrPeriod, '.']);
<a name="300"></a>    }
<a name="301"></a>
<a name="302"></a>    /*
<a name="303"></a>     *   Given a list of token strings, rebuild the original input string.
<a name="304"></a>     *   We can't recover the exact input string, because the tokenization
<a name="305"></a>     *   process throws away whitespace information, but we can at least
<a name="306"></a>     *   come up with something that will display cleanly and produce the
<a name="307"></a>     *   same results when run through the tokenizer.
<a name="308"></a>     *   
<a name="309"></a>     *   [Required] 
<a name="310"></a>     */
<a name="311"></a>    buildOrigText(toks)
<a name="312"></a>    {
<a name="313"></a>        local str;
<a name="314"></a>
<a name="315"></a>        /* start with an empty string */
<a name="316"></a>        str = '';
<a name="317"></a>
<a name="318"></a>        /* concatenate each token in the list */
<a name="319"></a>        for (local i = 1, local len = toks.length() ; i &lt;= len ; ++i)
<a name="320"></a>        {
<a name="321"></a>            /* add the current token to the string */
<a name="322"></a>            str += getTokOrig(toks[i]);
<a name="323"></a>
<a name="324"></a>            /*
<a name="325"></a>             *   if this looks like a hyphenated number that we picked
<a name="326"></a>             *   apart into two tokens, put it back together without
<a name="327"></a>             *   spaces
<a name="328"></a>             */
<a name="329"></a>            if (i + 2 &lt;= len
<a name="330"></a>                &amp;&amp; rexMatch(patSpelledTens, getTokVal(toks[i])) != nil
<a name="331"></a>                &amp;&amp; getTokVal(toks[i+1]) == '-'
<a name="332"></a>                &amp;&amp; rexMatch(patSpelledUnits, getTokVal(toks[i+2])) != nil)
<a name="333"></a>            {
<a name="334"></a>                /*
<a name="335"></a>                 *   it's a hyphenated number, all right - put the three
<a name="336"></a>                 *   tokens back together without any intervening spaces,
<a name="337"></a>                 *   so ['twenty', '-', 'one'] turns into 'twenty-one'
<a name="338"></a>                 */
<a name="339"></a>                str += getTokOrig(toks[i+1]) + getTokOrig(toks[i+2]);
<a name="340"></a>
<a name="341"></a>                /* skip ahead by the two extra tokens we're adding */
<a name="342"></a>                i += 2;
<a name="343"></a>            }
<a name="344"></a>            else if (i + 1 &lt;= len
<a name="345"></a>                     &amp;&amp; getTokType(toks[i]) == tokWord
<a name="346"></a>                     &amp;&amp; getTokType(toks[i+1]) == tokApostropheS)
<a name="347"></a>            {
<a name="348"></a>                /*
<a name="349"></a>                 *   it's a word followed by an apostrophe-s token - these
<a name="350"></a>                 *   are appended together without any intervening spaces
<a name="351"></a>                 */
<a name="352"></a>                str += getTokOrig(toks[i+1]);
<a name="353"></a>
<a name="354"></a>                /* skip the extra token we added */
<a name="355"></a>                ++i;
<a name="356"></a>            }
<a name="357"></a>
<a name="358"></a>            /*
<a name="359"></a>             *   if another token follows, and the next token isn't a
<a name="360"></a>             *   punctuation mark, add a space before the next token
<a name="361"></a>             */
<a name="362"></a>            if (i &lt; len &amp;&amp; rexMatch(patPunct, getTokVal(toks[i+1])) == nil)
<a name="363"></a>                str += ' ';
<a name="364"></a>        }
<a name="365"></a>
<a name="366"></a>        /* return the result string */
<a name="367"></a>        return str;
<a name="368"></a>    }
<a name="369"></a>
<a name="370"></a>    /* some pre-compiled regular expressions */
<a name="371"></a>    patSpelledTens = static new RexPattern(
<a name="372"></a>        '&lt;nocase&gt;twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety')
<a name="373"></a>    patSpelledUnits = static new RexPattern(
<a name="374"></a>        '&lt;nocase&gt;one|two|three|four|five|six|seven|eight|nine')
<a name="375"></a>    patPunct = static new RexPattern('[.,;:?!]')
<a name="376"></a>;
<a name="377"></a>
<a name="378"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

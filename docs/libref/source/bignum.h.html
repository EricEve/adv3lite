<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>bignum.h</title></head><body>
<table class=ban><tr><td><h1>bignum.h</h1><td align=right><a href="../file/bignum.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/* 
<a name="5"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This header defines the BigNumber intrinsic class.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>/* include our base class definition */
<a name="13"></a>#include "systype.h"
<a name="14"></a>
<a name="15"></a>/*
<a name="16"></a> *   The BigNumber intrinsic class lets you perform floating-point and
<a name="17"></a> *   integer arithmetic with (almost) any desired precision.  BigNumber uses
<a name="18"></a> *   a decimal representation, which means that decimal values can be
<a name="19"></a> *   represented exactly (i.e., with no rounding errors, as can happen with
<a name="20"></a> *   IEEE 'double' and 'float' values that languages like C typically
<a name="21"></a> *   support).  BigNumber combines a varying-length mantissa with an
<a name="22"></a> *   exponent; the length of the mantissa determines how many digits of
<a name="23"></a> *   precision a given BigNumber can store, and the exponent lets you
<a name="24"></a> *   represent very large or very small values with minimal storage.  You can
<a name="25"></a> *   specify the desired precision when you create a BigNumber explicitly;
<a name="26"></a> *   when BigNumber values are created implicitly by computations, the system
<a name="27"></a> *   chooses a precision based on the inputs to the calculations, typically
<a name="28"></a> *   equal to the largest of the precisions of the input values.
<a name="29"></a> *   
<a name="30"></a> *   The maximum precision for a BigNumber is about 64,000 digits, and the
<a name="31"></a> *   exponent can range from -32768 to +32767.  Since this is a decimal
<a name="32"></a> *   exponent, this implies an absolute value range from 1.0e-32768 to
<a name="33"></a> *   1.0e+32767.  The more digits of precision stored in a given BigNumber
<a name="34"></a> *   value, the more memory the object consumes, and the more time it takes
<a name="35"></a> *   to perform calculations using the value.  
<a name="36"></a> */
<a name="37"></a>intrinsic class BigNumber 'bignumber/030001': Object
<a name="38"></a>{
<a name="39"></a>    /* format to a string */
<a name="40"></a>    formatString(maxDigits?, flags?,
<a name="41"></a>                 wholePlaces?, fracDigits?, expDigits?, leadFiller?);
<a name="42"></a>
<a name="43"></a>    /* 
<a name="44"></a>     *   compare for equality after rounding to the smaller of my
<a name="45"></a>     *   precision and num's precision 
<a name="46"></a>     */
<a name="47"></a>    equalRound(num);
<a name="48"></a>
<a name="49"></a>    /* 
<a name="50"></a>     *   returns an integer giving the number of digits of precision that
<a name="51"></a>     *   this number stores 
<a name="52"></a>     */
<a name="53"></a>    getPrecision();
<a name="54"></a>
<a name="55"></a>    /* 
<a name="56"></a>     *   Return a new number, with the same value as this number but with
<a name="57"></a>     *   the given number of decimal digits of precision.  If the new
<a name="58"></a>     *   precision is higher than the old precision, this will increase
<a name="59"></a>     *   the precision to the requested new size and add trailing zeros
<a name="60"></a>     *   to the value.  If the new precision is lower than the old
<a name="61"></a>     *   precision, we'll round the number for the reduced precision.  
<a name="62"></a>     */
<a name="63"></a>    setPrecision(digits);
<a name="64"></a>
<a name="65"></a>    /* get the fractional part */
<a name="66"></a>    getFraction();
<a name="67"></a>
<a name="68"></a>    /* get the whole part (truncates the fraction - doesn't round) */
<a name="69"></a>    getWhole();
<a name="70"></a>
<a name="71"></a>    /* 
<a name="72"></a>     *   round to the given number of digits after the decimal point; if
<a name="73"></a>     *   the value is zero, round to integer; if the value is negative,
<a name="74"></a>     *   round to the given number of places before the decimal point 
<a name="75"></a>     */
<a name="76"></a>    roundToDecimal(places);
<a name="77"></a>
<a name="78"></a>    /* return the absolute value */
<a name="79"></a>    getAbs();
<a name="80"></a>
<a name="81"></a>    /* least integer greater than or equal to this number */
<a name="82"></a>    getCeil();
<a name="83"></a>
<a name="84"></a>    /* greatest integer less than or equal to this number */
<a name="85"></a>    getFloor();
<a name="86"></a>
<a name="87"></a>    /* get the base-10 scale of the number */
<a name="88"></a>    getScale();
<a name="89"></a>
<a name="90"></a>    /* 
<a name="91"></a>     *   scale by 10^x - if x is positive, this multiplies the number by
<a name="92"></a>     *   ten the given number of times; if x is negative, this divides the
<a name="93"></a>     *   number by ten the given number of times 
<a name="94"></a>     */
<a name="95"></a>    scaleTen(x);
<a name="96"></a>
<a name="97"></a>    /* negate - invert the sign of the number */
<a name="98"></a>    negate();
<a name="99"></a>
<a name="100"></a>    /* 
<a name="101"></a>     *   copySignFrom - combine the absolute value of self with the sign
<a name="102"></a>     *   of x 
<a name="103"></a>     */
<a name="104"></a>    copySignFrom(x);
<a name="105"></a>
<a name="106"></a>    /* determine if the value is negative */
<a name="107"></a>    isNegative();
<a name="108"></a>
<a name="109"></a>    /* 
<a name="110"></a>     *   Calculate the integer quotient and the remainder; returns a list
<a name="111"></a>     *   whose first element is the integer quotient (a BigNumber
<a name="112"></a>     *   containing an integer value), and whose second element is the
<a name="113"></a>     *   remainder (the value R such that dividend = quotient*x + R).
<a name="114"></a>     *   
<a name="115"></a>     *   Note that the quotient returned will not necessarily have the
<a name="116"></a>     *   same value as the whole part of dividing self by x with the '/'
<a name="117"></a>     *   operator, because this division handles rounding differently.  In
<a name="118"></a>     *   particular, the '/' operator will perform the appropriate
<a name="119"></a>     *   rounding on the quotient if the quotient has insufficient
<a name="120"></a>     *   precision to represent the exact result.  This routine, in
<a name="121"></a>     *   contrast, does NOT round the quotient, but merely truncates any
<a name="122"></a>     *   trailing digits that cannot be represented in the result's
<a name="123"></a>     *   precision.  The reason for this difference is that it ensures
<a name="124"></a>     *   that the relation (dividend=quotient*x+remainder) holds, which
<a name="125"></a>     *   would not always be the case if the quotient were rounded up.
<a name="126"></a>     *   
<a name="127"></a>     *   Note also that the remainder will not necessarily be less than
<a name="128"></a>     *   the divisor.  If the quotient cannot be exactly represented
<a name="129"></a>     *   (which occurs if the precision of the quotient is smaller than
<a name="130"></a>     *   its scale), the remainder will be the correct value so that the
<a name="131"></a>     *   relationship above holds, rather than the unique remainder that
<a name="132"></a>     *   is smaller than the divisor.  In all cases where there is
<a name="133"></a>     *   sufficient precision to represent the quotient exactly (to the
<a name="134"></a>     *   units digit only, since the quotient returned from this method
<a name="135"></a>     *   will always be an integer), the remainder will satisfy the
<a name="136"></a>     *   relationship AND will be the unique remainder with absolute value
<a name="137"></a>     *   less than the divisor.  
<a name="138"></a>     */
<a name="139"></a>    divideBy(x);
<a name="140"></a>
<a name="141"></a>    /* 
<a name="142"></a>     *   calculate and return the trigonometric sine of the value (taken
<a name="143"></a>     *   as a radian value) 
<a name="144"></a>     */
<a name="145"></a>    sine();
<a name="146"></a>
<a name="147"></a>    /* 
<a name="148"></a>     *   calculate and return the trigonometric cosine of the value (taken
<a name="149"></a>     *   as a radian value) 
<a name="150"></a>     */
<a name="151"></a>    cosine();
<a name="152"></a>
<a name="153"></a>    /* 
<a name="154"></a>     *   calculate and return the trigonometric tangent of the value
<a name="155"></a>     *   (taken as a radian value) 
<a name="156"></a>     */
<a name="157"></a>    tangent();
<a name="158"></a>
<a name="159"></a>    /* 
<a name="160"></a>     *   interpreting this number as a number of degrees, convert the
<a name="161"></a>     *   value to radians and return the result 
<a name="162"></a>     */
<a name="163"></a>    degreesToRadians();
<a name="164"></a>
<a name="165"></a>    /* 
<a name="166"></a>     *   interpreting this number as a number of radians, convert the
<a name="167"></a>     *   value to degrees and return the result 
<a name="168"></a>     */
<a name="169"></a>    radiansToDegrees();
<a name="170"></a>
<a name="171"></a>    /* 
<a name="172"></a>     *   Calculate and return the arcsine (in radians) of the value.  Note
<a name="173"></a>     *   that the value must be between -1 and +1 inclusive, since sine()
<a name="174"></a>     *   never has a value outside of this range. 
<a name="175"></a>     */
<a name="176"></a>    arcsine();
<a name="177"></a>
<a name="178"></a>    /* 
<a name="179"></a>     *   Calculate and return the arccosine (in radians).  The value must
<a name="180"></a>     *   be between -1 and +1 inclusive. 
<a name="181"></a>     */
<a name="182"></a>    arccosine();
<a name="183"></a>
<a name="184"></a>    /* calculate and return the arctangent (in radians) */
<a name="185"></a>    arctangent();
<a name="186"></a>
<a name="187"></a>    /* calculate the square root and return the result */
<a name="188"></a>    sqrt();
<a name="189"></a>
<a name="190"></a>    /* 
<a name="191"></a>     *   calculate the natural logarithm of this number and return the
<a name="192"></a>     *   result 
<a name="193"></a>     */
<a name="194"></a>    logE();
<a name="195"></a>
<a name="196"></a>    /* 
<a name="197"></a>     *   raise e (the base of the natural logarithm) to the power of this
<a name="198"></a>     *   value and return the result 
<a name="199"></a>     */
<a name="200"></a>    expE();
<a name="201"></a>
<a name="202"></a>    /* calculate the base-10 logarithm of the number and return the result */
<a name="203"></a>    log10();
<a name="204"></a>
<a name="205"></a>    /* 
<a name="206"></a>     *   raise this number to the power of the argument and return the
<a name="207"></a>     *   result 
<a name="208"></a>     */
<a name="209"></a>    raiseToPower(x);
<a name="210"></a>
<a name="211"></a>    /* calculate the hyperbolic sine, cosine, and tangent */
<a name="212"></a>    sinh();
<a name="213"></a>    cosh();
<a name="214"></a>    tanh();
<a name="215"></a>
<a name="216"></a>    /* class method: get the value of pi to a given precision */
<a name="217"></a>    getPi(digits);
<a name="218"></a>
<a name="219"></a>    /* class method: get the value of e to a given precision */
<a name="220"></a>    getE(digits);
<a name="221"></a>
<a name="222"></a>    /*
<a name="223"></a>     *   Get the type of this number.  This returns a combination of
<a name="224"></a>     *   NumTypeXxx flags, combined with the '|' operator.  This can be used
<a name="225"></a>     *   to check for special values, such as infinites and "not a number"
<a name="226"></a>     *   values.  
<a name="227"></a>     */
<a name="228"></a>    numType();
<a name="229"></a>}
<a name="230"></a>
<a name="231"></a>/* ------------------------------------------------------------------------ */
<a name="232"></a>/*
<a name="233"></a> *   flags for formatString 
<a name="234"></a> */
<a name="235"></a>
<a name="236"></a>/* always show a sign, even if positive */
<a name="237"></a>#define BignumSign          0x0001
<a name="238"></a>
<a name="239"></a>/* always show in exponential format (scientific notation, as in "1.0e20") */
<a name="240"></a>#define BignumExp           0x0002
<a name="241"></a>
<a name="242"></a>/* always show a sign in the exponent, even if positive */
<a name="243"></a>#define BignumExpSign      0x0004
<a name="244"></a>
<a name="245"></a>/* 
<a name="246"></a> *   show a zero before the decimal point - this is only relevant in
<a name="247"></a> *   non-exponential format when the number is between -1 and +1 
<a name="248"></a> */
<a name="249"></a>#define BignumLeadingZero  0x0008
<a name="250"></a>
<a name="251"></a>/* always show a decimal point */
<a name="252"></a>#define BignumPoint         0x0010
<a name="253"></a>
<a name="254"></a>/* insert commas to denote thousands, millions, etc */
<a name="255"></a>#define BignumCommas        0x0020
<a name="256"></a>
<a name="257"></a>/* show a leading space if the number is positive */
<a name="258"></a>#define BignumPosSpace     0x0040
<a name="259"></a>
<a name="260"></a>/* 
<a name="261"></a> *   use European-style formatting: use a comma instead of a period for
<a name="262"></a> *   the decimal point, and use periods instead of commas to set off
<a name="263"></a> *   thousands, millions, etc 
<a name="264"></a> */
<a name="265"></a>#define BignumEuroStyle     0x0080
<a name="266"></a>
<a name="267"></a>/* 
<a name="268"></a> *   "Compact" format: use the shorter of the regular format and scientific
<a name="269"></a> *   notation.  If the scientific notation exponent is less than -4 or
<a name="270"></a> *   greater than or equal to the number of digits after the decimal point,
<a name="271"></a> *   we'll use scientific notation; otherwise we'll use the plain format. 
<a name="272"></a> */
<a name="273"></a>#define BignumCompact      0x0100
<a name="274"></a>
<a name="275"></a>/* 
<a name="276"></a> *   maxDigits counts only significant digits; leading zeros aren't counted
<a name="277"></a> *   against the maximum. 
<a name="278"></a> */
<a name="279"></a>#define BignumMaxSigDigits 0x0200
<a name="280"></a>
<a name="281"></a>/* 
<a name="282"></a> *   Keep trailing zeros.  If there's a maxDigits value, this keeps enough
<a name="283"></a> *   trailing zeros so that the number of digits shown equals maxDigits.  By
<a name="284"></a> *   default, trailing zeros after the decimal point are removed. 
<a name="285"></a> */
<a name="286"></a>#define BignumKeepTrailingZeros 0x0400
<a name="287"></a>
<a name="288"></a>
<a name="289"></a>/* ------------------------------------------------------------------------ */
<a name="290"></a>/*
<a name="291"></a> *   Number type flags, for numType() 
<a name="292"></a> */
<a name="293"></a>
<a name="294"></a>/*
<a name="295"></a> *   Number type: ordinary number. 
<a name="296"></a> */
<a name="297"></a>#define NumTypeNum  0x0001
<a name="298"></a>
<a name="299"></a>/* 
<a name="300"></a> *   Number type: "Not a number" (NaN).  This indicates that the value is the
<a name="301"></a> *   result of a calculation with invalid input(s).  Currently there are no
<a name="302"></a> *   BigNumber calculations that return NaNs, as all functions on invalid
<a name="303"></a> *   inputs throw errors instead.  But it's possible to construct NaN value,
<a name="304"></a> *   such as by reading an IEEE 754-2008 NaN value from a file via
<a name="305"></a> *   unpackBytes().  
<a name="306"></a> */
<a name="307"></a>#define NumTypeNAN  0x0002
<a name="308"></a>
<a name="309"></a>/* 
<a name="310"></a> *   Number type: positive infinity, negative infinity.  These indicate a
<a name="311"></a> *   value that overflowed the capacity of the BigNumber type, or a
<a name="312"></a> *   calculation that yields infinity (e.g., tan(pi/2)).  Currently there are
<a name="313"></a> *   no BigNumber calculations that return Infinities, as all functions where
<a name="314"></a> *   an overflow is possible throw errors instead.  But it's possible to
<a name="315"></a> *   construct an Infinity value, such as by reading an IEEE 754-2008
<a name="316"></a> *   Infinity value from a file via unpackBytes().  
<a name="317"></a> */
<a name="318"></a>#define NumTypePInf 0x0004
<a name="319"></a>#define NumTypeNInf 0x0008
<a name="320"></a>#define NumTypeInf  (NumTypePInf | NumTypeNInf)
<a name="321"></a>
<a name="322"></a>/*
<a name="323"></a> *   Number type: zero, positive or negative.  Mathematically, zero is
<a name="324"></a> *   neither positive nor negative, but the BigNumber type retains a sign for
<a name="325"></a> *   all values, even zeros.  Negative zeros can come from calculations
<a name="326"></a> *   that yield negative results with absolute values too small for the
<a name="327"></a> *   internal representation.  It's also possible to construct a negative
<a name="328"></a> *   zero, such as by reading an IEEE 754-2008 negative zero value from a
<a name="329"></a> *   file via unpackBytes().  
<a name="330"></a> */
<a name="331"></a>#define NumTypePZero  0x0010
<a name="332"></a>#define NumTypeNZero  0x0020
<a name="333"></a>#define NumTypeZero (NumTypePZero | NumTypeNZero)
<a name="334"></a>
<a name="335"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

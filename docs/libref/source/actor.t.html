<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>actor.t</title></head><body>
<table class=ban><tr><td><h1>actor.t</h1><td align=right><a href="../file/actor.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>
<a name="5"></a>/*
<a name="6"></a> *   ****************************************************************************
<a name="7"></a> *    actor.t 
<a name="8"></a> *
<a name="9"></a> *    This module forms part of the adv3Lite library 
<a name="10"></a> *    (c) 2012-13 Eric Eve
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>/* Declare the eventList property in case the eventList module isn't included */
<a name="14"></a>property eventList;
<a name="15"></a>
<a name="16"></a>/* Declare the inRoomName property in case the senseRegion module isn't included */
<a name="17"></a>property inRoomName;
<a name="18"></a>
<a name="19"></a>/*    
<a name="20"></a> *   An Actor is an object representing a living being (or something that
<a name="21"></a> *   behaves like a living being, such as an intelligent robot), with which the
<a name="22"></a> *   player character can potentially converse, and which can move around and
<a name="23"></a> *   pursue his/her/its own agenda. This class is intended for the
<a name="24"></a> *   implementation of NPCs (non-player characters).
<a name="25"></a> */
<a name="26"></a>modify Actor
<a name="27"></a>    
<a name="28"></a>    /* 
<a name="29"></a>     *   Our current ActorState. This should normally be treated as a read-only
<a name="30"></a>     *   property; to change the current ActorState of an actor call the
<a name="31"></a>     *   setState() method.
<a name="32"></a>     */
<a name="33"></a>    curState = nil
<a name="34"></a>    
<a name="35"></a>    /*   
<a name="36"></a>     *   Set our current ActorState to a new state (stat) or to no state at all
<a name="37"></a>     *   (if the stat parameter is supplied as nil).
<a name="38"></a>     */
<a name="39"></a>    setState(stat)
<a name="40"></a>    {
<a name="41"></a>        /* 
<a name="42"></a>         *   First check that stat is a valid parameter for this method, which means that stat must
<a name="43"></a>         *   either be nil or an ActorState belonging to this Actor. 
<a name="44"></a>         */
<a name="45"></a>        if(stat &amp;&amp; !(objOfKind(stat, ActorState) &amp;&amp; stat.getActor == self))
<a name="46"></a>        {
<a name="47"></a>            DMsg(illegal actor state, '&lt;FONT COLOR=RED&gt;&lt;b&gt;WARNING!&lt;/b&gt;&lt;/FONT&gt; In the call to
<a name="48"></a>                setState(stat) on Actor &lt;&lt;theName&gt;&gt;, stat &lt;&lt;stat&gt;&gt; was not an ActorState belonging
<a name="49"></a>                to &lt;&lt;theName&gt;&gt;. ');
<a name="50"></a>            
<a name="51"></a>            return;
<a name="52"></a>        }        
<a name="53"></a>        
<a name="54"></a>        /* 
<a name="55"></a>         *   Only do anything if the new state (stat) is different from our
<a name="56"></a>         *   current state.
<a name="57"></a>         */
<a name="58"></a>        if(curState != stat)
<a name="59"></a>        {
<a name="60"></a>            /* 
<a name="61"></a>             *   If the current state is non-nil, call its deactivateState()
<a name="62"></a>             *   method to notify it that we're leaving it.
<a name="63"></a>             */
<a name="64"></a>            if(curState != nil)
<a name="65"></a>               curState.deactivateState(self, stat);
<a name="66"></a>            
<a name="67"></a>            /*  Set out current state to the new state. */
<a name="68"></a>            curState = stat;
<a name="69"></a>            
<a name="70"></a>            /*  
<a name="71"></a>             *   If the new state is non-nil, call its activateState() method to
<a name="72"></a>             *   notify it that we're entering it.
<a name="73"></a>             */
<a name="74"></a>            if(stat != nil)
<a name="75"></a>               stat.activateState(self, curState);           
<a name="76"></a>        }
<a name="77"></a>    }
<a name="78"></a>    
<a name="79"></a>    
<a name="80"></a>    /* 
<a name="81"></a>     *   Our state-specific description, which is appended to our desc to give
<a name="82"></a>     *   our full description. By default we simply take this from our current
<a name="83"></a>     *   ActorState.
<a name="84"></a>     */
<a name="85"></a>    stateDesc = (curState != nil ? curState.stateDesc : '')
<a name="86"></a>    
<a name="87"></a>    /*   
<a name="88"></a>     *   Our specialDesc (used to describe us in room listing). By default we
<a name="89"></a>     *   use our ActorState's specialDesc if we have a current ActorState or
<a name="90"></a>     *   else our actorSpecialDesc if our current ActorState is nil. But if
<a name="91"></a>     *   there's a current FollowAgendaItem we let it handle the specialDesc
<a name="92"></a>     *   instead.
<a name="93"></a>     */
<a name="94"></a>    specialDesc()
<a name="95"></a>    {
<a name="96"></a>        
<a name="97"></a>        local followItem;
<a name="98"></a>        
<a name="99"></a>        /* 
<a name="100"></a>         *   Check whether we have a FollowAgendaItem that's ready to be used,
<a name="101"></a>         *   and if so, register it as our current followAgendaItem.
<a name="102"></a>         */
<a name="103"></a>        if(agendaList != nil &amp;&amp;
<a name="104"></a>           (followItem = agendaList.valWhich({x: x.ofKind(FollowAgendaItem) &amp;&amp;
<a name="105"></a>                                            x.isReady &amp;&amp; !x.isDone})) != nil)
<a name="106"></a>            followAgendaItem = followItem;
<a name="107"></a>        
<a name="108"></a>        /* If we have a current followAgendaItem, use its specialDesc */
<a name="109"></a>        if(followAgendaItem != nil)
<a name="110"></a>            followAgendaItem.showSpecialDesc();
<a name="111"></a>        
<a name="112"></a>        /* 
<a name="113"></a>         *   Otherwise use our current ActorState's specialDesc if we have one
<a name="114"></a>         *   or our our actorSpecialDesc if not.
<a name="115"></a>         */
<a name="116"></a>        else
<a name="117"></a>            curState != nil &amp;&amp; curState.propType(&amp;specialDesc) != TypeNil
<a name="118"></a>                                                 ? curState.specialDesc : actorSpecialDesc;
<a name="119"></a>    }
<a name="120"></a>    
<a name="121"></a>    
<a name="122"></a>    /*   
<a name="123"></a>     *   The specialDesc to use if we don't have a current ActorState By default
<a name="124"></a>     *   we just display a message saying the actor is here or that the actor is
<a name="125"></a>     *   in a nested room.
<a name="126"></a>     */
<a name="127"></a>    actorSpecialDesc()
<a name="128"></a>    {	    
<a name="129"></a>        /* 
<a name="130"></a>         *   If this actor is the player character then we don't want to display
<a name="131"></a>         *   anything by default here.
<a name="132"></a>         */
<a name="133"></a>        if(isPlayerChar)
<a name="134"></a>            return;
<a name="135"></a>        
<a name="136"></a>        if(location == getOutermostRoom)
<a name="137"></a>            DMsg(actor here, '\^&lt;&lt;theNameIs&gt;&gt; &lt;&lt;postureDesc&gt;&gt; {here}. ');
<a name="138"></a>        else
<a name="139"></a>            DMsg(actor in location, '\^&lt;&lt;theNameIs&gt;&gt; &lt;&lt;postureDesc&gt;&gt; &lt;&lt;location.objInName&gt;&gt;. ');        		
<a name="140"></a>    }
<a name="141"></a>    
<a name="142"></a>    /*   
<a name="143"></a>     *   We normally list any actors after the miscellaneous contents of a room
<a name="144"></a>     */
<a name="145"></a>    specialDescBeforeContents = nil
<a name="146"></a>    
<a name="147"></a>    /*   
<a name="148"></a>     *   The specialDesc of this actor when it is viewed from a remote location.
<a name="149"></a>     *   If we have a current ActorState we use its remoteSpecialDesc, otherwise
<a name="150"></a>     *   we use the actorRemoteSpecialDesc on the actor. Either way the pov
<a name="151"></a>     *   parameter is the point of view object from which this actor is being
<a name="152"></a>     *   viewed (normally the player char).
<a name="153"></a>     *
<a name="154"></a>     *   Note that this method is generally only relevant if the senseRegion
<a name="155"></a>     *   module is used.
<a name="156"></a>     */
<a name="157"></a>    remoteSpecialDesc(pov) 
<a name="158"></a>    { 
<a name="159"></a>        (curState == nil || curState.propType(&amp;specialDesc) == TypeNil) 
<a name="160"></a>        ? actorRemoteSpecialDesc(pov) : curState.remoteSpecialDesc(pov);
<a name="161"></a>    }
<a name="162"></a>        
<a name="163"></a>    /* 
<a name="164"></a>     *   The remoteSpecialDesc to use if we don't have a current ActorState
<a name="165"></a>     *   (i.e. if curState is nil). By default we say the actor is in the remote
<a name="166"></a>     *   location.
<a name="167"></a>     *
<a name="168"></a>     */
<a name="169"></a>    actorRemoteSpecialDesc(pov) 
<a name="170"></a>    { 
<a name="171"></a>        if(fDaemon == nil)
<a name="172"></a>            DMsg(actor in remote location, '\^&lt;&lt;theNameIs&gt;&gt; &lt;&lt;if location != getOutermostRoom&gt;&gt;
<a name="173"></a>                &lt;&lt;location.remoteObjInName(pov)&gt;&gt; &lt;&lt;end&gt;&gt; 
<a name="174"></a>                &lt;&lt;getOutermostRoom.inRoomName(pov)&gt;&gt;. ');
<a name="175"></a>    }
<a name="176"></a>       
<a name="177"></a>    /*   
<a name="178"></a>     *   By default actors can't be picked up and carried around by other actors
<a name="179"></a>     *   (though game authors can override this if they need to create a
<a name="180"></a>     *   portable actor).
<a name="181"></a>     */
<a name="182"></a>    isFixed = true    
<a name="183"></a>    
<a name="184"></a>    /*   The message to display when someone tries to take this actor. */
<a name="185"></a>    cannotTakeMsg = BMsg(cannot take actor, '{The subj dobj} {won\'t} let {me}
<a name="186"></a>        {dummy} pick {him dobj} up. ')
<a name="187"></a>    
<a name="188"></a>    /*   The (portable) contents of an actor are regarded as being carried. */
<a name="189"></a>    contType = Carrier
<a name="190"></a>    
<a name="191"></a>    /* 
<a name="192"></a>     *   We don't normally list the contents of an Actor when Looking or
<a name="193"></a>     *   Examining.
<a name="194"></a>     */
<a name="195"></a>    contentsListed = nil
<a name="196"></a>    
<a name="197"></a>    /*   
<a name="198"></a>     *   The default response of the actor to a conversational command that is
<a name="199"></a>     *   not handled anywhere else.
<a name="200"></a>     */
<a name="201"></a>    noResponseMsg = BMsg(no response, '{The subj cobj} {doesnot respond[ed]}. ')
<a name="202"></a>    
<a name="203"></a>    
<a name="204"></a>    /* Handle a command (e.g. BOB, JUMP) directed at this actor. */
<a name="205"></a>    handleCommand(action)
<a name="206"></a>    {
<a name="207"></a>        /* 
<a name="208"></a>         *   If the Command is GiveTo and the iobj is the player char, treat it
<a name="209"></a>         *   as AskFor with the player char as the effective actor
<a name="210"></a>         */        
<a name="211"></a>        if(action.ofKind(GiveTo) &amp;&amp; gCommand.iobj == gPlayerChar)
<a name="212"></a>        {
<a name="213"></a>            /* Change the current actor to the player char */
<a name="214"></a>            gCommand.actor = gPlayerChar;
<a name="215"></a>            
<a name="216"></a>            /* Change the current action to AskFor */
<a name="217"></a>            gAction = AskFor.createInstance();
<a name="218"></a>            
<a name="219"></a>            /* Install the appropriate objects in the new action. */
<a name="220"></a>            gAction.curDobj == self;
<a name="221"></a>            gAction.curIobj == gCommand.dobj;
<a name="222"></a>            gAction.curObj = self;            
<a name="223"></a>            
<a name="224"></a>            /* 
<a name="225"></a>             *   Handle the command as if the player had issued an AskFor
<a name="226"></a>             *   command
<a name="227"></a>             */
<a name="228"></a>            handleTopic(&amp;askForTopics, gCommand.dobj);
<a name="229"></a>        }
<a name="230"></a>        
<a name="231"></a>        /* 
<a name="232"></a>         *   if the command is TellAbout then convert the command from X,tell me
<a name="233"></a>         *   about Y to ASK X ABOUT Y
<a name="234"></a>         */
<a name="235"></a>        else if(action.ofKind(TellAbout) &amp;&amp; gCommand.dobj == gPlayerChar)
<a name="236"></a>        {
<a name="237"></a>            /* 
<a name="238"></a>             *   if the command appears to ask the actor to tell the pc about
<a name="239"></a>             *   the pc, the player probably intended to tell the actor to tell
<a name="240"></a>             *   the pc about the actor (the reference of 'yourself' would be
<a name="241"></a>             *   the actor, not the pc).
<a name="242"></a>             */
<a name="243"></a>            if(gCommand.iobj.topicList[1] == gPlayerChar)
<a name="244"></a>                gCommand.iobj.topicList[1] = self;
<a name="245"></a>            
<a name="246"></a>            /* 
<a name="247"></a>             *   since we've translated this into an ASK ABOUT command, the
<a name="248"></a>             *   effective actor is now the player char.
<a name="249"></a>             */
<a name="250"></a>            gCommand.actor = gPlayerChar;
<a name="251"></a>            
<a name="252"></a>            /* Change the current action to AskFor */
<a name="253"></a>            gAction = AskAbout.createInstance();
<a name="254"></a>            
<a name="255"></a>            /* Install the appropriate objects in the new action. */
<a name="256"></a>            gAction.curDobj == self;
<a name="257"></a>            gAction.curIobj == gCommand.dobj;
<a name="258"></a>            gAction.curObj = self;
<a name="259"></a>            
<a name="260"></a>            
<a name="261"></a>            /* Handle the command as AskFor */ 
<a name="262"></a>            handleTopic(&amp;askTopics, gCommand.iobj.topicList);
<a name="263"></a>        }
<a name="264"></a>        
<a name="265"></a>        /* exclude SystemActions as a matter of course */
<a name="266"></a>        else if(action.ofKind(SystemAction))
<a name="267"></a>        {
<a name="268"></a>            DMsg(cannot command system action, 'Only the player can carry out
<a name="269"></a>                that kind of command. ');
<a name="270"></a>        }
<a name="271"></a>        
<a name="272"></a>        /* treat Actor, hello as saying hello to the actor */
<a name="273"></a>        else if(action.ofKind(Hello))
<a name="274"></a>        {
<a name="275"></a>            gCommand.actor = gPlayerChar;
<a name="276"></a>            sayHello();
<a name="277"></a>        }
<a name="278"></a>        
<a name="279"></a>        /* treat Actor, Bye as saying goodbye to the actor */
<a name="280"></a>        else if(action.ofKind(Goodbye))
<a name="281"></a>        {
<a name="282"></a>            gCommand.actor = gPlayerChar;
<a name="283"></a>            endConversation(endConvBye);
<a name="284"></a>        }    
<a name="285"></a>        
<a name="286"></a>        /* treat Actor, question as directing a question to the actor */
<a name="287"></a>        else if(action.ofKind(Query))
<a name="288"></a>        {
<a name="289"></a>            /* Make the player character the current actor */
<a name="290"></a>            gCommand.actor = gPlayerChar;
<a name="291"></a>            
<a name="292"></a>            /* Note the query type on the current action */
<a name="293"></a>            gAction.qType = gCommand.verbProd.qtype;
<a name="294"></a>            
<a name="295"></a>            /* Carry out the QueryTopic handling. */
<a name="296"></a>            handleTopic(&amp;queryTopics, gCommand.dobj.topicList);
<a name="297"></a>        }
<a name="298"></a>        
<a name="299"></a>        /* treat Actor, (say) something as SAY SOMETHING TO ACTOR */
<a name="300"></a>        else if(action.ofKind(SayAction))
<a name="301"></a>        {
<a name="302"></a>            /* Make the player character the current actor */
<a name="303"></a>            gCommand.actor = gPlayerChar;            
<a name="304"></a>            
<a name="305"></a>            /* Carry out the SayTopic handling */
<a name="306"></a>            handleTopic(&amp;sayTopics, gCommand.dobj.topicList, &amp;defaultSayResponse);
<a name="307"></a>        }
<a name="308"></a>        
<a name="309"></a>        /* Otherwise try letting a CommandTopic handle it */
<a name="310"></a>        else
<a name="311"></a>        {
<a name="312"></a>            /* 
<a name="313"></a>             *   Note the direct and indirect objects of the command on the
<a name="314"></a>             *   action.
<a name="315"></a>             */
<a name="316"></a>            action.curDobj = gCommand.dobj;
<a name="317"></a>            action.curIobj = gCommand.iobj;
<a name="318"></a>            
<a name="319"></a>            /* Carry out the CommandTopic handling with the action commanded. */
<a name="320"></a>            handleTopic(&amp;commandTopics, action, &amp;refuseCommandMsg);
<a name="321"></a>        }
<a name="322"></a>    }
<a name="323"></a>    
<a name="324"></a>    /*  
<a name="325"></a>     *   The default message to use in response to a command directed to this
<a name="326"></a>     *   actor that is not handled in any other way.
<a name="327"></a>     */
<a name="328"></a>    refuseCommandMsg = BMsg(refuse command, '{I} {have} better things to do. ')
<a name="329"></a>        
<a name="330"></a>    
<a name="331"></a>    /* 
<a name="332"></a>     *   Find the best response to the topic produced by the player's command.
<a name="333"></a>     *   prop is the xxxTopics list property we'll use to search for a matching
<a name="334"></a>     *   TopicEntry. We first search the current ActorState for a match and
<a name="335"></a>     *   then, only if we fail to find one, we search TopicEntries directly
<a name="336"></a>     *   located in the actor. First priority, however, is given to TopicEntries
<a name="337"></a>     *   whose convKeys match this actor's currentKeys (they match if the two
<a name="338"></a>     *   lists have at least one element in common).
<a name="339"></a>     */    
<a name="340"></a>    getBestMatch(prop, requestedList)    
<a name="341"></a>    {
<a name="342"></a>        /* 
<a name="343"></a>         *   In the implementation of the conversation system we expect the prop
<a name="344"></a>         *   parameter to be passed as a property pointer, but in the inherited
<a name="345"></a>         *   handling it's a list. To avoid accidents, first check what we've
<a name="346"></a>         *   got before converting the prop to a list.
<a name="347"></a>         *
<a name="348"></a>         */
<a name="349"></a>        local myList;
<a name="350"></a>        
<a name="351"></a>        /* 
<a name="352"></a>         *   If prop has been supplied as a property pointer, get the list
<a name="353"></a>         *   defined on that property
<a name="354"></a>         */
<a name="355"></a>        if(dataType(prop) == TypeProp)
<a name="356"></a>            myList = self.(prop);
<a name="357"></a>        
<a name="358"></a>        /*  
<a name="359"></a>         *   Otherwise, if prop is simply a value, convert it directly to a list
<a name="360"></a>         */
<a name="361"></a>        else
<a name="362"></a>            myList = valToList(prop);
<a name="363"></a>        
<a name="364"></a>        
<a name="365"></a>        /* 
<a name="366"></a>         *   If we have a current activeKeys list restrict the choice of topic
<a name="367"></a>         *   entries to those whose convkeys overlap with it, at least at a
<a name="368"></a>         *   first attempt. If that doesn't produce a match, try the normal
<a name="369"></a>         *   handling.
<a name="370"></a>         */             
<a name="371"></a>        if(activeKeys.length &gt; 0)
<a name="372"></a>        {
<a name="373"></a>            /* 
<a name="374"></a>             *   Obtain a list of those items in myList (the list of topic
<a name="375"></a>             *   entries we started with) that have convKeys that overlap with
<a name="376"></a>             *   our activeKeys.
<a name="377"></a>             */
<a name="378"></a>            local kList = myList.subset({x:
<a name="379"></a>                                   valToList(x.convKeys).overlapsWith(activeKeys)});
<a name="380"></a>            
<a name="381"></a>            /* 
<a name="382"></a>             *   See if we can find a match by carrying out the inherited
<a name="383"></a>             *   handling (from ActorTopicDatabase) with this sublist (for which
<a name="384"></a>             *   the convKeys and activeKeys overlap)
<a name="385"></a>             */
<a name="386"></a>            local match = inherited(kList, requestedList);
<a name="387"></a>            
<a name="388"></a>            /*   If we find a match, simply return it and end there. */
<a name="389"></a>            if(match != nil)
<a name="390"></a>                return match;
<a name="391"></a>        }
<a name="392"></a>      
<a name="393"></a>        /* 
<a name="394"></a>         *   Otherwise carry out the inherited handling (from
<a name="395"></a>         *   ActorTopicDatabase) with the complete list and return the result.
<a name="396"></a>         */
<a name="397"></a>        return inherited(myList, requestedList);
<a name="398"></a>    }
<a name="399"></a>    
<a name="400"></a>    /*  
<a name="401"></a>     *   Find the best response to use for a conversational command directed to
<a name="402"></a>     *   this actor. prop would normally be a property pointer for the property
<a name="403"></a>     *   containing the appropriate list or lists of Topic Entries to test, and
<a name="404"></a>     *   topic is the Topic object we're trying to match.
<a name="405"></a>     */
<a name="406"></a>    findBestResponse(prop, topic)
<a name="407"></a>    {
<a name="408"></a>        local bestMatch;
<a name="409"></a>        
<a name="410"></a>        /* If we have a current ActorState, first try to get its best match */
<a name="411"></a>        if(curState != nil)
<a name="412"></a>        {
<a name="413"></a>            /* Get the best matching TopicEntry from our current actor state. */
<a name="414"></a>            bestMatch = curState.getBestMatch(prop, topic);
<a name="415"></a>            
<a name="416"></a>            /* If we found a result, return it and end there. */
<a name="417"></a>            if(bestMatch != nil)
<a name="418"></a>                return bestMatch;
<a name="419"></a>        }
<a name="420"></a>        
<a name="421"></a>        /* 
<a name="422"></a>         *   If we don't have a current ActorState, or we can't find a match on
<a name="423"></a>         *   our current ActorState, find the best match from the TopicEntries
<a name="424"></a>         *   located directly within the actor.
<a name="425"></a>         */
<a name="426"></a>        return getBestMatch(prop, topic);
<a name="427"></a>    }
<a name="428"></a>    
<a name="429"></a>   
<a name="430"></a>    /* 
<a name="431"></a>     *   List of objects corresponding to non-conversation TopicEntry types for
<a name="432"></a>     *   which an ActorState's noResponseMsg should not be used. We separate
<a name="433"></a>     *   this lost out here to allow game code to add other game-specific types
<a name="434"></a>     *   (e.g. hugTopicObj if the game implements a Hug Action and a HugTopic).
<a name="435"></a>     */
<a name="436"></a>    physicalTopicObjs = [hitTopicObj, kissTopicObj, touchTopicObj]
<a name="437"></a>    
<a name="438"></a>    /* 
<a name="439"></a>     *   Handle a conversational command where prop is a pointer to the property
<a name="440"></a>     *   containing the appropriate list of TopicEntries to search (e.g.
<a name="441"></a>     *   &amp;askTopics), topic is the list of Topics to match, and defaultProp is
<a name="442"></a>     *   pointer to the property to invoke if we can't find a match.
<a name="443"></a>     */
<a name="444"></a>    handleTopic(prop, topic, defaultProp = &amp;noResponseMsg)
<a name="445"></a>    {
<a name="446"></a>        /* 
<a name="447"></a>         *   If the actor's current ActorState defines a noResponse property
<a name="448"></a>         *   then we display it rather than trying to match any TopicEntries
<a name="449"></a>         *   unless we're trying to match a non-conversational TopicEntry such
<a name="450"></a>         *   as HitTopic, TouchTopic or KissTopic.
<a name="451"></a>         */       
<a name="452"></a>        if(curState &amp;&amp; curState.propType(&amp;noResponse) != TypeNil &amp;&amp;
<a name="453"></a>           !topic.overlapsWith(physicalTopicObjs))
<a name="454"></a>        {
<a name="455"></a>            switch(curState.propType(&amp;noResponse))
<a name="456"></a>            {
<a name="457"></a>            case TypeDString:
<a name="458"></a>                curState.noResponse();
<a name="459"></a>                return nil;
<a name="460"></a>            case TypeSString:
<a name="461"></a>                say(curState.noResponse);
<a name="462"></a>                return nil;
<a name="463"></a>            case TypeCode:
<a name="464"></a>                if(gOutStream.watchForOutput({:curState.noResponse}))
<a name="465"></a>                    return nil;               
<a name="466"></a>            }
<a name="467"></a>            
<a name="468"></a>        }
<a name="469"></a>        
<a name="470"></a>        /* 
<a name="471"></a>         *   Reset the keysManaged flag to nil so that we can end this method by
<a name="472"></a>         *   carrying out the necessary keys management unless this is handled
<a name="473"></a>         *   indirectly through the call to response.handleTopic() below, which
<a name="474"></a>         *   may set this flag to true.
<a name="475"></a>         */
<a name="476"></a>        keysManaged = nil;
<a name="477"></a>        
<a name="478"></a>        /*  Note if we need a greeting response */
<a name="479"></a>        local greetingResponse = nil;
<a name="480"></a>        
<a name="481"></a>        /*  Note our current actor state */
<a name="482"></a>        local oldState = curState;
<a name="483"></a>        
<a name="484"></a>        /*   
<a name="485"></a>         *   If we're not already in conversation with this actor, see if
<a name="486"></a>         *   there's a HelloTopic or ImpHelloTopic that might change the
<a name="487"></a>         *   ActorState
<a name="488"></a>         */
<a name="489"></a>        
<a name="490"></a>        if(gPlayerChar.currentInterlocutor != self &amp;&amp;
<a name="491"></a>           valToList(topic)[1] not in (helloTopicObj, impHelloTopicObj, 
<a name="492"></a>                                       actorHelloTopicObj ))
<a name="493"></a>        {
<a name="494"></a>            /* Find a greeting response for an ImpHelloTopic/HelloTopic */
<a name="495"></a>            greetingResponse = findBestResponse(&amp;miscTopics, [impHelloTopicObj]);
<a name="496"></a>            
<a name="497"></a>            /* 
<a name="498"></a>             *   If there is a greeting response and it wants to change state,
<a name="499"></a>             *   temporarily change state before looking for the best match for
<a name="500"></a>             *   the topic we're acually looking for
<a name="501"></a>             */
<a name="502"></a>            if(greetingResponse &amp;&amp; greetingResponse.changeToState != nil)
<a name="503"></a>                curState = greetingResponse.changeToState;
<a name="504"></a>            
<a name="505"></a>        }
<a name="506"></a>        
<a name="507"></a>	
<a name="508"></a>        /* 
<a name="509"></a>         *   Note the best response we can find; i.e. the TopicEntry from the
<a name="510"></a>         *   prop list that best matches topic.
<a name="511"></a>         */
<a name="512"></a>        local response = findBestResponse(prop, topic);
<a name="513"></a>        
<a name="514"></a>        /*   
<a name="515"></a>         *   Change back to our original state, since if the response we found
<a name="516"></a>         *   isn't conversational or doesn't imply a greeting, we won't want to
<a name="517"></a>         *   change state; if we have found a conversational response that
<a name="518"></a>         *   implies a greeting, executing the greeting will change the state
<a name="519"></a>         *   to the new state.
<a name="520"></a>         */
<a name="521"></a>        curState = oldState;
<a name="522"></a>        
<a name="523"></a>        /* 
<a name="524"></a>         *   If we find a response, carry out an implied greeting if we need
<a name="525"></a>         *   one, and then display the response.
<a name="526"></a>         */
<a name="527"></a>        if(response != nil)
<a name="528"></a>        {    
<a name="529"></a>            /* 
<a name="530"></a>             *   Check whether we need to carry out an implied greeting. We need
<a name="531"></a>             *   to do so if we're not already the player character's current
<a name="532"></a>             *   interlocutor and the response we've found is a conversational
<a name="533"></a>             *   one (i.e. one in which a conversational exchange actually takes
<a name="534"></a>             *   place as opposed to one explaining why it can't or shouldn't).
<a name="535"></a>             */
<a name="536"></a>            if(gPlayerChar.currentInterlocutor != self &amp;&amp;
<a name="537"></a>               response.isConversational)
<a name="538"></a>            {            
<a name="539"></a>                /* Make the player character the current interlocutor. */
<a name="540"></a>                gPlayerChar.currentInterlocutor = self;
<a name="541"></a>                
<a name="542"></a>                /* 
<a name="543"></a>                 *   Only try an implicit greeting if the response we've found
<a name="544"></a>                 *   implies one (this prevents an implicit greeting from
<a name="545"></a>                 *   forever trying to trigger itself, for example) and if we
<a name="546"></a>                 *   found one to show.                 
<a name="547"></a>                 */
<a name="548"></a>                if(response.impliesGreeting &amp;&amp; greetingResponse != nil)
<a name="549"></a>                {
<a name="550"></a>                    /* 
<a name="551"></a>                     *   Carry out an implicit greeting. If this does anything
<a name="552"></a>                     *   add a paragraph break to separate it from the
<a name="553"></a>                     *   conversational exchange that follows.
<a name="554"></a>                     */
<a name="555"></a>                    greetingResponse.handleTopic();
<a name="556"></a>                      "&lt;.p&gt;";
<a name="557"></a>                }
<a name="558"></a>            }
<a name="559"></a>            
<a name="560"></a>            /* 
<a name="561"></a>             *   Let the response (the TopicEntry we've identified as the best
<a name="562"></a>             *   match to the topic requested) handle the topic.
<a name="563"></a>             */
<a name="564"></a>            response.handleTopic();     
<a name="565"></a>            
<a name="566"></a>            /* 
<a name="567"></a>             *   If the response was a conversational one, note that conversation
<a name="568"></a>             *   has taken place on this turn.
<a name="569"></a>             */
<a name="570"></a>            if(response.wasConversational)
<a name="571"></a>                noteConversed(); 
<a name="572"></a>        }
<a name="573"></a>        
<a name="574"></a>        /* Otherwise, if we haven't found a matching response... */
<a name="575"></a>        else
<a name="576"></a>        {         
<a name="577"></a>            /* 
<a name="578"></a>             *   If we were speculatively trying an initiateTopic that doesn't
<a name="579"></a>             *   actually find anything, don't count this as a conversational
<a name="580"></a>             *   turn from the point of view of updating pending and active
<a name="581"></a>             *   keys. The same applies if we were speculatively trying to find
<a name="582"></a>             *   an ImpHelloTopic or any other topic with a nil defaultProp.
<a name="583"></a>             */
<a name="584"></a>            if(defaultProp == nil)
<a name="585"></a>                return nil;
<a name="586"></a>            
<a name="587"></a>            /* Otherwise, show the default response */
<a name="588"></a>            else                
<a name="589"></a>            {               
<a name="590"></a>                say(self.(defaultProp));    
<a name="591"></a>            }
<a name="592"></a>           
<a name="593"></a>        }
<a name="594"></a>        
<a name="595"></a>        /* 
<a name="596"></a>         *   Carry out the key management if it hasn't already been carried out
<a name="597"></a>         *   on this turn. It may already have been by a tag handled by the
<a name="598"></a>         *   conversationManager object processed via the call to
<a name="599"></a>         *   response.handleTopic() above.
<a name="600"></a>         */
<a name="601"></a>        if(!keysManaged)
<a name="602"></a>            manageKeys();
<a name="603"></a>        
<a name="604"></a>         /* 
<a name="605"></a>          *   Return true or nil depending on whether we found a matching
<a name="606"></a>          *   response to display
<a name="607"></a>          */        
<a name="608"></a>        return response != nil;
<a name="609"></a>    }
<a name="610"></a>    
<a name="611"></a>    /* 
<a name="612"></a>     *   Move pending keys to active keys and clear pending keys if need be. We
<a name="613"></a>     *   call this out as a separate method to allow it to be directly called
<a name="614"></a>     *   from elsewhere.
<a name="615"></a>     */
<a name="616"></a>    manageKeys()
<a name="617"></a>    {
<a name="618"></a>        /* 
<a name="619"></a>         *   Reset the pending keys to nil unless we've been requested to retain
<a name="620"></a>         *   them. (The pendingKeys are the set of convKeys that a previous
<a name="621"></a>         *   conversational turn may have told us to match).
<a name="622"></a>         */
<a name="623"></a>        if(!keepPendingKeys)
<a name="624"></a>            pendingKeys = [];
<a name="625"></a>        
<a name="626"></a>        /* Set our activeKeys to our pendingKeys */
<a name="627"></a>        activeKeys = pendingKeys;
<a name="628"></a>        
<a name="629"></a>        /*  Reset the flag that tells us to keep our pending keys */
<a name="630"></a>        keepPendingKeys = nil;  
<a name="631"></a>        
<a name="632"></a>        /* Note that we have now managed our keys. */ 
<a name="633"></a>        keysManaged = true;		
<a name="634"></a>    }
<a name="635"></a>    
<a name="636"></a>    /* 
<a name="637"></a>     *   Flag; has the active/pending key management already been carried out on
<a name="638"></a>     *   this turn?
<a name="639"></a>     */
<a name="640"></a>    keysManaged = nil
<a name="641"></a>	
<a name="642"></a>    /* Convenience method to note that conversation has occurred on this turn */    
<a name="643"></a>    noteConversed()
<a name="644"></a>    {
<a name="645"></a>        /* Note that we're the player character's current interlocutor */
<a name="646"></a>        gPlayerChar.currentInterlocutor = self;
<a name="647"></a>        
<a name="648"></a>        /* Note that we last conversed on this turn */
<a name="649"></a>        lastConvTime = libGlobal.totalTurns;
<a name="650"></a>        
<a name="651"></a>        /* Note that this actor is a possible antecedent for a pronoun */
<a name="652"></a>        notePronounAntecedent(self);
<a name="653"></a>        
<a name="654"></a>        /* Add our boredomAgendaItem to our agenda if it isn't already there */
<a name="655"></a>        if(valToList(agendaList).indexOf(boredomAgendaItem) == nil)
<a name="656"></a>            addToAgenda(boredomAgendaItem);
<a name="657"></a>    }
<a name="658"></a>    
<a name="659"></a>    /* 
<a name="660"></a>     *   This method can be called on the actor when we want to display the text
<a name="661"></a>     *   of one or both sides of a conversational exchange with the actor
<a name="662"></a>     *   without going through the TopicEntry mechanism to do so.
<a name="663"></a>     */ 
<a name="664"></a>    actorSay(str)
<a name="665"></a>    {
<a name="666"></a>        /* 
<a name="667"></a>         *   Reset the keysManaged flag to nil so that we can end this method by
<a name="668"></a>         *   carrying out the necessary keys management unless this is handled
<a name="669"></a>         *   indirectly through the call to say(str) below, which may set this
<a name="670"></a>         *   flag to true.
<a name="671"></a>         */
<a name="672"></a>        keysManaged = nil;
<a name="673"></a>        
<a name="674"></a>        /* Not that we have conversed with the actor this turn */		
<a name="675"></a>        noteConversed();
<a name="676"></a>        
<a name="677"></a>        /* Display the text of the conversational exchange. */
<a name="678"></a>        say(str);
<a name="679"></a>        
<a name="680"></a>        /* Carry out the keys management if it hasn't already been carried out. */
<a name="681"></a>        if(!keysManaged)
<a name="682"></a>            manageKeys();
<a name="683"></a>    }
<a name="684"></a>    
<a name="685"></a>    
<a name="686"></a>    /* 
<a name="687"></a>     *   Conditionally use actorSay() or say() to output str depending on
<a name="688"></a>     *   whether str appears to be something the actor says or simply a
<a name="689"></a>     *   non-verbal response (or lack of response). If str contains quote marks
<a name="690"></a>     *   or the sequence @@ we'll assume it's something the actor says (and
<a name="691"></a>     *   strip out the @@ that would simply be there to mark str as something
<a name="692"></a>     *   the actor says, perhaps reported in indirect speech.
<a name="693"></a>     */     
<a name="694"></a>    condSay(str)
<a name="695"></a>    {
<a name="696"></a>        /* 
<a name="697"></a>         *   If str contains a quotation mark or @@ assume it's something this
<a name="698"></a>         *   actor says.
<a name="699"></a>         */
<a name="700"></a>        if(str.find('&lt;q&gt;') || str.find('"') || str.find('@@'))
<a name="701"></a>        {
<a name="702"></a>            /* Strip out the @@ sequence, which is simply a marker. */
<a name="703"></a>            str = str.findReplace('@@', '');
<a name="704"></a>                
<a name="705"></a>            /* 
<a name="706"></a>             *   Display str using actorSay(), so that it counts as
<a name="707"></a>             *   conversational.
<a name="708"></a>             */
<a name="709"></a>            actorSay(str);                
<a name="710"></a>        }
<a name="711"></a>        /* 
<a name="712"></a>         *   Otherwise just use say(), since we don't want the response to count
<a name="713"></a>         *   as conversational.
<a name="714"></a>         */
<a name="715"></a>        else
<a name="716"></a>            say(str);   
<a name="717"></a>    }
<a name="718"></a>    
<a name="719"></a>    /* 
<a name="720"></a>     *   Make the actor initiate the conversation. If state is non-nil the actor will change
<a name="721"></a>     *   ActorState to state after issuing a greeting. The text of str will then be displayed.
<a name="722"></a>     */
<a name="723"></a>    initiateConversation(state, str)
<a name="724"></a>    {
<a name="725"></a>        /* 
<a name="726"></a>         *   If the actor is not already the player character's current interlocutor, execute any
<a name="727"></a>         *   ActorHelloTopic in the actor's current state.
<a name="728"></a>         */
<a name="729"></a>        if(gPlayerChar.currentInterlocutor != getActor)
<a name="730"></a>            getActor.actorSayHello();
<a name="731"></a>        
<a name="732"></a>        /* If state is not nii, change our ActorState to state. */
<a name="733"></a>        if(state)
<a name="734"></a>            setState(state);              
<a name="735"></a>        
<a name="736"></a>        /* Use actorSay() to display str. */
<a name="737"></a>        actorSay(str);
<a name="738"></a>    }
<a name="739"></a>	
<a name="740"></a>    /* 
<a name="741"></a>     *   The last turn on which this actor conversed with the player character.
<a name="742"></a>     *   We start out with a value of -1 to mean that we haven't conversed at
<a name="743"></a>     *   all.
<a name="744"></a>     */
<a name="745"></a>    lastConvTime = -1
<a name="746"></a>    
<a name="747"></a>    /*  
<a name="748"></a>     *   Has this actor conversed with the player character on the current turn?
<a name="749"></a>     *   He/she/it has done so if our last conversation time is the same as the
<a name="750"></a>     *   game's turn count.
<a name="751"></a>     */
<a name="752"></a>    conversedThisTurn = (lastConvTime == libGlobal.totalTurns)
<a name="753"></a>
<a name="754"></a>    /*  
<a name="755"></a>     *   Did this actor converse with the player character on the previous turn?
<a name="756"></a>     *   He/she/it did so if our last conversation time is one less than the
<a name="757"></a>     *   game's current turn count.
<a name="758"></a>     */
<a name="759"></a>    conversedLastTurn = (lastConvTime == libGlobal.totalTurns - 1)
<a name="760"></a>    
<a name="761"></a>    
<a name="762"></a>    /* 
<a name="763"></a>     *   If this list is not empty then the choice of topic entries to match
<a name="764"></a>     *   will be restricted to those whose convKeys property includes at least
<a name="765"></a>     *   one of the key values in this list.
<a name="766"></a>     */
<a name="767"></a>    activeKeys = []
<a name="768"></a>    
<a name="769"></a>    /* 
<a name="770"></a>     *   a list of the keys to be copied into the activeKeys property for use in
<a name="771"></a>     *   the next conversational turn. These are normally added by game code via
<a name="772"></a>     *   &lt;.convnode&gt; tags and the like in conversational output.
<a name="773"></a>     */
<a name="774"></a>    pendingKeys = []
<a name="775"></a>    
<a name="776"></a>    /* 
<a name="777"></a>     *   If keepPendingKeys is set to true (normally by a &lt;.convstay&gt; tag) then
<a name="778"></a>     *   retain the pending conversation keys (and hence the active ones) for
<a name="779"></a>     *   the next conversational turn.
<a name="780"></a>     */    
<a name="781"></a>    keepPendingKeys = nil
<a name="782"></a>    
<a name="783"></a>    /* 
<a name="784"></a>     *   Add a convkey value to our pending keys list (for use as an active key
<a name="785"></a>     *   on the next conversational turn.     */
<a name="786"></a>    
<a name="787"></a>    addPendingKey(val)
<a name="788"></a>    {
<a name="789"></a>        pendingKeys += val;
<a name="790"></a>    }
<a name="791"></a>    
<a name="792"></a>    /* 
<a name="793"></a>     *   setConvNode() is effectively a synonym of addPendingKey(), but is a more intuitive name if
<a name="794"></a>     *   what we want to do is to set this actor's current convnode.
<a name="795"></a>     */
<a name="796"></a>    setConvNode(val)  { addPendingKey(val); }
<a name="797"></a>    
<a name="798"></a>    /* 
<a name="799"></a>     *   A list of the convKeys triggered by the most recent TopicEntry with a keyTopics property.
<a name="800"></a>     *   For internal library use only.
<a name="801"></a>     */
<a name="802"></a>    subTopicKeys = []
<a name="803"></a>    
<a name="804"></a>        
<a name="805"></a>    /*  Notification that an action is about to be carried out in our presence */
<a name="806"></a>    beforeAction()
<a name="807"></a>    {
<a name="808"></a>        /* First execute our own actorBeforeAction() method */
<a name="809"></a>        actorBeforeAction();
<a name="810"></a>        
<a name="811"></a>        /* 
<a name="812"></a>         *   Then execute our current ActorState's beforeAction() method, if we
<a name="813"></a>         *   have a current ActorState.
<a name="814"></a>         */
<a name="815"></a>        if(curState != nil)
<a name="816"></a>            curState.beforeAction();
<a name="817"></a>        
<a name="818"></a>        
<a name="819"></a>//        if(gActionIn (Take, TakeFrom) &amp;&amp; gDobj.isIn(getActor))
<a name="820"></a>//        {
<a name="821"></a>//            /* Display a message saying that removing obj is disallowed. */
<a name="822"></a>//            say(getActor.cannotTakeFromActorMsg(gDobj));
<a name="823"></a>//            
<a name="824"></a>//            /* Halt the action. */
<a name="825"></a>//            exit;
<a name="826"></a>//        }
<a name="827"></a>        
<a name="828"></a>    }
<a name="829"></a>    
<a name="830"></a>    /* 
<a name="831"></a>     *   Give this actor a chance to respond just before an action prior to any
<a name="832"></a>     *   response from its current actor state. By default we do nothing, but
<a name="833"></a>     *   game code can easily override this without any risk of breaking the
<a name="834"></a>     *   state-dependent beforeAction mechanism.
<a name="835"></a>     */    
<a name="836"></a>    actorBeforeAction()  { }
<a name="837"></a>    
<a name="838"></a>    /*  Notification that an action has just been carried out in our presence */
<a name="839"></a>    afterAction()
<a name="840"></a>    {
<a name="841"></a>        /* First execute our own actorAfterAction() method */
<a name="842"></a>        actorAfterAction();
<a name="843"></a>        
<a name="844"></a>        /* 
<a name="845"></a>         *   Then execute the afterAction() method on our current ActorState, if
<a name="846"></a>         *   we have one.
<a name="847"></a>         */
<a name="848"></a>        if(curState != nil)
<a name="849"></a>            curState.afterAction();
<a name="850"></a>           
<a name="851"></a>    }
<a name="852"></a>    
<a name="853"></a>    /* 
<a name="854"></a>     *   Give this actor a chance to respond just after an action prior to any
<a name="855"></a>     *   response from its current actor state. By default we do nothing, but
<a name="856"></a>     *   game code can easily override this without any risk of breaking the
<a name="857"></a>     *   state-dependent afterAction mechanism.
<a name="858"></a>     */ 
<a name="859"></a>    actorAfterAction() { }
<a name="860"></a>    
<a name="861"></a>     /* 
<a name="862"></a>      *   Notification that something else is about to travel. By default we
<a name="863"></a>      *   defer to out actor state, if we have one, but we also give the actor
<a name="864"></a>      *   object a chance to respond.
<a name="865"></a>      */
<a name="866"></a>    
<a name="867"></a>    beforeTravel(traveler, connector) 
<a name="868"></a>    {
<a name="869"></a>        /* 
<a name="870"></a>         *   If we have a current FollowAgendaItem, start by executing its
<a name="871"></a>         *   beforeTravel() method.
<a name="872"></a>         */
<a name="873"></a>        
<a name="874"></a>        if(followAgendaItem != nil &amp;&amp; followAgendaItem.isReady)
<a name="875"></a>            followAgendaItem.beforeTravel(traveler, connector);
<a name="876"></a>        
<a name="877"></a>        
<a name="878"></a>        /* 
<a name="879"></a>         *   Execute the beforeTravel() method on our current ActorState, if we
<a name="880"></a>         *   have one.
<a name="881"></a>         */
<a name="882"></a>        if(curState != nil)
<a name="883"></a>            curState.beforeTravel(traveler, connector);
<a name="884"></a>        
<a name="885"></a>        /*  Then execute our own actorBeforeTravel() method. */
<a name="886"></a>        actorBeforeTravel(traveler, connector);
<a name="887"></a>        
<a name="888"></a>        /*  
<a name="889"></a>         *   If the actor is waiting for the traveler to follow the actor via
<a name="890"></a>         *   connector, then set the follow fuse instead of executing the
<a name="891"></a>         *   actor's travel command.
<a name="892"></a>         */        
<a name="893"></a>        if(followAgendaItem != nil 
<a name="894"></a>           &amp;&amp; traveler == gPlayerChar 
<a name="895"></a>           &amp;&amp; followAgendaItem.isReady
<a name="896"></a>           &amp;&amp; followAgendaItem.nextConnector == connector)
<a name="897"></a>        {
<a name="898"></a>
<a name="899"></a>            setFollowMeFuse();
<a name="900"></a>            exit;
<a name="901"></a>        }
<a name="902"></a>        
<a name="903"></a>        
<a name="904"></a>        /* 
<a name="905"></a>         *   If the player char is talking to this actor and this actor is not
<a name="906"></a>         *   following the player character, end the conversation.
<a name="907"></a>         */
<a name="908"></a>        
<a name="909"></a>        if(gPlayerChar.currentInterlocutor == self &amp;&amp; traveler == gPlayerChar
<a name="910"></a>           &amp;&amp; fDaemon == nil)
<a name="911"></a>            endConversation(endConvLeave);
<a name="912"></a>        
<a name="913"></a>        /*  
<a name="914"></a>         *   If the traveler that's about to travel is the player character,
<a name="915"></a>         *   note the connector the player character is about to use.
<a name="916"></a>         */
<a name="917"></a>        if(traveler == gPlayerChar)
<a name="918"></a>            pcConnector = connector;       
<a name="919"></a>        
<a name="920"></a>        
<a name="921"></a>        
<a name="922"></a>    }
<a name="923"></a>    
<a name="924"></a>    /* The Travel Connector just traversed by the player character */    
<a name="925"></a>    pcConnector = nil
<a name="926"></a>    
<a name="927"></a>    /* 
<a name="928"></a>     *   If the player character has seen this actor travel then lastTravelInfo
<a name="929"></a>     *   contains a two-element list comprising the room the actor was seen
<a name="930"></a>     *   travelling from and the connector by which the actor was seen
<a name="931"></a>     *   travelling.
<a name="932"></a>     *
<a name="933"></a>     *   Note that if you move an actor by authorial fiat using moveInto() (say)
<a name="934"></a>     *   when the player character can see the actor, you might want to update
<a name="935"></a>     *   lastTravelInfo manually to ensure that any subsequent FOLLOW command
<a name="936"></a>     *   still works properly, e.g.:
<a name="937"></a>     *.
<a name="938"></a>     *.   "Bob storms out through the front door, slamming it behind him. ";
<a name="939"></a>     *.   bob.moveInto(nil);
<a name="940"></a>     *.   bob.lastTravelInfo = [hall, frontDoor];
<a name="941"></a>     *.
<a name="942"></a>     *   (If instead of or before bob.moveInto(nil) you had written
<a name="943"></a>     *   frontDoor.travelVia(bob), this wouldn't be necessary, since it would be
<a name="944"></a>     *   handled for you by frontDoor.travelVia()).
<a name="945"></a>     */
<a name="946"></a>    lastTravelInfo = nil
<a name="947"></a>    
<a name="948"></a>    /* 
<a name="949"></a>     *   Give this actor a chance to react just before another actor travels in
<a name="950"></a>     *   addition to any reaction from its current actor state. By default we do
<a name="951"></a>     *   nothing, but game code can easily override this without any risk of
<a name="952"></a>     *   breaking the state-dependent beforeTravel mechanism.
<a name="953"></a>     */ 
<a name="954"></a>    actorBeforeTravel(traveler, connector) { }
<a name="955"></a>       
<a name="956"></a>    /* 
<a name="957"></a>     *   Notification that travel has just taken place in our presence (usually
<a name="958"></a>     *   because an actor has just arrived in our location)
<a name="959"></a>     */    
<a name="960"></a>    afterTravel(traveler, connector) 
<a name="961"></a>    {
<a name="962"></a>        /* If we have a current ActorState, execute its afterTravel() method */
<a name="963"></a>        if(curState != nil)        
<a name="964"></a>            curState.afterTravel(traveler, connector);
<a name="965"></a>                   
<a name="966"></a>        
<a name="967"></a>        /* Execute our own actorAfterTravel() method */
<a name="968"></a>        actorAfterTravel(traveler, connector);           
<a name="969"></a>    }  
<a name="970"></a>        
<a name="971"></a>    /* The turn on which the player character last arrived in our location */
<a name="972"></a>    pcArrivalTurn = nil
<a name="973"></a>    
<a name="974"></a>    /* Flag -- has the player character just arrived? */
<a name="975"></a>    pcJustArrived = (pcArrivalTurn == gTurns)
<a name="976"></a>        
<a name="977"></a>    /* 
<a name="978"></a>     *   Give this actor a chance to react just after another actor travels in
<a name="979"></a>     *   addition to any reaction from its current actor state. By default we do
<a name="980"></a>     *   nothing, but game code can easily override this without any risk of
<a name="981"></a>     *   breaking the state-dependent afterTravel mechanism. 
<a name="982"></a>     */     
<a name="983"></a>    actorAfterTravel(traveler, connector) {}
<a name="984"></a>      
<a name="985"></a>    /*   
<a name="986"></a>     *   Terminate a conversation that's currently going on between this actor
<a name="987"></a>     *   and the player character. The reason parameter is the reason for ending
<a name="988"></a>     *   the conversation and can be one of endConvBye (the player character has
<a name="989"></a>     *   just said goodbye), endConvTravel (the player character is leaving the
<a name="990"></a>     *   location), endConvBoredom (this actor has become bored with waiting for
<a name="991"></a>     *   the player character to say anything) or endConvActor (this actor
<a name="992"></a>     *   wishes to terminate the conversation for some other reason of its own).
<a name="993"></a>     */
<a name="994"></a>    endConversation(reason)
<a name="995"></a>    {
<a name="996"></a>        /* 
<a name="997"></a>         *   If we're permitted to end the conversation for the reason
<a name="998"></a>         *   specified, display a farewell message appopriate to the reason
<a name="999"></a>         */
<a name="1000"></a>        if(canEndConversation(reason))
<a name="1001"></a>            sayGoodbye(reason);
<a name="1002"></a>        
<a name="1003"></a>        /* 
<a name="1004"></a>         *   otherwise if the player char is about to depart and the actor won't
<a name="1005"></a>         *   let the conversation end, block the travel
<a name="1006"></a>         */
<a name="1007"></a>        else if(reason == endConvLeave)
<a name="1008"></a>            exit;
<a name="1009"></a>        
<a name="1010"></a>        /* 
<a name="1011"></a>         *   This conversation is ending so reset the last topic mentioned (during the current
<a name="1012"></a>         *   conversation) to nil.
<a name="1013"></a>         */
<a name="1014"></a>        libGlobal.lastTopicMentioned = nil;
<a name="1015"></a>        
<a name="1016"></a>        /* Also reset the last fact mentioned. */
<a name="1017"></a>        libGlobal.lastFactMentioned = nil;
<a name="1018"></a>    }
<a name="1019"></a>    
<a name="1020"></a>    /* 
<a name="1021"></a>     *   Is the actor willing for this conversation to be ended? We first check
<a name="1022"></a>     *   the current actor state (if any) and then the actor object. If either
<a name="1023"></a>     *   raises an object it should display a message saying what the objection
<a name="1024"></a>     *   is (and then return nil). By default we simply return true, allowing
<a name="1025"></a>     *   the conversation to end.
<a name="1026"></a>     */    
<a name="1027"></a>    canEndConversation(reason)
<a name="1028"></a>    {
<a name="1029"></a>        
<a name="1030"></a>        /* 
<a name="1031"></a>         *   First check whether there's a Conversation Node that wants to
<a name="1032"></a>         *   object to the conversation ending. We do that by first seeing if
<a name="1033"></a>         *   there's an active NodeEndCheck object...
<a name="1034"></a>         */
<a name="1035"></a>        local nodeCheck = findBestResponse(&amp;initiateTopics, [nodeEndCheckObj]);
<a name="1036"></a>        
<a name="1037"></a>        /* 
<a name="1038"></a>         *... and if there is, seeing whether its canEndConversation() method
<a name="1039"></a>         *   objects.
<a name="1040"></a>         */        
<a name="1041"></a>        if(nodeCheck != nil &amp;&amp; !nodeCheck.canEndConversation(reason))
<a name="1042"></a>            return nil;
<a name="1043"></a>        
<a name="1044"></a>        /* 
<a name="1045"></a>         *   Then check with the current ActorState (if there is one) and our
<a name="1046"></a>         *   own actorCanEndConversation() method.
<a name="1047"></a>         */
<a name="1048"></a>        if(curState == nil || curState.canEndConversation(reason))
<a name="1049"></a>            return actorCanEndConversation(reason);
<a name="1050"></a>        
<a name="1051"></a>        
<a name="1052"></a>        /* 
<a name="1053"></a>         *   If we've reached this point it's because our current ActorState has
<a name="1054"></a>         *   objected to ending the conversation, so return nil to disallow it.
<a name="1055"></a>         */
<a name="1056"></a>        return nil;
<a name="1057"></a>    }
<a name="1058"></a>    
<a name="1059"></a>    /* 
<a name="1060"></a>     *   A state-independent check on whether this actor will allow the current
<a name="1061"></a>     *   conversation to end on account of reason. By default we simply return
<a name="1062"></a>     *   true to allow the conversation to end, but game code can override this
<a name="1063"></a>     *   to return nil to disallow the ending of the conversation (presumably
<a name="1064"></a>     *   under specific conditions).
<a name="1065"></a>     */
<a name="1066"></a>    actorCanEndConversation(reason) { return true; }
<a name="1067"></a>    
<a name="1068"></a>    /*
<a name="1069"></a>     *   Do we want an otherwise not understood input (such as "You're crazy") treated as an
<a name="1070"></a>     *   implicit SAY command (e.g., treated as SAY YOU'RE CRAZY) when the player character is in
<a name="1071"></a>     *   conversatiom with this Actor? Return true if so or nil otherwise.
<a name="1072"></a>     */
<a name="1073"></a>    allowImplicitSay()
<a name="1074"></a>    {
<a name="1075"></a>        /* 
<a name="1076"></a>         *   If neither this Actor nor its current ActorState defines any SayTopics then there's no
<a name="1077"></a>         *   point treating any user input as an implicit SAY command, so simply return nil.
<a name="1078"></a>         */        
<a name="1079"></a>        if(autoImplicitSay &amp;&amp; sayTopics.length == 0)
<a name="1080"></a>        {
<a name="1081"></a>            if(curState &amp;&amp; curState.sayTopics.length &gt; 0)
<a name="1082"></a>                return enableImplicitSay;
<a name="1083"></a>            else
<a name="1084"></a>                return nil;
<a name="1085"></a>        }
<a name="1086"></a>        
<a name="1087"></a>                     
<a name="1088"></a>        /*  
<a name="1089"></a>         *   If we don't want to count DefaultTopics as potential SayTopics for the purposes of
<a name="1090"></a>         *   interpreting otherwise not understood input, then check whether this Actor's sayTopic
<a name="1091"></a>         *   list includes anything that's not a DefaultTopic, and if not, return nil.
<a name="1092"></a>         */
<a name="1093"></a>        if(autoImplicitSay &amp;&amp; !defaultCountsAsSay 
<a name="1094"></a>           &amp;&amp; sayTopics.countWhich({x: !x.ofKind(DefaultTopic)}) == 0)
<a name="1095"></a>        {
<a name="1096"></a>            if(curState &amp;&amp; curState.sayTopics.countWhich({x: !x.ofKind(DefaultTopic)}) &gt; 0)
<a name="1097"></a>                return enableImplicitSay;
<a name="1098"></a>            else                
<a name="1099"></a>                return nil;
<a name="1100"></a>        }
<a name="1101"></a>                                   
<a name="1102"></a>        /*  Otherwise return the value of a user (game author) modifiable flag. */
<a name="1103"></a>        return enableImplicitSay;
<a name="1104"></a>    }
<a name="1105"></a>    
<a name="1106"></a>    
<a name="1107"></a>    /*
<a name="1108"></a>     *   User modifiable flag for use with the allowImplicitSay() method. Do we ever want to allow
<a name="1109"></a>     *   implicit SAY commands for this actor? By default we do allow this (true), since this has
<a name="1110"></a>     *   been the default library behaviour up until now, but game authors can change this either on
<a name="1111"></a>     *   individual Actors or by modifying the Actor class.
<a name="1112"></a>     */
<a name="1113"></a>    enableImplicitSay = true
<a name="1114"></a>    
<a name="1115"></a>    /*  
<a name="1116"></a>     *   Do we want a DefaultTopic to count as a SayTopic for the purpose of deciding whether to
<a name="1117"></a>     *   allow otherwise not understood commands being interpreted as implicit SAY commands? By
<a name="1118"></a>     *   default we don't, since that's most likely to be what game authors who don't explicitly
<a name="1119"></a>     *   define SayTopics (or DefaultSayTopics) intend, but game code can override this, either on
<a name="1120"></a>     *   individual actors or on the Actor class.
<a name="1121"></a>     */
<a name="1122"></a>    defaultCountsAsSay = nil
<a name="1123"></a>    
<a name="1124"></a>    
<a name="1125"></a>    /*
<a name="1126"></a>     *   Flag, do we want the allowImplicitSay() method to rule out the interpretation of commands
<a name="1127"></a>     *   as implicit Say commands if there are no available SayTopics for this actor? By default we
<a name="1128"></a>     *   do, but game code may wish to override this if the results of handling player input in this
<a name="1129"></a>     *   manner are felt to be inconsistent. If autoImplicitSay is set to nil then
<a name="1130"></a>     *   allowImplicitSay() will simply return the value of enableImplicitSay.
<a name="1131"></a>     */
<a name="1132"></a>    autoImplicitSay = true
<a name="1133"></a>    
<a name="1134"></a>    /* 
<a name="1135"></a>     *   Mechanism to allow this actor to follow the player char. We do this
<a name="1136"></a>     *   rather simplistically by checking whether the player char is still in
<a name="1137"></a>     *   our location and moving us to the player char's location if s/he is not
<a name="1138"></a>     *   on the assumption that if the player char can get there in one turn, so
<a name="1139"></a>     *   can we. On arriving in the player char's new location we announce that
<a name="1140"></a>     *   we've just followed the player char and then run the arrivingTurn
<a name="1141"></a>     *   method on our current actor state (if we have one).
<a name="1142"></a>     */    
<a name="1143"></a>    followDaemon()
<a name="1144"></a>    {
<a name="1145"></a>        /* First note which room we're currently in */
<a name="1146"></a>        local oldLoc = getOutermostRoom;
<a name="1147"></a>        
<a name="1148"></a>        /* 
<a name="1149"></a>         *   If we're not in the player character's current room, try to follow
<a name="1150"></a>         *   the player character
<a name="1151"></a>         */
<a name="1152"></a>        if(getOutermostRoom != gPlayerChar.getOutermostRoom)
<a name="1153"></a>        {                     
<a name="1154"></a>            
<a name="1155"></a>            local oldRoom = getOutermostRoom();
<a name="1156"></a>            
<a name="1157"></a>            /* 
<a name="1158"></a>             *   If we know which TravelConnector the player character left by,
<a name="1159"></a>             *   try to traverse it.
<a name="1160"></a>             */
<a name="1161"></a>            if(pcConnector != nil)                
<a name="1162"></a>                pcConnector.travelVia(self);
<a name="1163"></a>            
<a name="1164"></a>//            /* 
<a name="1165"></a>//             *   Otherwise, simply travel to the player character's current room
<a name="1166"></a>//             */
<a name="1167"></a>//            else
<a name="1168"></a>//                gPlayerChar.getOutermostRoom.travelVia(self);
<a name="1169"></a>//            
<a name="1170"></a>            /* If we have moved, report the fact. */
<a name="1171"></a>            if(getOutermostRoom != oldRoom)
<a name="1172"></a>            {
<a name="1173"></a>                /*                  
<a name="1174"></a>                 *   Display our message to say we're following the player character
<a name="1175"></a>                 */
<a name="1176"></a>                sayFollowing(oldLoc, pcConnector);
<a name="1177"></a>                
<a name="1178"></a>                /* 
<a name="1179"></a>                 *   Carry out any additional handling we want to do on arriving in our new
<a name="1180"></a>                 *   location.
<a name="1181"></a>                 */
<a name="1182"></a>                arrivingTurn();            
<a name="1183"></a>            }
<a name="1184"></a>            /* 
<a name="1185"></a>             *   Otherwise if we're no longer in the player character's location we've been unable
<a name="1186"></a>             *   to follow, so we stop trying to follow.
<a name="1187"></a>             */
<a name="1188"></a>            else if(getOutermostRoom != gRoom)
<a name="1189"></a>                stopFollowing();
<a name="1190"></a>        }        
<a name="1191"></a>        
<a name="1192"></a>        /* 
<a name="1193"></a>         *   Reset pcConnector to nil in any event so that a spurious value
<a name="1194"></a>         *   isn't left for a later turn.
<a name="1195"></a>         */
<a name="1196"></a>        pcConnector = nil;
<a name="1197"></a>    }
<a name="1198"></a>    
<a name="1199"></a>    /* 
<a name="1200"></a>     *   Game code can call this method to instruct this actor to start
<a name="1201"></a>     *   following the player char round the map
<a name="1202"></a>     */    
<a name="1203"></a>    startFollowing()
<a name="1204"></a>    {
<a name="1205"></a>        /* 
<a name="1206"></a>         *   Create a new Daemon to carry out the following and make a note of
<a name="1207"></a>         *   it
<a name="1208"></a>         */
<a name="1209"></a>        if(fDaemon == nil)
<a name="1210"></a>            fDaemon = new Daemon(self, &amp;followDaemon, 0); 
<a name="1211"></a>    }
<a name="1212"></a>    
<a name="1213"></a>    /* 
<a name="1214"></a>     *   Game code can call this method to instruct this actor to stop following
<a name="1215"></a>     *   the player char round the map.
<a name="1216"></a>     */    
<a name="1217"></a>    stopFollowing()
<a name="1218"></a>    {
<a name="1219"></a>        /* 
<a name="1220"></a>         *   If there's a currently active following Daemon, remove it from the
<a name="1221"></a>         *   game's list of events to be executed each turn.
<a name="1222"></a>         */
<a name="1223"></a>        if(fDaemon != nil)
<a name="1224"></a>            fDaemon.removeEvent();
<a name="1225"></a>        
<a name="1226"></a>        /*   Note that we no longer have an active following Daemon */
<a name="1227"></a>        fDaemon = nil;
<a name="1228"></a>        
<a name="1229"></a>        /*   
<a name="1230"></a>         *   Reset pcConnector to nil so that we don't leave an old spurious
<a name="1231"></a>         *   value for a later turn.
<a name="1232"></a>         */
<a name="1233"></a>        pcConnector = nil;
<a name="1234"></a>    }
<a name="1235"></a>    
<a name="1236"></a>    /* 
<a name="1237"></a>     *   Store the id of the daemon being used to make us follow the player
<a name="1238"></a>     *   char. We can check whether this actor is currently following or not by
<a name="1239"></a>     *   testing whether or not this is nil.
<a name="1240"></a>     */    
<a name="1241"></a>    fDaemon = nil
<a name="1242"></a>    
<a name="1243"></a>    /*   
<a name="1244"></a>     *   Display a message to say that we've just followed the player character
<a name="1245"></a>     *   to a new location from oldLoc.
<a name="1246"></a>     */
<a name="1247"></a>    sayFollowing(oldLoc, conn)
<a name="1248"></a>    {
<a name="1249"></a>        /* 
<a name="1250"></a>         *   If we don't have a current ActorState, use our own
<a name="1251"></a>         *   sayActorFollowing() method to say we've just followed the player
<a name="1252"></a>         *   character.
<a name="1253"></a>         */
<a name="1254"></a>        if(curState == nil)
<a name="1255"></a>            sayActorFollowing(oldLoc, conn);
<a name="1256"></a>        
<a name="1257"></a>        /*  Othewise call the sayFollowing() method on our current ActorState */
<a name="1258"></a>        else
<a name="1259"></a>            curState.sayFollowing(oldLoc, conn);
<a name="1260"></a>    }
<a name="1261"></a>    
<a name="1262"></a>    /*  
<a name="1263"></a>     *   Display a message to say that we've just followed the player character
<a name="1264"></a>     *   to a new location from oldLoc. The library provides a default message
<a name="1265"></a>     *   but this can be overridded as desired.
<a name="1266"></a>     */
<a name="1267"></a>    sayActorFollowing(oldLoc, conn)
<a name="1268"></a>    {
<a name="1269"></a>        /* 
<a name="1270"></a>         *   Create some local variables to use as message substitution
<a name="1271"></a>         *   parameters.
<a name="1272"></a>         */
<a name="1273"></a>        local follower = self, pc = gPlayerChar;
<a name="1274"></a>        gMessageParams(follower, pc);
<a name="1275"></a>        
<a name="1276"></a>        /* Display our default following message */
<a name="1277"></a>        DMsg(follow, '&lt;.p&gt;{The follower} follow{s/ed} behind {the pc}. ');
<a name="1278"></a>    }
<a name="1279"></a>    
<a name="1280"></a>    
<a name="1281"></a>    /* 
<a name="1282"></a>     *   In addition to providing a mechanism to allow an actor to follow the
<a name="1283"></a>     *   player character around (above) we provide a few methods to enable the
<a name="1284"></a>     *   player character to follow an actor (below). We do this by having the
<a name="1285"></a>     *   the FOLLOW command set a fuse which, when it is triggered later on the
<a name="1286"></a>     *   same turn, attempts to make the player character follow the target
<a name="1287"></a>     *   actor either if the target actor has just moved away from the player
<a name="1288"></a>     *   character's current location later on the same turn as the FOLLOW
<a name="1289"></a>     *   command was issued or if the player character is in the location from
<a name="1290"></a>     *   which he last saw the target actor depart, in which case the player
<a name="1291"></a>     *   character attempts to traverse the TravelConnector through which s/he
<a name="1292"></a>     *   saw the actor depart.
<a name="1293"></a>     */
<a name="1294"></a>    
<a name="1295"></a>    /*   
<a name="1296"></a>     *   Set the fuse to enable travel later on the same turn if this actor
<a name="1297"></a>     *   travels in the meantime. This method is called when a FOLLOW command is
<a name="1298"></a>     *   issed with this actor as its direct object.
<a name="1299"></a>     */
<a name="1300"></a>    setFollowMeFuse()
<a name="1301"></a>    {
<a name="1302"></a>        /* reset the travel info */
<a name="1303"></a>        lastTravelInfo = nil;
<a name="1304"></a>        
<a name="1305"></a>        /* set up a new fuse */ 
<a name="1306"></a>        followFuseID = new Fuse(self, &amp;followFuse, 0);
<a name="1307"></a>        
<a name="1308"></a>        /* give it a low priority so any events that move the actor fire first */
<a name="1309"></a>        followFuseID.eventOrder = 100000;
<a name="1310"></a>        
<a name="1311"></a>        /* 
<a name="1312"></a>         *   Suppress the next paragraph break (otherwise we get an unnecessary
<a name="1313"></a>         *   blank line after a FOLLOW command)
<a name="1314"></a>         */
<a name="1315"></a>        "&lt;.p0&gt;";
<a name="1316"></a>    }
<a name="1317"></a>    
<a name="1318"></a>    /* 
<a name="1319"></a>     *   A note of our current following fuse, if we have one; this is used by
<a name="1320"></a>     *   FollowAgendaItem to check whether the player character is ready to
<a name="1321"></a>     *   follow us.
<a name="1322"></a>     */
<a name="1323"></a>    followFuseID = nil
<a name="1324"></a>    
<a name="1325"></a>    /*   
<a name="1326"></a>     *   This method is executed right at the end of a turn on which the player
<a name="1327"></a>     *   has issued a command to follow this actor, and carries out the travel
<a name="1328"></a>     *   to follow this actor if the actor has traveled.
<a name="1329"></a>     */
<a name="1330"></a>    followFuse()
<a name="1331"></a>    {
<a name="1332"></a>        /* 
<a name="1333"></a>         *   If we have information relating to this actor's last travel
<a name="1334"></a>         *   movements, then follow this actor.
<a name="1335"></a>         */
<a name="1336"></a>        if(lastTravelInfo)
<a name="1337"></a>        {
<a name="1338"></a>                        
<a name="1339"></a>            /* Display a message saying that we're following this actor. */
<a name="1340"></a>            sayActorFollowingMe(lastTravelInfo[2]);
<a name="1341"></a>            
<a name="1342"></a>            /* 
<a name="1343"></a>             *   Make the following actor travel via the TravelConnector last
<a name="1344"></a>             *   traversed by this actor.
<a name="1345"></a>             */
<a name="1346"></a>            lastTravelInfo[2].travelVia(gActor);
<a name="1347"></a>        }
<a name="1348"></a>        
<a name="1349"></a>        /* 
<a name="1350"></a>         *   Otherwise display a message saying that the actor hasn't moved, but
<a name="1351"></a>         *   only if the followAgendaItem hasn't already reported it.
<a name="1352"></a>         */
<a name="1353"></a>        else
<a name="1354"></a>        {
<a name="1355"></a>            if(followAgendaItem == nil 
<a name="1356"></a>               || followAgendaItem.travelBlockReported
<a name="1357"></a>               == nil)
<a name="1358"></a>            say(actorStaysPutMsg);
<a name="1359"></a>        }
<a name="1360"></a>        
<a name="1361"></a>        /* Reset the following fuse ID to nil */
<a name="1362"></a>        followFuseID = nil;
<a name="1363"></a>        
<a name="1364"></a>        /* 
<a name="1365"></a>         *   If we have a current FollowAgendaItem and it's finished with, note
<a name="1366"></a>         *   that we no longer have a current FollowAgendaItem.
<a name="1367"></a>         */
<a name="1368"></a>        if(followAgendaItem != nil &amp;&amp; followAgendaItem.isDone)
<a name="1369"></a>        {     
<a name="1370"></a>            /* Finally note that we've arrived at our destination */
<a name="1371"></a>            followAgendaItem.noteArrival();
<a name="1372"></a>            
<a name="1373"></a>            followAgendaItem = nil;
<a name="1374"></a>        }
<a name="1375"></a>    }
<a name="1376"></a>
<a name="1377"></a>    /* The message to display when another actor follows this one. */
<a name="1378"></a>    sayActorFollowingMe(conn)
<a name="1379"></a>    {       
<a name="1380"></a>        /* 
<a name="1381"></a>         *   If we have a current followAgendaItem, let it handle it in the
<a name="1382"></a>         *   first instance.
<a name="1383"></a>         */
<a name="1384"></a>        if(followAgendaItem != nil)
<a name="1385"></a>            followAgendaItem.sayDeparting(conn);
<a name="1386"></a>        
<a name="1387"></a>        /* Otherwise, let the connector handle it. */
<a name="1388"></a>        else                
<a name="1389"></a>            conn.sayActorFollowing(gActor, self);
<a name="1390"></a>    }
<a name="1391"></a>    
<a name="1392"></a>    followActorMsg = BMsg(follow actor, '{I} follow{s/ed} {1}. ', theName)
<a name="1393"></a>    
<a name="1394"></a>    /* 
<a name="1395"></a>     *   The message to display when this actor doesn't go anywhere when the
<a name="1396"></a>     *   player character tries to follow this actor.
<a name="1397"></a>     */
<a name="1398"></a>    actorStaysPutMsg = BMsg(actor stays put, '{I} wait{s/ed} in vain for {1} to
<a name="1399"></a>        go anywhere. ', theName)
<a name="1400"></a>    
<a name="1401"></a>    
<a name="1402"></a>    /* Our currently executing FollowAgendaItem, if we have one. */
<a name="1403"></a>    followAgendaItem = nil
<a name="1404"></a>    
<a name="1405"></a>    /* 
<a name="1406"></a>     *   Display a message describing this actor's departure via conn. This
<a name="1407"></a>     *   looks a bit circuitous in that this method calls the corresponding
<a name="1408"></a>     *   method on the current ActorState, which by default calls our own
<a name="1409"></a>     *   sayActorDeparting() method, which in turn calls sayDeparting on the
<a name="1410"></a>     *   connector; the idea is to allow customization at any point with the
<a name="1411"></a>     *   connector's sayDeparting() method simply providing a fallback to a
<a name="1412"></a>     *   colourless default. Note, however, that game code shouldn't normally
<a name="1413"></a>     *   override the actor's sayDeparting() method, but should instead
<a name="1414"></a>     *   intervene either on the ActorState or on the actor's
<a name="1415"></a>     *   sayActorDeparting() method. Note also that the purpose of this method
<a name="1416"></a>     *   is to describe an NPC's departure from the point of view of the player
<a name="1417"></a>     *   character, not to describe the player character's movements.
<a name="1418"></a>     */
<a name="1419"></a>    sayDeparting(conn)
<a name="1420"></a>    {
<a name="1421"></a>        /* If we have a current ActorState, call its sayDeparting() method */
<a name="1422"></a>        if(curState != nil)
<a name="1423"></a>            curState.sayDeparting(conn);
<a name="1424"></a>        
<a name="1425"></a>        /* Otherwise, call our own sayActorDeparting() method */
<a name="1426"></a>        else
<a name="1427"></a>            sayActorDeparting(conn);
<a name="1428"></a>    }
<a name="1429"></a>    
<a name="1430"></a>    /*  
<a name="1431"></a>     *   Method to display a message saying that this actor (normally an NPC
<a name="1432"></a>     *   visible to the player character) is departing via conn (a
<a name="1433"></a>     *   TravelConnector object, which may be a Room as well as a Door or other
<a name="1434"></a>     *   kind of connector). Note that the default behaviour of
<a name="1435"></a>     *   ActorState.sayDeparting is simply to call this method.
<a name="1436"></a>     */
<a name="1437"></a>    sayActorDeparting(conn)
<a name="1438"></a>    {
<a name="1439"></a>        /* 
<a name="1440"></a>         *   By default we let the connector describe the departure in a manner
<a name="1441"></a>         *   appropriate to the kind of connector it is.
<a name="1442"></a>         */
<a name="1443"></a>        conn.sayDeparting(self);
<a name="1444"></a>    }
<a name="1445"></a>    
<a name="1446"></a>    /* 
<a name="1447"></a>     *   This method is executed when this actor has just followed the player
<a name="1448"></a>     *   character to a new location.
<a name="1449"></a>     */
<a name="1450"></a>    arrivingTurn()
<a name="1451"></a>    {
<a name="1452"></a>        /* If we have a current ActorState, execute its arrivingTurn() method */
<a name="1453"></a>        if(curState != nil)
<a name="1454"></a>            curState.arrivingTurn();
<a name="1455"></a>        
<a name="1456"></a>        /* Otherwise execute our own actorArrivingTurn() method. */
<a name="1457"></a>        else
<a name="1458"></a>            actorArrivingTurn();
<a name="1459"></a>    }
<a name="1460"></a>    
<a name="1461"></a>    /* 
<a name="1462"></a>     *   This method is executed when this actor has just followed the player
<a name="1463"></a>     *   character to a new location and there is no current ActorState. By
<a name="1464"></a>     *   default we do nothing.
<a name="1465"></a>     */
<a name="1466"></a>    actorArrivingTurn() { }
<a name="1467"></a>        
<a name="1468"></a>    /* 
<a name="1469"></a>     *   The message to display when the player char sees this actor arriving
<a name="1470"></a>     *   after traveling from loc.
<a name="1471"></a>     */
<a name="1472"></a>    sayArriving(fromLoc)
<a name="1473"></a>    {
<a name="1474"></a>       /* If we have a current ActorState, call its sayArriving() method */
<a name="1475"></a>        if(curState != nil)
<a name="1476"></a>            curState.sayArriving(fromLoc);
<a name="1477"></a>        
<a name="1478"></a>        /* Otherwise, call our own sayActorArriving() method */
<a name="1479"></a>        else
<a name="1480"></a>            sayActorArriving(fromLoc);   
<a name="1481"></a>    }
<a name="1482"></a>    
<a name="1483"></a>    /* 
<a name="1484"></a>     *   Default message to display when the player character sees this actor
<a name="1485"></a>     *   arriving. We use a very plain-vanilla message here, since in practice
<a name="1486"></a>     *   game code will often want to override this.
<a name="1487"></a>     */
<a name="1488"></a>     sayActorArriving(fromLoc)
<a name="1489"></a>    {
<a name="1490"></a>        local traveler = self;
<a name="1491"></a>        gMessageParams(traveler);
<a name="1492"></a>        
<a name="1493"></a>        /* Attempt to get the director this actor arrived from. */
<a name="1494"></a>        local dir = getOutermostRoom.getDirectionTo(fromLoc);      
<a name="1495"></a>        
<a name="1496"></a>        /* If we find it, display a message saying we've arrived from that direction. */
<a name="1497"></a>        if(dir)
<a name="1498"></a>            DMsg(actor arriving from dir,
<a name="1499"></a>                 '{The subj traveler} arrive{s/d} from &lt;&lt;dir.arrivalName&gt;&gt;. ');
<a name="1500"></a>        
<a name="1501"></a>        /* Otherwise, just say the actor arrived in the player character's locatton. */
<a name="1502"></a>        else            
<a name="1503"></a>            DMsg(actor arriving, '{The subj traveler} arrive{s/d} in the area. ');
<a name="1504"></a>    }
<a name="1505"></a>    
<a name="1506"></a>    
<a name="1507"></a>    /* 
<a name="1508"></a>     *   Make this actor travel via the connector conn and report its departure.
<a name="1509"></a>     *   If announceArrival is true (the default) we also announce the actor's
<a name="1510"></a>     *   arrival (if it's visible to the player char).
<a name="1511"></a>     *
<a name="1512"></a>     *   To suppress the default arrival announcement altogether, supply the
<a name="1513"></a>     *   second optional parameter as nil. In some cases it may be easier to do
<a name="1514"></a>     *   this and supply your own custom arrival message after calling
<a name="1515"></a>     *   travelVia() than to juggle with the various sayArriving() methods.
<a name="1516"></a>     */     
<a name="1517"></a>    travelVia(conn, announceArrival = true)
<a name="1518"></a>    {
<a name="1519"></a>        local wasSeenLeaving = nil;
<a name="1520"></a>        local oldLoc = location;
<a name="1521"></a>        
<a name="1522"></a>        if(Q.canSee(gPlayerChar, self))
<a name="1523"></a>        {           
<a name="1524"></a>            /* Note that we were seen leaving. */
<a name="1525"></a>            wasSeenLeaving = true;
<a name="1526"></a>        }
<a name="1527"></a>
<a name="1528"></a>        /* 
<a name="1529"></a>         *   If the player character can see this actor, display a message
<a name="1530"></a>         *   indicating this player's departure.
<a name="1531"></a>         */        
<a name="1532"></a>        if(wasSeenLeaving)
<a name="1533"></a>            sayDeparting(conn);
<a name="1534"></a>        
<a name="1535"></a>        /* Move this actor via conn. */
<a name="1536"></a>        conn.travelVia(self);
<a name="1537"></a>        
<a name="1538"></a>        if(announceArrival &amp;&amp; !wasSeenLeaving &amp;&amp; Q.canSee(gPlayerChar, self))
<a name="1539"></a>            sayArriving(oldLoc);
<a name="1540"></a>    }
<a name="1541"></a>       
<a name="1542"></a>    /*  
<a name="1543"></a>     *   The takeTurn() method is called on every Actor every turn to carry out
<a name="1544"></a>     *   a number of housekeeping functions relating to the conversation and
<a name="1545"></a>     *   agenda item systems.
<a name="1546"></a>     */
<a name="1547"></a>    takeTurn()
<a name="1548"></a>    {      
<a name="1549"></a>        
<a name="1550"></a>        /* 
<a name="1551"></a>         *   First, if we're the current interlocutor, check that we can
<a name="1552"></a>         *   still talk to the player character. If not, make us no longer the
<a name="1553"></a>         *   current interlocutor so we don't respond to conversational commands
<a name="1554"></a>         *   when we're no longer there.
<a name="1555"></a>         */        
<a name="1556"></a>        if(gPlayerChar.currentInterlocutor == self &amp;&amp; 
<a name="1557"></a>           !canTalkTo(gPlayerChar))
<a name="1558"></a>        {
<a name="1559"></a>            /* Reset the player character's current interlocutor to nil */
<a name="1560"></a>            gPlayerChar.currentInterlocutor = nil;
<a name="1561"></a>            
<a name="1562"></a>            /* 
<a name="1563"></a>             *   Reset our active and pending conversation keys so we don't
<a name="1564"></a>             *   behave as if we were still in an active conversation node.
<a name="1565"></a>             */
<a name="1566"></a>            activeKeys = [];
<a name="1567"></a>            pendingKeys = [];
<a name="1568"></a>            
<a name="1569"></a>            /* Terminate the method there; we've done enough for this turn. */
<a name="1570"></a>            return;
<a name="1571"></a>        }
<a name="1572"></a>        
<a name="1573"></a>        /*  
<a name="1574"></a>         *   Next, if we haven't already conversed this turn, and we have active
<a name="1575"></a>         *   conversation keys (meaning that we might be in a Conversation
<a name="1576"></a>         *   Node), try executing the NodeContinuationTopic associated with our
<a name="1577"></a>         *   current node (this can be used to nudge the player's memory that
<a name="1578"></a>         *   we're expecting an answer to a question we've just asked). If we
<a name="1579"></a>         *   find one and execute it, end there.
<a name="1580"></a>         */
<a name="1581"></a>        if(!conversedThisTurn &amp;&amp; activeKeys.length &gt; 0 &amp;&amp; canTalkTo(gPlayerChar) &amp;&amp;             
<a name="1582"></a>           initiateTopic(nodeObj))
<a name="1583"></a>                        return;
<a name="1584"></a>        
<a name="1585"></a>        
<a name="1586"></a>        /* 
<a name="1587"></a>         *   Next, if we haven't conversed this turn, try executing our highest
<a name="1588"></a>         *   priority AgendaItem, if we have one.
<a name="1589"></a>         */
<a name="1590"></a>        if(!conversedThisTurn &amp;&amp; !executeAgenda)
<a name="1591"></a>        {
<a name="1592"></a>            /* 
<a name="1593"></a>             *   If we haven't conversed this turn and we didn't find an
<a name="1594"></a>             *   AgendaItem to execute, then, if we have a current ActorState
<a name="1595"></a>             *   that's been mixed in with a Script class (typically some kind
<a name="1596"></a>             *   of EventList), execute our current ActorState's curScript
<a name="1597"></a>             *   method, provided the player character can see us. This allows
<a name="1598"></a>             *   an ActorState to display a series of 'fidget messages' or the
<a name="1599"></a>             *   like for an actor who hasn't otherwise done anything this turn.
<a name="1600"></a>             */
<a name="1601"></a>            if(curState != nil &amp;&amp; curState.ofKind(Script) 
<a name="1602"></a>               &amp;&amp; Q.canSee(gPlayerChar, self))
<a name="1603"></a>                curState.doScript();
<a name="1604"></a>        }
<a name="1605"></a>        
<a name="1606"></a>        /* 
<a name="1607"></a>         *   If we haven't conversed this term and we're meant to be in
<a name="1608"></a>         *   conversation with the player character, increment our boredomCount
<a name="1609"></a>         *   by one; this may eventually lead to this actor terminating the
<a name="1610"></a>         *   conversation of its own accord.
<a name="1611"></a>         */
<a name="1612"></a>        if(!conversedThisTurn &amp;&amp; gActor.currentInterlocutor == self)        
<a name="1613"></a>            boredomCount++;
<a name="1614"></a>            
<a name="1615"></a>        /*  Otherwise reset the boredomCount to zero */
<a name="1616"></a>        else
<a name="1617"></a>            boredomCount = 0;           
<a name="1618"></a>    }
<a name="1619"></a>    
<a name="1620"></a>    
<a name="1621"></a>    
<a name="1622"></a>    /* 
<a name="1623"></a>     *   our special "boredom" agenda item - this makes us initiate an end
<a name="1624"></a>     *   to an active conversation when the PC has ignored us for a given
<a name="1625"></a>     *   number of consecutive turns 
<a name="1626"></a>     */
<a name="1627"></a>    boredomAgendaItem = perInstance(new BoredomAgendaItem(self))
<a name="1628"></a>
<a name="1629"></a>    
<a name="1630"></a>    /* 
<a name="1631"></a>     *   If this is non-nil then a TOPICS command will use it to restrict the
<a name="1632"></a>     *   topics suggested to those with this key in their convKeys property.
<a name="1633"></a>     *   This could be used, for example, to provide a top-level 'menu' of
<a name="1634"></a>     *   topics when the full list would otherwise be overwhelming.
<a name="1635"></a>     */
<a name="1636"></a>    suggestionKey = nil
<a name="1637"></a>
<a name="1638"></a>    /* 
<a name="1639"></a>     *   Show a list of topics the player character might want to discuss with
<a name="1640"></a>     *   this actor. The explicit flag is true if the player has explicitly
<a name="1641"></a>     *   requested the topic list via a TOPICS command. The tag parameter can be
<a name="1642"></a>     *   a single convKey tag or a list of convKey tags; if tag is nil or 'all'
<a name="1643"></a>     *   then we don't restrict the suggestions by tag, otherwise we restrict
<a name="1644"></a>     *   the suggestions to those that match the tag (or one of the tags in the
<a name="1645"></a>     *   list of tags).
<a name="1646"></a>     */
<a name="1647"></a>    showSuggestions(explicit = true, tag = (pendingKeys == [] ? suggestionKey
<a name="1648"></a>                                            : pendingKeys))
<a name="1649"></a>    {
<a name="1650"></a>        /* 
<a name="1651"></a>         *   Start by creating a list of listable topics (i.e. those topics that
<a name="1652"></a>         *   could be reached by a conversational command issued by the player
<a name="1653"></a>         *   on the next turn)
<a name="1654"></a>         */
<a name="1655"></a>        local lst = listableTopics;
<a name="1656"></a>        
<a name="1657"></a>        /* 
<a name="1658"></a>         *   If we have a current ActorState, add its listableTopics to our
<a name="1659"></a>         *   list.
<a name="1660"></a>         */
<a name="1661"></a>        if(curState != nil)
<a name="1662"></a>            lst += curState.listableTopics;
<a name="1663"></a>        
<a name="1664"></a>        /* 
<a name="1665"></a>         *   If the tag parameter has been passed as a list, then for each tag
<a name="1666"></a>         *   in the list find all the matching TopicEntries, then find the
<a name="1667"></a>         *   intersect of all the listable TopicEntries with those that match
<a name="1668"></a>         *   all the tags.
<a name="1669"></a>         */
<a name="1670"></a>        if(dataType(tag) == TypeList)
<a name="1671"></a>        {
<a name="1672"></a>            /* Create a new empty Vector */
<a name="1673"></a>            local vec = new Vector(10);
<a name="1674"></a>            
<a name="1675"></a>            /* 
<a name="1676"></a>             *   Go through each tag in our list, looking it up in our
<a name="1677"></a>             *   convKeyTab table and adding all the corresponding TopicEntries
<a name="1678"></a>             *   (that match the tag) to our Vector.
<a name="1679"></a>             */
<a name="1680"></a>            foreach(local t in tag)
<a name="1681"></a>            {
<a name="1682"></a>                vec.appendUnique(valToList(convKeyTab[t]));
<a name="1683"></a>            }
<a name="1684"></a>            
<a name="1685"></a>            /* 
<a name="1686"></a>             *   Restrict our list of TopicEntries to those that are also found
<a name="1687"></a>             *   in the Vector of TopicEntries that match one of our tags.
<a name="1688"></a>             */
<a name="1689"></a>            lst = lst.intersect(vec.toList());    
<a name="1690"></a>        }
<a name="1691"></a>        
<a name="1692"></a>        /* 
<a name="1693"></a>         *   Otherwise, if the tag parameter is supplied, use it to provide a
<a name="1694"></a>         *   sublist of only those topics with a convKeys property matching the
<a name="1695"></a>         *   tag. A tag of 'all' is treated as a special value to allow a
<a name="1696"></a>         *   &lt;.suggest all&gt; tag to list all available special topics.
<a name="1697"></a>         */
<a name="1698"></a>        else if(tag not in (nil, 'all'))
<a name="1699"></a>            lst = lst.intersect(valToList(convKeyTab[tag]));
<a name="1700"></a> 
<a name="1701"></a>        /* 
<a name="1702"></a>         *   Use the suggestedTopicLister to show a list of Suggested Topics
<a name="1703"></a>         *   from the resulting list (lst).
<a name="1704"></a>         */
<a name="1705"></a>        suggestedTopicLister.show(lst, explicit);            
<a name="1706"></a>        
<a name="1707"></a>    }
<a name="1708"></a>    
<a name="1709"></a>        
<a name="1710"></a>     /* 
<a name="1711"></a>      *   A Lookup Table holding conversation keys. Entries in this list take
<a name="1712"></a>      *   the form tag -&gt; list of TopicEntries that match this tag (e.g. the key
<a name="1713"></a>      *   is a convKey tag, expressed as a single-quoted string, and the value
<a name="1714"></a>      *   is a list containing TopicEntries whose convKeys property contains
<a name="1715"></a>      *   that tag).
<a name="1716"></a>      */      
<a name="1717"></a>    convKeyTab = nil
<a name="1718"></a>    
<a name="1719"></a>    /* 
<a name="1720"></a>     *   Set the curiosityAroused flag to true for all topic entries with this
<a name="1721"></a>     *   convKey. This allows topics to be suggested when and only when the
<a name="1722"></a>     *   player character has some reason to be curious about them, even though
<a name="1723"></a>     *   they were actually available before.
<a name="1724"></a>     */
<a name="1725"></a>    arouse(key, stat=true)
<a name="1726"></a>    {
<a name="1727"></a>        /* 
<a name="1728"></a>         *   First check that we actually have any entries in our convKeyTab
<a name="1729"></a>         *   before we attempt to use them.
<a name="1730"></a>         */
<a name="1731"></a>        if(convKeyTab != nil)
<a name="1732"></a>            /* 
<a name="1733"></a>             *   If we do then go through every TopicEntry that has key amongst
<a name="1734"></a>             *   its convKeys (which we can obtain by looking up the list of suh
<a name="1735"></a>             *   TopicEntries in our convKeysTab) and set its curiosityAroused
<a name="1736"></a>             *   property to stat.
<a name="1737"></a>             */
<a name="1738"></a>            foreach(local cur in valToList(convKeyTab[key]))
<a name="1739"></a>        {
<a name="1740"></a>            cur.curiosityAroused = stat;
<a name="1741"></a>        }
<a name="1742"></a>    }
<a name="1743"></a>    
<a name="1744"></a>    /* 
<a name="1745"></a>     *   Set the activated flag to true for all topic entries with this convKey.
<a name="1746"></a>     *  
<a name="1747"></a>     */    
<a name="1748"></a>    makeActivated(key)    
<a name="1749"></a>    {
<a name="1750"></a>        /* 
<a name="1751"></a>         *   First check that we actually have any entries in our convKeyTab
<a name="1752"></a>         *   before we attempt to use them.
<a name="1753"></a>         */
<a name="1754"></a>        if(convKeyTab != nil)
<a name="1755"></a>        {
<a name="1756"></a>            /* 
<a name="1757"></a>             *   If we do then go through every TopicEntry that has key amongst
<a name="1758"></a>             *   its convKeys (which we can obtain by looking up the list of suh
<a name="1759"></a>             *   TopicEntries in our convKeysTab) and set its activated property
<a name="1760"></a>             *   to true.
<a name="1761"></a>             */
<a name="1762"></a>            foreach(local cur in valToList(convKeyTab[key]))
<a name="1763"></a>                cur.activate();
<a name="1764"></a>        }
<a name="1765"></a>    }
<a name="1766"></a>    
<a name="1767"></a>    
<a name="1768"></a>    /* 
<a name="1769"></a>     *   Set the activated flag to nil for all topic entries with this convKey.
<a name="1770"></a>     *  
<a name="1771"></a>     */    
<a name="1772"></a>    makeDeactivated(key)    
<a name="1773"></a>    {
<a name="1774"></a>        /* 
<a name="1775"></a>         *   First check that we actually have any entries in our convKeyTab
<a name="1776"></a>         *   before we attempt to use them.
<a name="1777"></a>         */
<a name="1778"></a>        if(convKeyTab != nil)
<a name="1779"></a>        {
<a name="1780"></a>            /* 
<a name="1781"></a>             *   If we do then go through every TopicEntry that has key amongst
<a name="1782"></a>             *   its convKeys (which we can obtain by looking up the list of suh
<a name="1783"></a>             *   TopicEntries in our convKeysTab) and set its activated property
<a name="1784"></a>             *   to nil.
<a name="1785"></a>             */
<a name="1786"></a>            foreach(local cur in valToList(convKeyTab[key]))
<a name="1787"></a>                cur.deactivate();
<a name="1788"></a>        }
<a name="1789"></a>    }
<a name="1790"></a>    
<a name="1791"></a>    /* 
<a name="1792"></a>     *   A list of all ConvNodes associated with this actor. This is a list of
<a name="1793"></a>     *   two element lists of the form [node-name, node-obj] where node-name is
<a name="1794"></a>     *   the convKeys property of the node and node is the associated object.
<a name="1795"></a>     */
<a name="1796"></a>    allNodes = []
<a name="1797"></a>        
<a name="1798"></a>    
<a name="1799"></a>    /* 
<a name="1800"></a>     *   Service method used by curNodeKey() and curNodeObj() to identify the
<a name="1801"></a>     *   current ConvNode object, if there is one.
<a name="1802"></a>     */
<a name="1803"></a>    curNodeIdx()
<a name="1804"></a>    {
<a name="1805"></a>        /* 
<a name="1806"></a>         *   If we have a current ConvNode, it will be the one specified by the
<a name="1807"></a>         *   first element in our activeKeys list.
<a name="1808"></a>         */
<a name="1809"></a>        local node = activeKeys.element(1);
<a name="1810"></a>        
<a name="1811"></a>        /*   If we don't have any activeKeys, then we don't have a ConvNode */
<a name="1812"></a>        if(node == nil)
<a name="1813"></a>            return nil;
<a name="1814"></a>        
<a name="1815"></a>        /*  
<a name="1816"></a>         *   The first activeKey may not be a ConvNode, so look it up in our
<a name="1817"></a>         *   list of ConvNodes (allNodes) to see if it's there and return its
<a name="1818"></a>         *   place in the list.
<a name="1819"></a>         */
<a name="1820"></a>        return allNodes.indexWhich({n: n[1] == node});
<a name="1821"></a>    }
<a name="1822"></a>    
<a name="1823"></a>    /*   The string name of our current convNode, if we have one. */
<a name="1824"></a>    curNodeKey()
<a name="1825"></a>    {
<a name="1826"></a>        /* 
<a name="1827"></a>         *   Get the index within allNodes of our current ConvNode, if there is
<a name="1828"></a>         *   one.
<a name="1829"></a>         */
<a name="1830"></a>        local idx = curNodeIdx;
<a name="1831"></a>        
<a name="1832"></a>        /*   
<a name="1833"></a>         *   If we found an index, return the key (first) element of the
<a name="1834"></a>         *   corresponding item in our allNodes list. Otherwise return nil.
<a name="1835"></a>         */
<a name="1836"></a>        return idx == nil ? nil : allNodes[idx][1];
<a name="1837"></a>    }
<a name="1838"></a>    
<a name="1839"></a>    /*   The object representing our current convNode, if we have one. */
<a name="1840"></a>    curNodeObj()
<a name="1841"></a>    {
<a name="1842"></a>        /* 
<a name="1843"></a>         *   Get the index within allNodes of our current ConvNode, if there is
<a name="1844"></a>         *   one.
<a name="1845"></a>         */
<a name="1846"></a>        local idx = curNodeIdx;
<a name="1847"></a>        
<a name="1848"></a>        /*   
<a name="1849"></a>         *   If we found an index, return the object (second) element of the
<a name="1850"></a>         *   corresponding item in our allNodes list. Otherwise return nil.
<a name="1851"></a>         */
<a name="1852"></a>        return idx == nil ? nil : allNodes[idx][2];
<a name="1853"></a>    }
<a name="1854"></a>    
<a name="1855"></a>    
<a name="1856"></a>    
<a name="1857"></a>    /* 
<a name="1858"></a>     *   We supply a getActor method that returns self so that objects such as
<a name="1859"></a>     *   TopicEntries that may be located either directly or indirectly in us
<a name="1860"></a>     *   can get at their associated actor by simply calling getActor on their
<a name="1861"></a>     *   immediate location; at some point such a chain of calls to
<a name="1862"></a>     *   location.getActor will end here.
<a name="1863"></a>     */    
<a name="1864"></a>    getActor { return self; }
<a name="1865"></a>    
<a name="1866"></a>    /*   
<a name="1867"></a>     *   The count of how many turns have passed during which no conversation
<a name="1868"></a>     *   has actually taken place when we're the player charater's current
<a name="1869"></a>     *   interlocutor. This can be used to terminate the conversation through
<a name="1870"></a>     *   'boredom' if the boredomCount exceeds our attention span.
<a name="1871"></a>     */
<a name="1872"></a>    boredomCount = 0
<a name="1873"></a>    
<a name="1874"></a>    
<a name="1875"></a>    /*  
<a name="1876"></a>     *   The maximum value that our boredomCount can reach before we terminate a
<a name="1877"></a>     *   conversation through 'boredom', because we've given up waiting for the
<a name="1878"></a>     *   player character to say anything. A value of nil (the default) meanns
<a name="1879"></a>     *   that we never terminate a conversation for this reason.
<a name="1880"></a>     */
<a name="1881"></a>    attentionSpan = nil
<a name="1882"></a>    
<a name="1883"></a>    
<a name="1884"></a>    
<a name="1885"></a>    /*  
<a name="1886"></a>     *   Should other actors who can notionally hear the PC talking to us
<a name="1887"></a>     *   overhear when information is imparted to us? I.e. should their
<a name="1888"></a>     *   setInform() methods be called too? If we have a curState we use its
<a name="1889"></a>     *   setting, otherwise we use the value of actorInformOverheard.
<a name="1890"></a>     */
<a name="1891"></a>    informOverheard = (curState == nil ? actorInformOverheard :
<a name="1892"></a>    curState.informOverheard)
<a name="1893"></a>    
<a name="1894"></a>    /*  
<a name="1895"></a>     *   Should other actors who can notionally hear the PC talking to us
<a name="1896"></a>     *   overhear when information is imparted to us when our current ActorState
<a name="1897"></a>     *   is nil? By default they should.
<a name="1898"></a>     */
<a name="1899"></a>    actorInformOverheard =  true
<a name="1900"></a>
<a name="1901"></a>
<a name="1902"></a>    /* 
<a name="1903"></a>     *   Say hello to the actor (when the greeting is initiated by the player
<a name="1904"></a>     *   character)
<a name="1905"></a>     */
<a name="1906"></a>    sayHello()
<a name="1907"></a>    {
<a name="1908"></a>        /* 
<a name="1909"></a>         *   Only carry out the  full greeting if we're not already the player
<a name="1910"></a>         *   character's current interlocutor.
<a name="1911"></a>         */
<a name="1912"></a>        if(gPlayerChar.currentInterlocutor != self)
<a name="1913"></a>        {
<a name="1914"></a>            /* 
<a name="1915"></a>             *   Note that we are now the player character's current
<a name="1916"></a>             *   interlocutor
<a name="1917"></a>             */
<a name="1918"></a>            gPlayerChar.currentInterlocutor = self;
<a name="1919"></a>            
<a name="1920"></a>            /*  Look for an appropriate HelloTopic to handle the greeting. */
<a name="1921"></a>            handleTopic(&amp;miscTopics, [expHelloTopicObj], &amp;noHelloResponseMsg);
<a name="1922"></a>        }
<a name="1923"></a>        /* 
<a name="1924"></a>         *   Otherwise display a message to say that we're already talking to
<a name="1925"></a>         *   this actor.
<a name="1926"></a>         */
<a name="1927"></a>        else            
<a name="1928"></a>            condSay(alreadyTalkingMsg);
<a name="1929"></a>        
<a name="1930"></a>        /* Add a paragraph break */
<a name="1931"></a>        "&lt;.p&gt;";
<a name="1932"></a>        
<a name="1933"></a>        /* Display a list of not-explicitly-asked-for topic suggestions */
<a name="1934"></a>        if(autoSuggest)
<a name="1935"></a>            showSuggestions(nil, suggestionKey);
<a name="1936"></a>    }
<a name="1937"></a>    
<a name="1938"></a>    /* 
<a name="1939"></a>     *   Flag - do we want to show a list of sugegsted topics in response to a TALK TO command. By
<a name="1940"></a>     *   default we let our current ActorState decide.
<a name="1941"></a>     */
<a name="1942"></a>    autoSuggest = curState ? curState.autoSuggest : true
<a name="1943"></a>    
<a name="1944"></a>    /* Have the actor greet the player character on the actor's initiative */
<a name="1945"></a>    actorSayHello()    
<a name="1946"></a>    {
<a name="1947"></a>        /* 
<a name="1948"></a>         *   First check that we're not already the player character's current
<a name="1949"></a>         *   interlocutor before issuing a greeting.
<a name="1950"></a>         */
<a name="1951"></a>        if(gPlayerChar.currentInterlocutor != self)
<a name="1952"></a>        {
<a name="1953"></a>            /* 
<a name="1954"></a>             *   Note that we have conversed with the player character on this
<a name="1955"></a>             *   turn.
<a name="1956"></a>             */
<a name="1957"></a>            noteConversed();
<a name="1958"></a>            
<a name="1959"></a>            /*  
<a name="1960"></a>             *   Find an appropriate ActorHelloTopic to handle the greeting; if
<a name="1961"></a>             *   we don't find one, use our nil Response (i.e., don't display
<a name="1962"></a>             *   anything)
<a name="1963"></a>             */
<a name="1964"></a>            return handleTopic(&amp;miscTopics, [actorHelloTopicObj], nil);
<a name="1965"></a>        }       
<a name="1966"></a>        
<a name="1967"></a>        /* Return nil to signal we didn't actually do anything */
<a name="1968"></a>        return nil;
<a name="1969"></a>    }
<a name="1970"></a>    
<a name="1971"></a>    /* 
<a name="1972"></a>     *   Say goodbye to this actor (farewell from the player character). The
<a name="1973"></a>     *   optional reason parameter is the reason we're saying goodbye, which
<a name="1974"></a>     *   defaults to endConvBye (i.e. the player character saying goodbye)
<a name="1975"></a>     */
<a name="1976"></a>    sayGoodbye(reason = endConvBye)
<a name="1977"></a>    {
<a name="1978"></a>        /* 
<a name="1979"></a>         *   If we've not the player character's current interlocutor and the
<a name="1980"></a>         *   player character tries to say goodbye to us, display a message
<a name="1981"></a>         *   saying that the player character isn't talking to us.
<a name="1982"></a>         */
<a name="1983"></a>        if(gPlayerChar.currentInterlocutor != self &amp;&amp; reason == endConvBye)
<a name="1984"></a>        {
<a name="1985"></a>            DMsg(not interlocutor, '{I}{\'m} not talking to {1}. ', theName);
<a name="1986"></a>        }        
<a name="1987"></a>        else
<a name="1988"></a>        {
<a name="1989"></a>            /* 
<a name="1990"></a>             *   Otherwise find the appropriate kind of ByeTopic to handle the
<a name="1991"></a>             *   farewell, which will vary according to the reason for the
<a name="1992"></a>             *   farewell.
<a name="1993"></a>             */
<a name="1994"></a>            handleTopic(&amp;miscTopics, [reason], 
<a name="1995"></a>                        reason == endConvBye ? &amp;noGoodbyeResponseMsg : nil);
<a name="1996"></a>            
<a name="1997"></a>            /* 
<a name="1998"></a>             *   Then note that we are no longer in conversation with the player
<a name="1999"></a>             *   character.
<a name="2000"></a>             */
<a name="2001"></a>            gPlayerChar.currentInterlocutor = nil;
<a name="2002"></a>        }
<a name="2003"></a>    }
<a name="2004"></a>    
<a name="2005"></a>    /* 
<a name="2006"></a>     *   The message to display when someone says hello to this actor but
<a name="2007"></a>     *   there's no accessible HelloTopic defined.
<a name="2008"></a>     */
<a name="2009"></a>   
<a name="2010"></a>    noHelloResponseMsg = BMsg(no hello response, '{I} now {have} {1} attention.
<a name="2011"></a>        ', possAdj)
<a name="2012"></a>    
<a name="2013"></a>    alreadyTalkingMsg = BMsg(already talking, '{I} {am} already talking to {1}.
<a name="2014"></a>        ', theName)
<a name="2015"></a>    
<a name="2016"></a>    noGoodbyeResponseMsg = BMsg(no goodbye response, 'The conversation{dummy}
<a name="2017"></a>        {is} ended. ')
<a name="2018"></a>    
<a name="2019"></a>    
<a name="2020"></a>    /* Do nothing if we can't fine a suitable Hello or Bye Topic/ */    
<a name="2021"></a>    nilResponse() { }
<a name="2022"></a>    
<a name="2023"></a>    /* 
<a name="2024"></a>     *   A list of all the ActorStates associated with this Actor; this is
<a name="2025"></a>     *   populated by the preinitialization of the individual ActorStates.
<a name="2026"></a>     */
<a name="2027"></a>    allStates = []
<a name="2028"></a>    
<a name="2029"></a>    /* 
<a name="2030"></a>     *   Is this actor ready to invoke a ConvAgendaItem? We're ready if we
<a name="2031"></a>     *   haven't conversed this term and we can speak to the other actor and
<a name="2032"></a>     *   we're not at a conversation node. This method is used by the isReady
<a name="2033"></a>     *   property of ConvAgendaItem (to save it having to make three separate
<a name="2034"></a>     *   calls to getActor).
<a name="2035"></a>     */
<a name="2036"></a>    
<a name="2037"></a>    convAgendaReady(other)
<a name="2038"></a>    {
<a name="2039"></a>        return !conversedThisTurn &amp;&amp; canTalkTo(other) &amp;&amp; activeKeys.length == 0;
<a name="2040"></a>    }
<a name="2041"></a>    
<a name="2042"></a>    
<a name="2043"></a>    /* Convenience methods for adding agenda items */
<a name="2044"></a>    
<a name="2045"></a>    /* 
<a name="2046"></a>     *   Add an agenda item to both myself and any DefaultAgendaTopic directly
<a name="2047"></a>     *   within me.
<a name="2048"></a>     */    
<a name="2049"></a>    addToBothAgendas([lst])
<a name="2050"></a>    {
<a name="2051"></a>        addToAgenda(lst...);
<a name="2052"></a>        if(defaultAgendaTopic != nil)
<a name="2053"></a>            defaultAgendaTopic.addToAgenda(lst...);
<a name="2054"></a>    }
<a name="2055"></a>    
<a name="2056"></a>    /* 
<a name="2057"></a>     *   Add an agenda item both to myself and to any DefaultAgendaTopics either
<a name="2058"></a>     *   directly in me or in any of my Actor States
<a name="2059"></a>     */    
<a name="2060"></a>    addToAllAgendas([lst])
<a name="2061"></a>    {
<a name="2062"></a>        addToBothAgendas(lst...);
<a name="2063"></a>        foreach(local state in allStates)
<a name="2064"></a>        {
<a name="2065"></a>            if(state.defaultAgendaTopic != nil)
<a name="2066"></a>                state.defaultAgendaTopic.addToAgenda(lst...);
<a name="2067"></a>        }      
<a name="2068"></a>    }
<a name="2069"></a>    
<a name="2070"></a>    /* 
<a name="2071"></a>     *   Add an agenda item to myself and to any DefaultAgendaTopios directly in
<a name="2072"></a>     *   me or in my current ActorState.
<a name="2073"></a>     */    
<a name="2074"></a>    addToCurAgendas([lst])
<a name="2075"></a>    {
<a name="2076"></a>        addToBothAgendas(lst...);
<a name="2077"></a>        if(curState != nil &amp;&amp; curState.defaultAgendaTopic != nil)
<a name="2078"></a>            curState.defaultAgendaTopic.addToAgenda(lst...);
<a name="2079"></a>    }
<a name="2080"></a>    
<a name="2081"></a>    /*  
<a name="2082"></a>     *   Remove an agenda Item both from this actor and from any associated
<a name="2083"></a>     *   DefaultAgendaTopics directly within this actor.
<a name="2084"></a>     */
<a name="2085"></a>    removeFromBothAgendas([lst])
<a name="2086"></a>    {
<a name="2087"></a>        removeFromAgenda(lst...);
<a name="2088"></a>        if(defaultAgendaTopic != nil)
<a name="2089"></a>            defaultAgendaTopic.removeFromAgenda(lst...);
<a name="2090"></a>    }
<a name="2091"></a>    
<a name="2092"></a>    /*  
<a name="2093"></a>     *   Remove an agenda Item both from this actor and from any associated
<a name="2094"></a>     *   DefaultAgendaTopics directly within this actor or in any of its
<a name="2095"></a>     *   ActorStates.
<a name="2096"></a>     */
<a name="2097"></a>    removeFromAllAgendas([lst])
<a name="2098"></a>    {
<a name="2099"></a>        removeFromBothAgendas(lst...);
<a name="2100"></a>        foreach(local state in allStates)
<a name="2101"></a>        {
<a name="2102"></a>            if(state.defaultAgendaTopic != nil)
<a name="2103"></a>                state.defaultAgendaTopic.removeFromAgenda(lst...);
<a name="2104"></a>        }      
<a name="2105"></a>    }
<a name="2106"></a>    
<a name="2107"></a>    /* 
<a name="2108"></a>     *   Remove an agenda item from myself and from any DefaultAgendaTopios
<a name="2109"></a>     *   directly in me or in my current ActorState.
<a name="2110"></a>     */
<a name="2111"></a>    removeFromCurAgendas([lst])
<a name="2112"></a>    {
<a name="2113"></a>        removeFromBothAgendas(lst...);
<a name="2114"></a>        if(curState != nil &amp;&amp; curState.defaultAgendaTopic != nil)
<a name="2115"></a>            curState.defaultAgendaTopic.removeFromAgenda(lst...);
<a name="2116"></a>    }
<a name="2117"></a>    
<a name="2118"></a>    /* 
<a name="2119"></a>     *   A list of agenda items to be added to our agenda at some later point.
<a name="2120"></a>     *   The main purpose is to allow game code to set up a list of AgendaItems
<a name="2121"></a>     *   (typically ConvAgendaItems) that become part of the actor's current
<a name="2122"></a>     *   agenda when conversation is initiated via a HelloTopic.
<a name="2123"></a>     */    
<a name="2124"></a>    pendingAgendaList = []
<a name="2125"></a>    
<a name="2126"></a>    /* Add an item to our pending agenda list */    
<a name="2127"></a>    addToPendingAgenda([lst])
<a name="2128"></a>    {
<a name="2129"></a>        foreach(local item in lst)
<a name="2130"></a>        {
<a name="2131"></a>            if(checkAgenda(item))
<a name="2132"></a>                pendingAgendaList += item;
<a name="2133"></a>        }
<a name="2134"></a>    }
<a name="2135"></a>    
<a name="2136"></a>    /* 
<a name="2137"></a>     *   Make our pending agenda items acting by moving them all from our
<a name="2138"></a>     *   pendingAgendaList to all our actual agenda lists (on the actor and on
<a name="2139"></a>     *   all our DefaultAgendaItems).
<a name="2140"></a>     */
<a name="2141"></a>    activatePendingAgenda()
<a name="2142"></a>    {
<a name="2143"></a>        foreach(local cur in pendingAgendaList)
<a name="2144"></a>            addToAllAgendas(cur);
<a name="2145"></a>        
<a name="2146"></a>        pendingAgendaList = [];
<a name="2147"></a>    }
<a name="2148"></a>    
<a name="2149"></a>    /*  Remove one or more agenda items from our pending agenda */
<a name="2150"></a>    removeFromPendingAgenda([lst])
<a name="2151"></a>    {
<a name="2152"></a>        foreach(local item in lst)
<a name="2153"></a>            pendingAgendaList -= item;
<a name="2154"></a>    }
<a name="2155"></a>      
<a name="2156"></a>    
<a name="2157"></a>    /*  
<a name="2158"></a>     *   Respond to an InitiateTopic triggered on this actor with top as the
<a name="2159"></a>     *   matching object
<a name="2160"></a>     */
<a name="2161"></a>    initiateTopic(top)
<a name="2162"></a>    {        
<a name="2163"></a>        /* 
<a name="2164"></a>         *   Try our current actor state first, if we have one, and only if it
<a name="2165"></a>         *   fails to find a response try handling the initiateTopic on the
<a name="2166"></a>         *   actor.
<a name="2167"></a>         */
<a name="2168"></a>        if(curState != nil &amp;&amp; curState.initiateTopic(top))
<a name="2169"></a>            return true;
<a name="2170"></a>        
<a name="2171"></a>        return inherited(top);
<a name="2172"></a>    }
<a name="2173"></a>    
<a name="2174"></a>    /* 
<a name="2175"></a>     *   The notifyRemove() method is triggered when actionMoveInto() tries to
<a name="2176"></a>     *   move an object that's located within this actor. By default we don't
<a name="2177"></a>     *   allow it since it typically represents an attempt by the player
<a name="2178"></a>     *   character to take something from this actor's inventory.
<a name="2179"></a>     */
<a name="2180"></a>    checkRemove(obj)
<a name="2181"></a>    {
<a name="2182"></a>        /* 
<a name="2183"></a>         *   If we're not the actor initiating the moving of obj and we don't
<a name="2184"></a>         *   allow this object to be removed from us, prevent the move.
<a name="2185"></a>         */
<a name="2186"></a>        
<a name="2187"></a>        if(gActor != self &amp;&amp; !allowOtherActorToTake(obj))
<a name="2188"></a>        {         
<a name="2189"></a>           
<a name="2190"></a>            /* Display a message saying that removing obj is disallowed. */
<a name="2191"></a>            say(cannotTakeFromActorMsg(obj));
<a name="2192"></a>                        
<a name="2193"></a>            /* Halt the action. */
<a name="2194"></a>            exit;
<a name="2195"></a>        }    
<a name="2196"></a>        
<a name="2197"></a>        inherited(obj);
<a name="2198"></a>    }
<a name="2199"></a>    
<a name="2200"></a>    /* 
<a name="2201"></a>     *   Return a message saying that the actor cannot take obj from our
<a name="2202"></a>     *   inventory.
<a name="2203"></a>     */
<a name="2204"></a>    cannotTakeFromActorMsg(obj)
<a name="2205"></a>    {
<a name="2206"></a>        /* 
<a name="2207"></a>         *   Set up a convenient pair of message substitution parameters to use
<a name="2208"></a>         *   in the mesage.
<a name="2209"></a>         */
<a name="2210"></a>        local this = self;
<a name="2211"></a>        gMessageParams(obj, this);
<a name="2212"></a>               
<a name="2213"></a>        /* Return the text of the message. */
<a name="2214"></a>        return BMsg(cannot take from actor, '{The subj this} {won\'t} let {me}
<a name="2215"></a>            have {the obj} while {he obj}{\'s} in {her this} possession. ');
<a name="2216"></a>    }
<a name="2217"></a>    
<a name="2218"></a>    /* 
<a name="2219"></a>     *   Is another actor allowed to take obj from our inventory? By default we
<a name="2220"></a>     *   return nil to disallow it for all objects.
<a name="2221"></a>     */
<a name="2222"></a>    allowOtherActorToTake(obj) { return nil; }
<a name="2223"></a>    
<a name="2224"></a>    /* An actor generally owns its contents */
<a name="2225"></a>    ownsContents = true
<a name="2226"></a>    
<a name="2227"></a>    /* 
<a name="2228"></a>     *   This definition is needed for the TopicGroup implementation, and should
<a name="2229"></a>     *   not normally be overridden in user game code. It allows TopicEntries
<a name="2230"></a>     *   and TopicGroups to determine their own active status by reference to
<a name="2231"></a>     *   that of their immediate location.
<a name="2232"></a>     */
<a name="2233"></a>    active = true
<a name="2234"></a>    
<a name="2235"></a>    /*   
<a name="2236"></a>     *   This property can be used by extensions or game code that wants to
<a name="2237"></a>     *   notify actors in some order of priority.
<a name="2238"></a>     */
<a name="2239"></a>    notificationOrder = 100
<a name="2240"></a>    
<a name="2241"></a>    /*
<a name="2242"></a>     *   ***********************************************************************
<a name="2243"></a>     *   ACTION HANDLING
<a name="2244"></a>     *****************************************************************/
<a name="2245"></a>         
<a name="2246"></a>    /* In general we can talk to actors */
<a name="2247"></a>    canTalkToMe = true
<a name="2248"></a>    
<a name="2249"></a>    dobjFor(TalkTo)
<a name="2250"></a>    {  
<a name="2251"></a>        action()
<a name="2252"></a>        {
<a name="2253"></a>            sayHello();
<a name="2254"></a>        }
<a name="2255"></a>    }
<a name="2256"></a>    
<a name="2257"></a>    dobjFor(AskAbout)
<a name="2258"></a>    {     
<a name="2259"></a>        action()
<a name="2260"></a>        {
<a name="2261"></a>            handleTopic(&amp;askTopics, gIobj.topicList);
<a name="2262"></a>        }
<a name="2263"></a>    }
<a name="2264"></a>    
<a name="2265"></a>    dobjFor(AskFor)
<a name="2266"></a>    {     
<a name="2267"></a>        action()
<a name="2268"></a>        {
<a name="2269"></a>            handleTopic(&amp;askForTopics, gIobj.topicList);
<a name="2270"></a>        }
<a name="2271"></a>    }
<a name="2272"></a>    
<a name="2273"></a>    dobjFor(TellAbout)
<a name="2274"></a>    {
<a name="2275"></a>        action()
<a name="2276"></a>        {
<a name="2277"></a>            handleTopic(&amp;tellTopics, gIobj.topicList);
<a name="2278"></a>        }
<a name="2279"></a>    }
<a name="2280"></a>    
<a name="2281"></a>    dobjFor(TalkAbout)
<a name="2282"></a>    {        
<a name="2283"></a>        action()
<a name="2284"></a>        {
<a name="2285"></a>            handleTopic(&amp;talkTopics, gIobj.topicList);
<a name="2286"></a>        }
<a name="2287"></a>    }
<a name="2288"></a>    
<a name="2289"></a>       
<a name="2290"></a>    
<a name="2291"></a>    dobjFor(SayTo)
<a name="2292"></a>    {        
<a name="2293"></a>        action()
<a name="2294"></a>        {
<a name="2295"></a>            handleTopic(&amp;sayTopics, gIobj.topicList, &amp;defaultSayResponse);
<a name="2296"></a>        }
<a name="2297"></a>    }
<a name="2298"></a>    
<a name="2299"></a>    defaultSayResponse = '&lt;&lt;pcDefaultSayQuip&gt;&gt;&lt;.p&gt;&lt;&lt;noResponseMsg&gt;&gt;'
<a name="2300"></a>    
<a name="2301"></a>    pcDefaultSayQuip = BMsg(default pcsayquip, 
<a name="2302"></a>                  '&lt;q&gt;&lt;&lt;gTopicText.substr(1,1).toUpper()&gt;&gt;&lt;&lt;gTopicText.substr(2).toLower()&gt;&gt;,&lt;/q&gt; 
<a name="2303"></a>        {i} {say}. ')   
<a name="2304"></a>    
<a name="2305"></a>    
<a name="2306"></a>    dobjFor(QueryAbout)
<a name="2307"></a>    {        
<a name="2308"></a>        action()
<a name="2309"></a>        {
<a name="2310"></a>            handleTopic(&amp;queryTopics, gIobj.topicList);
<a name="2311"></a>        }
<a name="2312"></a>    }
<a name="2313"></a>    
<a name="2314"></a>        
<a name="2315"></a>    /* The message to display if isKissable is nil */
<a name="2316"></a>    cannotKissMsg = BMsg(should not kiss, 'That hardly {dummy} seem{s/ed}
<a name="2317"></a>        appropriate. ')
<a name="2318"></a>    
<a name="2319"></a>    /*   
<a name="2320"></a>     *   The default response of the actor to an attempt to kiss him/her/it
<a name="2321"></a>     *   where this is not handled anywhere else, but allowKiss is true.
<a name="2322"></a>     */
<a name="2323"></a>    kissResponseMsg = BMsg(kiss response, '{The subj dobj} {doesn\'t like[d]}
<a name="2324"></a>        that. ')
<a name="2325"></a>    
<a name="2326"></a>    /*  
<a name="2327"></a>     *   An Actor is a more likely target of a KISS action than is an animate
<a name="2328"></a>     *   object.
<a name="2329"></a>     */
<a name="2330"></a>    kissRank = 100
<a name="2331"></a>    
<a name="2332"></a>    dobjFor(Kiss)
<a name="2333"></a>    {       
<a name="2334"></a>        action()
<a name="2335"></a>        {
<a name="2336"></a>            handleTopic(&amp;miscTopics, [kissTopicObj], &amp;kissResponseMsg);
<a name="2337"></a>        }
<a name="2338"></a>    
<a name="2339"></a>    }
<a name="2340"></a>    
<a name="2341"></a>    /* 
<a name="2342"></a>     *   By default it's normally possible to attack an actor, even if we don't
<a name="2343"></a>     *   want to allow it. Game code might want to override this to nil for
<a name="2344"></a>     *   actors it's obviously futile to try attacking, such as ghosts, gods and
<a name="2345"></a>     *   giants.
<a name="2346"></a>     */
<a name="2347"></a>    isAttackable = true
<a name="2348"></a>    
<a name="2349"></a>     /* 
<a name="2350"></a>      *   By default we'll respond to ATTACK ACTOR with the shouldNotAttackMsg;
<a name="2351"></a>      *   to enable responses to ATTACK via HitTopics (or some other custom
<a name="2352"></a>      *   handling in the action stage) set allowAttack to true.
<a name="2353"></a>      *
<a name="2354"></a>      *   If there are actors the player character will never want to attack
<a name="2355"></a>      *   (because their friendly or harmless, for instance) but which
<a name="2356"></a>      *   nevertheless could in principle could be attacked, the checkAttackMsg
<a name="2357"></a>      *   property can be defined (as on Thing) to stop the attack at the check
<a name="2358"></a>      *   stage.
<a name="2359"></a>      */       
<a name="2360"></a>    
<a name="2361"></a>    
<a name="2362"></a>    /* The message to display if isAttackable is nil */
<a name="2363"></a>    cannotAttackMsg = BMsg(cannot attack actor, 'That hardly {dummy} seem{s/ed}
<a name="2364"></a>        appropriate. ')
<a name="2365"></a>       
<a name="2366"></a>    /* 
<a name="2367"></a>     *   A messaqe to display if we want to rule out attacking this actor at the check stage. By
<a name="2368"></a>     *   default we leave it as nil.
<a name="2369"></a>     */
<a name="2370"></a>    checkAttackMsg = nil
<a name="2371"></a>    
<a name="2372"></a>    /* 
<a name="2373"></a>     *   The message to display if attacking goes ahead but no HitTopics have
<a name="2374"></a>     *   been defined.
<a name="2375"></a>     */
<a name="2376"></a>    attackResponseMsg = cannotAttackMsg
<a name="2377"></a>    
<a name="2378"></a>    dobjFor(Attack) 
<a name="2379"></a>    {       
<a name="2380"></a>        action()
<a name="2381"></a>        {
<a name="2382"></a>            handleTopic(&amp;miscTopics, [hitTopicObj], &amp;attackResponseMsg);
<a name="2383"></a>        }
<a name="2384"></a>    
<a name="2385"></a>    }
<a name="2386"></a>    
<a name="2387"></a>    
<a name="2388"></a>    
<a name="2389"></a>    dobjFor(AttackWith) asDobjFor(Attack)
<a name="2390"></a>    
<a name="2391"></a>    
<a name="2392"></a>    touchResponseMsg = BMsg(should not touch actor, '{The subj dobj} {doesn\'t
<a name="2393"></a>        appreciate[d]} being touched. ')
<a name="2394"></a>    
<a name="2395"></a>    feelDesc = touchResponseMsg
<a name="2396"></a>    touchDesc = touchResponseMsg
<a name="2397"></a>    
<a name="2398"></a>    
<a name="2399"></a>    dobjFor(Feel)
<a name="2400"></a>    {
<a name="2401"></a>        action()
<a name="2402"></a>        {
<a name="2403"></a>            local prop;
<a name="2404"></a>            if(gActionIs(Touch) &amp;&amp; propDefined(&amp;touchDesc) &amp;&amp; dataType(&amp;touchDesc) != TypeNil)
<a name="2405"></a>                prop = &amp;touchDesc;
<a name="2406"></a>            else
<a name="2407"></a>                prop = &amp;feelDesc;               
<a name="2408"></a>            
<a name="2409"></a>            handleTopic(&amp;miscTopics, [touchTopicObj], prop);
<a name="2410"></a>        }
<a name="2411"></a>    }
<a name="2412"></a>    
<a name="2413"></a>    
<a name="2414"></a>    
<a name="2415"></a>    iobjFor(GiveTo)
<a name="2416"></a>    {        
<a name="2417"></a>        action()
<a name="2418"></a>        {
<a name="2419"></a>            handleTopic(&amp;giveTopics, [gDobj]);
<a name="2420"></a>        }
<a name="2421"></a>    }
<a name="2422"></a>    
<a name="2423"></a>    iobjFor(ShowTo)
<a name="2424"></a>    {        
<a name="2425"></a>        action()
<a name="2426"></a>        {
<a name="2427"></a>            handleTopic(&amp;showTopics, [gDobj]);
<a name="2428"></a>        }
<a name="2429"></a>    }
<a name="2430"></a>    
<a name="2431"></a>    
<a name="2432"></a>    /* 
<a name="2433"></a>     *   Unlike inaminate objects, actors can be the logical target of a ThrowTo
<a name="2434"></a>     *   action
<a name="2435"></a>     */    
<a name="2436"></a>    canThrowToMe = true
<a name="2437"></a>    
<a name="2438"></a>    /* 
<a name="2439"></a>     *   We'll assume that actors can catch anything thrown at them by default,
<a name="2440"></a>     *   but game code may wish to override this assumption.
<a name="2441"></a>     */
<a name="2442"></a>    canCatchThrown(obj) { return true; }
<a name="2443"></a>    
<a name="2444"></a>      
<a name="2445"></a>    
<a name="2446"></a>    iobjFor(ThrowTo)
<a name="2447"></a>    {
<a name="2448"></a>        action()
<a name="2449"></a>        {
<a name="2450"></a>            /* 
<a name="2451"></a>             *   First check whether the throw is possible by checking with the
<a name="2452"></a>             *   Query object. This will normally only be relevant if the target
<a name="2453"></a>             *   actor is in a location remote from that of the thrower. If the
<a name="2454"></a>             *   Q object rules out the throw, move the direct object to the
<a name="2455"></a>             *   thrower's room and display a message saying the object fell
<a name="2456"></a>             *   short.
<a name="2457"></a>             */
<a name="2458"></a>            if(!Q.canThrowTo(gActor, self))
<a name="2459"></a>            {
<a name="2460"></a>                gDobj.moveInto(gActor.getOutermostRoom);
<a name="2461"></a>                say(throwFallsShortMsg);
<a name="2462"></a>                
<a name="2463"></a>            }            
<a name="2464"></a>            
<a name="2465"></a>            /* 
<a name="2466"></a>             *   Otherwise if this Actor can catch Dobj when it's thrown, move
<a name="2467"></a>             *   the direct object into this Actor and display an appropriate
<a name="2468"></a>             *   message.
<a name="2469"></a>             */
<a name="2470"></a>            else if(canCatchThrown(gDobj))
<a name="2471"></a>            {
<a name="2472"></a>                gDobj.moveInto(self);
<a name="2473"></a>                sayActorCatches(gDobj);
<a name="2474"></a>            }
<a name="2475"></a>            
<a name="2476"></a>            /* 
<a name="2477"></a>             *   Otherwise move the direct object into this actor's location and
<a name="2478"></a>             *   display a message saying that the actor dropped the catch.
<a name="2479"></a>             */
<a name="2480"></a>            else
<a name="2481"></a>            {
<a name="2482"></a>                gDobj.moveInto(location);
<a name="2483"></a>                sayActorDropsCatch(gDobj);   
<a name="2484"></a>            }
<a name="2485"></a>        }       
<a name="2486"></a>    }
<a name="2487"></a>    
<a name="2488"></a>    /* Display a message saying that this actor catches obj */
<a name="2489"></a>    sayActorCatches(obj)
<a name="2490"></a>    {
<a name="2491"></a>        gMessageParams(obj);
<a name="2492"></a>        DMsg(catch okay, '{The subj iobj} {catches} {the obj}. ');
<a name="2493"></a>    }
<a name="2494"></a>    
<a name="2495"></a>    /* Display a message saying that this actor failst to catch obj */
<a name="2496"></a>    sayActorDropsCatch(obj)
<a name="2497"></a>    {
<a name="2498"></a>        gMessageParams(obj);
<a name="2499"></a>        DMsg(drop catch, '{The subj iobj} fail{s/ed} to catch {the obj},
<a name="2500"></a>            so that {he obj} land{s/ed} on the ground instead. ');
<a name="2501"></a>    }
<a name="2502"></a>    
<a name="2503"></a>    dobjFor(Follow)
<a name="2504"></a>    {
<a name="2505"></a>        preCond = []
<a name="2506"></a>        
<a name="2507"></a>        verify()
<a name="2508"></a>        {
<a name="2509"></a>            /* 
<a name="2510"></a>             *   If the player character can see the actor s/he wants to follow,
<a name="2511"></a>             *   and they're in the same location then following the target is
<a name="2512"></a>             *   logical.
<a name="2513"></a>             */
<a name="2514"></a>            if(Q.canSee(gActor, self) &amp;&amp; isIn(gActor.getOutermostRoom))
<a name="2515"></a>                logical;
<a name="2516"></a>            
<a name="2517"></a>            /*   But we can't follow an actor we can see in a remote location */
<a name="2518"></a>            else if(Q.canSee(gActor, self))
<a name="2519"></a>                illogicalNow(cantFollowFromHereMsg);
<a name="2520"></a>            
<a name="2521"></a>            /*  And we can't follow the actor if we don't know where it went */
<a name="2522"></a>            else if(lastTravelInfo == nil)
<a name="2523"></a>                illogicalNow(dontKnowWhereGoneMsg);
<a name="2524"></a>            
<a name="2525"></a>            /*  
<a name="2526"></a>             *   And we can't follow the actor if we're not in the location we
<a name="2527"></a>             *   last saw it depart from.
<a name="2528"></a>             */
<a name="2529"></a>            else if(!gActor.isIn(lastTravelInfo[1]))
<a name="2530"></a>                illogicalNow(cantStartFromHereMsg);
<a name="2531"></a>        }
<a name="2532"></a>        
<a name="2533"></a>        action()
<a name="2534"></a>        {
<a name="2535"></a>            /* 
<a name="2536"></a>             *   If we can see the actor we want to follow, then set the
<a name="2537"></a>             *   following Fuse (to fire at the end of this turn so we can
<a name="2538"></a>             *   follow the actor if it moves on this turn)
<a name="2539"></a>             */
<a name="2540"></a>            if(Q.canSee(gActor, self))
<a name="2541"></a>            {
<a name="2542"></a>                setFollowMeFuse();
<a name="2543"></a>            }
<a name="2544"></a>            
<a name="2545"></a>            /* 
<a name="2546"></a>             *   Otherwise use our stored travel information to try to follow
<a name="2547"></a>             *   this actor.
<a name="2548"></a>             */
<a name="2549"></a>            else if(lastTravelInfo)
<a name="2550"></a>            {
<a name="2551"></a>                /* Display a message to say we're following this actor */
<a name="2552"></a>                sayHeadAfterActor(lastTravelInfo[2]);
<a name="2553"></a>                
<a name="2554"></a>                /* 
<a name="2555"></a>                 *   Then travel via the connector this actor was seen to leave
<a name="2556"></a>                 *   by.
<a name="2557"></a>                 */
<a name="2558"></a>                lastTravelInfo[2].travelVia(gActor);
<a name="2559"></a>                
<a name="2560"></a>                /* 
<a name="2561"></a>                 *   reset the lastTravelInfo now that it's been used and is no
<a name="2562"></a>                 *   longer relevant.
<a name="2563"></a>                 */
<a name="2564"></a>                lastTravelInfo = nil;
<a name="2565"></a>            }
<a name="2566"></a>        }
<a name="2567"></a>        
<a name="2568"></a>    }
<a name="2569"></a>   
<a name="2570"></a>    sayHeadAfterActor(conn)
<a name="2571"></a>    {
<a name="2572"></a>        DMsg(say head after actor, '{I} head{s/ed} off {1} after {2}. ',
<a name="2573"></a>             conn.traversalMsg, theName);
<a name="2574"></a>    }
<a name="2575"></a>    
<a name="2576"></a>    waitToSeeMsg = BMsg(wait to see, '{I} wait{s/ed} to see where {he dobj}
<a name="2577"></a>        {goes}. ')
<a name="2578"></a>     
<a name="2579"></a>
<a name="2580"></a>    dontKnowWhereGoneMsg = BMsg(dont know where gone, '{I} {don\'t know} where
<a name="2581"></a>        {the subj dobj} {has} gone. ')
<a name="2582"></a>    cantStartFromHereMsg = BMsg(cannot start from here, '{I}{\'m} not where {i}
<a name="2583"></a>        last saw {the dobj}. ')
<a name="2584"></a>    cantFollowFromHereMsg = BMsg(cannot follow from here, '{I} {can\'t} follow
<a name="2585"></a>        {him dobj} from {here}. ')
<a name="2586"></a>    
<a name="2587"></a>    /* This actor's current stance towards the player character */
<a name="2588"></a>    stance = (stanceToward(gPlayerChar))
<a name="2589"></a>    
<a name="2590"></a>    /* Unless overriden our initial stance is the default stance defined on libGlobal. */
<a name="2591"></a>    initialStance = libGlobal.defaultStance 
<a name="2592"></a>    
<a name="2593"></a>    /* Our stance towards actor */
<a name="2594"></a>    stanceToward(actor)
<a name="2595"></a>    {
<a name="2596"></a>        return stanceTab[actor];
<a name="2597"></a>    }
<a name="2598"></a>    
<a name="2599"></a>    /* 
<a name="2600"></a>     *   A LookupTable containing our stance to various actors. It starts out with our stance
<a name="2601"></a>     *   towards the player character set to our initial stance, and to everyone else set to the
<a name="2602"></a>     *   default stance. Even if we don't want to track this actor's stance towards every other
<a name="2603"></a>     *   actor. it may be important to do so towards different potential player characters should
<a name="2604"></a>     *   the player character change in the course of the game.
<a name="2605"></a>     */
<a name="2606"></a>    stanceTab = [
<a name="2607"></a>        gPlayerChar -&gt; initialStance,
<a name="2608"></a>        * -&gt; libGlobal.defaultStance
<a name="2609"></a>    ]
<a name="2610"></a>        
<a name="2611"></a>    /* Set out stance towards actor */
<a name="2612"></a>    setStanceToward(actor, stance_)    
<a name="2613"></a>    {
<a name="2614"></a>        if(objOfKind(actor, Actor) &amp;&amp; objOfKind(stance_, Stance))
<a name="2615"></a>            stanceTab[actor] = stance_;
<a name="2616"></a>        else
<a name="2617"></a>            DMsg(set stance error, '&lt;FONT color=red&gt;&lt;b&gt;WARNING&lt;/b&gt;&lt;/FONT&gt;: in
<a name="2618"></a>                setStanceToward(&lt;&lt;actor&gt;&gt;, &lt;&lt;stance_&gt;&gt;) &lt;&lt;actor&gt;&gt; is not an Actor and/or &lt;&lt;stance_&gt;&gt;
<a name="2619"></a>                is not a Stance. ');
<a name="2620"></a>    }
<a name="2621"></a>    
<a name="2622"></a>    /* 
<a name="2623"></a>     *   Returns a list of actors towards whom this Actor has the most positive stance (out of the
<a name="2624"></a>     *   stanches s/he currently holds).
<a name="2625"></a>     */
<a name="2626"></a>    likesBest()  { return likes(true); }
<a name="2627"></a>    
<a name="2628"></a>    /* 
<a name="2629"></a>     *   Returns a list of actors towards whom this Actor has the least positive stance (out of the
<a name="2630"></a>     *   stanches s/he currently holds).    */
<a name="2631"></a>    likesLeast()  { return likes(nil); }
<a name="2632"></a>    
<a name="2633"></a>    /* 
<a name="2634"></a>     *   Return a list of actors towards whom this Actor has the either the most positive stance
<a name="2635"></a>     *   (stat = true) or the most negative stance (stat = nil)
<a name="2636"></a>     */
<a name="2637"></a>    likes(stat)
<a name="2638"></a>    {
<a name="2639"></a>        /* Set up a new Vector. */
<a name="2640"></a>        local vec = new Vector;
<a name="2641"></a>        
<a name="2642"></a>        /* Iterate through all the actors in the game to build a vector containing them all. */
<a name="2643"></a>        for(local a = firstObj(Actor); a != nil; a = nextObj(a, Actor))        
<a name="2644"></a>        {
<a name="2645"></a>            vec.append(a);
<a name="2646"></a>        }
<a name="2647"></a>        
<a name="2648"></a>        /* 
<a name="2649"></a>         *   Remove ourselves (this Actor) from the list, since we don't want to include our
<a name="2650"></a>         *   attitude to ourself in this reckoning.
<a name="2651"></a>         */
<a name="2652"></a>        vec.removeElement(self);        
<a name="2653"></a>            
<a name="2654"></a>        /* Sore the vector in either descending or ascending order according to the value of stat */
<a name="2655"></a>        vec.sort(stat, {a, b: stanceToward(a) - stanceToward(b)});
<a name="2656"></a>        
<a name="2657"></a>        /* 
<a name="2658"></a>         *   Note the score of the first item in vec, which will be the actor to whom this Actor has
<a name="2659"></a>         *   the most positive or most negative stance score depending on whether stat is true or
<a name="2660"></a>         *   nil.
<a name="2661"></a>         */
<a name="2662"></a>        local maxStance = stanceToward(vec[1]);
<a name="2663"></a>        
<a name="2664"></a>        /* 
<a name="2665"></a>         *   Obtain the subset of actors with the maximum positive or negative stance, convert the
<a name="2666"></a>         *   resulting vector to a list and return the result.
<a name="2667"></a>         */
<a name="2668"></a>        return vec.subset({x: stanceToward(x) == maxStance}).toList();
<a name="2669"></a>    }
<a name="2670"></a>    
<a name="2671"></a>    /* 
<a name="2672"></a>     *   Return a list of actors who have either the most positive stance (stat = true) or the most
<a name="2673"></a>     *   negative stance (stat = nil) towards this Actor
<a name="2674"></a>     */
<a name="2675"></a>    likedBy(stat)
<a name="2676"></a>    {
<a name="2677"></a>        /* Set up a new Vector */
<a name="2678"></a>        local vec = new Vector;
<a name="2679"></a>        
<a name="2680"></a>        /* Iterate through every Actor in the game to build a Vector listing them all. */
<a name="2681"></a>        for(local a = firstObj(Actor); a != nil; a = nextObj(a, Actor))        
<a name="2682"></a>        {
<a name="2683"></a>            vec.append(a);
<a name="2684"></a>        }
<a name="2685"></a>        
<a name="2686"></a>        /* 
<a name="2687"></a>         *   Remove ourselves (this Actor) from the list, since we don't want to include our
<a name="2688"></a>         *   attitude to ourself in this reckoning.
<a name="2689"></a>         */
<a name="2690"></a>        vec.removeElement(self);    
<a name="2691"></a>        
<a name="2692"></a>        /* Sore the vector in either descending or ascending order according to the value of stat */
<a name="2693"></a>        vec.sort(stat, {a, b: a.stanceToward(self) - b.stanceToward(self)});
<a name="2694"></a>        
<a name="2695"></a>        /* 
<a name="2696"></a>         *   Note the score of the first item in vec, which will be the actor with the most positive
<a name="2697"></a>         *   or most negative stance  towards this Actor depending on whether stat is true or nil.
<a name="2698"></a>         */
<a name="2699"></a>        local maxStance = vec[1].stanceToward(self);
<a name="2700"></a>        
<a name="2701"></a>        /* 
<a name="2702"></a>         *   Obtain the subset of actors with the maximum positive or negative stance, convert the
<a name="2703"></a>         *   resulting vector to a list and return the result.
<a name="2704"></a>         */
<a name="2705"></a>        return vec.subset({x: x.stanceToward(self) == maxStance}).toList();
<a name="2706"></a>    }
<a name="2707"></a>    
<a name="2708"></a>    /* Return a list of the actors who have the most positive stance towards this Actor. */
<a name="2709"></a>    mostLikedBy() {return likedBy(true); }
<a name="2710"></a>    
<a name="2711"></a>    /* Return a list of the actors who have the most least stance towards this Actor. */
<a name="2712"></a>    leastLikedBy() {return likedBy(nil); }
<a name="2713"></a>    
<a name="2714"></a>    /* 
<a name="2715"></a>     *   Our mood (unlike our stance) may be state dependent. However we assume its not actor
<a name="2716"></a>     *   dependent (I'm not sad toward bob but happy towards sally), although of course different
<a name="2717"></a>     *   actors may affect our mood in different ways.
<a name="2718"></a>     *
<a name="2719"></a>     *   If we don't have a current ActorState or our current ActorState's mood is nil, we fall back
<a name="2720"></a>     *   on our own actorMood.
<a name="2721"></a>     */     
<a name="2722"></a>    mood = (stateDependentMoods &amp;&amp; curState &amp;&amp; curState.mood ? curState.mood : actorMood)   
<a name="2723"></a>    
<a name="2724"></a>    /* 
<a name="2725"></a>     *   Our mood when this isn't defined by our current ActorsState. We default to the default
<a name="2726"></a>     *   mood.
<a name="2727"></a>     */
<a name="2728"></a>    actorMood = libGlobal.defaultMood
<a name="2729"></a>    
<a name="2730"></a>    /* 
<a name="2731"></a>     *   Set our current mood. If we have a current state we set its mood to the new value,
<a name="2732"></a>     *   otherwise we set our own actorMood to the new value.
<a name="2733"></a>     */
<a name="2734"></a>    setMood(mood_)
<a name="2735"></a>    {
<a name="2736"></a>        if(objOfKind(mood_, Mood))
<a name="2737"></a>        {
<a name="2738"></a>            if(curState &amp;&amp; stateDependentMoods)
<a name="2739"></a>                curState.mood = mood_;
<a name="2740"></a>            else
<a name="2741"></a>                actorMood = mood_;
<a name="2742"></a>        }
<a name="2743"></a>        else
<a name="2744"></a>        {
<a name="2745"></a>            DMsg(set mood error, '&lt;FONT color=red&gt;&lt;b&gt;WARNING!&lt;/b&gt;&lt;/FONT&gt;: in setMood(&lt;&lt;mood_&gt;&gt;),
<a name="2746"></a>                &lt;&lt;mood_&gt;&gt; is not a Mood. ');
<a name="2747"></a>        }
<a name="2748"></a>    }
<a name="2749"></a>    
<a name="2750"></a>    /* Flad; do we want this Actor's moods to depend on their ActorState, by default we do */
<a name="2751"></a>    stateDependentMoods = true
<a name="2752"></a>    
<a name="2753"></a>  
<a name="2754"></a>;
<a name="2755"></a>
<a name="2756"></a>/*  
<a name="2757"></a> *   An ActorState represents a state (possibly one of many) an actor can be in
<a name="2758"></a> *   or get into. This can control how the actor is described and the actor's
<a name="2759"></a> *   response to certain conversational commands and other actions.
<a name="2760"></a> *
<a name="2761"></a> *   ActorStates should always be located directly in the Actor to which they
<a name="2762"></a> *   belong.
<a name="2763"></a> */
<a name="2764"></a>
<a name="2765"></a>class ActorState: EndConvBlocker, ActorTopicDatabase
<a name="2766"></a>    
<a name="2767"></a>    /* 
<a name="2768"></a>     *   The stateDesc from the actor's current ActorState is appended to the
<a name="2769"></a>     *   desc defined on the actor when the actor is described via an EXAMINE
<a name="2770"></a>     *   command.
<a name="2771"></a>     */
<a name="2772"></a>    stateDesc = nil
<a name="2773"></a>    
<a name="2774"></a>    /*   
<a name="2775"></a>     *   The specialDesc from the actor's current ActorState is used as the
<a name="2776"></a>     *   specialDesc for that actor in a room listing.
<a name="2777"></a>     */
<a name="2778"></a>    specialDesc = nil
<a name="2779"></a>    
<a name="2780"></a>    /*   
<a name="2781"></a>     *   If our associated actor is viewed from a remote location, use the
<a name="2782"></a>     *   ActorState's remoteSpecialDesc to describe the actor in a room listing.
<a name="2783"></a>     *   By default we just use the specialDesc.
<a name="2784"></a>     */    
<a name="2785"></a>    remoteSpecialDesc(pov) { specialDesc; }
<a name="2786"></a>    
<a name="2787"></a>    
<a name="2788"></a>    /*   
<a name="2789"></a>     *   Set isInitState to true if you want this ActorState to be the one the
<a name="2790"></a>     *   associated Actor starts out in.
<a name="2791"></a>     */
<a name="2792"></a>    isInitState = nil
<a name="2793"></a>    
<a name="2794"></a>    
<a name="2795"></a>    /*   Initialize this ActorState (this is actually called at preinit). */
<a name="2796"></a>    initializeActorState()
<a name="2797"></a>    {
<a name="2798"></a>        /*   
<a name="2799"></a>         *   Initialize our getActor property from the getActor property of our
<a name="2800"></a>         *   location, which should simply return our associated actor. This
<a name="2801"></a>         *   should normally never change at run-time.
<a name="2802"></a>         */
<a name="2803"></a>        getActor = location.getActor;
<a name="2804"></a>        
<a name="2805"></a>        /* 
<a name="2806"></a>         *   If we're our Actor's initial state and we have a getActor (our
<a name="2807"></a>         *   associated actor) set our actor's current state to this ActorState
<a name="2808"></a>         */
<a name="2809"></a>        if(isInitState &amp;&amp; getActor != nil)
<a name="2810"></a>            getActor.curState = self;
<a name="2811"></a>        
<a name="2812"></a>       
<a name="2813"></a>        
<a name="2814"></a>        /*   Add this ActorState to our actor's list of ActorStates */
<a name="2815"></a>        addToActor();
<a name="2816"></a>               
<a name="2817"></a>    }
<a name="2818"></a>    
<a name="2819"></a>    /*   Add this ActorState to our actor's list of ActorStates */
<a name="2820"></a>    addToActor()
<a name="2821"></a>    {
<a name="2822"></a>        /* 
<a name="2823"></a>         *   First convert our actor's allStates property to an empty list if
<a name="2824"></a>         *   it's still nil
<a name="2825"></a>         */
<a name="2826"></a>        if(getActor.allStates == nil)
<a name="2827"></a>            getActor.allStates = [];
<a name="2828"></a>        
<a name="2829"></a>        /*   Then add ourself to our actor's list of all its ActorStates */
<a name="2830"></a>        getActor.allStates += self;
<a name="2831"></a>    }
<a name="2832"></a>    
<a name="2833"></a>    /*  
<a name="2834"></a>     *   The afterAction() method is called on an actor's current ActorState
<a name="2835"></a>     *   when the actor is in scope for the action that's just taken place. This
<a name="2836"></a>     *   allows game code to define state-specific reactions.
<a name="2837"></a>     */
<a name="2838"></a>    afterAction() {}
<a name="2839"></a>    
<a name="2840"></a>    
<a name="2841"></a>    /*  
<a name="2842"></a>     *   The beforeAction() method is called on an actor's current ActorState
<a name="2843"></a>     *   when the actor is in scope for the action that's just about to take
<a name="2844"></a>     *   place. This allows game code to define state-specific reactions.
<a name="2845"></a>     */
<a name="2846"></a>    beforeAction() {}
<a name="2847"></a>    
<a name="2848"></a>    /*  
<a name="2849"></a>     *   Display a message saying that we're following the player character from
<a name="2850"></a>     *   oldLoc when our actor is in this ActorState (and the actor is following
<a name="2851"></a>     *   the player character)
<a name="2852"></a>     */
<a name="2853"></a>    sayFollowing(oldLoc, conn)
<a name="2854"></a>    {
<a name="2855"></a>        /* Create some convenient message substitution parameters */
<a name="2856"></a>        local follower = getActor, pc = gPlayerChar;
<a name="2857"></a>        gMessageParams(follower, pc);
<a name="2858"></a>        
<a name="2859"></a>        /* Display the message */
<a name="2860"></a>        DMsg(state follow, '{The follower} follow{s/ed} behind {the pc}. ');
<a name="2861"></a>    }
<a name="2862"></a>    
<a name="2863"></a>    /*  
<a name="2864"></a>     *   Display a message saying that our associated actor (typically an NPC
<a name="2865"></a>     *   whose departure is being viewed by the player character) is departing
<a name="2866"></a>     *   via conn. By default we simply use our actor's sayActorDeparting(conn)
<a name="2867"></a>     *   method.
<a name="2868"></a>     */
<a name="2869"></a>    sayDeparting(conn) { getActor.sayActorDeparting(conn); }
<a name="2870"></a>    
<a name="2871"></a>    /* 
<a name="2872"></a>     *   The message to display when the player char sees this actor arriving
<a name="2873"></a>     *   after traveling from loc. By default we simply use our actor's
<a name="2874"></a>     *   sayActorArriving(fromLoc) method.
<a name="2875"></a>     */
<a name="2876"></a>    sayArriving(fromLoc) { getActor.sayActorArriving(fromLoc); }
<a name="2877"></a>    
<a name="2878"></a>    
<a name="2879"></a>    /*   
<a name="2880"></a>     *   Our associated actor. This is set to our location at preinit by our
<a name="2881"></a>     *   initializeActorState method.
<a name="2882"></a>     */
<a name="2883"></a>    getActor = nil
<a name="2884"></a>    
<a name="2885"></a>    
<a name="2886"></a>    /*   
<a name="2887"></a>     *   Our actor's attention span while our actor is in this ActorState. This
<a name="2888"></a>     *   is the number of turns the actor will wait for the player character to
<a name="2889"></a>     *   say something when a our actor is the player character's current
<a name="2890"></a>     *   conversation partner, before our actor gives up on the conversation and
<a name="2891"></a>     *   terminates it through 'boredom'. A value of nil (the default) means our
<a name="2892"></a>     *   actor is infinitely patient and will never terminate a conversation for
<a name="2893"></a>     *   this reason.
<a name="2894"></a>     */
<a name="2895"></a>    attentionSpan = nil
<a name="2896"></a>    
<a name="2897"></a>    /* 
<a name="2898"></a>     *   the arrivingTurn method is executed when an actor in this state has
<a name="2899"></a>     *   just followed the player char to a new location.
<a name="2900"></a>     */    
<a name="2901"></a>    arrivingTurn() { }
<a name="2902"></a>    
<a name="2903"></a>    
<a name="2904"></a>    
<a name="2905"></a>    /*
<a name="2906"></a>     *   Activate the state - this is called when we're about to become
<a name="2907"></a>     *   the active state for an actor.  We do nothing by default.
<a name="2908"></a>     */
<a name="2909"></a>    activateState(actor, oldState) { }
<a name="2910"></a>
<a name="2911"></a>    /* 
<a name="2912"></a>     *   Deactivate the state - this is called when we're the active state
<a name="2913"></a>     *   for an actor, and the actor is about to switch to a new state.
<a name="2914"></a>     *   We do nothing by default.  
<a name="2915"></a>     */
<a name="2916"></a>    deactivateState(actor, newState) { }
<a name="2917"></a>    
<a name="2918"></a>    
<a name="2919"></a>    /* 
<a name="2920"></a>     *   The beforeTravel notification triggered when the Actor is in this
<a name="2921"></a>     *   ActorState and traveler is just about to travel via connector. By
<a name="2922"></a>     *   default we do nothing.
<a name="2923"></a>     */
<a name="2924"></a>    beforeTravel(traveler, connector) {}
<a name="2925"></a>        
<a name="2926"></a>    /* 
<a name="2927"></a>     *   The afterTravel notification triggered when the Actor is in this
<a name="2928"></a>     *   ActorState and traveler has just traveled via connector. By default we
<a name="2929"></a>     *   do nothing.
<a name="2930"></a>     */
<a name="2931"></a>    afterTravel(traveler, connector) {}
<a name="2932"></a>    
<a name="2933"></a>    /* Flag -- has the player character just arrived? */
<a name="2934"></a>    pcJustArrived = (getActor.pcArrivalTurn == gTurns)
<a name="2935"></a>    
<a name="2936"></a>        
<a name="2937"></a>    /*   
<a name="2938"></a>     *   Determine whether our actor will allow a current conversation to be
<a name="2939"></a>     *   terminated for reason when in this ActorState. Return true to allow the
<a name="2940"></a>     *   conversation to be terminated and nil otherwise. By default we simply
<a name="2941"></a>     *   return true. If we return nil we should also display a message
<a name="2942"></a>     *   explaining why we're not allowing the conversation to end.
<a name="2943"></a>     */
<a name="2944"></a>    canEndConversation(reason) { return true; }
<a name="2945"></a>    
<a name="2946"></a>    /*   
<a name="2947"></a>     *   The active property is used by any TopicGroups and TopicEntries located
<a name="2948"></a>     *   directly within us to determine whether they in turn are active.
<a name="2949"></a>     *   Normally there is no reason for game code to override this on an
<a name="2950"></a>     *   ActorState; the property is simply provided so that TopicGroups and
<a name="2951"></a>     *   TopicEntries can call location.active regardless of whether they're
<a name="2952"></a>     *   located in TopicGroups, ActorStates or Actors.
<a name="2953"></a>     */    
<a name="2954"></a>    active = (location.active)
<a name="2955"></a>    
<a name="2956"></a>    /*   
<a name="2957"></a>     *   If the noResponse method is defined (i.e. non-nil) then this ActorState
<a name="2958"></a>     *   will behave like a TADS 3 HermitActorState, i.e. the noResponse message
<a name="2959"></a>     *   will be displayed in response to any conversational command
<a name="2960"></a>     *
<a name="2961"></a>     *   noResponse can be either a single-quoted string, a double-quoted string
<a name="2962"></a>     *   or a method. If it's a string then it will be displayed instead of any
<a name="2963"></a>     *   TopicEntry. It it's a method it will be executed; if it then displays
<a name="2964"></a>     *   anything no attempt will be made to match a TopicEntry, but it if
<a name="2965"></a>     *   doesn't display anything the conversational command will go on to be
<a name="2966"></a>     *   handled as normal.
<a name="2967"></a>     */
<a name="2968"></a>    noResponse = nil
<a name="2969"></a>   
<a name="2970"></a>    /* 
<a name="2971"></a>     *   The getBestMatch() method is already defined on TopicDatabase, from
<a name="2972"></a>     *   which ActorState inherits via ActorTopicDatabase. ActorState overrides
<a name="2973"></a>     *   it to allow certain modifications particular to ActorState, such as the
<a name="2974"></a>     *   possibility that the prop parameter might be passed as either a list or
<a name="2975"></a>     *   a property pointer to a list property, and the need to take into
<a name="2976"></a>     *   account the actor's activeKeys list.
<a name="2977"></a>     */    
<a name="2978"></a>    getBestMatch(prop, requestedList)
<a name="2979"></a>    {
<a name="2980"></a>        
<a name="2981"></a>        local myList;
<a name="2982"></a>        
<a name="2983"></a>        /* 
<a name="2984"></a>         *   In the implementation of the conversation system, prop should be
<a name="2985"></a>         *   passed as a property pointer, but in the base TopicDatabase class
<a name="2986"></a>         *   the corresponding parameter is a list, so check what we have before
<a name="2987"></a>         *   we deal with it.
<a name="2988"></a>         *
<a name="2989"></a>         *   If prop has been passed as a property pointer, get our list from
<a name="2990"></a>         *   the corresponding property.
<a name="2991"></a>         */        
<a name="2992"></a>        if(dataType(prop) == TypeProp)        
<a name="2993"></a>            myList = self.(prop);
<a name="2994"></a>        
<a name="2995"></a>        /*  Otherwise get our list directely from the prop parameter. */
<a name="2996"></a>        else
<a name="2997"></a>            myList = valToList(prop);
<a name="2998"></a>        
<a name="2999"></a>        /* 
<a name="3000"></a>         *   If we have a current activeKeys list restrict the choice of topic
<a name="3001"></a>         *   entries to those whose convkeys overlap with it, at least at a
<a name="3002"></a>         *   first attempt. If that doesn't produce a match, try the normal
<a name="3003"></a>         *   handling. We need to do this first to ensure that we prioritize
<a name="3004"></a>         *   TopicEntries whose convKeys match our actor's activeKeys (which is
<a name="3005"></a>         *   the whole point of our actor having activeKeys).
<a name="3006"></a>         */
<a name="3007"></a>        
<a name="3008"></a>        if(getActor.activeKeys.length &gt; 0)
<a name="3009"></a>        {
<a name="3010"></a>            /* 
<a name="3011"></a>             *   Obtain a list that is that subset of our original list where
<a name="3012"></a>             *   the convKeys of the TopicEntries in the list overlaps with our
<a name="3013"></a>             *   actor's active keys (i.e. at this stage we only want to
<a name="3014"></a>             *   consider TopicEntries selected by our actor's active keys)
<a name="3015"></a>             */
<a name="3016"></a>            local kList = myList.subset({x:
<a name="3017"></a>                                   valToList(x.convKeys).overlapsWith(getActor.activeKeys)});
<a name="3018"></a>            
<a name="3019"></a>            /*   
<a name="3020"></a>             *   Now find the best match that results from using the inherited
<a name="3021"></a>             *   handling with our restricted list
<a name="3022"></a>             */
<a name="3023"></a>            local match = inherited(kList, requestedList);
<a name="3024"></a>            
<a name="3025"></a>            /*   If we found a suitable match, return it. */
<a name="3026"></a>            if(match != nil)
<a name="3027"></a>                return match;
<a name="3028"></a>            
<a name="3029"></a>            /* 
<a name="3030"></a>             *   If we didn't find a match in the current state that overlaps
<a name="3031"></a>             *   with activeKeys, try finding one in the actor. (Not doing this
<a name="3032"></a>             *   would break the Conversation Nodes mechanism, quite apart from
<a name="3033"></a>             *   anything else). Note we can only do this is prop has been
<a name="3034"></a>             *   passed as a property pointer, as the method expects.
<a name="3035"></a>             */            
<a name="3036"></a>            if(dataType(prop) == TypeProp)
<a name="3037"></a>            {
<a name="3038"></a>                /* 
<a name="3039"></a>                 *   If prop was passed as a property pointer, obtain the list
<a name="3040"></a>                 *   from the corresponding property on our actor (if it wasn't
<a name="3041"></a>                 *   there's no need to do anything since we're already stored
<a name="3042"></a>                 *   it as a list)
<a name="3043"></a>                 */
<a name="3044"></a>                myList = getActor.(prop);
<a name="3045"></a>                
<a name="3046"></a>                /*   
<a name="3047"></a>                 *   Obtain that subset of our list that contains TopicEntries
<a name="3048"></a>                 *   whose convKeys overlap with our actor's activeKeys
<a name="3049"></a>                 .*/
<a name="3050"></a>                kList = myList.subset({x:
<a name="3051"></a>                                      valToList(x.convKeys).overlapsWith(getActor.activeKeys)});
<a name="3052"></a>                
<a name="3053"></a>                /*  
<a name="3054"></a>                 *   Try to find a best match using the inherited handling with
<a name="3055"></a>                 *   our new sub-list.
<a name="3056"></a>                 */
<a name="3057"></a>                match = inherited(kList, requestedList);
<a name="3058"></a>                
<a name="3059"></a>                /*  If we found a suitable match, return it. */
<a name="3060"></a>                if(match != nil)
<a name="3061"></a>                    return match;
<a name="3062"></a>                
<a name="3063"></a>                /* 
<a name="3064"></a>                 *   Restore the list to this ActorState's list of relevant
<a name="3065"></a>                 *   TopicEntries
<a name="3066"></a>                 */
<a name="3067"></a>                myList = self.(prop);
<a name="3068"></a>            }
<a name="3069"></a>        }
<a name="3070"></a>      
<a name="3071"></a>        /* 
<a name="3072"></a>         *   If we haven't found a match corresponding to our actor's
<a name="3073"></a>         *   activeKeys, or if our actor doesn't have any activeKeys, simply
<a name="3074"></a>         *   return the result of the inherited handling.
<a name="3075"></a>         */
<a name="3076"></a>        return inherited(myList, requestedList);
<a name="3077"></a>    }
<a name="3078"></a>    
<a name="3079"></a>    /*  
<a name="3080"></a>     *   Should other actors who can notionally hear the PC talking to us
<a name="3081"></a>     *   overhear when information is imparted to us and we're in this
<a name="3082"></a>     *   ActorState? I.e. should their setInform() methods be called too? By
<a name="3083"></a>     *   default they should.
<a name="3084"></a>     */
<a name="3085"></a>    informOverheard = true
<a name="3086"></a>    
<a name="3087"></a>    /* 
<a name="3088"></a>     *   The actor's mood when the actor is in this atate. If this is nil the actor uses the value
<a name="3089"></a>     *   of the actorMood property instead.
<a name="3090"></a>     */
<a name="3091"></a>    mood = nil   
<a name="3092"></a>    
<a name="3093"></a>    /* Calling actorSay() on an ActorState calls actorSay() on its associated Actor. */
<a name="3094"></a>    actorSay(str) { getActor.actorSay(str); }
<a name="3095"></a>    
<a name="3096"></a>    /* 
<a name="3097"></a>     *   Calling initiateConverstion() on an ActorState calls ainitiateConverstion() on its
<a name="3098"></a>     *   associated Actor.
<a name="3099"></a>     */
<a name="3100"></a>    initiateConversation(state, str) {getActor.initiateConversation(state, str); }
<a name="3101"></a>    
<a name="3102"></a>    /* 
<a name="3103"></a>     *   Flag: do we want the game to suggest topics of conversation after a TALK TO commmand when
<a name="3104"></a>     *   the actor is in this ActorState? By default we do.
<a name="3105"></a>     */
<a name="3106"></a>    autoSuggest = true
<a name="3107"></a>;
<a name="3108"></a>
<a name="3109"></a>/*  
<a name="3110"></a> *   A TopicDatabase is an object that can contain TopicEntries and return the
<a name="3111"></a> *   best match on request. ActorTopicDatabase is a specialization of
<a name="3112"></a> *   TopicDatabase for use with the conversation system, and is used as a mix-in
<a name="3113"></a> *   class in the list of classes from which Actor and ActorState inherit.
<a name="3114"></a> */
<a name="3115"></a>modify ActorTopicDatabase
<a name="3116"></a>       
<a name="3117"></a>    /* 
<a name="3118"></a>     *   The various lists of TopicEntries located within this TopicDatabase.
<a name="3119"></a>     *   For exampel the askTopics list would contain a list of all our
<a name="3120"></a>     *   AskTopics. Note that the same TopicEntry can appear in more than one
<a name="3121"></a>     *   list; for example an AskTellTopic would appear in both the askTopics
<a name="3122"></a>     *   list and the tellTopics list, and a DefaultAnyTopic would appear in all
<a name="3123"></a>     *   the lists apart from initiateTopics.
<a name="3124"></a>     */
<a name="3125"></a>    askTopics = []
<a name="3126"></a>    tellTopics = []
<a name="3127"></a>    sayTopics = []
<a name="3128"></a>    queryTopics = []
<a name="3129"></a>    giveTopics = []
<a name="3130"></a>    showTopics = []
<a name="3131"></a>    askForTopics = []
<a name="3132"></a>    talkTopics = []
<a name="3133"></a>    initiateTopics = []
<a name="3134"></a>    miscTopics = []
<a name="3135"></a>    commandTopics = []
<a name="3136"></a>    
<a name="3137"></a>    /* 
<a name="3138"></a>     *   Return a list of our listable topics, that is the topic entries located
<a name="3139"></a>     *   within us that should be included in a topic inventory listing because
<a name="3140"></a>     *   they are (a) currently reachable and (b) currently marked for listing.
<a name="3141"></a>     *   The resulting list forms part of the list passed to the
<a name="3142"></a>     *   suggestedTopicLister.
<a name="3143"></a>     */
<a name="3144"></a>    listableTopics()
<a name="3145"></a>    {
<a name="3146"></a>        
<a name="3147"></a>        /* Get the list of Listable topics. */
<a name="3148"></a>        local lst = getListableTopics();
<a name="3149"></a>        
<a name="3150"></a>        /* 
<a name="3151"></a>         *   Filter the list to remove master topics that effectively duplicate subtopics and return
<a name="3152"></a>         *   the filtered list.
<a name="3153"></a>         */
<a name="3154"></a>        return suppressedList(lst);        
<a name="3155"></a>    }
<a name="3156"></a>    
<a name="3157"></a>    /* 
<a name="3158"></a>     *   Return a list of our listable topics, that is the topic entries located
<a name="3159"></a>     *   within us that should be included in a topic inventory listing because
<a name="3160"></a>     *   they are (a) currently reachable and (b) currently marked for listing.
<a name="3161"></a>     *   The resulting list forms part of the list passed to the
<a name="3162"></a>     *   suggestedTopicLister via listableTopics();
<a name="3163"></a>     */
<a name="3164"></a>    getListableTopics()
<a name="3165"></a>    {
<a name="3166"></a>        /* 
<a name="3167"></a>         *   Start by creating a list of all the TopicEntries we contain
<a name="3168"></a>         *   (excluding InitiateTopics, which are never suggested because
<a name="3169"></a>         *   they're never a response to a conversational command).
<a name="3170"></a>         */
<a name="3171"></a>        local lst = miscTopics + askTopics + tellTopics + sayTopics +
<a name="3172"></a>            queryTopics + giveTopics + askForTopics + talkTopics + showTopics
<a name="3173"></a>            + commandTopics;
<a name="3174"></a>        
<a name="3175"></a>        /*  Note our actor. */
<a name="3176"></a>        local actor = getActor;
<a name="3177"></a>        
<a name="3178"></a>        /*  Remove any duplicates from our list */
<a name="3179"></a>        lst = lst.getUnique();
<a name="3180"></a>        
<a name="3181"></a>        /*  
<a name="3182"></a>         *   Form that subset of our list that contains TopicEntries that are
<a name="3183"></a>         *   actually listable. These are TopicEntries that meet all of the
<a name="3184"></a>         *   following conditions:
<a name="3185"></a>         
<a name="3186"></a>         *. 1) They define a name property (used to list them)
<a name="3187"></a>         *. 2) They are currently active
<a name="3188"></a>         *. 3) Their curiosity is not yet satisfied
<a name="3189"></a>         *. 4) Their curiosity has been aroused
<a name="3190"></a>         *. 5) They are reachable (i.e. they could potentially be triggered
<a name="3191"></a>         *   by a player command on the current turn).
<a name="3192"></a>         *
<a name="3193"></a>         *   Note that we deliberately leave the reachability test to last as it
<a name="3194"></a>         *   is the most computationally demanding.
<a name="3195"></a>         */
<a name="3196"></a>        lst = lst.subset({x: x.name!= nil &amp;&amp; x.active &amp;&amp; !x.curiositySatisfied 
<a name="3197"></a>                        &amp;&amp; x.curiosityAroused &amp;&amp; x.isReachable});
<a name="3198"></a>        
<a name="3199"></a>        /*  
<a name="3200"></a>         *   If our actor has any activeKeys, further narrow down our list to
<a name="3201"></a>         *   those TopicEntries whose convKeys match (i.e. overlap with) our
<a name="3202"></a>         *   actor's activeKeys.
<a name="3203"></a>         */
<a name="3204"></a>        if(actor.activeKeys.length &gt; 0)
<a name="3205"></a>            lst = lst.subset({x: actor.activeKeys.overlapsWith(x.convKeys)});
<a name="3206"></a>        
<a name="3207"></a>        
<a name="3208"></a>        
<a name="3209"></a>        /* Return the resulting list. */
<a name="3210"></a>        return lst;
<a name="3211"></a>    }
<a name="3212"></a>   
<a name="3213"></a>    
<a name="3214"></a>    /* 
<a name="3215"></a>     *   Filter lst to remove any master topics that called any listed subtopics via their keyTopics
<a name="3216"></a>     *   property.
<a name="3217"></a>     */
<a name="3218"></a>    suppressedList(lst)
<a name="3219"></a>    {
<a name="3220"></a>        local new_lst = lst;
<a name="3221"></a>        
<a name="3222"></a>        /* 
<a name="3223"></a>         *   Remove from the list any high level topic entries that have triggered a subordinate
<a name="3224"></a>         *   TopicEntry that's also in the list of suggestions, since it's probably redundant to
<a name="3225"></a>         *   list both.
<a name="3226"></a>         */        
<a name="3227"></a>        foreach(local item in lst)
<a name="3228"></a>        {
<a name="3229"></a>            if(item.convKeys)
<a name="3230"></a>            {
<a name="3231"></a>                /* 
<a name="3232"></a>                 *   Create a sublist including only any items for which autoSuppress is true and
<a name="3233"></a>                 *   where there is no overlap between their keyTopics and the convKeys of any
<a name="3234"></a>                 *   currently listed subtopics.
<a name="3235"></a>                 */
<a name="3236"></a>                new_lst = new_lst.subset({x: !x.autoSuppress || 
<a name="3237"></a>                                         valToList(item.convKeys).intersect( valToList(
<a name="3238"></a>                    x.keyTopics) ) == []});
<a name="3239"></a>            }
<a name="3240"></a>        }
<a name="3241"></a>        
<a name="3242"></a>        return new_lst;
<a name="3243"></a>    }
<a name="3244"></a>    
<a name="3245"></a>    
<a name="3246"></a>    /* 
<a name="3247"></a>     *   Obtain the identify of any DefaultAgendaTopic contained in this
<a name="3248"></a>     *   database
<a name="3249"></a>     */
<a name="3250"></a>    defaultAgendaTopic = static 
<a name="3251"></a>                       askTopics.valWhich({x: x.ofKind(DefaultAgendaTopic)})
<a name="3252"></a>    
<a name="3253"></a>    /*  Handle an InitiateTopic */
<a name="3254"></a>    initiateTopic(top)
<a name="3255"></a>    {
<a name="3256"></a>       return handleTopic(&amp;initiateTopics, [top], nil);
<a name="3257"></a>    }
<a name="3258"></a>    
<a name="3259"></a>    
<a name="3260"></a>;
<a name="3261"></a>
<a name="3262"></a>/* 
<a name="3263"></a> *   A TopicGroup is an object that can be used to group ActorTopicEntries that
<a name="3264"></a> *   share common features such as convKeys or isActive conditions. A TopicGroup
<a name="3265"></a> *   can be used anywhere an ActorTopicEntry can be used, and any
<a name="3266"></a> *   ActorTopicEntries should behave just as they would if they were in the
<a name="3267"></a> *   TopicGroup's container, apart from the modifications imposed by the
<a name="3268"></a> *   TopicGroup.
<a name="3269"></a> */
<a name="3270"></a>class TopicGroup: object
<a name="3271"></a>    
<a name="3272"></a>    /* 
<a name="3273"></a>     *   Add a topic entry to our database; since a TopicGroup isn't a
<a name="3274"></a>     *   TopicDatabase we simply ask our location to add it to its database. We
<a name="3275"></a>     *   also modify the convKeys and scoreBoost properties of any items
<a name="3276"></a>     *   contained in us according to our own convKeys and scoreBoost
<a name="3277"></a>     *   properties.
<a name="3278"></a>     */
<a name="3279"></a>    addTopic(obj)
<a name="3280"></a>    {
<a name="3281"></a>        /* Add the topic entry to our enclosing topic database */
<a name="3282"></a>        location.addTopic(obj);
<a name="3283"></a>        
<a name="3284"></a>        /* 
<a name="3285"></a>         *   For each TopicEntry located in this TopicGroup, add any convKeys
<a name="3286"></a>         *   defined on the TopicGroup to those defined on the individual
<a name="3287"></a>         *   TopicEntries
<a name="3288"></a>         */        
<a name="3289"></a>        obj.convKeys =
<a name="3290"></a>            valToList(obj.convKeys).appendUnique(valToList(convKeys));
<a name="3291"></a>        
<a name="3292"></a>        /* 
<a name="3293"></a>         *   Unless our curiosityAroused is -1 (the default, a special value meaning "leave well
<a name="3294"></a>         *   alone", copy our curiosityAroused (true or nil to all the TopicEntries we contain.
<a name="3295"></a>         */
<a name="3296"></a>        
<a name="3297"></a>        if(curiosityAroused != -1)
<a name="3298"></a>            obj.curiosityAroused = curiosityAroused;
<a name="3299"></a>        
<a name="3300"></a>         /* 
<a name="3301"></a>         *   Unless our activated is -1 (the default, a special value meaning "leave well
<a name="3302"></a>         *   alone", copy our activated (true or nil to all the TopicEntries we contain.
<a name="3303"></a>         */
<a name="3304"></a>        
<a name="3305"></a>        if(activated != -1)
<a name="3306"></a>            obj.activated = activated;
<a name="3307"></a>        
<a name="3308"></a>        /* Add this topic entry to our contents list. */        
<a name="3309"></a>        contents += obj;
<a name="3310"></a>     }
<a name="3311"></a>      
<a name="3312"></a>    
<a name="3313"></a>    /*  
<a name="3314"></a>     *   A TopicGroup's isActive property can be used to make all the
<a name="3315"></a>     *   TopicEntries enclosed within in inactive by being set to nil; if it is
<a name="3316"></a>     *   true then the enclosed TopicEntries are active if their own isActive
<a name="3317"></a>     *   property is true.
<a name="3318"></a>     */
<a name="3319"></a>    isActive = true
<a name="3320"></a>    
<a name="3321"></a>    /* 
<a name="3322"></a>     *   This TopicGroup is active if both its own isActive property is true and
<a name="3323"></a>     *   its location is active (this allows us to locate TopicGroups within
<a name="3324"></a>     *   other TopicGroups, for instance)
<a name="3325"></a>     */
<a name="3326"></a>    active = (isActive &amp;&amp; location.active)
<a name="3327"></a>    
<a name="3328"></a>    /*  
<a name="3329"></a>     *   A list of convKeys that should be added to the convKeys of each of our
<a name="3330"></a>     *   TopicEntries.
<a name="3331"></a>     */
<a name="3332"></a>    convKeys = nil
<a name="3333"></a>    
<a name="3334"></a>    /*   
<a name="3335"></a>     *   A scoreBoost that should be added to the scoreBoost of each of our
<a name="3336"></a>     *   TopicEntries.
<a name="3337"></a>     */
<a name="3338"></a>    scoreBoost = 0
<a name="3339"></a>    
<a name="3340"></a>    /*  
<a name="3341"></a>     *   By how much do we boost the score of any TopicEntries we contain? We
<a name="3342"></a>     *   need to add our own score boost to that our own location.
<a name="3343"></a>     */
<a name="3344"></a>    scoreBooster()
<a name="3345"></a>    {
<a name="3346"></a>        local sb = scoreBoost;
<a name="3347"></a>        
<a name="3348"></a>        if(location.propDefined(&amp;scoreBooster))
<a name="3349"></a>            sb += location.scoreBooster();
<a name="3350"></a>        
<a name="3351"></a>        return sb;
<a name="3352"></a>    }
<a name="3353"></a>    
<a name="3354"></a>    
<a name="3355"></a>    /* 
<a name="3356"></a>     *   If our curiosityAroused is not -1, it will be copied to all the the TopicEntries we
<a name="3357"></a>     *   contained at preinit or game startup. This can be used to set all our contents' initial
<a name="3358"></a>     *   curiosityAroused to either true or nil without having to set it on every one of our
<a name="3359"></a>     *   TopioEntries individually.
<a name="3360"></a>     */
<a name="3361"></a>    curiosityAroused = -1
<a name="3362"></a>    
<a name="3363"></a>    /* 
<a name="3364"></a>     *   If our activated is not -1, it will be copied to all the the TopicEntries we
<a name="3365"></a>     *   contained at preinit or game startup. This can be used to set all our contents' initial
<a name="3366"></a>     *   activatd to either true or nil without having to set it on every one of our
<a name="3367"></a>     *   TopioEntries individually.
<a name="3368"></a>     */
<a name="3369"></a>    activated = -1
<a name="3370"></a>    
<a name="3371"></a>    /*   
<a name="3372"></a>     *   If we're being used as a conversation node, our node is active when our
<a name="3373"></a>     *   own convKeys matches (i.e. overlaps with) that of our actor's
<a name="3374"></a>     *   activeKeys.
<a name="3375"></a>     */
<a name="3376"></a>    nodeActive()
<a name="3377"></a>    {
<a name="3378"></a>        return valToList(convKeys).overlapsWith(getActor.activeKeys);
<a name="3379"></a>    }
<a name="3380"></a>    
<a name="3381"></a>    /* Our associated actor is our location's associated actor. */
<a name="3382"></a>    getActor = (location.getActor)    
<a name="3383"></a>    
<a name="3384"></a>    /* The list of TopicEntries we contain. */
<a name="3385"></a>    contents = []
<a name="3386"></a>;
<a name="3387"></a>
<a name="3388"></a>/* 
<a name="3389"></a> *   A ConvNode is a TopicGroup specialized for use as a ConversationNode; it's
<a name="3390"></a> *   active when its nodeActive property is true.
<a name="3391"></a> */
<a name="3392"></a>
<a name="3393"></a>class ConvNode: TopicGroup
<a name="3394"></a>    isActive = nodeActive
<a name="3395"></a>    
<a name="3396"></a>    /* 
<a name="3397"></a>     *   Register this ConvNode with its associated actor and set up any implictly defined
<a name="3398"></a>     *   NodeEndCheck and NodeContinuationTopic objects.
<a name="3399"></a>     *.
<a name="3400"></a>     */
<a name="3401"></a>    register()
<a name="3402"></a>    {
<a name="3403"></a>        /* Get our asociated actor. */
<a name="3404"></a>        local actor = getActor;
<a name="3405"></a>        
<a name="3406"></a>        /* Add to our actor's list of ConvNodes. */
<a name="3407"></a>        actor.allNodes = actor.allNodes.append([convKeys, self]);    
<a name="3408"></a>        
<a name="3409"></a>        /* 
<a name="3410"></a>         *   If this Convnode defines one or more of the sayBlockXXX methods, create a NodeEndCheck
<a name="3411"></a>         *   object for this ConvNode and moved all the sayBlockXXX methods over to our newly
<a name="3412"></a>         *   created NodeEndCheck.
<a name="3413"></a>         */
<a name="3414"></a>        if(propDefined(&amp;sayBlockLeave) || propDefined(&amp;sayBlockBye) || propDefined(&amp;sayBlockBoredom))
<a name="3415"></a>        {
<a name="3416"></a>            /* Create our NodeEndCheck object. */
<a name="3417"></a>            local nec = new NodeEndCheck;
<a name="3418"></a>            
<a name="3419"></a>            /* Set its location to ourself. */
<a name="3420"></a>            nec.location = self;
<a name="3421"></a>            
<a name="3422"></a>            /* Move our sayBlockXXX methods over to our new NodeEndCheck object. */
<a name="3423"></a>            moveMethod(nec, &amp;sayBlockLeave);
<a name="3424"></a>            moveMethod(nec, &amp;sayBlockBye);
<a name="3425"></a>            moveMethod(nec, &amp;sayBlockBoredom);    
<a name="3426"></a>            
<a name="3427"></a>            /* 
<a name="3428"></a>             *   Initialize our new NodeEndCheck object with our convKeys and add it to our
<a name="3429"></a>             *   enclosing database.
<a name="3430"></a>             */
<a name="3431"></a>            
<a name="3432"></a>            addTopic(nec);
<a name="3433"></a>        }        
<a name="3434"></a>        
<a name="3435"></a>        /* 
<a name="3436"></a>         *   If this Convnode defines a nodeContinuationMsg, create a NodeContinuationTopic object
<a name="3437"></a>         *   for this ConvNode and move our nodeContinuationMsg over to our newly created
<a name="3438"></a>         *   NodeContinuationTopic.
<a name="3439"></a>         */
<a name="3440"></a>        if(propDefined(&amp;nodeContinuationMsg))
<a name="3441"></a>        {
<a name="3442"></a>            /* Create our NodeContinuationTopic object. */
<a name="3443"></a>            local nct = new NodeContinuationTopic;
<a name="3444"></a>            
<a name="3445"></a>            /* Set its location to ourself. */
<a name="3446"></a>            nct.location = self;                 
<a name="3447"></a>            
<a name="3448"></a>            /* Move our nodeContinuationMsg method over to our new NodeEndCheck object. */
<a name="3449"></a>            moveMethod(nct, &amp;nodeContinuationMsg, &amp;topicResponse);
<a name="3450"></a>            
<a name="3451"></a>            /* 
<a name="3452"></a>             *   Initialize our new NodeContinuation object with our convKeys and add it to our
<a name="3453"></a>             *   enclosing database.
<a name="3454"></a>             */
<a name="3455"></a>            addTopic(nct);
<a name="3456"></a>        }
<a name="3457"></a>        
<a name="3458"></a>        /* 
<a name="3459"></a>         *   If this Convnode defines a convstayMsg, create a DefaultConvstayTopic object
<a name="3460"></a>         *   for this ConvNode and move our convsratMsg over to our newly created
<a name="3461"></a>         *   DefaultConvstayTopic.
<a name="3462"></a>         */
<a name="3463"></a>        
<a name="3464"></a>        if(propDefined(&amp;convstayMsg))
<a name="3465"></a>        {
<a name="3466"></a>            /* Create our DefaultConvstayTopic object. */
<a name="3467"></a>            local dct = new DefaultConvstayTopic;
<a name="3468"></a>            
<a name="3469"></a>            /* Set its location to ourself. */
<a name="3470"></a>            dct.location = self;                 
<a name="3471"></a>            
<a name="3472"></a>            /* Move our nodeContinuationMsg method over to our new NodeEndCheck object. */
<a name="3473"></a>            moveMethod(dct, &amp;convstayMsg, &amp;topicResponse);
<a name="3474"></a>            
<a name="3475"></a>            /* 
<a name="3476"></a>             *   Initialize our new NodeContinuation object with our convKeys and add it to our
<a name="3477"></a>             *   enclosing database.
<a name="3478"></a>             */
<a name="3479"></a>            addTopic(dct);
<a name="3480"></a>        }
<a name="3481"></a>        
<a name="3482"></a>    }
<a name="3483"></a>    
<a name="3484"></a>    /* 
<a name="3485"></a>     *   We can define any of these three sayBlockXXX properties on a ConvNode and the library will
<a name="3486"></a>     *   create a NodeEndCheck to which they'll be moved. This means we shouldn't define these
<a name="3487"></a>     *   properties on a ConvNode and also create a NodeEndCheck object for the same ConvNode.
<a name="3488"></a>     *
<a name="3489"></a>     *   Any of these methods/properties can be defined as a double-quoted string, single-quoted
<a name="3490"></a>     *   string, or a method to display text, just as on a NodeEndCheck object, but if we want
<a name="3491"></a>     *   something more complex, such as employing an EventList to vary the text displayed we'll
<a name="3492"></a>     *   need to create our NodeEndCheck object manually and define the EventList there.
<a name="3493"></a>     */
<a name="3494"></a>    // sayBlockLeave
<a name="3495"></a>    // sayBlockBye
<a name="3496"></a>    // sayBlockBoredom
<a name="3497"></a>    
<a name="3498"></a>    /*
<a name="3499"></a>     *   We can define a nodeContinuationMsg on a ConvNode and it will become the topicResponse of a
<a name="3500"></a>     *   NodeContinuationTopic.
<a name="3501"></a>     */
<a name="3502"></a>    // nodeContinuationMsg
<a name="3503"></a>    
<a name="3504"></a>    
<a name="3505"></a>    /*
<a name="3506"></a>     *   We can define a convstayMsg on a ConvNode and it will become the topicResponse of a
<a name="3507"></a>     *   DefaultConvstayTopic.
<a name="3508"></a>     */
<a name="3509"></a>    // convstayMsg
<a name="3510"></a>    
<a name="3511"></a>;
<a name="3512"></a>
<a name="3513"></a>convNodePreinit: PreinitObject
<a name="3514"></a>    execute()
<a name="3515"></a>    {
<a name="3516"></a>        forEachInstance(ConvNode, {c: c.register() });
<a name="3517"></a>    }
<a name="3518"></a>;
<a name="3519"></a>
<a name="3520"></a>/* 
<a name="3521"></a> *   An ActorTopicEntry is a specialization of TopicEntry for use with the
<a name="3522"></a> *   conversation system. ActorTopicEntries represent potential responses to
<a name="3523"></a> *   conversational commands like ASK BOB ABOUT LIGHTHOUSE or TELL GEORGE ABOUT
<a name="3524"></a> *   FIRE.
<a name="3525"></a> *
<a name="3526"></a> *   Since ActorTopicEntry inherits from ReplaceRedirector as well as
<a name="3527"></a> *   TopicEntry, its topicResponse() methods can make use of doInstead() and
<a name="3528"></a> *   doNested().
<a name="3529"></a> */
<a name="3530"></a>class ActorTopicEntry: ReplaceRedirector, TopicEntry
<a name="3531"></a>    
<a name="3532"></a>    /* 
<a name="3533"></a>     *   To make this a suggested topic, just give it a name under which it will
<a name="3534"></a>     *   be suggested (of the kind that could follow 'You could ask about ' or
<a name="3535"></a>     *   'You could tell him about ' or 'You could show him ' etc.). Note that
<a name="3536"></a>     *   for QueryTopics and SayTopics that are specified with a matchObj the
<a name="3537"></a>     *   library constructs this name automatically.
<a name="3538"></a>     */         
<a name="3539"></a>    name = nil
<a name="3540"></a>    
<a name="3541"></a>    /* 
<a name="3542"></a>     *   Set autoName to true to have this topic entry generate a name from its
<a name="3543"></a>     *   first matchObj's theName     */
<a name="3544"></a>    
<a name="3545"></a>    autoName = nil
<a name="3546"></a>    
<a name="3547"></a>    /* 
<a name="3548"></a>     *   Our last conversational response if we're a StopEventList. This can be set as a negative
<a name="3549"></a>     *   numner, such as -1 to mean the last but one. This may be useful if our final response is a
<a name="3550"></a>     *   summary of what the NPC has said rather than a conversational response which s/he speaks,
<a name="3551"></a>     *   so that we don't want to suggest the final response or treat it as conversational.
<a name="3552"></a>     */
<a name="3553"></a>    lastConvResponse = nil  
<a name="3554"></a>    
<a name="3555"></a>    /* 
<a name="3556"></a>     *   The script class we want lastConvResponse to be applicable. By default this is
<a name="3557"></a>     *   StopEventList, which is what it is designed to be used with, but this allows game code to
<a name="3558"></a>     *   adjust this. It also allows gameCode to override lastConvResponse on ActorTopicEntry and
<a name="3559"></a>     *   have it only apply to ActorTopicEntries that are also of lcrScriptClass.
<a name="3560"></a>     */
<a name="3561"></a>    lcrScriptClass = StopEventList
<a name="3562"></a>    
<a name="3563"></a>    /* 
<a name="3564"></a>     *   Should we be treated as conversational? Normally an ActorTopicEntry should (except for
<a name="3565"></a>     *   certain subtypes) but if we're also a script and our lastConvResponse has been defined as
<a name="3566"></a>     *   non-nil we may want to do something different.
<a name="3567"></a>     */
<a name="3568"></a>    isConversational()
<a name="3569"></a>    {
<a name="3570"></a>        /* 
<a name="3571"></a>         *   If lastConvResponse is nil or we haven't been mixed in with a Script (EventList) class,
<a name="3572"></a>         *   simply return true
<a name="3573"></a>         */
<a name="3574"></a>        if(lastConvResponse == nil || !ofKind(lcrScriptClass))
<a name="3575"></a>            return true;               
<a name="3576"></a>        
<a name="3577"></a>        /* 
<a name="3578"></a>         *   Otherwise return true only if our current script state is less than or equal that
<a name="3579"></a>         *   defined by of lastConvResponse property.
<a name="3580"></a>         */
<a name="3581"></a>        return curScriptState &lt;= (lastConvResponse &gt; 0 ? lastConvResponse : eventList.length +
<a name="3582"></a>                                  lastConvResponse);
<a name="3583"></a>    }
<a name="3584"></a>    
<a name="3585"></a>    /* 
<a name="3586"></a>     *   Was this ActorTopicEntry just before we display our Topic Response, which could change the
<a name="3587"></a>     *   value of isConversational by advancing curScriptState.
<a name="3588"></a>     */
<a name="3589"></a>    wasConversational = true
<a name="3590"></a>    
<a name="3591"></a>    /*  
<a name="3592"></a>     *   Normally a conversational command implies a greeting (that is, it
<a name="3593"></a>     *   should trigger a greeting if a conversation is not already in process).
<a name="3594"></a>     *   This needs to be overridden to nil on ActorTopicEntries that explicitly
<a name="3595"></a>     *   handle greetings (HelloTopic and its subclasses) to avoid an infinite
<a name="3596"></a>     *   loop.
<a name="3597"></a>     */
<a name="3598"></a>    impliesGreeting = isConversational
<a name="3599"></a>    
<a name="3600"></a>    /* 
<a name="3601"></a>     *   A string or list of strings defining one or more groups to which this
<a name="3602"></a>     *   topic entry belongs. Under certain circumstances an ActorTopicEntry may
<a name="3603"></a>     *   be prioritized if its convKeys overlaps with the associated actor's
<a name="3604"></a>     *   activeKeys.
<a name="3605"></a>     */
<a name="3606"></a>    convKeys = nil
<a name="3607"></a>    
<a name="3608"></a>    /* 
<a name="3609"></a>     *   Test whether any of this Topic Entry's convKeys match those in the
<a name="3610"></a>     *   Actor's activeKeys list (whether or not the latter has any entries).
<a name="3611"></a>     *   This can be used in the isActive property to make this topic entry
<a name="3612"></a>     *   *only* available when its convKeys are active.
<a name="3613"></a>     */    
<a name="3614"></a>    nodeActive()
<a name="3615"></a>    {
<a name="3616"></a>        return valToList(convKeys).overlapsWith(getActor.activeKeys);
<a name="3617"></a>    }
<a name="3618"></a>    
<a name="3619"></a>    /* Add this ActorTopicEntry to its associated actor's table of convKeys */
<a name="3620"></a>    addToConvKeyTable()   
<a name="3621"></a>    {
<a name="3622"></a>        /* Note our associated actor. */
<a name="3623"></a>        local actor = getActor;
<a name="3624"></a>        
<a name="3625"></a>        /* If our actor doesn't yet have a convKeyTab, create one */
<a name="3626"></a>        if(actor.convKeyTab == nil)
<a name="3627"></a>            actor.convKeyTab = new LookupTable;
<a name="3628"></a>        
<a name="3629"></a>        /*  
<a name="3630"></a>         *   Go through every key in our convKeys list and add this
<a name="3631"></a>         *   ActorTopicEntry to the list of ActorTopicEntries that correspond to
<a name="3632"></a>         *   it in our actor's convKeyList.
<a name="3633"></a>         */
<a name="3634"></a>        foreach(local k in valToList(convKeys))
<a name="3635"></a>        {
<a name="3636"></a>            /* Obtain the existing value corresponding to this key */
<a name="3637"></a>            local val = actor.convKeyTab[k];
<a name="3638"></a>            
<a name="3639"></a>            /* 
<a name="3640"></a>             *   Make sure the value is a list, and then add this
<a name="3641"></a>             *   ActorTopicEntry to it before storing it in the table.
<a name="3642"></a>             */
<a name="3643"></a>            actor.convKeyTab[k] = valToList(val) + self;
<a name="3644"></a>        }
<a name="3645"></a>    }
<a name="3646"></a>    
<a name="3647"></a>    /* Initialize this ActorTopicEntry (this is actually called at preinit) */
<a name="3648"></a>    initializeTopicEntry()
<a name="3649"></a>    {
<a name="3650"></a>        /* Carry out the inherited handling (on TopicEntry) */
<a name="3651"></a>        inherited;
<a name="3652"></a>        
<a name="3653"></a>        /* 
<a name="3654"></a>         *   Add this ActorTopicEntry and its associated convKeys to our actor's
<a name="3655"></a>         *   convKeyTable
<a name="3656"></a>         */
<a name="3657"></a>        addToConvKeyTable();
<a name="3658"></a>        
<a name="3659"></a>        /*  
<a name="3660"></a>         *   If our autoname property is true, construct our name (for use in
<a name="3661"></a>         *   suggesting this TopicEntry) provided we have something to construct
<a name="3662"></a>         *   it from.
<a name="3663"></a>         */
<a name="3664"></a>        if(autoName &amp;&amp; matchObj != nil &amp;&amp; name is in (nil, ''))
<a name="3665"></a>            buildName();
<a name="3666"></a>    }
<a name="3667"></a>    
<a name="3668"></a>    /* 
<a name="3669"></a>     *   Construct the name of this ActorTopicEntry by using the theName
<a name="3670"></a>     *   property of our first matchObj.     
<a name="3671"></a>     */
<a name="3672"></a>    buildName() { name = valToList(matchObj)[1].theName; }
<a name="3673"></a>    
<a name="3674"></a>    /* Our associated actor is our location's associated actor. */
<a name="3675"></a>    getActor = (location.getActor)
<a name="3676"></a>    
<a name="3677"></a>    /* 
<a name="3678"></a>     *   The number of times to suggest this topic entry, if we do suggest it. By default this is
<a name="3679"></a>     *   either once (if we're not also an EventList) or the number of items in our eventList (if we
<a name="3680"></a>     *   are an EventList). If you want this topic entry to go on being suggested ad infinitum, set
<a name="3681"></a>     *   timesToSuggest to nil. If, on the other hand, you want it to be suggested fewer times than
<a name="3682"></a>     *   there are items in the EventList, say because the final item in a StopEventList is a
<a name="3683"></a>     *   summary of what was said before rather than a conversational response from the NPC,
<a name="3684"></a>     *   override the lastConvResponse accordingly (most likely to -1).
<a name="3685"></a>     */  
<a name="3686"></a>    timesToSuggest()
<a name="3687"></a>    {
<a name="3688"></a>        /* 
<a name="3689"></a>         *   If we're a Script type object - an EventList say - only suugest us the number of times
<a name="3690"></a>         *   there are entries in the event list. Store this number in a local variable.
<a name="3691"></a>         */
<a name="3692"></a>        local t = (ofKind(Script) ? eventList.length : 1);
<a name="3693"></a>        
<a name="3694"></a>        /* 
<a name="3695"></a>         *   If out lastConvResponse property is non-nil, adjust our times to suggest accordingly
<a name="3696"></a>         *   provided we're mixed in with lscrScriptClass (usually StopEventList).
<a name="3697"></a>         */
<a name="3698"></a>        if(lastConvResponse != nil &amp;&amp; ofKind(lcrScriptClass))
<a name="3699"></a>        {
<a name="3700"></a>            /* 
<a name="3701"></a>             *   If lastConvResponse is negative (typically -1) we want to stop suggesting that
<a name="3702"></a>             *   number of items from the end of the list. Since lastConvResponse is negative we add
<a name="3703"></a>             *   it to t to reduce t accordingly.
<a name="3704"></a>             */
<a name="3705"></a>            if(lastConvResponse &lt; 0)
<a name="3706"></a>                t += lastConvResponse;
<a name="3707"></a>            
<a name="3708"></a>            /* If t is positive, it's simply the numnber of times we want to suggest. */
<a name="3709"></a>            if(lastConvResponse &gt; 0)
<a name="3710"></a>                t = lastConvResponse;           
<a name="3711"></a>        }
<a name="3712"></a>        
<a name="3713"></a>        /* Set ourselves to t so we don't have to repeat these calculations. */
<a name="3714"></a>        timesToSuggest = t;
<a name="3715"></a>        
<a name="3716"></a>        /* return the number of times we want this topic to be suggested. */
<a name="3717"></a>        return t;      
<a name="3718"></a>    }
<a name="3719"></a>    
<a name="3720"></a>    /* 
<a name="3721"></a>     *   Assuming this topic entry is ever suggested, it will continue to be
<a name="3722"></a>     *   suggested until curiositySatisfied becomes true. By default this occurs
<a name="3723"></a>     *   when the topic has been invoked timesToSuggest times. If, however, we
<a name="3724"></a>     *   have any keyTopics we'll take our curiosity to be satisfied when our
<a name="3725"></a>     *   keyTopics have all been satisfied.
<a name="3726"></a>     */
<a name="3727"></a>    curiositySatisfied()
<a name="3728"></a>    {
<a name="3729"></a>        if(keyTopics == nil)
<a name="3730"></a>            return( timesToSuggest != nil &amp;&amp; timesInvoked &gt;= timesToSuggest);
<a name="3731"></a>        else
<a name="3732"></a>            return getKeyTopics(nil).length == 0;
<a name="3733"></a>    }
<a name="3734"></a>    
<a name="3735"></a>    /* The number of times this topic entry has been invoked. */
<a name="3736"></a>    timesInvoked = 0
<a name="3737"></a>    
<a name="3738"></a>    /* 
<a name="3739"></a>     *   Flag:do we want to suppress suggesting this topic if subtopics it has suggested through its
<a name="3740"></a>     *   keyTopic property are in the current list of suggested topics. By default we do but this
<a name="3741"></a>     *   can be overridden to nil if it produces unwanted behaviour.
<a name="3742"></a>     */
<a name="3743"></a>    autoSuppress = true
<a name="3744"></a>    
<a name="3745"></a>    /*   
<a name="3746"></a>     *   Flag - the complement to autoSuppress. If this is true then when the player changes the
<a name="3747"></a>     *   main topic when a list of suggestions of subtopics from another main topic (e.g. by typing
<a name="3748"></a>     *   ASK ABOUT WEATHER after a previous ASK ABOUT ISLAND has called up a suggested list of
<a name="3749"></a>     *   subtopics about the island), then we'll suppress the list of subtopics (on the basis that
<a name="3750"></a>     *   the player appears to be no longer interested in them, at least for the time being.
<a name="3751"></a>     */
<a name="3752"></a>    autoSuppressSubTopics = true
<a name="3753"></a>    
<a name="3754"></a>    /* 
<a name="3755"></a>     *   We won't suggest this topic entry (if we ever suggest it at all) until
<a name="3756"></a>     *   its curiosityAroused property by true. By default it normally is from
<a name="3757"></a>     *   the start, but this can be overridden in individual cases if desired.
<a name="3758"></a>     */
<a name="3759"></a>    curiosityAroused = true
<a name="3760"></a>    
<a name="3761"></a>    /* 
<a name="3762"></a>     *   The suggestAs property can be overridden to change the list this topic
<a name="3763"></a>     *   entry will be suggested as if you don't want it placed in the list the
<a name="3764"></a>     *   library chooses by default. The allowed values are one of AskTopic,
<a name="3765"></a>     *   TellTopic, GiveTopic, ShowTopic, or TalkTopic. Normally, though, the
<a name="3766"></a>     *   library default will work perfectly well and you don't need to specify
<a name="3767"></a>     *   this property. If you do it must be specified as a kind that this topic
<a name="3768"></a>     *   entry can actually match, e.g. TellTopic for an AskTellTopic or
<a name="3769"></a>     *   ShowTopic for a GiveShowTopic.
<a name="3770"></a>     */    
<a name="3771"></a>    suggestAs = nil
<a name="3772"></a>    
<a name="3773"></a>    /*   
<a name="3774"></a>     *   The order this TopicEntry appears in within its group in a list of
<a name="3775"></a>     *   suggested topics. The higher this number, the later this topic will be
<a name="3776"></a>     *   suggested. Note that this does not override the grouping of suggestions
<a name="3777"></a>     *   into AskTopics, TellTopics, etc.
<a name="3778"></a>     */
<a name="3779"></a>    listOrder = 100
<a name="3780"></a>    
<a name="3781"></a>    /* 
<a name="3782"></a>     *   Handle the display of this topic entry's topicResponse or of its suggested subtopics as
<a name="3783"></a>     *   appopriate.
<a name="3784"></a>     */
<a name="3785"></a>    baseHandleTopic()
<a name="3786"></a>    {
<a name="3787"></a>        /* Increment our timesInvoked counter */            
<a name="3788"></a>        timesInvoked++ ;
<a name="3789"></a>        
<a name="3790"></a>        /* 
<a name="3791"></a>         *   If we have a list of keyTopics defined, then we display them as a
<a name="3792"></a>         *   list of topic suggestions instead of showing our topicResponse.
<a name="3793"></a>         *   This allows one topicEntry to be used as a means of suggesting
<a name="3794"></a>         *   other, more specific, topics.
<a name="3795"></a>         */
<a name="3796"></a>        if(valToList(keyTopics).length &gt; 0)
<a name="3797"></a>        {
<a name="3798"></a>            /* Show a list of our keyTopics */
<a name="3799"></a>            showKeyTopics(self);
<a name="3800"></a>            
<a name="3801"></a>            /* 
<a name="3802"></a>             *   Throw an abort signal so that showing a list of topics doesn't
<a name="3803"></a>             *   count as a player turn.
<a name="3804"></a>             */
<a name="3805"></a>            abort;
<a name="3806"></a>        }
<a name="3807"></a>               
<a name="3808"></a>        /* Otherwise execute our topicResponse  */
<a name="3809"></a>        else
<a name="3810"></a>        {
<a name="3811"></a>            /* 
<a name="3812"></a>             *   Note whether we were conversational just before we display our response. We do this
<a name="3813"></a>             *   because if we're also an EventList our isConversational state may change as a
<a name="3814"></a>             *   result of ourScriptState advancing.
<a name="3815"></a>             */
<a name="3816"></a>            wasConversational = isConversational;
<a name="3817"></a>            
<a name="3818"></a>            
<a name="3819"></a>            /* 
<a name="3820"></a>             *   If our topicResponse has been defined as an EventList, call its doScript method.
<a name="3821"></a>             *   This has been implemented more for internal use in connection with ConvNode and
<a name="3822"></a>             *   NodeContinuationTopic than for user code. Game code should normally continue to mix
<a name="3823"></a>             *   any EventList class it may want to use with the TopicEntry class being employed and
<a name="3824"></a>             *   define the contemts of the EventList on the eventList property, typically via the
<a name="3825"></a>             *   TopicEntry template.
<a name="3826"></a>             */
<a name="3827"></a>            if(propType(&amp;topicResponse) == TypeObject &amp;&amp; topicResponse.ofKind(Script))
<a name="3828"></a>                 topicResponse.doScript();
<a name="3829"></a>            else            
<a name="3830"></a>            /* Otherwise just show our topic response. */
<a name="3831"></a>            topicResponse();
<a name="3832"></a>        }
<a name="3833"></a>        
<a name="3834"></a>        /* 
<a name="3835"></a>         *   If we've just had a conversationasl exchange, update libGlobal.lastTopicMentioned with
<a name="3836"></a>         *   the topic we've just matched.
<a name="3837"></a>         */
<a name="3838"></a>        if(wasConversational)
<a name="3839"></a>            libGlobal.lastTopicMentioned = topicMatched;
<a name="3840"></a>    }
<a name="3841"></a>    
<a name="3842"></a>    /*   
<a name="3843"></a>     *   Handle this topic (if we're the ActorTopicEntry selected to respond to
<a name="3844"></a>     *   a conversational command.
<a name="3845"></a>     */
<a name="3846"></a>    handleTopic()
<a name="3847"></a>    {       
<a name="3848"></a>        /* 
<a name="3849"></a>         *   Filter the topic suggestions to exclude any subtopics related to a master topic that
<a name="3850"></a>         *   the player has just moved away from.
<a name="3851"></a>         */        
<a name="3852"></a>        filterTopicSuggestions();
<a name="3853"></a>        
<a name="3854"></a>        /* 
<a name="3855"></a>         *   Carry out the base handling of displaying this topic or triggering its subtopics.
<a name="3856"></a>         */
<a name="3857"></a>        baseHandleTopic();
<a name="3858"></a>    }
<a name="3859"></a>    
<a name="3860"></a>    /* 
<a name="3861"></a>     *   Filter the list of topics to be suggested by removing from the list any subtopics relating
<a name="3862"></a>     *   to a new main topic (e.g. when the player types A WEATHER when the list of subtopic
<a name="3863"></a>     *   relating to A ISLAND is still available. The subtopics are removed simply by having their
<a name="3864"></a>     *   curiosityAroused reset to nil, indicating that the player's curiosity has moved on
<a name="3865"></a>     *   elsewhere. at least for the time being.
<a name="3866"></a>     */    
<a name="3867"></a>    filterTopicSuggestions()
<a name="3868"></a>    {
<a name="3869"></a>        /* Store a list of our keyTopics */
<a name="3870"></a>        local klst = valToList(keyTopics);
<a name="3871"></a>        
<a name="3872"></a>        /* Store a list of our convKeys. */
<a name="3873"></a>        local clst = valToList(convKeys);  
<a name="3874"></a>        
<a name="3875"></a>        /* Note the actor we're a topic entry for. */
<a name="3876"></a>        local actor = getActor();
<a name="3877"></a>        
<a name="3878"></a>        /* Store a list of the last keyTopics to be referenced for this actor. */
<a name="3879"></a>        local slst = valToList(actor.subTopicKeys);
<a name="3880"></a>        
<a name="3881"></a>        /* 
<a name="3882"></a>         *   If there was a previous list of keyTopics and it has nothing in common with our own
<a name="3883"></a>         *   convKeys, then the player has changed the subject, so we may want to suppress the
<a name="3884"></a>         *   listing of suggested subtopics relating to the previous main topic.
<a name="3885"></a>         */
<a name="3886"></a>        if(slst != klst &amp;&amp; slst.intersect(clst) == [])
<a name="3887"></a>        {
<a name="3888"></a>            /* 
<a name="3889"></a>             *   We only want to carry out the filtering if our autoSuppressSubTopics is true and
<a name="3890"></a>             *   there is a previous list of keyTopics resulting from an earlier conversational
<a name="3891"></a>             *   command.
<a name="3892"></a>             */
<a name="3893"></a>            if(autoSuppressSubTopics &amp;&amp; slst.length() &gt; 0)                           
<a name="3894"></a>            {
<a name="3895"></a>                /* First obetain a list of listable Topics for the current actor. */
<a name="3896"></a>                local topList = actor.listableTopics;
<a name="3897"></a>                
<a name="3898"></a>                /* 
<a name="3899"></a>                 *   If our actor has a current actor state, add the listable topics for that actor
<a name="3900"></a>                 *   state.
<a name="3901"></a>                 */
<a name="3902"></a>                if(actor.curState) topList += actor.curState.listableTopics;
<a name="3903"></a>                               
<a name="3904"></a>                /* 
<a name="3905"></a>                 *   Filter our list of suggested topics to include only those whose convKeys have
<a name="3906"></a>                 *   some keys in common with the list of previously invoked keyTopics (that is,
<a name="3907"></a>                 *   topics that relate to the same master topic).
<a name="3908"></a>                 */
<a name="3909"></a>                topList = topList.subset({x: valToList(x.convKeys).intersect(slst)
<a name="3910"></a>                                         != [] });
<a name="3911"></a>                
<a name="3912"></a>                /* 
<a name="3913"></a>                 *   Go through our list of topics and set to nil the curiosityAroused property of
<a name="3914"></a>                 *   any whose convKeys list has nothing in common with the keyTopics of the just
<a name="3915"></a>                 *   invoked TopicEntry.
<a name="3916"></a>                 */
<a name="3917"></a>                foreach(local item in topList)
<a name="3918"></a>                {
<a name="3919"></a>                    if( valToList(item.convKeys).intersect(klst) == [])
<a name="3920"></a>                        item.curiosityAroused = nil;              
<a name="3921"></a>                }                
<a name="3922"></a>            }
<a name="3923"></a>            
<a name="3924"></a>            /* 
<a name="3925"></a>             *   Store our keyList in our actor's subTopicKeys to be available for comparison on the
<a name="3926"></a>             *   next conversational command.
<a name="3927"></a>             */
<a name="3928"></a>            actor.subTopicKeys = klst;
<a name="3929"></a>        }
<a name="3930"></a>    }
<a name="3931"></a>    
<a name="3932"></a>    
<a name="3933"></a>        
<a name="3934"></a>    /* 
<a name="3935"></a>     *   The keyTopics can contain a convKey or a list of convKeys, in which
<a name="3936"></a>     *   case when this TopicEntry is triggered instead of responding directly
<a name="3937"></a>     *   it will list topic suggestions that correspond to the convKeys defined
<a name="3938"></a>     *   here. For example, a TopicEntry that responded to ASK BOB ABOUT
<a name="3939"></a>     *   TROUBLES could define a keyTopics property of 'troubles' that triggered
<a name="3940"></a>     *   more specific suggestions such as "You could ask when the troubles
<a name="3941"></a>     *   started, or what the troubles were, or how the troubles ended",
<a name="3942"></a>     *   assuming that these QueryTopics had a convKeys property of 'troubles'
<a name="3943"></a>     *
<a name="3944"></a>     *   If you want this TopicEntry to display its topicResponse in the normal
<a name="3945"></a>     *   way, leave keyTopics as nil.
<a name="3946"></a>     */
<a name="3947"></a>    keyTopics = nil
<a name="3948"></a>    
<a name="3949"></a>    /* 
<a name="3950"></a>     *   Flag, do we want a master topic to automatically update all its associated subtopics
<a name="3951"></a>     *   (associated via its keyTopics property). By default we do, or else they won't be included
<a name="3952"></a>     *   in any list of suggestions at this point.
<a name="3953"></a>     */
<a name="3954"></a>    arouseKeyTopics = true
<a name="3955"></a>    
<a name="3956"></a>    /* 
<a name="3957"></a>     *   Flag, do we want a master topic to automatically update all its associated subtopics
<a name="3958"></a>     *   (associated via its keyTopics property). By default we don't (for now).
<a name="3959"></a>     */
<a name="3960"></a>    activateKeyTopics = nil
<a name="3961"></a>    
<a name="3962"></a>    /* Show our suggested keyTopics, if keyTopics is defined. */
<a name="3963"></a>    showKeyTopics(parent)
<a name="3964"></a>    {
<a name="3965"></a>        /* 
<a name="3966"></a>         *   First construct a list of TopicEntries that match the keys in our
<a name="3967"></a>         *   keyTopics.
<a name="3968"></a>         */
<a name="3969"></a>        local lst = getKeyTopics(true);
<a name="3970"></a>        
<a name="3971"></a>        /*   
<a name="3972"></a>         *   If the list contains any entries, display the list of suggestions
<a name="3973"></a>         *   using the suggestedTopicLister
<a name="3974"></a>         */
<a name="3975"></a>        if(lst.length &gt; 0)                    
<a name="3976"></a>           suggestedTopicLister.show(lst);       
<a name="3977"></a>        
<a name="3978"></a>        /* 
<a name="3979"></a>         *   Otherwise display a message explaining that we've nothing to
<a name="3980"></a>         *   discuss on this topic.
<a name="3981"></a>         */
<a name="3982"></a>        else
<a name="3983"></a>        {
<a name="3984"></a>            if(parent.mayAddSubtopics)                
<a name="3985"></a>                DMsg(nothing to discuss on that topic, '{I} {have} nothing to
<a name="3986"></a>                    discuss on that topic just {then}. '); 
<a name="3987"></a>            else
<a name="3988"></a>                DMsg(nothing more to discuss on that topic, '{I} {have} nothing more to
<a name="3989"></a>                    discuss on that topic. ');
<a name="3990"></a>        }
<a name="3991"></a>    }
<a name="3992"></a>    
<a name="3993"></a>    /* Obtain a list of the TopicEntries that match our keyTopics property. */
<a name="3994"></a>    getKeyTopics(updateStatus)
<a name="3995"></a>    {
<a name="3996"></a>        /* Make a note of our associated actor. */
<a name="3997"></a>        local actor = getActor();
<a name="3998"></a>
<a name="3999"></a>        /* Initialize an empty list */
<a name="4000"></a>        local lst = [];
<a name="4001"></a>        
<a name="4002"></a>        /* 
<a name="4003"></a>         *   For each key value in our keyTopics list, look up the associated
<a name="4004"></a>         *   TopicEntries in our actor's convKeyTab and add them to our list. If
<a name="4005"></a>         *   however a key value looks like a &lt;. &gt; tag, output the tag (this
<a name="4006"></a>         *   could be use to activate or arouse a group of topics just prior to
<a name="4007"></a>         *   suggesting them).
<a name="4008"></a>         */
<a name="4009"></a>        foreach(local ky in valToList(keyTopics))
<a name="4010"></a>        {
<a name="4011"></a>            /* 
<a name="4012"></a>             *   If this value looks like a control tag, output it straight
<a name="4013"></a>             *   away.
<a name="4014"></a>             */
<a name="4015"></a>            if(ky.startsWith('&lt;.'))
<a name="4016"></a>            {
<a name="4017"></a>                if(updateStatus)
<a name="4018"></a>                    say(ky.trim);   
<a name="4019"></a>            }
<a name="4020"></a>            /* Otherwise add it to our list. */
<a name="4021"></a>            else 
<a name="4022"></a>            {
<a name="4023"></a>                if(activateKeyTopics &amp;&amp; updateStatus)
<a name="4024"></a>                    actor.makeActivated(ky);
<a name="4025"></a>                
<a name="4026"></a>                lst += actor.convKeyTab[ky];
<a name="4027"></a>                
<a name="4028"></a>                /* 
<a name="4029"></a>                 *   And if arouseKeyTopics is true, then also arouse the topics associated with the
<a name="4030"></a>                 *   key ky (to set their curiosity aroused to true).
<a name="4031"></a>                 */                   
<a name="4032"></a>                if(arouseKeyTopics &amp;&amp; updateStatus)
<a name="4033"></a>                    actor.arouse(ky);             
<a name="4034"></a>                
<a name="4035"></a>            }
<a name="4036"></a>        }
<a name="4037"></a>        
<a name="4038"></a>        /* 
<a name="4039"></a>         *   if we want to arouse all our key topics, then go through our list arousing them all.
<a name="4040"></a>         */
<a name="4041"></a>        
<a name="4042"></a>        
<a name="4043"></a>        /*   
<a name="4044"></a>         *   Reduce our list to a subset that only contains those TopicEntries
<a name="4045"></a>         *   that (1) are active, (2) don't yet have their curiosity satisfied,
<a name="4046"></a>         *   (3) have their curiosity aroused and (4) are reachable (i.e. they
<a name="4047"></a>         *   would actually be triggered if the player were to follow the
<a name="4048"></a>         *   suggestion). If we're trying simply to determine whether this
<a name="4049"></a>         *   TopicEntry should be suggested (i.e. when updateStatus = nil) we
<a name="4050"></a>         *   need to use slightly less stringent criteria to determine the list
<a name="4051"></a>         *   of items that we might key, since our keyed items may not have been
<a name="4052"></a>         *   activated yet.
<a name="4053"></a>         */
<a name="4054"></a>        if(updateStatus)
<a name="4055"></a>            lst = lst.subset({t: t.active &amp;&amp; !t.curiositySatisfied &amp;&amp;
<a name="4056"></a>                             t.curiosityAroused &amp;&amp; t.isReachable });
<a name="4057"></a>        else
<a name="4058"></a>            lst = lst.subset({t:t.isActive &amp;&amp; !t.curiositySatisfied});
<a name="4059"></a>            
<a name="4060"></a>        /* Remove any duplicate entries from the list. */
<a name="4061"></a>        lst = nilToList(lst).getUnique();
<a name="4062"></a>        
<a name="4063"></a>        /* Return the list. */
<a name="4064"></a>        return lst;
<a name="4065"></a>    }
<a name="4066"></a>    
<a name="4067"></a>    /*  
<a name="4068"></a>     *   Flag: may this actor add further suggestible subtopics beyond those initially defined? By
<a name="4069"></a>     *   defatult we'll assume not. This only affects the message displayed when there are no
<a name="4070"></a>     *   subtopics related to a particular parent topic left to display.
<a name="4071"></a>     */
<a name="4072"></a>    mayAddSubtopics = nil
<a name="4073"></a>       
<a name="4074"></a>    
<a name="4075"></a>    /* 
<a name="4076"></a>     *   A flag that can be set with an &lt;.activate&gt; tag. It must be true for
<a name="4077"></a>     *   this TopicEntry to be active, regardless of the value of isActive. It
<a name="4078"></a>     *   starts out true by default, but it can be set to nil on TopicEntries
<a name="4079"></a>     *   that you want to start out as inactive subsequently activate via an
<a name="4080"></a>     *   activate tag.
<a name="4081"></a>     */
<a name="4082"></a>    activated = true
<a name="4083"></a>    
<a name="4084"></a>    
<a name="4085"></a>    /* 
<a name="4086"></a>     *   Activate this TopicEntry. This would normally be called in game code
<a name="4087"></a>     *   via an &lt;.activate&gt; tag. 
<a name="4088"></a>     */
<a name="4089"></a>    activate() { activated = true; }
<a name="4090"></a>    
<a name="4091"></a>    /*  
<a name="4092"></a>     *   Deactivate this topic. This could typically be used from within the
<a name="4093"></a>     *   topicResponse of an ActorTopicEntry you only want to use once (or in
<a name="4094"></a>     *   the last entry in a StopEventList of an ActorTopicEntry). It can also
<a name="4095"></a>     *   be called via a &lt;.deactivate key&gt; tag in combination with the convKeys.
<a name="4096"></a>     */
<a name="4097"></a>    deactivate() { activated = nil; }
<a name="4098"></a>    
<a name="4099"></a>    /* 
<a name="4100"></a>     *   This TopicEntry is active if its own isActive property is true and its
<a name="4101"></a>     *   activated property is true and if its location is active. This allows
<a name="4102"></a>     *   the isActive conditions of individual TopicEntries to be combined with
<a name="4103"></a>     *   that of any TopicGroups they're in. This property should not normally
<a name="4104"></a>     *   be overridden in game code.
<a name="4105"></a>     */
<a name="4106"></a>    active = (isActive &amp;&amp; activated &amp;&amp; location.active)
<a name="4107"></a>    
<a name="4108"></a>    
<a name="4109"></a>    /* 
<a name="4110"></a>     *   Determine whether this TopicEntry is currently reachable, i.e. whether
<a name="4111"></a>     *   it could be reached if the player asked/told etc. about its matchObj on
<a name="4112"></a>     *   the next turn.
<a name="4113"></a>     */
<a name="4114"></a>    isReachable()
<a name="4115"></a>    {
<a name="4116"></a>        /* Note our associated actor */
<a name="4117"></a>        local actor = getActor;
<a name="4118"></a>        
<a name="4119"></a>        /* 
<a name="4120"></a>         *   If the actor has a current ActorState and we're in a different
<a name="4121"></a>         *   ActorState then we're reachable only if we're in the current
<a name="4122"></a>         *   ActorState
<a name="4123"></a>         */        
<a name="4124"></a>        if(actor.curState != nil &amp;&amp; location.ofKind(ActorState) 
<a name="4125"></a>           &amp;&amp; location != actor.curState)
<a name="4126"></a>            return nil;
<a name="4127"></a>        
<a name="4128"></a>                    
<a name="4129"></a>        /* 
<a name="4130"></a>         *   If we don't have a matchObj (or our matchObj is an Action) assume
<a name="4131"></a>         *   we're reachable unless certain conditions apply (e.g. we're blocked
<a name="4132"></a>         *   by a DefaultTopic).
<a name="4133"></a>         */        
<a name="4134"></a>        if(matchObj == nil || matchObj.ofKind(Action))
<a name="4135"></a>        {
<a name="4136"></a>            /* 
<a name="4137"></a>             *   if the actor doesn't have a current actor state or we're in the
<a name="4138"></a>             *   current actor state, assume we're reachable
<a name="4139"></a>             */            
<a name="4140"></a>            if(actor.curState == nil || location == actor.curState)            
<a name="4141"></a>               return true;
<a name="4142"></a>            
<a name="4143"></a>            /* 
<a name="4144"></a>             *   Otherwise, we're reachable if the current actor state doesn't
<a name="4145"></a>             *   have a DefaulTopic that might block us, or if our convKeys
<a name="4146"></a>             *   overlap with that of the actor's activeKeys
<a name="4147"></a>             */
<a name="4148"></a>            
<a name="4149"></a>            /*   First check if we're reachable by virtue of our convKeys */
<a name="4150"></a>            if(valToList(convKeys).overlapsWith(getActor.activeKeys))
<a name="4151"></a>                return true;
<a name="4152"></a>            
<a name="4153"></a>            
<a name="4154"></a>            /*   
<a name="4155"></a>             *   Then check for a DefaultTopic in the Actor's current ActorState
<a name="4156"></a>             */
<a name="4157"></a>            foreach(local prop in includeInList)
<a name="4158"></a>            {
<a name="4159"></a>                if(actor.curState.(prop).indexWhich({ t: t.ofKind(DefaultTopic)
<a name="4160"></a>                    }) != nil)
<a name="4161"></a>                    return nil;
<a name="4162"></a>            }
<a name="4163"></a>            
<a name="4164"></a>            /* 
<a name="4165"></a>             *   There's nothing obvious that makes this TopicEntry unreachable,
<a name="4166"></a>             *   so return true to say we are reachable.
<a name="4167"></a>             */
<a name="4168"></a>            return true;
<a name="4169"></a>            
<a name="4170"></a>        }
<a name="4171"></a>        
<a name="4172"></a>        /* 
<a name="4173"></a>         *   We're not reachable if the player char doesn't know about our
<a name="4174"></a>         *   matchObj
<a name="4175"></a>         */
<a name="4176"></a>        
<a name="4177"></a>        if(valToList(matchObj).indexWhich({ x: x.isClass() 
<a name="4178"></a>                                          || gPlayerChar.knowsAbout(x)}) == nil)         
<a name="4179"></a>            return nil;
<a name="4180"></a>        
<a name="4181"></a>        /* 
<a name="4182"></a>         *   Otherwise we're reachable if we're the best match for our matchObj
<a name="4183"></a>         *   according to our suggestion type
<a name="4184"></a>         */
<a name="4185"></a>        
<a name="4186"></a>        /* 
<a name="4187"></a>         *   If the author has indicated a suggestAs property, use it to
<a name="4188"></a>         *   determine which list property we should test for, otherwise use the
<a name="4189"></a>         *   first one in our own list, which should correspond to the topic
<a name="4190"></a>         *   suggestion lister's default behaviour. By this means we simulate
<a name="4191"></a>         *   the command the sugggestion lister will suggest; e.g. if it would
<a name="4192"></a>         *   suggest ASK ABOUT FOO we test whether this topic entry is reachable
<a name="4193"></a>         *   via an ASK ABOUT command, so we want to test whether its the best
<a name="4194"></a>         *   response for its matchObj from the askTopic list.
<a name="4195"></a>         */
<a name="4196"></a>        
<a name="4197"></a>        /*   
<a name="4198"></a>         *   Find the topic entry list property of our TopicDatabase that would
<a name="4199"></a>         *   be searched to find us if the player followed the suggestion to try
<a name="4200"></a>         *   us (e.g. if we would be listed as "You could ask about foo" prop
<a name="4201"></a>         *   should come out as &amp;askTopics).
<a name="4202"></a>         */
<a name="4203"></a>        local prop = (suggestAs != nil ? suggestAs.includeInList[1] :
<a name="4204"></a>                      includeInList[1]);
<a name="4205"></a>        
<a name="4206"></a>        /*   
<a name="4207"></a>         *   If we'd be sought as a QueryTopic, determine what qType we'd match;
<a name="4208"></a>         *   if we can match more than one qType, select our first one for this
<a name="4209"></a>         *   exercise.
<a name="4210"></a>         */             
<a name="4211"></a>        if(prop == &amp;queryTopics)
<a name="4212"></a>            gAction.qType = qtype.split('|')[1];
<a name="4213"></a>        
<a name="4214"></a>        /* 
<a name="4215"></a>         *   Try seeing what the best response would be if we asked our actor to
<a name="4216"></a>         *   find the best matching TopicEntry for our matchObj in its prop list
<a name="4217"></a>         *   (e.g. its askTopics list if prop is &amp;askTopics). If the result is
<a name="4218"></a>         *   this TopicEntry, then this TopicEntry is reachable, so return true.
<a name="4219"></a>         */
<a name="4220"></a>        if(actor.findBestResponse(prop, matchObj) == self)
<a name="4221"></a>            return true;
<a name="4222"></a>        
<a name="4223"></a>        /*   
<a name="4224"></a>         *   Otherwise it's not reachable, so return nil. (This might happen if
<a name="4225"></a>         *   another matching topic has a higher matchScore, for example).
<a name="4226"></a>         */
<a name="4227"></a>        return nil;           
<a name="4228"></a>            
<a name="4229"></a>    }
<a name="4230"></a>;
<a name="4231"></a> 
<a name="4232"></a>
<a name="4233"></a>/* 
<a name="4234"></a> *   CommandTopicHelper is a mix-in class for use with CommandTopic and
<a name="4235"></a> *   DefaultCommantTopic to provide some common handling for both. Its base
<a name="4236"></a> *   class LCommandTopicHelper (which provides a method for reconstructing the
<a name="4237"></a> *   text of a command issued to an actor) must be defined in the
<a name="4238"></a> *   language-specific part of the library.
<a name="4239"></a> */
<a name="4240"></a>class CommandTopicHelper: LCommandTopicHelper
<a name="4241"></a>    handleTopic()
<a name="4242"></a>    {
<a name="4243"></a>        /* Carry out the inherited handling */
<a name="4244"></a>        inherited;
<a name="4245"></a>        
<a name="4246"></a>        /* 
<a name="4247"></a>         *   If this CommandTopic allows the action our actor has been ordered
<a name="4248"></a>         *   to carry out to proceed, then execute it
<a name="4249"></a>         */
<a name="4250"></a>        if(allowAction)
<a name="4251"></a>            myAction.exec(gCommand);
<a name="4252"></a>    }
<a name="4253"></a>    
<a name="4254"></a>    /* 
<a name="4255"></a>     *   Set this to true to allow the action to proceed as commanded by the
<a name="4256"></a>     *   player.
<a name="4257"></a>     */
<a name="4258"></a>    allowAction = nil
<a name="4259"></a>        
<a name="4260"></a>    /*   
<a name="4261"></a>     *   The action our actor has been ordered to carry out, which will be the
<a name="4262"></a>     *   action on the current Command object.
<a name="4263"></a>     */
<a name="4264"></a>    myAction = (gCommand.action)
<a name="4265"></a>;
<a name="4266"></a>
<a name="4267"></a>/*  
<a name="4268"></a> *   A CommandTopic is a TopicEntry that handles a command directed at this
<a name="4269"></a> *   actor (e.g. BOB, JUMP).
<a name="4270"></a> */
<a name="4271"></a>class CommandTopic: CommandTopicHelper, ActorTopicEntry    
<a name="4272"></a>    matchTopic(top)
<a name="4273"></a>    {
<a name="4274"></a>               
<a name="4275"></a>        myAction = top;
<a name="4276"></a>        
<a name="4277"></a>        /* 
<a name="4278"></a>         *   If we've specified that this CommandTopic must match specific
<a name="4279"></a>         *   objects and the action we've been passed doesn't match them, return
<a name="4280"></a>         *   nil.
<a name="4281"></a>         */
<a name="4282"></a>        if(matchDobj != nil &amp;&amp; (top.curDobj == nil ||
<a name="4283"></a>           valToList(matchDobj).indexWhich ({x: top.curDobj.ofKind(x)}) == nil))
<a name="4284"></a>            return nil;
<a name="4285"></a>        
<a name="4286"></a>        if(matchIobj != nil &amp;&amp; (top.curIobj == nil ||
<a name="4287"></a>           valToList(matchIobj).indexWhich ({x: top.curIobj.ofKind(x)}) == nil))
<a name="4288"></a>            return nil;
<a name="4289"></a>     
<a name="4290"></a>        /* return the inherited handling */
<a name="4291"></a>        return inherited(top);
<a name="4292"></a>        
<a name="4293"></a>        
<a name="4294"></a>    }
<a name="4295"></a>    
<a name="4296"></a>    
<a name="4297"></a>    /* 
<a name="4298"></a>     *   The direct and indirect objects I must match (individually or as one of
<a name="4299"></a>     *   a list) if this CommandTopic is to be matched.
<a name="4300"></a>     */
<a name="4301"></a>    matchDobj = nil
<a name="4302"></a>    matchIobj = nil
<a name="4303"></a>    
<a name="4304"></a>    /* the action I've just matched. */
<a name="4305"></a>    myAction = nil
<a name="4306"></a>    
<a name="4307"></a>    
<a name="4308"></a>    /* 
<a name="4309"></a>     *   CommandTopics are included in the commandTopics list of their
<a name="4310"></a>     *   ActorTopicDatabase
<a name="4311"></a>     */
<a name="4312"></a>    includeInList = [&amp;commandTopics]
<a name="4313"></a>    
<a name="4314"></a>    
<a name="4315"></a>;
<a name="4316"></a>
<a name="4317"></a>/* 
<a name="4318"></a> *   A MiscTopic is an ActorTopicEntry that responds not to a conversational
<a name="4319"></a> *   command specifying a separate topic (such as ASK BOB ABOUT FRUIT) but just
<a name="4320"></a> *   to as simple command like YES, NO, HELLO or GOODBYE
<a name="4321"></a> */
<a name="4322"></a>class MiscTopic: ActorTopicEntry
<a name="4323"></a>    /* 
<a name="4324"></a>     *   A MiscTopic isn't matched to a topic in the normal sense, but we
<a name="4325"></a>     *   instead pass the routine an obj parameter to determine what particular
<a name="4326"></a>     *   kind of MiscTopic (e.g. YesTopic or ByeTopic) we want to match.
<a name="4327"></a>     */    
<a name="4328"></a>    matchTopic(obj)
<a name="4329"></a>    {
<a name="4330"></a>        /* Note the topic we're trying to match. */
<a name="4331"></a>        topicMatched = obj;
<a name="4332"></a>        
<a name="4333"></a>        /* 
<a name="4334"></a>         *   if it's one of our matching topics, return our match score,
<a name="4335"></a>         *   otherwise return a nil score to indicate failure 
<a name="4336"></a>         */
<a name="4337"></a>        return (valToList(matchObj).indexOf(obj) != nil) ? matchScore +
<a name="4338"></a>            scoreBooster(): nil;
<a name="4339"></a>    }
<a name="4340"></a>;
<a name="4341"></a>
<a name="4342"></a>/*  
<a name="4343"></a> *   A KissTopic can be used to provide a response to KISS ACTOR, provided that
<a name="4344"></a> *   we have overridden allowKiss to true on the actor object. This allows the
<a name="4345"></a> *   response to Kiss to vary according to ActorState or other conditions in a a
<a name="4346"></a> *   way that can readily be expressed in a declarative programming style
<a name="4347"></a> */
<a name="4348"></a>class KissTopic: MiscTopic
<a name="4349"></a>    /* 
<a name="4350"></a>     *   KissTopics should be included in the miscTopics list of their
<a name="4351"></a>     *   TopicDatabase (Actor or ActorState)
<a name="4352"></a>     */
<a name="4353"></a>    includeInList = [&amp;miscTopics]
<a name="4354"></a>    
<a name="4355"></a>    /*   A KissTopic matches the kissTopicObj */
<a name="4356"></a>    matchObj = kissTopicObj
<a name="4357"></a>    
<a name="4358"></a>    /*   
<a name="4359"></a>     *   A KissTopic is not regarded as conversational, since KISS ACTOR is not
<a name="4360"></a>     *   normally treated as a conversational exchange.
<a name="4361"></a>     */
<a name="4362"></a>    isConversational = nil
<a name="4363"></a>    
<a name="4364"></a>    /*   Kissing someone should not trigger a greeting */
<a name="4365"></a>    impliesGreeting = nil
<a name="4366"></a>;
<a name="4367"></a>
<a name="4368"></a>/*  The kissTopicObject is simply an object used for KissTopic to match. */
<a name="4369"></a>kissTopicObj: object;
<a name="4370"></a>
<a name="4371"></a>
<a name="4372"></a>/*  
<a name="4373"></a> *   A HitTopic can be used to respond to HIT ACTOR (or ATTACK ACTOR, etc.),
<a name="4374"></a> *   provided the actor's allowAtack property has been overridden to true
<a name="4375"></a> */
<a name="4376"></a>class HitTopic: MiscTopic
<a name="4377"></a>    /* 
<a name="4378"></a>     *   HitTopics should be included in the miscTopics list of their
<a name="4379"></a>     *   TopicDatabase (Actor or ActorState)
<a name="4380"></a>     */
<a name="4381"></a>    includeInList = [&amp;miscTopics]
<a name="4382"></a>    
<a name="4383"></a>    /* HitTopics match the hitTopicObj */
<a name="4384"></a>    matchObj = hitTopicObj
<a name="4385"></a>    
<a name="4386"></a>    /* 
<a name="4387"></a>     *   Hitting someone is not normally regarded as form of conversational
<a name="4388"></a>     *   exchange.
<a name="4389"></a>     */
<a name="4390"></a>    isConversational = nil
<a name="4391"></a>    
<a name="4392"></a>    /*  Hitting someone does not trigger a greeting */
<a name="4393"></a>    impliesGreeting = nil
<a name="4394"></a>;
<a name="4395"></a>
<a name="4396"></a>/* The hitTopicObj exists solely as something for HitTopics to match. */
<a name="4397"></a>hitTopicObj: object;
<a name="4398"></a>
<a name="4399"></a>class TouchTopic: MiscTopic
<a name="4400"></a>    /* 
<a name="4401"></a>     *   TouchTopics should be included in the miscTopics list of their
<a name="4402"></a>     *   TopicDatabase (Actor or ActorState)
<a name="4403"></a>     */
<a name="4404"></a>    includeInList = [&amp;miscTopics]
<a name="4405"></a>    
<a name="4406"></a>    /* TouchTopics match the hitTopicObj */
<a name="4407"></a>    matchObj = touchTopicObj
<a name="4408"></a>    
<a name="4409"></a>    /* 
<a name="4410"></a>     *   Touching someone is not normally regarded as form of conversational
<a name="4411"></a>     *   exchange.
<a name="4412"></a>     */
<a name="4413"></a>    isConversational = nil
<a name="4414"></a>    
<a name="4415"></a>    /*  Touching someone does not trigger a greeting */
<a name="4416"></a>    impliesGreeting = nil
<a name="4417"></a>;
<a name="4418"></a>
<a name="4419"></a>/* The touchTopicObj exists solely as something for HitTopics to match. */
<a name="4420"></a>touchTopicObj: object;
<a name="4421"></a>
<a name="4422"></a>/* A YesTopic is a TopicEntry that responds to YES or SAY YES */
<a name="4423"></a>class YesTopic: MiscTopic
<a name="4424"></a>    /* YesTopics are included in the miscTopics list of their TopicDatabase */
<a name="4425"></a>    includeInList = [&amp;miscTopics]
<a name="4426"></a>    
<a name="4427"></a>    /* YesTopics match the yesTopicObj */
<a name="4428"></a>    matchObj = yesTopicObj
<a name="4429"></a>    
<a name="4430"></a>    /* 
<a name="4431"></a>     *   We give YesTopic a name so that it can be suggested in response to a
<a name="4432"></a>     *   request to display a list of suggested topics.
<a name="4433"></a>     */
<a name="4434"></a>    name = BMsg(say yes, 'say yes')
<a name="4435"></a>;
<a name="4436"></a>
<a name="4437"></a>/* A NoTopic is a TopicEntry that responds to NO or SAY NO */
<a name="4438"></a>class NoTopic: MiscTopic
<a name="4439"></a>    /* NoTopics are included in the miscTopics list of their TopicDatabase */    
<a name="4440"></a>    includeInList = [&amp;miscTopics]
<a name="4441"></a>    
<a name="4442"></a>    /* NoTopics match the noTopicObj */
<a name="4443"></a>    matchObj = noTopicObj
<a name="4444"></a>    
<a name="4445"></a>    /* 
<a name="4446"></a>     *   We give NoTopic a name so that it can be suggested in response to a
<a name="4447"></a>     *   request to display a list of suggested topics.
<a name="4448"></a>     */
<a name="4449"></a>    name = BMsg(say no, 'say no')
<a name="4450"></a>    
<a name="4451"></a>    /* 
<a name="4452"></a>     *   We define the suggestAs property of the NoTopic so that the
<a name="4453"></a>     *   suggestedTopicLister can readily separate it from YesTopics
<a name="4454"></a>     */
<a name="4455"></a>    suggestAs = NoTopic
<a name="4456"></a>;
<a name="4457"></a>
<a name="4458"></a>/* A YesNoTopic is a TopicEntry that responds to either YES or NO */
<a name="4459"></a>class YesNoTopic: MiscTopic
<a name="4460"></a>        /* 
<a name="4461"></a>         *   YesNoTopics are included in the miscTopics list of their
<a name="4462"></a>         *   TopicDatabase
<a name="4463"></a>         */
<a name="4464"></a>    includeInList = [&amp;miscTopics]
<a name="4465"></a>    
<a name="4466"></a>    /* YesNoTopics match the yesTopicObj or the noTopicObj*/
<a name="4467"></a>    matchObj = [yesTopicObj, noTopicObj]
<a name="4468"></a>    
<a name="4469"></a>    /* 
<a name="4470"></a>     *   We give YesNoTopic a name so that it can be suggested in response to a
<a name="4471"></a>     *   request to display a list of suggested topics.
<a name="4472"></a>     */
<a name="4473"></a>    name = BMsg(say yes or no, 'say yes or no')
<a name="4474"></a>;
<a name="4475"></a>
<a name="4476"></a>/*  
<a name="4477"></a> *   A GreetingTopic is a kind of TopicEntry used in greeting protocols (saying
<a name="4478"></a> *   Hello or Goodbye). Game code will not use this class directly but will
<a name="4479"></a> *   instead use one or more of its subclasses
<a name="4480"></a> */
<a name="4481"></a>class GreetingTopic: MiscTopic
<a name="4482"></a>    includeInList = [&amp;miscTopics]
<a name="4483"></a>    impliesGreeting = nil
<a name="4484"></a>    
<a name="4485"></a>    /* 
<a name="4486"></a>     *   It may be that we want to change to a different actor state when we
<a name="4487"></a>     *   begin or end a conversation. If so the changeToState property can be
<a name="4488"></a>     *   used to specify which state to change to.
<a name="4489"></a>     */
<a name="4490"></a>    changeToState = nil
<a name="4491"></a>    
<a name="4492"></a>    /*   
<a name="4493"></a>     *   Handling a GreetingTopic includes the requested state change, if
<a name="4494"></a>     *   changeToState is defined
<a name="4495"></a>     */
<a name="4496"></a>    handleTopic()
<a name="4497"></a>    {
<a name="4498"></a>        /* 
<a name="4499"></a>         *   Carry out the inherited handling and store the result (true or nil
<a name="4500"></a>         *   for success or failure)
<a name="4501"></a>         */
<a name="4502"></a>        local result = inherited();
<a name="4503"></a>        
<a name="4504"></a>        /*  
<a name="4505"></a>         *   If changeToState is not nil, change our actor's current ActorState
<a name="4506"></a>         *   accordingly
<a name="4507"></a>         */
<a name="4508"></a>        if(changeToState != nil)
<a name="4509"></a>            getActor.setState(changeToState);        
<a name="4510"></a>        
<a name="4511"></a>        /* Return the result of the inherited handling. */
<a name="4512"></a>        return result;
<a name="4513"></a>    }
<a name="4514"></a>;
<a name="4515"></a>
<a name="4516"></a>/* 
<a name="4517"></a> *   A HelloTopic is a TopicEntry that handles an explicit greeting (the player
<a name="4518"></a> *   character explicitly saying Hello to this actor). It also handles implicit
<a name="4519"></a> *   greetings (triggered when the player enters a conversational command when a
<a name="4520"></a> *   conversation with this actor is not already going on), unless we have also
<a name="4521"></a> *   defined an ImpHelloTopic, which will then take preference.
<a name="4522"></a> */
<a name="4523"></a>class HelloTopic: GreetingTopic    
<a name="4524"></a>    /* A HelloTopic matches either helloTopicObj or impHelloTopicObj or expHelloTopicObj */
<a name="4525"></a>    matchObj = [helloTopicObj, impHelloTopicObj, expHelloTopicObj]    
<a name="4526"></a>    
<a name="4527"></a>    handleTopic()    
<a name="4528"></a>    {
<a name="4529"></a>        /* 
<a name="4530"></a>         *   Activate our actor's pending agenda items at the start of this new
<a name="4531"></a>         *   conversation.
<a name="4532"></a>         */
<a name="4533"></a>        getActor.activatePendingAgenda();
<a name="4534"></a>        
<a name="4535"></a>        /* Carry out the inherited handling and return the result. */
<a name="4536"></a>        return inherited;
<a name="4537"></a>    }
<a name="4538"></a>;
<a name="4539"></a>
<a name="4540"></a>/* 
<a name="4541"></a> *   An ImpHelloTopic is one that handles an implied greeting; i.e. it is used
<a name="4542"></a> *   to start a conversation when some other conversational command is used
<a name="4543"></a> *   before the conversation is underway.
<a name="4544"></a> */
<a name="4545"></a>class ImpHelloTopic: HelloTopic
<a name="4546"></a>    /* An ImpHelloTopic matches the impHelloTopicObj only. */
<a name="4547"></a>    matchObj = [impHelloTopicObj]
<a name="4548"></a>    
<a name="4549"></a>    /* 
<a name="4550"></a>     *   We give ImpHelloTopic a higher than usual matchScore so that it's used
<a name="4551"></a>     *   in preference to a HelloTopic when both are present to match the
<a name="4552"></a>     *   impHelloTopicObj.
<a name="4553"></a>     */
<a name="4554"></a>    matchScore = 150
<a name="4555"></a>;
<a name="4556"></a>
<a name="4557"></a>/* 
<a name="4558"></a> *   An ExpHelloTopic is one that handles an explicit greeting; i.e. it is used to start a
<a name="4559"></a> *   conversation only when the player character explcitly greets an actor, but not when some other
<a name="4560"></a> *   conversational command is used before the conversation is underway.
<a name="4561"></a> */
<a name="4562"></a>
<a name="4563"></a>class ExpHelloTopic: HelloTopic
<a name="4564"></a>    /* An ExpHelloTopic matches the expHelloTopicObj or the helloTopicObj. */
<a name="4565"></a>    matchObj = [helloTopicObj, expHelloTopicObj] 
<a name="4566"></a>    /* 
<a name="4567"></a>     *   We give ExpHelloTopic a higher than usual matchScore so that it's used
<a name="4568"></a>     *   in preference to a HelloTopic when both are present to match the
<a name="4569"></a>     *   impHelloTopicObj.
<a name="4570"></a>     */
<a name="4571"></a>    matchScore = 150
<a name="4572"></a>;
<a name="4573"></a>
<a name="4574"></a>expHelloTopicObj: object; 
<a name="4575"></a>
<a name="4576"></a>
<a name="4577"></a>
<a name="4578"></a>/*
<a name="4579"></a> *   Actor Hello topic - this handles greetings when an NPC initiates the
<a name="4580"></a> *   conversation. 
<a name="4581"></a> */
<a name="4582"></a>class ActorHelloTopic: HelloTopic    
<a name="4583"></a>    /* An ActorHelloTopic matches the actorHelloTopicObj only. */
<a name="4584"></a>    matchObj = [actorHelloTopicObj]
<a name="4585"></a>    
<a name="4586"></a>    matchScore = 200
<a name="4587"></a>
<a name="4588"></a>
<a name="4589"></a>    /* 
<a name="4590"></a>     *   If we use this as a greeting upon entering a ConvNode, we'll want
<a name="4591"></a>     *   to stay in the node afterward
<a name="4592"></a>     */
<a name="4593"></a>    noteInvocation(fromActor)
<a name="4594"></a>    {
<a name="4595"></a>        /* Carry out the inherited handling. */
<a name="4596"></a>        inherited(fromActor);
<a name="4597"></a>        
<a name="4598"></a>        /* Issue a constay tag */-
<a name="4599"></a>        "&lt;.convstay&gt;";
<a name="4600"></a>    }
<a name="4601"></a>;
<a name="4602"></a>
<a name="4603"></a>/*
<a name="4604"></a> *   A goodbye topic - this handles both explicit GOODBYE commands and
<a name="4605"></a> *   implied goodbyes.  Implied goodbyes happen when a conversation ends
<a name="4606"></a> *   without an explicit GOODBYE command, such as when the player character
<a name="4607"></a> *   walks away from the NPC, or the NPC gets bored and wanders off, or the
<a name="4608"></a> *   NPC terminates the conversation of its own volition.  
<a name="4609"></a> */
<a name="4610"></a>class ByeTopic: GreetingTopic    
<a name="4611"></a>    /* 
<a name="4612"></a>     *   This most general kind of ByeTopic matches every kind of
<a name="4613"></a>     *   conversation-ending object
<a name="4614"></a>     */
<a name="4615"></a>    matchObj = [endConvBye,
<a name="4616"></a>                 endConvLeave, endConvBoredom, endConvActor]
<a name="4617"></a>
<a name="4618"></a>    
<a name="4619"></a>;
<a name="4620"></a>
<a name="4621"></a>/* 
<a name="4622"></a> *   An implied goodbye topic.  This handles ONLY automatic (implied)
<a name="4623"></a> *   conversation endings, which happen when we walk away from an actor
<a name="4624"></a> *   we're talking to, or the other actor ends the conversation after being
<a name="4625"></a> *   ignored for too long, or the other actor ends the conversation of its
<a name="4626"></a> *   own volition via npc.endConversation().
<a name="4627"></a> *   
<a name="4628"></a> *   We use a higher-than-default matchScore so that any time we have both
<a name="4629"></a> *   a ByeTopic and an ImpByeTopic that are both active, we'll choose the
<a name="4630"></a> *   more specific ImpByeTopic.  
<a name="4631"></a> */
<a name="4632"></a>class ImpByeTopic: GreetingTopic    
<a name="4633"></a>    /* 
<a name="4634"></a>     *   The ImpByeTopic matches endConvLeave, endConvBoredom, or endConvActor
<a name="4635"></a>     *   (but not endConvBye).
<a name="4636"></a>     */
<a name="4637"></a>    matchObj = [endConvLeave, endConvBoredom, endConvActor]
<a name="4638"></a>    
<a name="4639"></a>    /* 
<a name="4640"></a>     *   Give ImpByeTopic a high matchScore so that it takes precedence over
<a name="4641"></a>     *   ByeTopic when both are present.
<a name="4642"></a>     */
<a name="4643"></a>    matchScore = 200
<a name="4644"></a>;
<a name="4645"></a>
<a name="4646"></a>
<a name="4647"></a>class ExpByeTopic: GreetingTopic    
<a name="4648"></a>    /* 
<a name="4649"></a>     *   The ExpByeTopic matches endConvBye only, i.e. when the player character explicitly says
<a name="4650"></a>     *   goodbye to another actor.
<a name="4651"></a>     */
<a name="4652"></a>    matchObj = [endConvBye]
<a name="4653"></a>    
<a name="4654"></a>    /* 
<a name="4655"></a>     *   Give ImpByeTopic a high matchScore so that it takes precedence over
<a name="4656"></a>     *   ByeTopic when both are present.
<a name="4657"></a>     */
<a name="4658"></a>    matchScore = 200
<a name="4659"></a>;
<a name="4660"></a>
<a name="4661"></a>/*
<a name="4662"></a> *   A "bored" goodbye topic.  This handles ONLY goodbyes that happen when
<a name="4663"></a> *   the actor we're talking terminates the conversation out of boredom
<a name="4664"></a> *   (i.e., after a period of inactivity in the conversation).
<a name="4665"></a> *   
<a name="4666"></a> *   Note that this is a subset of ImpByeTopic - ImpByeTopic handles
<a name="4667"></a> *   "bored" and "leaving" goodbyes, while this one handles only the
<a name="4668"></a> *   "bored" goodbyes.  You can use this kind of topic if you want to
<a name="4669"></a> *   differentiate the responses to "bored" and "leaving" conversation
<a name="4670"></a> *   endings.  
<a name="4671"></a> */
<a name="4672"></a>class BoredByeTopic: GreetingTopic    
<a name="4673"></a>    /* A BoredByeTopic matches endConvBoredom only */
<a name="4674"></a>    matchObj = [endConvBoredom]
<a name="4675"></a>    
<a name="4676"></a>    /* 
<a name="4677"></a>     *   Give BoredByeTopic an even higher matchScore so that it takes
<a name="4678"></a>     *   precedence over ImpByeTopic when both are present.
<a name="4679"></a>     */
<a name="4680"></a>    matchScore = 300
<a name="4681"></a>;
<a name="4682"></a>
<a name="4683"></a>/*
<a name="4684"></a> *   A "leaving" goodbye topic.  This handles ONLY goodbyes that happen
<a name="4685"></a> *   when the PC walks away from the actor they're talking to.
<a name="4686"></a> *   
<a name="4687"></a> *   Note that this is a subset of ImpByeTopic - ImpByeTopic handles
<a name="4688"></a> *   "bored" and "leaving" goodbyes, while this one handles only the
<a name="4689"></a> *   "leaving" goodbyes.  You can use this kind of topic if you want to
<a name="4690"></a> *   differentiate the responses to "bored" and "leaving" conversation
<a name="4691"></a> *   endings.  
<a name="4692"></a> */
<a name="4693"></a>class LeaveByeTopic: GreetingTopic    
<a name="4694"></a>    /* A LeaveByeTopic matches endConvLeave only */
<a name="4695"></a>    matchObj = [endConvLeave]
<a name="4696"></a>    
<a name="4697"></a>    /* 
<a name="4698"></a>     *   Give LeaveByeTopic an even higher matchScore so that it takes
<a name="4699"></a>     *   precedence over ImpByeTopic when both are present.
<a name="4700"></a>     */
<a name="4701"></a>    matchScore = 300
<a name="4702"></a>;
<a name="4703"></a>
<a name="4704"></a>/*
<a name="4705"></a> *   An "actor" goodbye topic.  This handles ONLY goodbyes that happen when
<a name="4706"></a> *   the NPC terminates the conversation of its own volition via
<a name="4707"></a> *   npc.endConversation(). 
<a name="4708"></a> */
<a name="4709"></a>class ActorByeTopic: GreetingTopic   
<a name="4710"></a>    /* An ActorByeTopic matches endConvActor only */
<a name="4711"></a>    matchObj = [endConvActor]
<a name="4712"></a>    
<a name="4713"></a>    /* 
<a name="4714"></a>     *   Give BoredByeTopic an even higher matchScore so that it takes
<a name="4715"></a>     *   precedence over ImpByeTopic when both are present.
<a name="4716"></a>     */
<a name="4717"></a>    matchScore = 300
<a name="4718"></a>;
<a name="4719"></a>
<a name="4720"></a>/* a topic for both HELLO and GOODBYE */
<a name="4721"></a>class HelloGoodbyeTopic: GreetingTopic    
<a name="4722"></a>    /* A HelloGoodbyeTopic matches every kind of hello and endConv object */
<a name="4723"></a>    matchObj = [helloTopicObj, impHelloTopicObj, expHelloTopicObj,
<a name="4724"></a>                 endConvBye, endConvBoredom, endConvLeave,
<a name="4725"></a>                 endConvActor]
<a name="4726"></a>    
<a name="4727"></a>    /* 
<a name="4728"></a>     *   We give HelloGoodByeTopic a slightly lower than normal matchScore to
<a name="4729"></a>     *   ensure that all the other, more specific, types of HelloTopic and
<a name="4730"></a>     *   ByeTopics take precedence over it.
<a name="4731"></a>     */
<a name="4732"></a>    matchScore = 90
<a name="4733"></a>;
<a name="4734"></a>
<a name="4735"></a>/* 
<a name="4736"></a> *   Topic singletons representing HELLO and GOODBYE topics.  These are
<a name="4737"></a> *   used as the parameter to matchTopic() when we're looking for the
<a name="4738"></a> *   response to the corresponding verbs. 
<a name="4739"></a> */
<a name="4740"></a>helloTopicObj: object;
<a name="4741"></a>endConvBye: object;
<a name="4742"></a>
<a name="4743"></a>/* 
<a name="4744"></a> *   a topic singleton for implied greetings (the kind of greeting that
<a name="4745"></a> *   happens when we jump right into a conversation with a command like
<a name="4746"></a> *   ASK ABOUT or TELL ABOUT, rather than explicitly saying HELLO first) 
<a name="4747"></a> */
<a name="4748"></a>impHelloTopicObj: object;
<a name="4749"></a>
<a name="4750"></a>/*
<a name="4751"></a> *   a topic singleton for an NPC-initiated hello (this is the kind of
<a name="4752"></a> *   greeting that happens when the NPC is the one who initiates the
<a name="4753"></a> *   conversation, via actor.initiateConversation()) 
<a name="4754"></a> */
<a name="4755"></a>actorHelloTopicObj: object;
<a name="4756"></a>
<a name="4757"></a>
<a name="4758"></a>/* 
<a name="4759"></a> *   topic singletons for the two kinds of automatic goodbyes (the kind of
<a name="4760"></a> *   conversation ending that happens when we simply walk away from an
<a name="4761"></a> *   actor we're in conversation with, or when we ignore the other actor
<a name="4762"></a> *   for enough turns that the actor gets bored and ends the conversation
<a name="4763"></a> *   of its own volition) 
<a name="4764"></a> */
<a name="4765"></a>endConvBoredom: object;
<a name="4766"></a>endConvLeave: object;
<a name="4767"></a>
<a name="4768"></a>/*
<a name="4769"></a> *   a topic singleton for an NPC-initiated goodbye (this is the kind of
<a name="4770"></a> *   goodbye that happens when the NPC is the one who breaks off the
<a name="4771"></a> *   conversation, via npc.endConversation()) 
<a name="4772"></a> */
<a name="4773"></a>endConvActor: object;
<a name="4774"></a>
<a name="4775"></a>
<a name="4776"></a>/* 
<a name="4777"></a> *   A DefaultTopic is a kind of TopicEntry for use as a fallback when the
<a name="4778"></a> *   player attempts to discuss a topic that game code doesn't explicitly cater
<a name="4779"></a> *   for.
<a name="4780"></a> */
<a name="4781"></a>class DefaultTopic: ActorTopicEntry       
<a name="4782"></a>    /* A DefaultTopic matches any Thing or Topic or yes or no */
<a name="4783"></a>    matchObj = [Thing, Topic, yesTopicObj, noTopicObj]
<a name="4784"></a>    
<a name="4785"></a>    /* 
<a name="4786"></a>     *   A DefaultTopic has a very low matchScore to allow anything more
<a name="4787"></a>     *   specific to take precedence.
<a name="4788"></a>     */
<a name="4789"></a>    matchScore = 1    
<a name="4790"></a>    
<a name="4791"></a>    
<a name="4792"></a>    /* 
<a name="4793"></a>     *   Don't match this DefaultTopic if top is one of the topics we want to
<a name="4794"></a>     *   avoid matching. Otherwise carry out the inherited handling.
<a name="4795"></a>     */
<a name="4796"></a>    matchTopic(top)
<a name="4797"></a>    {
<a name="4798"></a>        if(avoidMatching(top))
<a name="4799"></a>            return nil;
<a name="4800"></a>        else
<a name="4801"></a>            return inherited(top);
<a name="4802"></a>    }
<a name="4803"></a>    
<a name="4804"></a>    /* 
<a name="4805"></a>     *   A list of topics we don't want this DefaultTopic to match, so matching
<a name="4806"></a>     *   can fall through to another topic database to handle it (thereby
<a name="4807"></a>     *   facilitating the common handling of some topics across ActorStates).
<a name="4808"></a>     */
<a name="4809"></a>    
<a name="4810"></a>    exceptions = []
<a name="4811"></a>    
<a name="4812"></a>    /* 
<a name="4813"></a>     *   Do we want to avoid this DefaultTopic matching top, so that it can be
<a name="4814"></a>     *   matched elsewhere? By default we do so if top is listed in our
<a name="4815"></a>     *   exceptions.
<a name="4816"></a>     */
<a name="4817"></a>    
<a name="4818"></a>    avoidMatching(top)
<a name="4819"></a>    {
<a name="4820"></a>        return (valToList(exceptions).indexOf(top) != nil);
<a name="4821"></a>    }
<a name="4822"></a>;
<a name="4823"></a>
<a name="4824"></a>/* 
<a name="4825"></a> *   A DefaultAnyTopic is a DefaultTopic that can match any kind of
<a name="4826"></a> *   conversational command, except for HELLO and GOODBYE (unless matchGreetings
<a name="4827"></a> *   is true.
<a name="4828"></a> */
<a name="4829"></a> 
<a name="4830"></a>class DefaultAnyTopic: DefaultTopic
<a name="4831"></a>    /* 
<a name="4832"></a>     *   DefaultAnyTopics are included in all the lists of their TopicDatabase
<a name="4833"></a>     *   that contain lists of conversational responses.
<a name="4834"></a>     */
<a name="4835"></a>    includeInList = [&amp;sayTopics, &amp;queryTopics, &amp;askTopics, &amp;tellTopics,
<a name="4836"></a>        &amp;giveTopics, &amp;showTopics, &amp;askForTopics, &amp;talkTopics, &amp;miscTopics,
<a name="4837"></a>    &amp;commandTopics]
<a name="4838"></a>    
<a name="4839"></a>    /* 
<a name="4840"></a>     *   A DefaultAnyTopic matches any conversational command and should also
<a name="4841"></a>     *   match Commands (where the matchObj will be an action); they can
<a name="4842"></a>     *   optionally match HELLO and BYE as well.
<a name="4843"></a>     */
<a name="4844"></a>    matchObj = inherited + Action + (matchGreetings ? [helloTopicObj,
<a name="4845"></a>        endConvBye] : [])    
<a name="4846"></a> 
<a name="4847"></a>    /* 
<a name="4848"></a>     *   Flag - should we match HELLO and BYE? By default we don't since many
<a name="4849"></a>     *   DefaultAnyTopic responses won't be suitable for this purpose, but this
<a name="4850"></a>     *   can be overridden to true for DefaultAnyTopics that should match HELLO
<a name="4851"></a>     *   and BYE as well as other conversational commands.
<a name="4852"></a>     */
<a name="4853"></a>    matchGreetings = nil
<a name="4854"></a>;
<a name="4855"></a>
<a name="4856"></a>/* 
<a name="4857"></a> *   A DefaultAnyNonSayTopic matches any conversational command except SAY and should also match
<a name="4858"></a> *   Commands (where the matchObj will be an action); they can optionally match HELLO and BYE as
<a name="4859"></a> *   well. */
<a name="4860"></a>
<a name="4861"></a>class DefaultAnyNonSayTopic: DefaultAnyTopic
<a name="4862"></a>    includeInList = [&amp;queryTopics, &amp;askTopics, &amp;tellTopics,
<a name="4863"></a>        &amp;giveTopics, &amp;showTopics, &amp;askForTopics, &amp;talkTopics, &amp;miscTopics,
<a name="4864"></a>    &amp;commandTopics]
<a name="4865"></a>    
<a name="4866"></a>    matchScore = 2
<a name="4867"></a>;
<a name="4868"></a>
<a name="4869"></a>/* 
<a name="4870"></a> *   A DefaultConvstayTopic is a specialised form of DefaultAnyTopic for use in a ConvNode. It
<a name="4871"></a> *   automatically adds a &lt;.convstay&gt; (or optionally, &lt;.convstayt&gt;) tag to any response so the game
<a name="4872"></a> *   author doesn't need to type it. Additionally, unlike a normal DefaultAnyTopic it also matches
<a name="4873"></a> *   KISS, HIT and TOUCH commands, so that these won't result in players accidentally breaking out
<a name="4874"></a> *   of a ConvNode.
<a name="4875"></a> */ 
<a name="4876"></a>class DefaultConvstayTopic: DefaultAnyTopic
<a name="4877"></a>    /* 
<a name="4878"></a>     *   We want to match kissTopicObj, hitTopicObj &amp; touchTopicObj in addition to everything
<a name="4879"></a>     *   DefaultAnyTopic matches. 
<a name="4880"></a>     */
<a name="4881"></a>    matchObj = inherited + (matchNonConv ? [kissTopicObj, hitTopicObj, touchTopicObj] : [])
<a name="4882"></a>    
<a name="4883"></a>    /* 
<a name="4884"></a>     *   If we've matched kissTopicObj. hitTopicObj or touchTopicObj then display our
<a name="4885"></a>     *   nonConvResponse, otherwiae carry out our inherited handling.
<a name="4886"></a>     */
<a name="4887"></a>    handleTopic()
<a name="4888"></a>    {
<a name="4889"></a>        if(topicMatched is in (kissTopicObj, hitTopicObj, touchTopicObj))        
<a name="4890"></a>            nonConvResponse;        
<a name="4891"></a>        else
<a name="4892"></a>            inherited;
<a name="4893"></a>        
<a name="4894"></a>        /* Either way add a convstay tag to keep us in our current ConvNode */
<a name="4895"></a>        say(convstayTag);
<a name="4896"></a>    }
<a name="4897"></a>    
<a name="4898"></a>    /* 
<a name="4899"></a>     *   If we've matched kiss, hit or touch we're not converstaiona. Otherwise use our inherited
<a name="4900"></a>     *   handling.
<a name="4901"></a>     */
<a name="4902"></a>    isConversational
<a name="4903"></a>    {
<a name="4904"></a>        return topicMatched is in (kissTopicObj, hitTopicObj, touchTopicObj) ? nil : inherited;
<a name="4905"></a>    }
<a name="4906"></a>    
<a name="4907"></a>    /* 
<a name="4908"></a>     *   Do we want this DefaultTopic to match the non-conversational commands KISS, HIT and FEEL?.
<a name="4909"></a>     *   By default we so as we probably don't want these commands to break our of the ConvNode.
<a name="4910"></a>     */    
<a name="4911"></a>    matchNonConv = true
<a name="4912"></a>    
<a name="4913"></a>    
<a name="4914"></a>    /* The response we show to KISS, HIT, or FEEL. Game code can override. */
<a name="4915"></a>    nonConvResponse = DMsg(non conv response, 'Best keep {my} mind on the conversation. ')
<a name="4916"></a>    
<a name="4917"></a>    /* 
<a name="4918"></a>     *   The tag to add to the end of every response. By default this is &lt;.convstay&gt; but game code
<a name="4919"></a>     *   could override it to &lt;.convstayt&gt; (or even to a &lt;.convode...&gt; tag if you wanted every
<a name="4920"></a>     *   response to lead to a new ConvMode).
<a name="4921"></a>     */
<a name="4922"></a>    convstayTag = '&lt;.convstay&gt;'
<a name="4923"></a>;
<a name="4924"></a>
<a name="4925"></a>
<a name="4926"></a>
<a name="4927"></a>/* 
<a name="4928"></a> *   A DefaultAgendaTopic can be used to give the actor the opportunity to seize
<a name="4929"></a> *   the conversational initiative when the player enters a conversational
<a name="4930"></a> *   command for which there's no explicit match. Instead of giving a bland
<a name="4931"></a> *   default response the actor can instead respond with an item from its own
<a name="4932"></a> *   agenda, e.g. "Never mind that, what I really want to know is...".
<a name="4933"></a> *
<a name="4934"></a> *   Items can be added to the agenda of a DefaultAgendaTopic by calling its
<a name="4935"></a> *   addToAgenda method. To obtain a reference to a DefaultAgendaTopic use the
<a name="4936"></a> *   defaultAgendaTopic property of the Actor or ActorState in which it is
<a name="4937"></a> *   located (note, therefore, that there should only be at most one of these
<a name="4938"></a> *   per Actor or Actor State).
<a name="4939"></a> *
<a name="4940"></a> *   Note that you should define the topicResponse or eventList property of a
<a name="4941"></a> *   DefaultAgendaTopic in case none of the agenda items in its agenda list turn
<a name="4942"></a> *   out to be executable.
<a name="4943"></a> */
<a name="4944"></a>class DefaultAgendaTopic: AgendaManager, DefaultAnyTopic
<a name="4945"></a>    
<a name="4946"></a>    handleTopic()
<a name="4947"></a>    {
<a name="4948"></a>        /* 
<a name="4949"></a>         *   Try to execute our next agenda item. If this fails fall back on our
<a name="4950"></a>         *   inherited handling.
<a name="4951"></a>         */        
<a name="4952"></a>        if(!executeAgenda())
<a name="4953"></a>            inherited();
<a name="4954"></a>    }
<a name="4955"></a>    
<a name="4956"></a>    /* 
<a name="4957"></a>     *   This kind of Default Topic is active only when it has any agenda items
<a name="4958"></a>     *   to process.
<a name="4959"></a>     */   
<a name="4960"></a>    active = inherited &amp;&amp; agendaList != nil &amp;&amp; 
<a name="4961"></a>           agendaList.indexWhich({x: x.isReady})
<a name="4962"></a>    
<a name="4963"></a>    /* 
<a name="4964"></a>     *   When this DefaultTopic is active we want it to take priority over over
<a name="4965"></a>     *   DefaultTopics.
<a name="4966"></a>     */
<a name="4967"></a>    matchScore = 10
<a name="4968"></a>;
<a name="4969"></a>
<a name="4970"></a>/* 
<a name="4971"></a> *   A DefaultConversationTopic is a DefaultTopic that matches any strictly
<a name="4972"></a> *   conversational command; it matches everything a DefaultAnyTopic matches
<a name="4973"></a> *   apart from GIVE and SHOW (which don't necessarily imply verbal exchanges)
<a name="4974"></a> */
<a name="4975"></a>class DefaultConversationTopic: DefaultTopic
<a name="4976"></a>    includeInList = [&amp;sayTopics, &amp;queryTopics, &amp;askTopics, &amp;tellTopics,
<a name="4977"></a>        &amp;askForTopics, &amp;talkTopics]
<a name="4978"></a>    matchScore = 2
<a name="4979"></a>;
<a name="4980"></a>
<a name="4981"></a>/* 
<a name="4982"></a> *   A DefaultConversationTopic is a DefaultConverationTopic that matches any strictly
<a name="4983"></a> *   conversational command apart from SAY.
<a name="4984"></a> */
<a name="4985"></a>class DefaultNonSayTopic: DefaultConversationTopic
<a name="4986"></a>    includeInList = [&amp;queryTopics, &amp;askTopics, &amp;tellTopics,
<a name="4987"></a>        &amp;askForTopics, &amp;talkTopics]
<a name="4988"></a>    
<a name="4989"></a>    matchScore = 3
<a name="4990"></a>;
<a name="4991"></a>
<a name="4992"></a>/* Default Topic to match ASK ABOUT and TELL ABOUT */
<a name="4993"></a>class DefaultAskTellTopic: DefaultTopic
<a name="4994"></a>    includeInList = [&amp;askTopics, &amp;tellTopics]
<a name="4995"></a>    matchScore = 4    
<a name="4996"></a>;
<a name="4997"></a>
<a name="4998"></a>/* Default Topic to match GIVE and SHOW */
<a name="4999"></a>class DefaultGiveShowTopic: DefaultTopic
<a name="5000"></a>    includeInList = [&amp;giveTopics, &amp;showTopics]
<a name="5001"></a>    matchScore = 4
<a name="5002"></a>;
<a name="5003"></a>
<a name="5004"></a>/* Default Topic to match ASK ABOUT */
<a name="5005"></a>class DefaultAskTopic: DefaultTopic
<a name="5006"></a>    includeInList = [&amp;askTopics]
<a name="5007"></a>    matchScore = 5
<a name="5008"></a>;
<a name="5009"></a>
<a name="5010"></a>/* Default Topic to match TELL (SOMEONE) ABOUT */
<a name="5011"></a>class DefaultTellTopic: DefaultTopic
<a name="5012"></a>    includeInList = [&amp;tellTopics]
<a name="5013"></a>    matchScore = 5
<a name="5014"></a>;
<a name="5015"></a>
<a name="5016"></a>/* Default Topic to match TALK ABOUT */
<a name="5017"></a>class DefaultTalkTopic: DefaultTopic
<a name="5018"></a>    includeInList = [&amp;talkTopics]
<a name="5019"></a>    matchScore = 5
<a name="5020"></a>;
<a name="5021"></a>
<a name="5022"></a>/* Default Topic to match GIVE (something to someone) */
<a name="5023"></a>class DefaultGiveTopic: DefaultTopic 
<a name="5024"></a>    includeInList = [&amp;giveTopics]
<a name="5025"></a>    matchScore = 5
<a name="5026"></a>;
<a name="5027"></a>
<a name="5028"></a>/* Default Topic to match SHOW (something to someone) */
<a name="5029"></a>class DefaultShowTopic: DefaultTopic
<a name="5030"></a>    includeInList = [&amp;showTopics]
<a name="5031"></a>    matchScore = 5
<a name="5032"></a>;
<a name="5033"></a>
<a name="5034"></a>/* Default Topic to match ASK (someone) FOR (something) */
<a name="5035"></a>class DefaultAskForTopic: DefaultTopic
<a name="5036"></a>    includeInList = [&amp;askForTopics]
<a name="5037"></a>    matchScore = 5
<a name="5038"></a>;
<a name="5039"></a>
<a name="5040"></a>/* Default Topic to match SAY (something) */
<a name="5041"></a>class DefaultSayTopic: DefaultTopic
<a name="5042"></a>    includeInList = [&amp;sayTopics]
<a name="5043"></a>    matchScore = 5
<a name="5044"></a>    
<a name="5045"></a>    topicResponse = "&lt;&lt;(getActor.defaultSayResponse)&gt;&gt;"
<a name="5046"></a>;
<a name="5047"></a>
<a name="5048"></a>
<a name="5049"></a>/* Default Topic to match ASK (WHO/WHAT/WHY/WHERE/WHEN/HOW/IF) */
<a name="5050"></a>class DefaultQueryTopic: DefaultTopic
<a name="5051"></a>    includeInList = [&amp;queryTopics]
<a name="5052"></a>    matchScore = 5
<a name="5053"></a>;
<a name="5054"></a>
<a name="5055"></a>/* Default Topic to match SAY (something) or ASK (WHO/WHAT/WHY etc.) */
<a name="5056"></a>class DefaultSayQueryTopic: DefaultTopic
<a name="5057"></a>    includeInList = [&amp;sayTopics, &amp;queryTopics]
<a name="5058"></a>    matchScore = 4
<a name="5059"></a>;
<a name="5060"></a>
<a name="5061"></a>/* DefaultTopic to match SAY (something) OR TELL (someone) ABOUT (something) */
<a name="5062"></a>class DefaultSayTellTopic: DefaultTopic
<a name="5063"></a>    includeInList = [&amp;sayTopics, &amp;tellTopics]
<a name="5064"></a>    matchScore = 4
<a name="5065"></a>;
<a name="5066"></a>
<a name="5067"></a>/* 
<a name="5068"></a> *   DefaultTopic to match TELL (someone) ABOUT (something) OR TALK ABOUT
<a name="5069"></a> *   (something)
<a name="5070"></a> */
<a name="5071"></a>class DefaultTellTalkTopic: DefaultTopic
<a name="5072"></a>    includeInList = [&amp;tellTopics, &amp;talkTopics]
<a name="5073"></a>    matchScore = 4
<a name="5074"></a>;
<a name="5075"></a>
<a name="5076"></a>/* 
<a name="5077"></a> *   DefaultTopic to match SAY (something) OR TELL (someone) ABOUT (something)
<a name="5078"></a> *   OR TALK ABOUT (something)
<a name="5079"></a> */
<a name="5080"></a>class DefaultSayTellTalkTopic: DefaultTopic
<a name="5081"></a>    includeInList = [&amp;sayTopics, &amp;tellTopics, &amp;talkTopics]
<a name="5082"></a>    matchScore = 3
<a name="5083"></a>;
<a name="5084"></a>
<a name="5085"></a>/* Default Topic to match ASK ABOUT/HOW/WHAT/WHY/WHEN/WHO/IF/WHERE etc */
<a name="5086"></a>class DefaultAskQueryTopic: DefaultTopic
<a name="5087"></a>    includeInList = [&amp;queryTopics, &amp;askTopics]
<a name="5088"></a>    matchScore = 4
<a name="5089"></a>;
<a name="5090"></a>
<a name="5091"></a>/* 
<a name="5092"></a> *   DefaultTopic to match orders directed to this actor by the player
<a name="5093"></a> *   (character)
<a name="5094"></a> */
<a name="5095"></a>class DefaultCommandTopic: CommandTopicHelper, DefaultTopic
<a name="5096"></a>    includeInList = [&amp;commandTopics]
<a name="5097"></a>    matchScore = 5
<a name="5098"></a>    matchObj = [Action]
<a name="5099"></a>;
<a name="5100"></a>
<a name="5101"></a>/* A TopicEntry that matches ASK ABOUT */
<a name="5102"></a>class AskTopic: ActorTopicEntry
<a name="5103"></a>    includeInList = [&amp;askTopics]
<a name="5104"></a>;
<a name="5105"></a>
<a name="5106"></a>/* A TopicEntry that matches TELL ABOUT */
<a name="5107"></a>class TellTopic: ActorTopicEntry
<a name="5108"></a>    includeInList = [&amp;tellTopics]
<a name="5109"></a>;
<a name="5110"></a>
<a name="5111"></a>/* A TopicEntry that matches ASK ABOUT or TELL ABOUT*/
<a name="5112"></a>class AskTellTopic: ActorTopicEntry
<a name="5113"></a>    includeInList = [&amp;askTopics, &amp;tellTopics]
<a name="5114"></a>;
<a name="5115"></a>
<a name="5116"></a>/* A TopicEntry that matches ASK ABOUT or TELL ABOUT or SHOW*/
<a name="5117"></a>class AskTellShowTopic: ActorTopicEntry
<a name="5118"></a>    includeInList = [&amp;askTopics, &amp;tellTopics, &amp;showTopics]
<a name="5119"></a>;
<a name="5120"></a>
<a name="5121"></a>/* A TopicEntry that matches ASK ABOUT or TELL ABOUT or GIVE or SHOW*/
<a name="5122"></a>class AskTellGiveShowTopic: ActorTopicEntry
<a name="5123"></a>    includeInList = [&amp;askTopics, &amp;tellTopics, &amp;giveTopics, &amp;showTopics]   
<a name="5124"></a>;
<a name="5125"></a>
<a name="5126"></a>/* A TopicEntry that matches ASK FOR */
<a name="5127"></a>class AskForTopic: ActorTopicEntry
<a name="5128"></a>    includeInList = [&amp;askForTopics]
<a name="5129"></a>;
<a name="5130"></a>
<a name="5131"></a>/* A TopicEntry that matches ASK ABOUT or ASK FOR*/
<a name="5132"></a>class AskAboutForTopic: ActorTopicEntry
<a name="5133"></a>    includeInList = [&amp;askForTopics, &amp;askTopics]
<a name="5134"></a>;
<a name="5135"></a>
<a name="5136"></a>/* A TopicEntry that matches GIVE TO */
<a name="5137"></a>class GiveTopic: ActorTopicEntry
<a name="5138"></a>    includeInList = [&amp;giveTopics]
<a name="5139"></a>;
<a name="5140"></a>
<a name="5141"></a>/* A TopicEntry that matches SHOW TO */
<a name="5142"></a>class ShowTopic: ActorTopicEntry
<a name="5143"></a>    includeInList = [&amp;showTopics]
<a name="5144"></a>;
<a name="5145"></a>
<a name="5146"></a>/* A TopicEntry that matches GIVE TO or SHOW TO */
<a name="5147"></a>class GiveShowTopic: ActorTopicEntry
<a name="5148"></a>    includeInList = [&amp;giveTopics, &amp;showTopics]
<a name="5149"></a>;
<a name="5150"></a>
<a name="5151"></a>class TellTalkShowTopic: ActorTopicEntry
<a name="5152"></a>    includeInList = [&amp;tellTopics, &amp;talkTopics, &amp;showTopics]   
<a name="5153"></a>;
<a name="5154"></a>
<a name="5155"></a>
<a name="5156"></a>/* 
<a name="5157"></a> *   SpecialTopic is the base class for two kinds of TopicEntry that extend the
<a name="5158"></a> *   conversation system beyong basic ask/tell: SayTopic and QueryTopic. The
<a name="5159"></a> *   SpecialTopic class defines the common handling but is not used directly in
<a name="5160"></a> *   game code, which will use either SayTopic or QueryTopic
<a name="5161"></a> */
<a name="5162"></a>class SpecialTopic: ActorTopicEntry
<a name="5163"></a>    
<a name="5164"></a>    /* 
<a name="5165"></a>     *   Carry out the initialization (actually preinitialization) of a
<a name="5166"></a>     *   SpecialTopic
<a name="5167"></a>     */
<a name="5168"></a>    initializeTopicEntry()
<a name="5169"></a>    {
<a name="5170"></a>        /* First carry out the inherited handling */
<a name="5171"></a>        inherited;
<a name="5172"></a>        
<a name="5173"></a>        
<a name="5174"></a>        /* 
<a name="5175"></a>         *   if the matchPattern contains a semi-colon assume it's not a regex
<a name="5176"></a>         *   match pattern but the vocab for a new Topic object.
<a name="5177"></a>         */        
<a name="5178"></a>        
<a name="5179"></a>        if(matchPattern != nil &amp;&amp; (matchPattern.find(';') != nil ||                             
<a name="5180"></a>                                   matchPattern.find(rex) == nil))            
<a name="5181"></a>        {
<a name="5182"></a>            /* 
<a name="5183"></a>             *   first see if there's already a Topic that has our matchPattern
<a name="5184"></a>             *   as its vocab.
<a name="5185"></a>             */            
<a name="5186"></a>            matchObj = findMatchingTopic(matchPattern);
<a name="5187"></a>            
<a name="5188"></a>            /* if we found a matching topic, we're done. */
<a name="5189"></a>            if(matchObj != nil)
<a name="5190"></a>            {
<a name="5191"></a>                /* set the matchPattern to nil, since we shan't be using it. */
<a name="5192"></a>                matchPattern = nil;               
<a name="5193"></a>            }
<a name="5194"></a>            else
<a name="5195"></a>            {
<a name="5196"></a>                
<a name="5197"></a>                /* create a new Topic object using the matchPattern as its vocab */
<a name="5198"></a>                matchObj = new Topic(matchPattern);
<a name="5199"></a>                
<a name="5200"></a>                /* then set the matchPattern to nil, since we shan't be using it. */
<a name="5201"></a>                matchPattern = nil;
<a name="5202"></a>                
<a name="5203"></a>                /* add the new matchObj to the universal scope list */
<a name="5204"></a>                World.universalScope += matchObj;
<a name="5205"></a>            }
<a name="5206"></a>        }
<a name="5207"></a>        
<a name="5208"></a>        /* 
<a name="5209"></a>         *   Although the inherited handling might have built our name property
<a name="5210"></a>         *   already, it won't have done if we created our matchObj from our
<a name="5211"></a>         *   matchPattern property, so if need be we try building it again here.
<a name="5212"></a>         */
<a name="5213"></a>        if(autoName)
<a name="5214"></a>           buildName();
<a name="5215"></a>        
<a name="5216"></a>        /* 
<a name="5217"></a>         *   It may be we want this SpecialTopic also to respond to a
<a name="5218"></a>         *   conventional ASK ABOUT X or TELL ABOUT X. We can do this by
<a name="5219"></a>         *   defining the askMatchObj and tellMatchObj properties.
<a name="5220"></a>         *
<a name="5221"></a>         *   First check if our askMatchObj is non-nil and equal to our
<a name="5222"></a>         *   tellMatchObj. If so then we want this SpecialTopic also to behave
<a name="5223"></a>         *   like an AskTellTopic that matches askMatchObj. To that end we
<a name="5224"></a>         *   create a SlaveTopic to represent the AskTellTopic
<a name="5225"></a>         */
<a name="5226"></a>        if(askMatchObj != nil &amp;&amp; askMatchObj == tellMatchObj)
<a name="5227"></a>        {
<a name="5228"></a>            new SlaveTopic(askMatchObj, self, [&amp;askTopics, &amp;tellTopics]);            
<a name="5229"></a>        }
<a name="5230"></a>        
<a name="5231"></a>        /* 
<a name="5232"></a>         *   Otherwise, if we have an askMatchObj, create a SlaveTopic to
<a name="5233"></a>         *   represent us as an AskTopic so that we also match ASK ABOUT
<a name="5234"></a>         *   askMatchObj.
<a name="5235"></a>         */
<a name="5236"></a>        else if(askMatchObj != nil)
<a name="5237"></a>            new SlaveTopic(askMatchObj, self, [&amp;askTopics]);
<a name="5238"></a>        
<a name="5239"></a>        /*   
<a name="5240"></a>         *   If we have a tellMatchObj that's different from our askMatchObj
<a name="5241"></a>         *   (and non-nil), create a new SlaveTopic to represent a TellTopic
<a name="5242"></a>         *   that we also match.
<a name="5243"></a>         */
<a name="5244"></a>        if(tellMatchObj != nil &amp;&amp; tellMatchObj != askMatchObj)
<a name="5245"></a>            new SlaveTopic(tellMatchObj, self, [&amp;tellTopics]);
<a name="5246"></a>    }
<a name="5247"></a>    
<a name="5248"></a>    /* 
<a name="5249"></a>     *   A Regular expression pattern to look for the kinds of characters we'd expect to find in our
<a name="5250"></a>     *   matchPattern property if it actually represents a regular expression for this TopicEntry to
<a name="5251"></a>     *   match. We use this to help determine whether the matchPattern property contains a regex to
<a name="5252"></a>     *   match or the vocab of a Topic object to create on the fly. In tge latest version we exclude
<a name="5253"></a>     *   parentheses from the match pattern since these could be used to mark weak tokens in an
<a name="5254"></a>     *   ordinary name rather than indicating a regular expression.
<a name="5255"></a>     */    
<a name="5256"></a>//    rex = static new RexPattern('&lt;langle|rangle|star|dollar|vbar|percent|caret|lparen|rparen&gt;')
<a name="5257"></a>    
<a name="5258"></a>    rex = static new RexPattern('&lt;langle|rangle|star|dollar|vbar|percent|caret')
<a name="5259"></a>    
<a name="5260"></a>    /* 
<a name="5261"></a>     *   If we want this SpecialTopic also to match an ASK ABOUT command, define
<a name="5262"></a>     *   the askMatchObj to hold the topic or list of topics that said ASK ABOUT
<a name="5263"></a>     *   command should match here.
<a name="5264"></a>     */
<a name="5265"></a>    askMatchObj = nil
<a name="5266"></a>    
<a name="5267"></a>    /* 
<a name="5268"></a>     *   If we want this SpecialTopic also to match an TELL ABOUT command,
<a name="5269"></a>     *   define the askMatchObj to hold the topic or list of topics that said
<a name="5270"></a>     *   TELL ABOUT command should match here.
<a name="5271"></a>     */
<a name="5272"></a>    tellMatchObj = nil
<a name="5273"></a>    
<a name="5274"></a>    /* 
<a name="5275"></a>     *   For a SpeciallTopic make constructing a name property automatically the
<a name="5276"></a>     *   default.
<a name="5277"></a>     */
<a name="5278"></a>    autoName = true
<a name="5279"></a>    
<a name="5280"></a>;
<a name="5281"></a>
<a name="5282"></a>/*  
<a name="5283"></a> *   A SlaveTopic is a special kind of TopicEntry created by a SpecialTopic to
<a name="5284"></a> *   function as an AskTopic, TellTopic or AskTellTopic that produces the same
<a name="5285"></a> *   response at the SpecialTopic. Game code would not normally define
<a name="5286"></a> *   SlaveTopics directly
<a name="5287"></a> */
<a name="5288"></a>class SlaveTopic: ActorTopicEntry
<a name="5289"></a>    
<a name="5290"></a>    /* Construct a SlaveTopic */
<a name="5291"></a>    construct(matchObj_, masterObj_, includeInList_)
<a name="5292"></a>    {
<a name="5293"></a>        /* Note the Topic/Object (or objects) this TopicEntry should match. */           
<a name="5294"></a>        matchObj = matchObj_;
<a name="5295"></a>        
<a name="5296"></a>        /* 
<a name="5297"></a>         *   Note our masterObj, which will be the SpecialTopic that called our
<a name="5298"></a>         *   c constructor.
<a name="5299"></a>         */
<a name="5300"></a>        masterObj = masterObj_;
<a name="5301"></a>        
<a name="5302"></a>        /*  Note which list or lists of TopicEntries we should be included in */
<a name="5303"></a>        includeInList = includeInList_;
<a name="5304"></a>        
<a name="5305"></a>        /*  Our location is the same as our masterObj's location. */
<a name="5306"></a>        location = masterObj.location;
<a name="5307"></a>        
<a name="5308"></a>        /*  Our matchScore is the same as our masterObj's matchScore. */
<a name="5309"></a>        matchScore = masterObj.matchScore;
<a name="5310"></a>        
<a name="5311"></a>        /*  Our scoreBoost is the same as our masterObj's location. */
<a name="5312"></a>        scoreBoost = masterObj.scoreBoost;
<a name="5313"></a>        
<a name="5314"></a>        /* Carry out our initialization as a TopicEntry. */
<a name="5315"></a>        initializeTopicEntry();
<a name="5316"></a>    }
<a name="5317"></a>    
<a name="5318"></a>    initializeTopicEntry()
<a name="5319"></a>    {
<a name="5320"></a>        /* 
<a name="5321"></a>         *   Only carry out our initialization if we haven't been initialized
<a name="5322"></a>         *   already.
<a name="5323"></a>         */
<a name="5324"></a>        if(!initialized)
<a name="5325"></a>        {
<a name="5326"></a>            /* Carry out the inherited handling. */
<a name="5327"></a>            inherited();
<a name="5328"></a>            
<a name="5329"></a>            /* Note that we've now been initialized. */
<a name="5330"></a>            initialized = true;
<a name="5331"></a>        }
<a name="5332"></a>    }
<a name="5333"></a>    
<a name="5334"></a>    /* 
<a name="5335"></a>     *   To handle this topic we simply call the handleTopic method on our
<a name="5336"></a>     *   masterObj (i.e. the SpecialTopic that created us)
<a name="5337"></a>     */
<a name="5338"></a>    handleTopic() { masterObj.handleTopic(); }
<a name="5339"></a>    
<a name="5340"></a>    /* Our masterObj is the SpecialTopic that created us */
<a name="5341"></a>    masterObj = nil
<a name="5342"></a>    
<a name="5343"></a>    /* Flag: has this SlaveTopic already been initialized. */
<a name="5344"></a>    initialized = nil
<a name="5345"></a>;
<a name="5346"></a>
<a name="5347"></a>/* 
<a name="5348"></a> *   A QueryTopic is a kind of SpecialTopic that extends the range of questions
<a name="5349"></a> *   that the player (character) can ask an NPC from ASK ABOUT so-and-so to ASK
<a name="5350"></a> *   WHO/WHAT/WHY/WHERE/WHETHER/IF/HOW so-and-so. The type of question to be
<a name="5351"></a> *   matched (who/what/why/when etc.) needs to be defined on a QueryTopic's
<a name="5352"></a> *   qType property (so that it can be matched by the QueryTopic's grammar). The
<a name="5353"></a> *   remainder of the question is the Topic a particular QueryTopic matches.
<a name="5354"></a> */
<a name="5355"></a>class QueryTopic: SpecialTopic
<a name="5356"></a>    
<a name="5357"></a>    /* 
<a name="5358"></a>     *   Check whether this QueryTopic matches the question asked. For it to do
<a name="5359"></a>     *   so it must match not only the topic but the qType (query type)
<a name="5360"></a>     */
<a name="5361"></a>    matchTopic(top)
<a name="5362"></a>    {
<a name="5363"></a>        /* 
<a name="5364"></a>         *   A QueryTopic can match more than one query type, so first we split
<a name="5365"></a>         *   our qType property into a potential list.
<a name="5366"></a>         */
<a name="5367"></a>        local qtList = qtype.split('|');
<a name="5368"></a>        
<a name="5369"></a>        /* 
<a name="5370"></a>         *   If the action's qType isn't in our list of qTypes, then we don't
<a name="5371"></a>         *   match the question asked, so return nil to indicate a failure to
<a name="5372"></a>         *   match.
<a name="5373"></a>         */
<a name="5374"></a>        if(qtList.indexOf(gAction.qType) == nil)
<a name="5375"></a>            return nil;
<a name="5376"></a>        
<a name="5377"></a>        /* 
<a name="5378"></a>         *   This will be the case if the player just typed a command like ASK WHY or ASK WHERE, in
<a name="5379"></a>         *   which case if we have a QueryTopic that might match it, we'll accept it.
<a name="5380"></a>         */
<a name="5381"></a>        if(top.vocab == gAction.qType + '!')
<a name="5382"></a>            return matchScore() + scoreBoost();
<a name="5383"></a>                
<a name="5384"></a>        /* 
<a name="5385"></a>         *   Otherwise carry out the inherited handling to see whether we match
<a name="5386"></a>         *   the topic (i.e., the rest of the question following the qType word)
<a name="5387"></a>         */
<a name="5388"></a>        return inherited(top);
<a name="5389"></a>    }
<a name="5390"></a>    
<a name="5391"></a>    /* 
<a name="5392"></a>     *   The list of query types we match, e.g. 'where'. To match multiple types
<a name="5393"></a>     *   list them divided by a vertical bar, e.g. 'if|whether'
<a name="5394"></a>     */
<a name="5395"></a>    qtype = nil    
<a name="5396"></a>    
<a name="5397"></a>    
<a name="5398"></a>    initializeTopicEntry()
<a name="5399"></a>    {
<a name="5400"></a>        /* 
<a name="5401"></a>         *   If qtype isn't specified but matchPattern is, take the first word
<a name="5402"></a>         *   of the matchPattern to be the qtype.
<a name="5403"></a>         */
<a name="5404"></a>        if(qtype == nil &amp;&amp; matchPattern != nil)
<a name="5405"></a>        {
<a name="5406"></a>            /* 
<a name="5407"></a>             *   Find the first space in our matchPattern string. This should
<a name="5408"></a>             *   mark the end of the first word.
<a name="5409"></a>             */
<a name="5410"></a>            local idx = matchPattern.find(' ');
<a name="5411"></a>            
<a name="5412"></a>            /* Only do anything if we find a space */
<a name="5413"></a>            if(idx)
<a name="5414"></a>            {
<a name="5415"></a>                /* 
<a name="5416"></a>                 *   Take the qType to be the first word, i.e. the beginning of
<a name="5417"></a>                 *   the string up to but not including the first space
<a name="5418"></a>                 */
<a name="5419"></a>                qtype = matchPattern.substr(1, idx - 1);
<a name="5420"></a>                
<a name="5421"></a>                /*   
<a name="5422"></a>                 *   Take the true matchPattern -- or rather the Topic vocab --
<a name="5423"></a>                 *   to be the rest of the matchPattern string following the
<a name="5424"></a>                 *   first space.
<a name="5425"></a>                 */
<a name="5426"></a>                matchPattern = matchPattern.substr(idx + 1).trim();
<a name="5427"></a>            }
<a name="5428"></a>            
<a name="5429"></a>        }
<a name="5430"></a>     
<a name="5431"></a>        /* Carry out the inherited handling. */
<a name="5432"></a>        inherited;    
<a name="5433"></a>    }
<a name="5434"></a>    
<a name="5435"></a>    /* 
<a name="5436"></a>     *   When we build the name of a QueryTopic (for use in a list of topic
<a name="5437"></a>     *   suggestions) we need to include the query type (qType).
<a name="5438"></a>     */
<a name="5439"></a>    buildName()
<a name="5440"></a>    {
<a name="5441"></a>        /* 
<a name="5442"></a>         *   Don't attempt to construct the name if we already have one or we
<a name="5443"></a>         *   don't have a matchObj.
<a name="5444"></a>         */
<a name="5445"></a>        if(name == nil &amp;&amp; matchObj != nil)
<a name="5446"></a>        {
<a name="5447"></a>            /* 
<a name="5448"></a>             *   Split our qType property into a list of query types, since it
<a name="5449"></a>             *   could be specified as several possible types separated by
<a name="5450"></a>             *   vertical bars
<a name="5451"></a>             */
<a name="5452"></a>            local qList = qtype.split('|');
<a name="5453"></a>            
<a name="5454"></a>            /*   
<a name="5455"></a>             *   Prepend the first word from the query type list to the name of
<a name="5456"></a>             *   our matchObj to create our name
<a name="5457"></a>             */
<a name="5458"></a>            name = qList[1] + ' ' + valToList(matchObj)[1].name; 
<a name="5459"></a>        }
<a name="5460"></a>    }
<a name="5461"></a>    
<a name="5462"></a>    /* A QueryTopic belongs in the queryTopics list of its TopicDatabase */
<a name="5463"></a>    includeInList = [&amp;queryTopics]          
<a name="5464"></a>;
<a name="5465"></a>
<a name="5466"></a>
<a name="5467"></a>/* 
<a name="5468"></a> *   A SayTopic is a kind of SpecialTopic that allows the player (character) to
<a name="5469"></a> *   say virtually anything (within reason) to an NPC; a SayTopic may be
<a name="5470"></a> *   triggered by a command that explicitly begins with SAY, but it may also be
<a name="5471"></a> *   triggered by any combination of words that matches its matchObj and doesn't
<a name="5472"></a> *   correspond to any other recognizable command. This allows the player to
<a name="5473"></a> *   respond, for example, with either SAY YOU DON'T KNOW or just I DON'T KNOW,
<a name="5474"></a> *   to trigger an appropriately defined SayTopic.
<a name="5475"></a> */
<a name="5476"></a>class SayTopic: SpecialTopic
<a name="5477"></a>   
<a name="5478"></a>    /* 
<a name="5479"></a>     *   When we construct the name of a SayTopic we use the name property of
<a name="5480"></a>     *   its matchObj rather that theName property, since it won't normally make
<a name="5481"></a>     *   sense to include the definite article at the beginning of suggestions
<a name="5482"></a>     *   of things that can be said.
<a name="5483"></a>     */
<a name="5484"></a>    buildName()
<a name="5485"></a>    {
<a name="5486"></a>        /* 
<a name="5487"></a>         *   We don't try to construct a name if we have one already or if we
<a name="5488"></a>         *   don't have a matchObhj.
<a name="5489"></a>         */
<a name="5490"></a>        if(name == nil &amp;&amp; matchObj != nil)
<a name="5491"></a>            /* 
<a name="5492"></a>             *   The matchObj property could in principle be specified as a
<a name="5493"></a>             *   list, in which case use the first (and possibly only) item in
<a name="5494"></a>             *   the list to construct our name.
<a name="5495"></a>             */
<a name="5496"></a>            name = valToList(matchObj)[1].name; 
<a name="5497"></a>    }
<a name="5498"></a>
<a name="5499"></a>    /* SayTopics belong in the sayTopics list of their TopicDatabase */    
<a name="5500"></a>    includeInList = [&amp;sayTopics]
<a name="5501"></a>    
<a name="5502"></a>    /* 
<a name="5503"></a>     *   When a SayTopic is suggested we normally precede its name by 'say',
<a name="5504"></a>     *   e.g. 'say you are happy'. In some cases an author might want to use a
<a name="5505"></a>     *   SayTopic to match input that's better without the initial 'say', e.g.
<a name="5506"></a>     *   'tell a lie', in which case set includeSayInName to nil to suppress the
<a name="5507"></a>     *   initial 'say' in topic inventory listings.
<a name="5508"></a>     */
<a name="5509"></a>    
<a name="5510"></a>    includeSayInName = true
<a name="5511"></a>;
<a name="5512"></a>
<a name="5513"></a>/* A TalkTopic is a TopicEntry that responds to TALK ABOUT so-and-so. */
<a name="5514"></a>class TalkTopic: ActorTopicEntry
<a name="5515"></a>    includeInList = [&amp;talkTopics]
<a name="5516"></a>;
<a name="5517"></a>    
<a name="5518"></a>/* 
<a name="5519"></a> *   A TellTalkTopic is a TopicEntry that responds to TELL ABOUT or TALK ABOUT
<a name="5520"></a> *   so-and-so.
<a name="5521"></a> */
<a name="5522"></a>class TellTalkTopic: TalkTopic
<a name="5523"></a>    includeInList = [&amp;tellTopics, &amp;talkTopics]
<a name="5524"></a>;
<a name="5525"></a> 
<a name="5526"></a>/* 
<a name="5527"></a> *   An AskTellTalkTopic is a TopicEntry that responds to ASK ABOUT or TELL
<a name="5528"></a> *   ABOUT or TALK ABOUT so-and-so.
<a name="5529"></a> */
<a name="5530"></a>class AskTellTalkTopic: TalkTopic
<a name="5531"></a>    includeInList = [&amp;askTopics, &amp;tellTopics, &amp;talkTopics]
<a name="5532"></a>;
<a name="5533"></a>
<a name="5534"></a>/* 
<a name="5535"></a> *   An AskTalkTopic is a TopicEntry that responds to ASK ABOUT or TALK ABOUT
<a name="5536"></a> *   so-and-so.
<a name="5537"></a> */
<a name="5538"></a>class AskTalkTopic: TalkTopic
<a name="5539"></a>    includeInList = [&amp;askTopics, &amp;talkTopics]
<a name="5540"></a>;
<a name="5541"></a>
<a name="5542"></a>
<a name="5543"></a>/* 
<a name="5544"></a> *   An initiateTopic is used for conversational topics initiated by the actor
<a name="5545"></a> *   through a call to initiateTopic() on the actor or ActorState
<a name="5546"></a> */
<a name="5547"></a>class InitiateTopic: ActorTopicEntry
<a name="5548"></a>    includeInList = [&amp;initiateTopics]
<a name="5549"></a>    
<a name="5550"></a>    matchTopic(top)
<a name="5551"></a>    {
<a name="5552"></a>        agendaItem = libGlobal.agendaItem;
<a name="5553"></a>        
<a name="5554"></a>        return inherited(top);
<a name="5555"></a>    }
<a name="5556"></a>    
<a name="5557"></a>    /* The agendaItem that invoked us, if there was one. */
<a name="5558"></a>    agendaItem = nil
<a name="5559"></a>    
<a name="5560"></a>    /* The reason the agendaItem invoked us. */
<a name="5561"></a>    reasonInvoked = (agendaItem ? agendaItem.reasonInvoked : nil)
<a name="5562"></a>    
<a name="5563"></a>    /* 
<a name="5564"></a>     *   Was the reason we were invoked the DefaultTopicReason, meaning that our ConvAngendaItem was
<a name="5565"></a>     *   invoked via a DefaultAgendaTopic?
<a name="5566"></a>     */
<a name="5567"></a>    defaultInvocation = (reasonInvoked == DefaultTopicReason)
<a name="5568"></a>    
<a name="5569"></a>;
<a name="5570"></a>
<a name="5571"></a>/*  
<a name="5572"></a> *   An AltTopic is a TopicEntry that can be located inside another TopicEntry;
<a name="5573"></a> *   to provide an alternative response to the same conversational commands when
<a name="5574"></a> *   its isActive property is true. An AltTopic takes precedence over its
<a name="5575"></a> *   enclosing TopicEntry when its active property is true, but otherwise takes
<a name="5576"></a> *   most of its properties (apart from its topicResponse) from the TopicEntry
<a name="5577"></a> *   in which it is located. You can have as many AltTopics as you like
<a name="5578"></a> *   associated with any given TopicEntry; the one that will be used will be the
<a name="5579"></a> *   last to be defined for which isActive is true.
<a name="5580"></a> */
<a name="5581"></a>class AltTopic: ActorTopicEntry
<a name="5582"></a>    
<a name="5583"></a>    /* 
<a name="5584"></a>     *   By default we take most of our property values from the corresponding
<a name="5585"></a>     *   property on the TopicEntry we're located in
<a name="5586"></a>     */
<a name="5587"></a>    getActor = location.getActor
<a name="5588"></a>      
<a name="5589"></a>    convKeys = location.convKeys    
<a name="5590"></a>    includeInList = location.includeInList
<a name="5591"></a>    name = location.name
<a name="5592"></a>    suggestAs = location.suggestAs 
<a name="5593"></a> 
<a name="5594"></a>    allowAction = location.allowAction
<a name="5595"></a>    myAction = location.myAction
<a name="5596"></a>    actionPhrase = (location.actionPhrase)
<a name="5597"></a>    
<a name="5598"></a>    /* 
<a name="5599"></a>     *   We match if our location matches, but if it does match we add our
<a name="5600"></a>     *   relative source text order to our location's match score to give us a
<a name="5601"></a>     *   higher score the later we're defined after our associated TopicEntry.
<a name="5602"></a>     */
<a name="5603"></a>    matchTopic(top)
<a name="5604"></a>    {
<a name="5605"></a>        /* Note the topic we're trying to match. */
<a name="5606"></a>        topicMatched = top;
<a name="5607"></a>        
<a name="5608"></a>        agendaItem = libGlobal.agendaItem;
<a name="5609"></a>        
<a name="5610"></a>        local score = location.matchTopic(top);
<a name="5611"></a>        
<a name="5612"></a>        return score == nil ? nil : score + sourceTextOrder -
<a name="5613"></a>            location.sourceTextOrder;
<a name="5614"></a>    }
<a name="5615"></a>    
<a name="5616"></a>    agendaItem = nil
<a name="5617"></a>;
<a name="5618"></a>
<a name="5619"></a>
<a name="5620"></a>/* 
<a name="5621"></a> *   A NodeContinuationTopic is aspecial kind of InitiateTopic that can be used
<a name="5622"></a> *   to prompt the player/pc when particular convKeys have been activated. It is
<a name="5623"></a> *   generally used when a Conversation Node is active to remind the player that
<a name="5624"></a> *   the player character's conversation partner is waiting for an answer.
<a name="5625"></a> */
<a name="5626"></a>
<a name="5627"></a>class NodeContinuationTopic: InitiateTopic
<a name="5628"></a>    matchObj = nodeObj
<a name="5629"></a>    
<a name="5630"></a>    /* 
<a name="5631"></a>     *   We're only active when one or more of our keys is active (having been
<a name="5632"></a>     *   activated through an &lt;.convnode&gt; tag).
<a name="5633"></a>     */
<a name="5634"></a>    active = (nodeActive &amp;&amp; inherited)
<a name="5635"></a>    
<a name="5636"></a>    /* 
<a name="5637"></a>     *   Particular instances must override this property to stipulate which
<a name="5638"></a>     *   keys we're active for. (This isn't needed if the NodeContinuationTopic
<a name="5639"></a>     *   is located in a ConvNode, since the ConvNode will then take care of
<a name="5640"></a>     *   this for us).
<a name="5641"></a>     */
<a name="5642"></a>    convKeys = nil
<a name="5643"></a>    
<a name="5644"></a>    handleTopic()
<a name="5645"></a>    {
<a name="5646"></a>        /* 
<a name="5647"></a>         *   We don't want a NodeContinuationTopic to reset the active keys, so
<a name="5648"></a>         *   we send a convstay tag to retain them.
<a name="5649"></a>         */
<a name="5650"></a>        "&lt;.p&gt;&lt;.convstay&gt;";
<a name="5651"></a>        
<a name="5652"></a>        /* Carry out the inherited handling. */
<a name="5653"></a>        inherited();
<a name="5654"></a>    }
<a name="5655"></a>;
<a name="5656"></a>
<a name="5657"></a>/* 
<a name="5658"></a> *   A NodeEndCheck may optionally be assigned to a Conversation Node (as
<a name="5659"></a> *   defined on the convKeys property, or through being located in a ConvNode
<a name="5660"></a> *   object) to decide whether a conversation is allowed to end while it's at
<a name="5661"></a> *   this node. There's no need to define one of these objects for a
<a name="5662"></a> *   conversation node if you're happy for the conversation to be ended during
<a name="5663"></a> *   it under all circumstances.
<a name="5664"></a> */
<a name="5665"></a>
<a name="5666"></a>class NodeEndCheck: EndConvBlocker, InitiateTopic
<a name="5667"></a>    matchObj = nodeEndCheckObj
<a name="5668"></a>    
<a name="5669"></a>    /* 
<a name="5670"></a>     *   We're only active when one or more of our keys is active (having been
<a name="5671"></a>     *   activated through an &lt;.convnode&gt; tag).
<a name="5672"></a>     */
<a name="5673"></a>    active = (nodeActive &amp;&amp; inherited)
<a name="5674"></a>    
<a name="5675"></a>    
<a name="5676"></a>    /* 
<a name="5677"></a>     *   Particular instances must override this property to stipulate which
<a name="5678"></a>     *   keys we're active for, unless this NodeEndCheck is located within a
<a name="5679"></a>     *   ConvNode object which will take care of this for us. Note that instead
<a name="5680"></a>     *   of locating a NodeEndCheck in a particular ConvNode, you can specify
<a name="5681"></a>     *   the convKeys for a number of ConvNodes here, and this NodeEndCheck will
<a name="5682"></a>     *   then apply to them all.
<a name="5683"></a>     */
<a name="5684"></a>    convKeys = nil
<a name="5685"></a>    
<a name="5686"></a>    /*   
<a name="5687"></a>     *   Decide whether the conversation can be ended for reason while the conversation is at this
<a name="5688"></a>     *   node. By default we simply return true but instances can override to return nil when the
<a name="5689"></a>     *   conversation should not be permitted to end. When the method returns nil it should also
<a name="5690"></a>     *   display a message saying why the conversation may not be ended.
<a name="5691"></a>     *
<a name="5692"></a>     *   For most games, however, it will be easier to leave this method as it is and employ one or
<a name="5693"></a>     *   more of the endBlockTravel, endBlockTravel and endBlockBoredom properies to define what
<a name="5694"></a>     *   happenes.
<a name="5695"></a>     */    
<a name="5696"></a>    canEndConversation(reason)
<a name="5697"></a>    {
<a name="5698"></a>        /* 
<a name="5699"></a>         *   Our response depends on the value of the reaaon parameter, which should be one of
<a name="5700"></a>         *   endConvBye, encConvLeave, or endConvBoredom.
<a name="5701"></a>         */
<a name="5702"></a>        
<a name="5703"></a>        switch(reason)
<a name="5704"></a>        {
<a name="5705"></a>            /* 
<a name="5706"></a>             *   If reason is endConvBye, the player is trying to end the conversation by saying
<a name="5707"></a>             *   BYE. If we define a sayBlockBye property call it and return the result.
<a name="5708"></a>             */
<a name="5709"></a>        case endConvBye:
<a name="5710"></a>            if(propDefined(&amp;sayBlockBye))
<a name="5711"></a>                return block(&amp;sayBlockBye);
<a name="5712"></a>            break;
<a name="5713"></a>            
<a name="5714"></a>            /* 
<a name="5715"></a>             *   If reason is endConvLeave, the player is trying to end the conversation by moving
<a name="5716"></a>             *   to another location. If we define a sayBlockLeave property call it and return the
<a name="5717"></a>             *   result.
<a name="5718"></a>             */
<a name="5719"></a>        case endConvLeave:
<a name="5720"></a>            if(propDefined(&amp;sayBlockLeave))
<a name="5721"></a>               return block(&amp;sayBlockLeave);
<a name="5722"></a>            break;
<a name="5723"></a>            
<a name="5724"></a>            /* 
<a name="5725"></a>             *   If reason is endConvBoredom the NPC has exhausted their patience for waiting for
<a name="5726"></a>             *   the player to make a conversational response. If we define a sayBlockBoredom
<a name="5727"></a>             *   property call it and return the result.
<a name="5728"></a>             */
<a name="5729"></a>        case endConvBoredom:
<a name="5730"></a>            if(propDefined(&amp;sayBlockBoredom))
<a name="5731"></a>               return block(&amp;sayBlockBoredom);
<a name="5732"></a>            break;
<a name="5733"></a>            
<a name="5734"></a>            /* 
<a name="5735"></a>             *   For anything else, return our default value (true or nil to allow the conversation
<a name="5736"></a>             *   to be ended or to block it silently.
<a name="5737"></a>             */
<a name="5738"></a>        default:
<a name="5739"></a>            return defaultVal;
<a name="5740"></a>        }
<a name="5741"></a>        
<a name="5742"></a>        /*
<a name="5743"></a>         *   If we reach here, return our default value (true or nil to allow the conversation to be
<a name="5744"></a>         *   ended or to block it silently..
<a name="5745"></a>         */
<a name="5746"></a>        return defaultVal;
<a name="5747"></a>    }
<a name="5748"></a>    
<a name="5749"></a>    /* 
<a name="5750"></a>     *   We can optionally define one or more of these three properties (game code needs to define
<a name="5751"></a>     *   at least one of them for this NodeEndCheck objecct to have any effect, unless we've
<a name="5752"></a>     *   overridden canEndConversation to handle in in some other way.
<a name="5753"></a>     *
<a name="5754"></a>     *   Any of these three properties can be defined as one of:
<a name="5755"></a>     *.   A single-quoted string, in which the string is displayed and the method returns nil to
<a name="5756"></a>     *   block ending the conversation without treating what has just been displayed as a
<a name="5757"></a>     *   conversational response.
<a name="5758"></a>     *
<a name="5759"></a>     *.   A double-quoted string, in which case the string is displayed and we return blockEndConv
<a name="5760"></a>     *   so that the response is treated as conversational.
<a name="5761"></a>     *
<a name="5762"></a>     *.   A method, in which case the method is executed and its return value (which should be one
<a name="5763"></a>     *   of nil, true, or blockEndConv) is returned to our caller.
<a name="5764"></a>     *
<a name="5765"></a>     *.   An event list, in which case its doScript method is called and we return blockEndConv to
<a name="5766"></a>     *   treat it as as conversational response.
<a name="5767"></a>     */
<a name="5768"></a>     // sayBlockTravel() {}
<a name="5769"></a>     // sayBlockBye () {}
<a name="5770"></a>     // sayBlockBoredom() {}
<a name="5771"></a>    
<a name="5772"></a>    /* 
<a name="5773"></a>     *   The method that handles prop (a proprty pointer) according to its property type. For the
<a name="5774"></a>     *   possibilities, see the immediately preceeding comment.
<a name="5775"></a>     */
<a name="5776"></a>    block(prop)
<a name="5777"></a>    {
<a name="5778"></a>        switch(propType(prop))
<a name="5779"></a>        {
<a name="5780"></a>        case TypeSString:
<a name="5781"></a>            say(self.(prop));
<a name="5782"></a>            return nil;
<a name="5783"></a>        case TypeCode:
<a name="5784"></a>            return self.(prop);
<a name="5785"></a>        case TypeDString:
<a name="5786"></a>            self.(prop);
<a name="5787"></a>            return blockEndConv;
<a name="5788"></a>        case TypeFuncPtr:
<a name="5789"></a>            local f = self.(prop);
<a name="5790"></a>            (f)();
<a name="5791"></a>            return blockEndConv;
<a name="5792"></a>        case TypeObject:
<a name="5793"></a>            local obj = self.(prop);
<a name="5794"></a>            if(obj.ofKind(Script))
<a name="5795"></a>            {
<a name="5796"></a>                obj.doScript();
<a name="5797"></a>                return blockEndConv;
<a name="5798"></a>            }
<a name="5799"></a>            
<a name="5800"></a>            /* This is provided to handle cases not handled by any other mechanism. */
<a name="5801"></a>            if(obj.propDefined(&amp;block))
<a name="5802"></a>                return obj.block();
<a name="5803"></a>            
<a name="5804"></a>            return defaultVal;
<a name="5805"></a>            /* 
<a name="5806"></a>             *   This is provided to allow a way to force a true result for a particular case when
<a name="5807"></a>             *   defaultVal is nil.
<a name="5808"></a>             */
<a name="5809"></a>        case TypeTrue:
<a name="5810"></a>            return true;
<a name="5811"></a>            
<a name="5812"></a>            /* 
<a name="5813"></a>             *   This is provided to allow a way to force a nil result for a particular case when
<a name="5814"></a>             *   defaultVal is nil.
<a name="5815"></a>             */
<a name="5816"></a>        case TypeEnum:
<a name="5817"></a>            return nil;
<a name="5818"></a>                   
<a name="5819"></a>            /* 
<a name="5820"></a>             *   This is provided as an alternative way to allow a way to to handle cases not
<a name="5821"></a>             *   handled by any other mechanism.
<a name="5822"></a>             */
<a name="5823"></a>        case TypeProp:
<a name="5824"></a>            local nprop = self.(prop);
<a name="5825"></a>            return self.(nprop);  
<a name="5826"></a>             
<a name="5827"></a>            
<a name="5828"></a>        default:
<a name="5829"></a>            return defaultVal;
<a name="5830"></a>            
<a name="5831"></a>        }
<a name="5832"></a>    }
<a name="5833"></a>    
<a name="5834"></a>    
<a name="5835"></a>    
<a name="5836"></a>    /* 
<a name="5837"></a>     *   Do nothing here; this class only exists for the sake of its
<a name="5838"></a>     *   canEndConversation() method.
<a name="5839"></a>     */    
<a name="5840"></a>    handleTopic() { }  
<a name="5841"></a>    
<a name="5842"></a>    /* 
<a name="5843"></a>     *   The default value canEndConversation should return if nothing else intervenes. By default
<a name="5844"></a>     *   this is true, to allow ending the conversation by default, but in particular cass we could
<a name="5845"></a>     *   set this to nil to sllently rule out ending the conversation.
<a name="5846"></a>     */
<a name="5847"></a>    defaultVal = true;
<a name="5848"></a>;
<a name="5849"></a>
<a name="5850"></a>
<a name="5851"></a>
<a name="5852"></a>/* 
<a name="5853"></a> *   EndConvBlocker is a mix-in class whose sole function is to define the
<a name="5854"></a> *   blockEndConv method common to Actor, ActorState and NodeEndCheck
<a name="5855"></a> */
<a name="5856"></a>modify EndConvBlocker
<a name="5857"></a>    /* 
<a name="5858"></a>     *   Convenience method that notes that conversation has occurred on this
<a name="5859"></a>     *   turn and returns nil. This is to allow us to use:
<a name="5860"></a>     *.
<a name="5861"></a>     *   return blockEndConv;
<a name="5862"></a>     *
<a name="5863"></a>     *   in the canEndConversation method to suppress the output of any
<a name="5864"></a>     *   NodeContinuationTopic on this turn.     */
<a name="5865"></a>    
<a name="5866"></a>    blockEndConv()
<a name="5867"></a>    {
<a name="5868"></a>        /* Note that the actor has conversed on this turn */
<a name="5869"></a>        getActor.noteConversed();
<a name="5870"></a>        
<a name="5871"></a>        /* 
<a name="5872"></a>         *   Return nil to signal that we're not allowing the conversation to
<a name="5873"></a>         *   end.
<a name="5874"></a>         */
<a name="5875"></a>        return nil;
<a name="5876"></a>    }
<a name="5877"></a>;
<a name="5878"></a>
<a name="5879"></a>/* Singleton object to allow initiateTopic to trigger a NodeContinuationTopic */
<a name="5880"></a>nodeObj: object;
<a name="5881"></a>
<a name="5882"></a>/* Singleton object to allow initiateTopic to trigger a NodeEndCheck */
<a name="5883"></a>nodeEndCheckObj: object;
<a name="5884"></a>
<a name="5885"></a>
<a name="5886"></a>/* 
<a name="5887"></a> *   Preinitialize all the Actors in the game and the objects associated with
<a name="5888"></a> *   them.
<a name="5889"></a> */
<a name="5890"></a>actorPreinit:PreinitObject
<a name="5891"></a>    execute()
<a name="5892"></a>    {       
<a name="5893"></a>        /* Initialize every ActorState defined in the game */
<a name="5894"></a>        forEachInstance(ActorState, {a: a.initializeActorState() } );
<a name="5895"></a>        
<a name="5896"></a>        /* Initialize every ActorTopicEntry definined in the game */
<a name="5897"></a>        forEachInstance(ActorTopicEntry, {a: a.initializeTopicEntry() });
<a name="5898"></a>        
<a name="5899"></a>        /* 
<a name="5900"></a>         *   Set up a new Schedulable in the game to run our eachTurn method each
<a name="5901"></a>         *   turn
<a name="5902"></a>         */
<a name="5903"></a>                    
<a name="5904"></a>        eventManager.schedulableList += actorSchedule;
<a name="5905"></a>            
<a name="5906"></a>//            new Daemon(self, &amp;eachTurn, 1);
<a name="5907"></a>//        
<a name="5908"></a>//        /*   Give the actorDaemon a relatively late running order */
<a name="5909"></a>//        actorDaemon.eventOrder = 300;
<a name="5910"></a>    }
<a name="5911"></a>    
<a name="5912"></a>    /* 
<a name="5913"></a>     *   Make use that various other preinitializations presupposed by our own
<a name="5914"></a>     *   have been carried out before ours
<a name="5915"></a>     */
<a name="5916"></a>    execBeforeMe = [World, libObjectInitializer, pronounPreinit]
<a name="5917"></a>   
<a name="5918"></a>;
<a name="5919"></a>
<a name="5920"></a>actorSchedule: Event
<a name="5921"></a>    eventOrder = 100
<a name="5922"></a>    executeEvent() { forEachInstance(Actor, {a: a.takeTurn() }); }
<a name="5923"></a>;
<a name="5924"></a>
<a name="5925"></a>
<a name="5926"></a>/* ------------------------------------------------------------------------ */
<a name="5927"></a>/*
<a name="5928"></a> *   Conversation manager output filter.  We look for special tags in the output
<a name="5929"></a> *   stream:
<a name="5930"></a> *
<a name="5931"></a> *   &lt;.reveal key&gt; - add 'key' to the knowledge token lookup table.  The 'key'
<a name="5932"></a> *   is an arbitrary string, which we can look up in the table to determine if
<a name="5933"></a> *   the key has even been revealed.  This can be used to make a response
<a name="5934"></a> *   conditional on another response having been displayed, because the key will
<a name="5935"></a> *   only be added to the table when the text containing the &lt;.reveal key&gt;
<a name="5936"></a> *   sequence is displayed.
<a name="5937"></a> *
<a name="5938"></a> *   &lt;.unreveal key&gt; - remove 'key from the knowledge token lookup table.
<a name="5939"></a> *
<a name="5940"></a> *   &lt;.inform key&gt; - add 'key' to our actor's knowledge token lookup take. The
<a name="5941"></a> *   'key' is an arbitrary string, which we can look up in the table to
<a name="5942"></a> *   determine if the actor has ever been informed about this key.  This can be
<a name="5943"></a> *   used to make a response conditional on another response having been
<a name="5944"></a> *   displayed, because the key will only be added to the information table when
<a name="5945"></a> *   the text containing the &lt;.inform key&gt; sequence is displayed.
<a name="5946"></a> *
<a name="5947"></a> *   &lt;.convnode name&gt; - add 'name' to the current list of convKeys (this
<a name="5948"></a> *   actually adds it to the actor's pendingKeys for use on the next turn); this
<a name="5949"></a> *   is normally used to trigger a Conversation Node that's defined to match the
<a name="5950"></a> *   same name.
<a name="5951"></a> *
<a name="5952"></a> *   &lt;.convodet name&gt; does the same as &lt;.convnode name&gt; and additionally
<a name="5953"></a> *   schedules a topic inventory (a listing of suggested topics); this can be
<a name="5954"></a> *   used to ensure that the player knows what conversational options are
<a name="5955"></a> *   available in the node we're about to enter, where this isn't obvious from
<a name="5956"></a> *   the context.
<a name="5957"></a> *
<a name="5958"></a> *   &lt;.convstay&gt; - retain the same list of active keys for the next
<a name="5959"></a> *   conversational response (and thus has the effect of making the conversation
<a name="5960"></a> *   remain in the same conversation node).
<a name="5961"></a> *
<a name="5962"></a> *   &lt;.convstayt&gt; - does the same as &lt;.convstay&gt; but additionally schedules a
<a name="5963"></a> *   topic inventory.
<a name="5964"></a> *
<a name="5965"></a> *   &lt;.topics&gt; - schedule a topic inventory for the end of the turn (just before
<a name="5966"></a> *   the next command prompt)
<a name="5967"></a> *
<a name="5968"></a> *   &lt;.arouse key&gt; Set the curiosityAroused property to true for all
<a name="5969"></a> *   TopicEntries whose convKeys include key
<a name="5970"></a> *
<a name="5971"></a> *   &lt;.suggest key&gt; Schedule a topic inventory for all topic entries whose
<a name="5972"></a> *   convKeys include key.
<a name="5973"></a> *
<a name="5974"></a> *   &lt;.sugkey key&gt; Set our actor's suggestionKey to key (this potentially
<a name="5975"></a> *   restricts the list of topics that will be suggested)
<a name="5976"></a> *
<a name="5977"></a> *   &lt;.activate key&gt; Set the activated property to true for every topic entry
<a name="5978"></a> *   whose convKeys list includes key.
<a name="5979"></a> *
<a name="5980"></a> *   &lt;.agenda item&gt; Add item to the agenda list of our Actor and any associated
<a name="5981"></a> *   DefaultAgendaTopics.
<a name="5982"></a> *
<a name="5983"></a> *   &lt;.remove item&gt; Remove item from the agenda list of our Actor and any
<a name="5984"></a> *   associated DefaultAgendaTopics.
<a name="5985"></a> *
<a name="5986"></a> *   &lt;.state newstate&gt; Change our actor's current ActorState to newstate.
<a name="5987"></a> *
<a name="5988"></a> *   &lt;.known obj&gt; Mark obj (a Thing or Topic) as now being known (i.e. familiar)
<a name="5989"></a> */
<a name="5990"></a>modify conversationManager
<a name="5991"></a>    /*
<a name="5992"></a>     *   Custom extended tags.  Games and library extensions can add their
<a name="5993"></a>     *   own tag processing as needed, by using 'modify' to extend this
<a name="5994"></a>     *   object.  There are two things you have to do to add your own tags:
<a name="5995"></a>     *   
<a name="5996"></a>     *   First, add a 'customTags' property that defines a regular
<a name="5997"></a>     *   expression for your added tags.  This will be incorporated into
<a name="5998"></a>     *   the main pattern we use to look for tags.  Simply specify a
<a name="5999"></a>     *   string that lists your tags separated by "|" characters, like
<a name="6000"></a>     *   this:
<a name="6001"></a>     *   
<a name="6002"></a>     *   customTags = 'foo|bar'
<a name="6003"></a>     *   
<a name="6004"></a>     *   Second, define a doCustomTag() method to process the tags.  The
<a name="6005"></a>     *   filter routine will call your doCustomTag() method whenever it
<a name="6006"></a>     *   finds one of your custom tags in the output stream.  
<a name="6007"></a>     */
<a name="6008"></a>    customTags = nil
<a name="6009"></a>    doCustomTag(tag, arg) { /* do nothing by default */ }
<a name="6010"></a>
<a name="6011"></a>    /* 
<a name="6012"></a>     *   The actor we're dealing with is the player character's current
<a name="6013"></a>     *   interlocutor
<a name="6014"></a>     */
<a name="6015"></a>    respondingActor = (gPlayerChar.currentInterlocutor)
<a name="6016"></a>    
<a name="6017"></a>    factTagMarker = '$'  
<a name="6018"></a>    
<a name="6019"></a>    /* 
<a name="6020"></a>     *   Strip our factTagMarker from the start of arg. Game authors shouldn't use it for most tags,
<a name="6021"></a>     *   but just to be safe we'll do it for all the string tags anyway.
<a name="6022"></a>     */
<a name="6023"></a>    stripFactTagMarker(arg)
<a name="6024"></a>    {
<a name="6025"></a>        return arg.startsWith(factTagMarker) ? arg.substr(1 + factTagMarker.length()) : arg; 
<a name="6026"></a>    }
<a name="6027"></a>    
<a name="6028"></a>    /* filter text written to the output stream */
<a name="6029"></a>    filterText(ostr, txt)
<a name="6030"></a>    {
<a name="6031"></a>        local start;
<a name="6032"></a>        local actor;
<a name="6033"></a>        
<a name="6034"></a>        /* scan for our special tags */
<a name="6035"></a>        for (start = 1 ; ; )
<a name="6036"></a>        {
<a name="6037"></a>            local match;
<a name="6038"></a>            local arg;
<a name="6039"></a>            local tag;
<a name="6040"></a>            local nxtOfs;
<a name="6041"></a>            local obj;
<a name="6042"></a>            local args;
<a name="6043"></a>            
<a name="6044"></a>            /* scan for the next tag */
<a name="6045"></a>            match = rexSearch(tagPat, txt, start);
<a name="6046"></a>
<a name="6047"></a>            /* if we didn't find it, we're done */
<a name="6048"></a>            if (match == nil)
<a name="6049"></a>                break;
<a name="6050"></a>
<a name="6051"></a>            /* note the next offset */
<a name="6052"></a>            nxtOfs = match[1] + match[2];
<a name="6053"></a>
<a name="6054"></a>            /* get the argument (the third group from the match) */
<a name="6055"></a>            arg = rexGroup(3);
<a name="6056"></a>            if (arg != nil)
<a name="6057"></a>                arg = arg[3];
<a name="6058"></a>
<a name="6059"></a>            /* pick out the tag */
<a name="6060"></a>            tag = rexGroup(1)[3].toLower(); 
<a name="6061"></a>
<a name="6062"></a>                       
<a name="6063"></a>            /* check which tag we have */
<a name="6064"></a>            switch (tag)
<a name="6065"></a>            {
<a name="6066"></a>                /* 
<a name="6067"></a>                 *   We distiguish between information that is revealed *to* the
<a name="6068"></a>                 *   player char (by using a &lt;.reveal&gt; tag) and information
<a name="6069"></a>                 *   imparted by the player char to other characters (using the
<a name="6070"></a>                 *   &lt;.inform&gt; tag). Game authors do not have to observe this
<a name="6071"></a>                 *   distinction if they only want to use &lt;.reveal&gt; as in the
<a name="6072"></a>                 *   adv3 library, but it may be a useful distinction for some
<a name="6073"></a>                 *   games.
<a name="6074"></a>                 *
<a name="6075"></a>                 *   Note that there is one global table of revealed tags (on
<a name="6076"></a>                 *   libGlobal) use for revealed items, but that each actor
<a name="6077"></a>                 *   (apart from the player char) maintains its own table of
<a name="6078"></a>                 *   items imparted through inform tags.
<a name="6079"></a>                 *
<a name="6080"></a>                 *   Note also that a &lt;.reveal&gt; or &lt;.inform&gt; tag causes the tag
<a name="6081"></a>                 *   to be added to the informNameTag table of every actor who
<a name="6082"></a>                 *   can hear the conversation, not just the current
<a name="6083"></a>                 *   interlocutor.
<a name="6084"></a>                 *
<a name="6085"></a>                 *   If &lt;.inform&gt; tags are used as well as &lt;.reveal&gt; tags it's
<a name="6086"></a>                 *   therefore a good idea to regard the tags as a global
<a name="6087"></a>                 *   namespace -- i.e. one tag value should be used consistently
<a name="6088"></a>                 *   to represent one piece of information.
<a name="6089"></a>                 *
<a name="6090"></a>                 *   Finally, note that the gRevealed() macro only adds the tag
<a name="6091"></a>                 *   to the libGlobal table - it doesn't result in any other
<a name="6092"></a>                 *   actors being informed. It can therefore be used (among
<a name="6093"></a>                 *   other things) to reveal information that remains private to
<a name="6094"></a>                 *   the player char.
<a name="6095"></a>                 */
<a name="6096"></a>             
<a name="6097"></a>                
<a name="6098"></a>            case 'reveal':
<a name="6099"></a>                /* reveal the key by adding it to our database */
<a name="6100"></a>                arg = stripFactTagMarker(arg);
<a name="6101"></a>                args = arg.split('=');
<a name="6102"></a>                if(args.length &gt; 1)
<a name="6103"></a>                {
<a name="6104"></a>                    arg = enumTabObj.getEnum(args[2]) ?? args[2];
<a name="6105"></a>                    
<a name="6106"></a>                    setRevealed(args[1], arg);
<a name="6107"></a>                }
<a name="6108"></a>                else                
<a name="6109"></a>                    setRevealed(arg);
<a name="6110"></a>                break;
<a name="6111"></a>                
<a name="6112"></a>                /* unreveal the key by removing it from our database */
<a name="6113"></a>            case 'unreveal':
<a name="6114"></a>                arg = stripFactTagMarker(arg);
<a name="6115"></a>               
<a name="6116"></a>                setUnrevealed(arg);
<a name="6117"></a>                break;
<a name="6118"></a>                
<a name="6119"></a>            case 'inform':    
<a name="6120"></a>                /* reveal the key by adding it to the actor's database */
<a name="6121"></a>                arg = stripFactTagMarker(arg);
<a name="6122"></a>                args = arg.split('=');
<a name="6123"></a>                if(args.length &gt; 1)
<a name="6124"></a>                {        
<a name="6125"></a>                    arg = enumTabObj.getEnum(args[2]) ?? args[2];
<a name="6126"></a>                    setInformed(args[1], arg);
<a name="6127"></a>                }
<a name="6128"></a>                else 
<a name="6129"></a>                    setInformed(arg);
<a name="6130"></a>                break;
<a name="6131"></a>                
<a name="6132"></a>                
<a name="6133"></a>            case 'convnode':
<a name="6134"></a>            case 'convnodet':    
<a name="6135"></a>                /* 
<a name="6136"></a>                 *   if there's a current responding actor, add the key to its
<a name="6137"></a>                 *   list of pending keys (for use on the next conversational
<a name="6138"></a>                 *   turn).
<a name="6139"></a>                 */                
<a name="6140"></a>                arg = stripFactTagMarker(arg);
<a name="6141"></a>                if(respondingActor != nil)
<a name="6142"></a>                {
<a name="6143"></a>                    /* 
<a name="6144"></a>                     *   If we are processing several convnode tags on the same
<a name="6145"></a>                     *   turn, we want them all to take effect; otherwise we
<a name="6146"></a>                     *   want the new convnode to replace any that was
<a name="6147"></a>                     *   previously in effect.
<a name="6148"></a>                     */
<a name="6149"></a>                    if(convnodeSetTurn == libGlobal.totalTurns)
<a name="6150"></a>                        respondingActor.addPendingKey(arg);
<a name="6151"></a>                    else
<a name="6152"></a>                        respondingActor.pendingKeys = [arg];
<a name="6153"></a>                }
<a name="6154"></a>                
<a name="6155"></a>                /* Note that we have set a new convnode on this turn */
<a name="6156"></a>                convnodeSetTurn = libGlobal.totalTurns;
<a name="6157"></a>                
<a name="6158"></a>                /* 
<a name="6159"></a>                 *   We deliberatelty don't put a BREAK; statement here since we
<a name="6160"></a>                 *   need to fall through ro the convstay behaviour to ensure that
<a name="6161"></a>                 *   our keys aren't obliterated as soon as they're set.
<a name="6162"></a>                 */                
<a name="6163"></a>            case 'convstay':
<a name="6164"></a>            case 'convstayt':                    
<a name="6165"></a>                /* 
<a name="6166"></a>                 *   Leave the responding actor in the old conversation
<a name="6167"></a>                 *   node - we don't need to change the ConvNode, but we do
<a name="6168"></a>                 *   need to note that we've explicitly set it 
<a name="6169"></a>                 */
<a name="6170"></a>                if (respondingActor != nil)
<a name="6171"></a>                    respondingActor.keepPendingKeys = true;
<a name="6172"></a>               
<a name="6173"></a>                /* 
<a name="6174"></a>                 *   If the tag was 'convnode' we didn't ask for a topic
<a name="6175"></a>                 *   inventory, so we need to avoid falling through. If the tag
<a name="6176"></a>                 *   was 'convnodet' or 'convstayt' we want a topic inventory
<a name="6177"></a>                 *   too, so we fall through to the 'topics' tag.
<a name="6178"></a>                 */                
<a name="6179"></a>                if(tag is in ('convnodet', 'convstayt') 
<a name="6180"></a>                   &amp;&amp; respondingActor != nil)                    
<a name="6181"></a>                    scheduleTopicInventory(respondingActor.pendingKeys);
<a name="6182"></a>                    
<a name="6183"></a>                 break;
<a name="6184"></a>
<a name="6185"></a>            case 'topics':
<a name="6186"></a>                /* schedule a topic inventory listing */
<a name="6187"></a>                if (respondingActor != nil)
<a name="6188"></a>                    scheduleTopicInventory(respondingActor.pendingKeys == [] ? 
<a name="6189"></a>                                           respondingActor.suggestionKey
<a name="6190"></a>                                           : respondingActor.pendingKeys);
<a name="6191"></a>                break;
<a name="6192"></a>                
<a name="6193"></a>            case 'arouse':
<a name="6194"></a>            case 'unarouse':    
<a name="6195"></a>            case 'abate':
<a name="6196"></a>                arg = stripFactTagMarker(arg);
<a name="6197"></a>                /* 
<a name="6198"></a>                 *   make the curiosityAroused property true or nil for Topic Entries
<a name="6199"></a>                 *   with the appropriate key.
<a name="6200"></a>                 */
<a name="6201"></a>                if (respondingActor != nil)
<a name="6202"></a>                    respondingActor.arouse(arg, tag=='arouse');
<a name="6203"></a>                
<a name="6204"></a>                break;
<a name="6205"></a>                       
<a name="6206"></a>                
<a name="6207"></a>            case 'suggest':
<a name="6208"></a>                arg = stripFactTagMarker(arg);
<a name="6209"></a>                 /* translate the string 'nil' to an actual nil */
<a name="6210"></a>                if(arg == 'nil')
<a name="6211"></a>                    arg = nil;
<a name="6212"></a>                
<a name="6213"></a>                /* 
<a name="6214"></a>                 *   If we have a responding actor, schedule a topic inventory
<a name="6215"></a>                 *   for topic entries that match arg
<a name="6216"></a>                 */
<a name="6217"></a>                if (respondingActor != nil)
<a name="6218"></a>                    scheduleTopicInventory(arg);
<a name="6219"></a>                break;
<a name="6220"></a>                
<a name="6221"></a>            case 'sugkey':
<a name="6222"></a>                arg = stripFactTagMarker(arg);
<a name="6223"></a>                /* translate the string 'nil' to an actual nil */
<a name="6224"></a>                if(arg == 'nil')
<a name="6225"></a>                    arg = nil;
<a name="6226"></a>                /* set the suggestionKey on the responding actor to arg */
<a name="6227"></a>                if (respondingActor != nil)
<a name="6228"></a>                    respondingActor.suggestionKey = arg;
<a name="6229"></a>                break;    
<a name="6230"></a>                
<a name="6231"></a>            case 'activate':
<a name="6232"></a>                arg = stripFactTagMarker(arg);
<a name="6233"></a>                /* 
<a name="6234"></a>                 *   Set the activated property to true for all Topic Entries
<a name="6235"></a>                 *   with the appropriate key.
<a name="6236"></a>                 */
<a name="6237"></a>                if (respondingActor != nil)
<a name="6238"></a>                    respondingActor.makeActivated(arg);
<a name="6239"></a>                break;
<a name="6240"></a>                
<a name="6241"></a>            case 'deactivate':
<a name="6242"></a>                arg = stripFactTagMarker(arg);
<a name="6243"></a>                /* 
<a name="6244"></a>                 *   Set the activated property to true for all Topic Entries
<a name="6245"></a>                 *   with the appropriate key.
<a name="6246"></a>                 */
<a name="6247"></a>                if (respondingActor != nil)
<a name="6248"></a>                    respondingActor.makeDeactivated(arg);
<a name="6249"></a>                break;
<a name="6250"></a>                
<a name="6251"></a>            case 'agenda':
<a name="6252"></a>                /* add an agenda item to all relevant objects */
<a name="6253"></a>                
<a name="6254"></a>                /* 
<a name="6255"></a>                 *   Obtain the object corresponding to arg (a string value)
<a name="6256"></a>                 *   from our object name table
<a name="6257"></a>                 */
<a name="6258"></a>                obj = objNameTab[arg];
<a name="6259"></a>                
<a name="6260"></a>                /* 
<a name="6261"></a>                 *   If the object we're trying to add to an agenda list isn't
<a name="6262"></a>                 *   an AgendaItem belonging to our respondingActor, display an
<a name="6263"></a>                 *   error message.
<a name="6264"></a>                 */
<a name="6265"></a>                if(obj == nil || !obj.ofKind(AgendaItem) || 
<a name="6266"></a>                   obj.getActor != respondingActor)
<a name="6267"></a>                {
<a name="6268"></a>                    showAgendaError(tag, arg);
<a name="6269"></a>                }
<a name="6270"></a>                else
<a name="6271"></a>                    /* 
<a name="6272"></a>                     *   Otherwise add the AgendaItem obj to our
<a name="6273"></a>                     *   respondingActor's agendaList and that of any associated
<a name="6274"></a>                     *   DefaultAgendaTopics
<a name="6275"></a>                     */
<a name="6276"></a>                    respondingActor.addToAllAgendas(obj);
<a name="6277"></a>                break;
<a name="6278"></a>                
<a name="6279"></a>            case 'remove':
<a name="6280"></a>                /* remove an agenda item from all relevant objects */
<a name="6281"></a>                
<a name="6282"></a>                /* 
<a name="6283"></a>                 *   Obtain the object corresponding to arg (a string value)
<a name="6284"></a>                 *   from our object name table
<a name="6285"></a>                 */
<a name="6286"></a>                obj = objNameTab[arg];
<a name="6287"></a>                
<a name="6288"></a>                /* 
<a name="6289"></a>                 *   If the object we're trying to add to an agenda list isn't
<a name="6290"></a>                 *   an AgendaItem belonging to our respondingActor, display an
<a name="6291"></a>                 *   error message.
<a name="6292"></a>                 */
<a name="6293"></a>                if(obj == nil || !obj.ofKind(AgendaItem) || 
<a name="6294"></a>                   obj.getActor != respondingActor)
<a name="6295"></a>                {
<a name="6296"></a>                    showAgendaError(tag, arg);
<a name="6297"></a>                }
<a name="6298"></a>                else
<a name="6299"></a>                    /* 
<a name="6300"></a>                     *   Otherwise remove the AgendaItem obj from our
<a name="6301"></a>                     *   respondingActor's agendaList and that of any associated
<a name="6302"></a>                     *   DefaultAgendaTopics
<a name="6303"></a>                     */
<a name="6304"></a>                    respondingActor.removeFromAllAgendas(obj);
<a name="6305"></a>                break;
<a name="6306"></a>                
<a name="6307"></a>            case 'state':
<a name="6308"></a>                /* change ActorState */
<a name="6309"></a>                
<a name="6310"></a>                /* 
<a name="6311"></a>                 *   Obtain the object corresponding to arg (a string value)
<a name="6312"></a>                 *   from our object name table
<a name="6313"></a>                 */
<a name="6314"></a>                obj = objNameTab[arg];
<a name="6315"></a>                
<a name="6316"></a>                /* Convert a string 'nil' to an actual nil */
<a name="6317"></a>                if(arg == 'nil')
<a name="6318"></a>                    obj = nil;                
<a name="6319"></a>                
<a name="6320"></a>                /* 
<a name="6321"></a>                 *   Otherwise if the object we're trying to add to an agenda
<a name="6322"></a>                 *   list isn't an ActorState belonging to our respondingActor,
<a name="6323"></a>                 *   display an error message.
<a name="6324"></a>                 */
<a name="6325"></a>                else if(obj == nil || !obj.ofKind(ActorState) || 
<a name="6326"></a>                   obj.getActor != respondingActor)
<a name="6327"></a>                {
<a name="6328"></a>                    showStateError(tag, arg);
<a name="6329"></a>                }
<a name="6330"></a>                else
<a name="6331"></a>                    /* 
<a name="6332"></a>                     *   Otherwise set our respondingActor's ActorState to the
<a name="6333"></a>                     *   new state requested (obj).
<a name="6334"></a>                     */
<a name="6335"></a>                    respondingActor.setState(obj);
<a name="6336"></a>                break;
<a name="6337"></a>            
<a name="6338"></a>                /* Fallthrough is deliberate here, the treatment of all three tags is very similar */
<a name="6339"></a>            case 'npcknow':
<a name="6340"></a>            case 'pcknow':
<a name="6341"></a>            case 'known':
<a name="6342"></a>                /* mark as item as known. */
<a name="6343"></a>                
<a name="6344"></a>                /* 
<a name="6345"></a>                 *   If our tag is npcknown, we want to update the knowledge of the NPC the player
<a name="6346"></a>                 *   is in conversation with, otherwise we want to update the player character's
<a name="6347"></a>                 *   knowledge.
<a name="6348"></a>                 */
<a name="6349"></a>                actor = (tag == 'npcknow' ? respondingActor : gPlayerChar);
<a name="6350"></a>                
<a name="6351"></a>                
<a name="6352"></a>                /* 
<a name="6353"></a>                 *   If arg contains is not a valid identifier name, it can't be an object name, so
<a name="6354"></a>                 *   assume it's a fact tag string and set obj accordingly.
<a name="6355"></a>                 */
<a name="6356"></a>                
<a name="6357"></a>                if(!isValidIdentifierName(arg))
<a name="6358"></a>                {    
<a name="6359"></a>                    /* 
<a name="6360"></a>                     *   If we've started arg with the factTagMarker character to force it to be a
<a name="6361"></a>                     *   non-valid identifier name, remove the factTagMarker to get at the the
<a name="6362"></a>                     *   actual tag name, otherwise simple use arg as the tag name.
<a name="6363"></a>                     */
<a name="6364"></a>                    arg = stripFactTagMarker(arg);   
<a name="6365"></a>                    
<a name="6366"></a>                    args = arg.split('=');
<a name="6367"></a>                    
<a name="6368"></a>                    obj = (actor == gPlayerChar) ? gPlayerChar : self;
<a name="6369"></a>                    if(args.length &gt; 1)
<a name="6370"></a>                    {        
<a name="6371"></a>                        arg = enumTabObj.getEnum(args[2]) ?? args[2];
<a name="6372"></a>                        obj.setInformed(args[1], arg);
<a name="6373"></a>                    }
<a name="6374"></a>                    else 
<a name="6375"></a>                        obj.setInformed(arg);
<a name="6376"></a>                }
<a name="6377"></a>                
<a name="6378"></a>                else
<a name="6379"></a>                {
<a name="6380"></a>                    /* 
<a name="6381"></a>                     *   Obtain the object corresponding to arg (a string value) from our object
<a name="6382"></a>                     *   name table
<a name="6383"></a>                     */
<a name="6384"></a>                    obj = objNameTab[arg];
<a name="6385"></a>                    
<a name="6386"></a>                    /* 
<a name="6387"></a>                     *   If the obj doesn't exist, or it isn't a Mentionable, display an error
<a name="6388"></a>                     *   message
<a name="6389"></a>                     */
<a name="6390"></a>                    if(obj == nil || !obj.ofKind(Mentionable))
<a name="6391"></a>                    {                                               
<a name="6392"></a>                        showKnownError(tag, arg);
<a name="6393"></a>                        
<a name="6394"></a>                        /* Set obj to nil so we know not to use it. */
<a name="6395"></a>                        obj = nil;
<a name="6396"></a>                        
<a name="6397"></a>                    }    
<a name="6398"></a>                    /* If obj is not nil, make our player character know about it. */
<a name="6399"></a>                    if(obj != nil &amp;&amp; actor != nil)
<a name="6400"></a>                        actor.setKnowsAbout(obj);
<a name="6401"></a>                }
<a name="6402"></a>                
<a name="6403"></a>                
<a name="6404"></a>                break;
<a name="6405"></a>                
<a name="6406"></a>            default:
<a name="6407"></a>                /* check for an extended tag */
<a name="6408"></a>                doCustomTag(tag, arg);
<a name="6409"></a>                break;
<a name="6410"></a>            }
<a name="6411"></a>
<a name="6412"></a>            /* continue the search after this match */
<a name="6413"></a>            start = nxtOfs;
<a name="6414"></a>        }
<a name="6415"></a>
<a name="6416"></a>        /* 
<a name="6417"></a>         *   remove the tags from the text by replacing every occurrence
<a name="6418"></a>         *   with an empty string, and return the result 
<a name="6419"></a>         */
<a name="6420"></a>        return rexReplace(tagPat, txt, '', ReplaceAll);
<a name="6421"></a>    }
<a name="6422"></a>
<a name="6423"></a>    
<a name="6424"></a>    /* The turn on which we last processed a convnode tag */
<a name="6425"></a>    convnodeSetTurn = 0
<a name="6426"></a>    
<a name="6427"></a>    /* regular expression pattern for our tags */
<a name="6428"></a>    tagPat = static new RexPattern(
<a name="6429"></a>        '&lt;nocase&gt;&lt;langle&gt;&lt;dot&gt;'
<a name="6430"></a>        + '(reveal|unreveal|agenda|remove|state|known|activate|inform|convstay|topics'
<a name="6431"></a>        + (customTags != nil ? '|' + customTags : '')
<a name="6432"></a>        + '|arouse|suggest|sugkey|convnode|convnodet|convstayt|deactivate|unarouse|abate'
<a name="6433"></a>        + '|pcknow|npcknow)'
<a name="6434"></a>        + '(&lt;space&gt;+(&lt;^rangle&gt;+))?'
<a name="6435"></a>        + '&lt;rangle&gt;')
<a name="6436"></a>
<a name="6437"></a>	/* Provided we have a respondingActor, call its manageKeys method. */	
<a name="6438"></a>    manageKeys()
<a name="6439"></a>    {
<a name="6440"></a>	   if(respondingActor != nil)
<a name="6441"></a>	      respondingActor.manageKeys();
<a name="6442"></a>    }	
<a name="6443"></a>		
<a name="6444"></a>    /*
<a name="6445"></a>     *   Schedule a topic inventory request.  Game code can call this at
<a name="6446"></a>     *   any time to request that the player character's topic inventory
<a name="6447"></a>     *   be shown automatically just before the next command prompt.  In
<a name="6448"></a>     *   most cases, game code won't call this directly, but will request
<a name="6449"></a>     *   the same effect using the &lt;.topics&gt; tag in topic response text.  
<a name="6450"></a>     */
<a name="6451"></a>    scheduleTopicInventory(key = nil)
<a name="6452"></a>    {
<a name="6453"></a>        /* note that we have a request for a prompt-time topic inventory */
<a name="6454"></a>        pendingTopicInventory = true;      
<a name="6455"></a>        
<a name="6456"></a>        /* note the key to be used for this request. */
<a name="6457"></a>        pendingTopicInventoryKey = key;
<a name="6458"></a>    }
<a name="6459"></a>
<a name="6460"></a>    /*
<a name="6461"></a>     *   Mark a tag as revealed.  This adds an entry for the tag to the
<a name="6462"></a>     *   revealedNameTab table.  We simply set the table entry to 'true'; the
<a name="6463"></a>     *   presence of the tag in the table constitutes the indication that the
<a name="6464"></a>     *   tag has been revealed.
<a name="6465"></a>     *
<a name="6466"></a>     *   (Games and library extensions can use 'modify' to override this and
<a name="6467"></a>     *   store more information in the table entry.  For example, you could
<a name="6468"></a>     *   store the time when the information was first revealed, or the location
<a name="6469"></a>     *   where it was learned.  If you do override this, just be sure to set the
<a name="6470"></a>     *   revealedNameTab entry for the tag to a non-nil and non-zero value, so
<a name="6471"></a>     *   that any code testing the presence of the table entry will see that the
<a name="6472"></a>     *   slot is indeed set.)
<a name="6473"></a>     *
<a name="6474"></a>     *   The actual method and the revealedNameTab are on libGlobal rather than
<a name="6475"></a>     *   here in order to make them available to games that don't include
<a name="6476"></a>     *   actor.t.
<a name="6477"></a>     */
<a name="6478"></a>    setRevealed(tag, val?)
<a name="6479"></a>    {
<a name="6480"></a>        /* Note that our tag has been revealed */
<a name="6481"></a>        libGlobal.setRevealed(tag, val);
<a name="6482"></a>        
<a name="6483"></a>        /* 
<a name="6484"></a>         *   If we're in a conversational context (so that we have a respondingActor) update the
<a name="6485"></a>         *   last fact mentioned to tag.
<a name="6486"></a>         */
<a name="6487"></a>        if(respondingActor != nil)
<a name="6488"></a>            libGlobal.lastFactMentioned = tag;
<a name="6489"></a>        
<a name="6490"></a>        /* 
<a name="6491"></a>         *   If something has just been revealed to us, it has also just been revealed to every
<a name="6492"></a>         *   other actor in the vicinity who could overhear the conversation (including the actor
<a name="6493"></a>         *   who has just spoken, if there is one; if there isn't then the revealed tag is
<a name="6494"></a>         *   presumably being used for a non-conversational purpose, so we don't try to inform any
<a name="6495"></a>         *   other actors).
<a name="6496"></a>         *
<a name="6497"></a>         *   Note that we only do this if our respondingActor wants to allow it through its
<a name="6498"></a>         *   informOverheard property and the global option to inform on reveal is set on libGlobal.
<a name="6499"></a>         *   If we want to model a private conversation that other people present don't pick up, we
<a name="6500"></a>         *   can override informOverheard on the the current ActorState or actorInformedOverhead on
<a name="6501"></a>         *   the Actor.
<a name="6502"></a>         */                
<a name="6503"></a>        if(libGlobal.informOnReveal &amp;&amp; respondingActor != nil &amp;&amp; respondingActor.informOverheard)
<a name="6504"></a>        {
<a name="6505"></a>            
<a name="6506"></a>            forEachInstance(Actor, new function(a) {
<a name="6507"></a>                if(a != gPlayerChar &amp;&amp; Q.canHear(a, respondingActor))
<a name="6508"></a>                    a.setInformed(tag);
<a name="6509"></a>            } );
<a name="6510"></a>            
<a name="6511"></a>        }
<a name="6512"></a>    }
<a name="6513"></a>    
<a name="6514"></a>    /*
<a name="6515"></a>     *   Mark a tag as unrevealed.  This removes an entry for the tag to the revealedNameTab table.
<a name="6516"></a>     *
<a name="6517"></a>     *   The actual method and the revealedNameTab are on libGlobal rather than here in order to
<a name="6518"></a>     *   make them available to games that don't include actor.t.
<a name="6519"></a>     */
<a name="6520"></a>    setUnrevealed(tag)
<a name="6521"></a>    {
<a name="6522"></a>        libGlobal.setUnrevealed(tag);       
<a name="6523"></a>    }
<a name="6524"></a>
<a name="6525"></a>    /* 
<a name="6526"></a>     *   Notify every actor who's in a position to hear that we've just imparted
<a name="6527"></a>     *   some information.
<a name="6528"></a>     */
<a name="6529"></a>    setInformed(tag, val?)
<a name="6530"></a>    {
<a name="6531"></a>        /*
<a name="6532"></a>         *   Note that we only do this if our respondingActor wants to allow it
<a name="6533"></a>         *   through its informOverheard property. If we want to model a private
<a name="6534"></a>         *   conversation that other people present don't pick up, we can
<a name="6535"></a>         *   override informOverheard on the the current ActorState or
<a name="6536"></a>         *   actorInformedOverhead on the Actor.
<a name="6537"></a>         */
<a name="6538"></a>        if(respondingActor.informOverheard)
<a name="6539"></a>        {
<a name="6540"></a>            forEachInstance(Actor, new function(a) {
<a name="6541"></a>                if(a != gPlayerChar &amp;&amp; Q.canHear(a, gPlayerChar))
<a name="6542"></a>                    a.setInformed(tag, val);
<a name="6543"></a>            } );
<a name="6544"></a>        }
<a name="6545"></a>        
<a name="6546"></a>        /* 
<a name="6547"></a>         *   If this is a private conversation (informOverheard = nil), just set
<a name="6548"></a>         *   the informed tage on our respondingActor alone.
<a name="6549"></a>         */
<a name="6550"></a>        else
<a name="6551"></a>        {
<a name="6552"></a>            respondingActor.setInformed(tag, val);
<a name="6553"></a>        }
<a name="6554"></a>        
<a name="6555"></a>        /* Update the last fact mentioned to the tag. */
<a name="6556"></a>        libGlobal.lastFactMentioned = tag;
<a name="6557"></a>        
<a name="6558"></a>    }
<a name="6559"></a>    
<a name="6560"></a>    /* 
<a name="6561"></a>     *   Display an error message if the game code tries to add or remove agenda
<a name="6562"></a>     *   items from an agendaList using a &lt;.agenda item&gt; or &lt;.remove item&gt; tag,
<a name="6563"></a>     *   when item doesn't correspond to a valid AgendaItem, but only do so if
<a name="6564"></a>     *   the game has been compiled for debugging.
<a name="6565"></a>     */
<a name="6566"></a>    showAgendaError(tag, arg)
<a name="6567"></a>    {
<a name="6568"></a>#ifdef __DEBUG
<a name="6569"></a>        "WARNING!!! ";
<a name="6570"></a>        if(obj == nil)
<a name="6571"></a>            showObjNotExistError(tag, arg, 'Agenda Item');
<a name="6572"></a>        else if(!obj.ofKind(AgendaItem))
<a name="6573"></a>            showWrongKindofObjectError(tag, arg, 'an Agenda Item');
<a name="6574"></a>        else if(obj.getActor != respondingActor)
<a name="6575"></a>            showObjDoesNotBelongToActorError(tag, arg, 'Agenda Item');
<a name="6576"></a>        
<a name="6577"></a>        
<a name="6578"></a>#endif        
<a name="6579"></a>    }
<a name="6580"></a>    
<a name="6581"></a>    
<a name="6582"></a>    /* 
<a name="6583"></a>     *   Display an error message if the game code tries to change our actor's
<a name="6584"></a>     *   ActorState via a &lt;.state newstate&gt; tag, when tag doesn't correspond to
<a name="6585"></a>     *   a valid ActorState, but only do so if the game has been compiled for
<a name="6586"></a>     *   debugging.
<a name="6587"></a>     */
<a name="6588"></a>    showStateError(tag, arg)
<a name="6589"></a>    {
<a name="6590"></a>        #ifdef __DEBUG
<a name="6591"></a>        "WARNING!!! ";
<a name="6592"></a>        if(obj == nil)
<a name="6593"></a>            showObjNotExistError(tag, arg, 'Actor State');
<a name="6594"></a>        else if(!obj.ofKind(ActorState))
<a name="6595"></a>            showWrongKindofObjectError(tag, arg, 'an ActorState');
<a name="6596"></a>        else if(obj.getActor != respondingActor)
<a name="6597"></a>            showObjDoesNotBelongToActorError(tag, arg, 'Actor State');
<a name="6598"></a>        
<a name="6599"></a>        #endif
<a name="6600"></a>    }
<a name="6601"></a>
<a name="6602"></a>    /* 
<a name="6603"></a>     *   Display an error message if the game code tries mark an object as known
<a name="6604"></a>     *   about using a &lt;.known obj&gt; tag, when obj doesn't correspond to a valid
<a name="6605"></a>     *   Mentionable object, but only do so if the game has been compiled for
<a name="6606"></a>     *   debugging.
<a name="6607"></a>     */
<a name="6608"></a>    showKnownError(tag, arg)
<a name="6609"></a>    {
<a name="6610"></a>         #ifdef __DEBUG
<a name="6611"></a>        "WARNING!!! ";
<a name="6612"></a>        if(obj == nil)
<a name="6613"></a>            showObjNotExistError(tag, arg, 'Mentionable');
<a name="6614"></a>        else if(!obj.ofKind(Mentionable))
<a name="6615"></a>            showWrongKindofObjectError(tag, arg, 'a Mentionable');
<a name="6616"></a>        
<a name="6617"></a>#endif
<a name="6618"></a>    }
<a name="6619"></a>    
<a name="6620"></a>    /* 
<a name="6621"></a>     *   Various supporting routines for displaying error messages that are only
<a name="6622"></a>     *   needed if the game has been compiled for debugging
<a name="6623"></a>     */
<a name="6624"></a>    
<a name="6625"></a> #ifdef __DEBUG   
<a name="6626"></a>    /* The object referred to by tag doesn't exist */
<a name="6627"></a>    showObjNotExistError(tag, arg, typ)
<a name="6628"></a>    {
<a name="6629"></a>        "&lt;&lt;typ&gt;&gt; &lt;&lt;arg&gt;&gt; for (actor = &lt;&lt;respondingActor.name&gt;&gt; was not added to
<a name="6630"></a>        conversationManager.objNameTab or does not exist. Check that you have
<a name="6631"></a>        spelled the &lt;&lt;typ&gt;&gt; &lt;&lt;arg&gt;&gt; name correctly. ";
<a name="6632"></a>    }
<a name="6633"></a>    
<a name="6634"></a>    /* The object referred to by tag is the wrong sort of object */
<a name="6635"></a>    showWrongKindofObjectError(tag, arg, typ)
<a name="6636"></a>    {
<a name="6637"></a>        "&lt;tag&gt; is not &lt;&lt;typ&gt;&gt; so can't be used in a &lt;&lt;tag&gt;&gt; tag (see
<a name="6638"></a>        TopicEntries for &lt;&lt;respondingActor.theName&gt;&gt; ";
<a name="6639"></a>    }
<a name="6640"></a>    
<a name="6641"></a>    /* The object referred to by tag doesn't belong to the actor in question */
<a name="6642"></a>    showObjDoesNotBelongToActorError(tag, arg, typ)
<a name="6643"></a>    {
<a name="6644"></a>        "&lt;&lt;typ&gt;&gt; &lt;&lt;tag&gt;&gt; does not belong to
<a name="6645"></a>            &lt;&lt;respondingActor.theName&gt;&gt;, so can't be used in a &lt;&lt;tag&gt;&gt; tag. ";
<a name="6646"></a>    }
<a name="6647"></a> #endif   
<a name="6648"></a>    
<a name="6649"></a>    /* a vector of actors, indexed by their convMgrID values */
<a name="6650"></a>    idToActor = static new Vector(32)
<a name="6651"></a>
<a name="6652"></a>    /* preinitialize */
<a name="6653"></a>    execute()
<a name="6654"></a>    {
<a name="6655"></a>        
<a name="6656"></a>        /*  Add ourselves to the list of output filters. */        
<a name="6657"></a>        mainOutputStream.addOutputFilter(self);
<a name="6658"></a>        
<a name="6659"></a>        /* 
<a name="6660"></a>         *   Set up the prompt daemon that makes automatic topic inventory
<a name="6661"></a>         *   suggestions when appropriate 
<a name="6662"></a>         */
<a name="6663"></a>        new PromptDaemon(self, &amp;topicInventoryDaemon);
<a name="6664"></a>    }
<a name="6665"></a>
<a name="6666"></a>    /*
<a name="6667"></a>     *   Prompt daemon: show topic inventory when appropriate.  When a
<a name="6668"></a>     *   response explicitly asks us to show a topic inventory using the
<a name="6669"></a>     *   &lt;.topics&gt; tag, or when other game code asks us to show topic
<a name="6670"></a>     *   inventory by calling scheduleTopicInventory(), we'll show the
<a name="6671"></a>     *   inventory just before the command input prompt.  
<a name="6672"></a>     */
<a name="6673"></a>    topicInventoryDaemon()
<a name="6674"></a>    {
<a name="6675"></a>        /* if we have a topic inventory scheduled, show it now */
<a name="6676"></a>        if (pendingTopicInventory)
<a name="6677"></a>        {
<a name="6678"></a>            /* 
<a name="6679"></a>             *   Show the player character's topic inventory.  This is not
<a name="6680"></a>             *   an explicit inventory request, since the player didn't ask
<a name="6681"></a>             *   for it.  
<a name="6682"></a>             */
<a name="6683"></a>            
<a name="6684"></a>            if(gPlayerChar.currentInterlocutor != nil)
<a name="6685"></a>                gPlayerChar.currentInterlocutor.showSuggestions(nil,
<a name="6686"></a>                    pendingTopicInventoryKey); 
<a name="6687"></a>
<a name="6688"></a>            /* we no longer have a pending inventory request */
<a name="6689"></a>            pendingTopicInventory = nil;
<a name="6690"></a>            pendingTopicInventoryKey = nil;
<a name="6691"></a>        }
<a name="6692"></a>    }
<a name="6693"></a>
<a name="6694"></a>    /* flag: we have a pending prompt-time topic inventory request */
<a name="6695"></a>    pendingTopicInventory = nil
<a name="6696"></a>    
<a name="6697"></a>    /* The key to use for the pending prompt-time inventory request */
<a name="6698"></a>    pendingTopicInventoryKey = nil
<a name="6699"></a>    
<a name="6700"></a>    objNameTab = static new LookupTable
<a name="6701"></a>;
<a name="6702"></a>
<a name="6703"></a>/* 
<a name="6704"></a> *   Base class for items (Actors and DefaultAgendaTopics) that can handle
<a name="6705"></a> *   AgendaItems */
<a name="6706"></a>
<a name="6707"></a>modify AgendaManager
<a name="6708"></a>    
<a name="6709"></a>    /* 
<a name="6710"></a>     *   Our agendaList is the list of AgendaItems we're ready to execute when
<a name="6711"></a>     *   they're isReady property is true.
<a name="6712"></a>     */
<a name="6713"></a>    agendaList = nil
<a name="6714"></a>    
<a name="6715"></a>    /* 
<a name="6716"></a>     *   add an agenda item. We try to make this as author-proof as possible so
<a name="6717"></a>     *   that the method will accept addToAgenda(item), addToAgenda(item1,
<a name="6718"></a>     *   item2, ...) or addToAgenda([item1, item2,..])
<a name="6719"></a>     */     
<a name="6720"></a>     addToAgenda([lst])
<a name="6721"></a>    {
<a name="6722"></a>        /* if we don't have an agenda list yet, create one */
<a name="6723"></a>        if (agendaList == nil)
<a name="6724"></a>            agendaList = new Vector(10);
<a name="6725"></a>        
<a name="6726"></a>        /* add the item or items. */
<a name="6727"></a>        foreach(local val in lst)
<a name="6728"></a>        {    
<a name="6729"></a>            foreach(local cur in valToList(val))
<a name="6730"></a>            {
<a name="6731"></a>                /* Check that cur is a valid value nefore doing anything with it. */
<a name="6732"></a>                if(getActor.checkAgenda(cur))
<a name="6733"></a>                {
<a name="6734"></a>                    /* Add cut to our agendaList. */
<a name="6735"></a>                    agendaList += cur;
<a name="6736"></a>                    
<a name="6737"></a>                    /* reset the agenda item */
<a name="6738"></a>                    cur.resetItem();
<a name="6739"></a>                    
<a name="6740"></a>                    /* 
<a name="6741"></a>                     *   carry out any registration needed - primarily needed for FollowAgendaItems.
<a name="6742"></a>                     */
<a name="6743"></a>                    cur.registerItem();
<a name="6744"></a>                }
<a name="6745"></a>            }
<a name="6746"></a>        }
<a name="6747"></a>        
<a name="6748"></a>        /* 
<a name="6749"></a>         *   Keep the list in ascending order of agendaOrder values - this will
<a name="6750"></a>         *   ensure that we'll always choose the earliest item that's ready to
<a name="6751"></a>         *   run
<a name="6752"></a>         */
<a name="6753"></a>        agendaList.sort(SortAsc, {a, b: a.agendaOrder - b.agendaOrder});       
<a name="6754"></a>    }
<a name="6755"></a>
<a name="6756"></a>    /* remove one or more agenda items */
<a name="6757"></a>    removeFromAgenda([lst])
<a name="6758"></a>    {
<a name="6759"></a>        /* if we have an agenda list, remove the item */
<a name="6760"></a>        if (agendaList != nil)
<a name="6761"></a>        {
<a name="6762"></a>            foreach(local val in lst)
<a name="6763"></a>            {
<a name="6764"></a>                foreach(local item in valToList(val))
<a name="6765"></a>                {
<a name="6766"></a>                    agendaList.removeElement(item);                    
<a name="6767"></a>                }
<a name="6768"></a>            }
<a name="6769"></a>        }
<a name="6770"></a>    }
<a name="6771"></a>
<a name="6772"></a>    /*
<a name="6773"></a>     *   Execute the next item in our agenda, if there are any items in the
<a name="6774"></a>     *   agenda that are ready to execute.  We'll return true if we found
<a name="6775"></a>     *   an item to execute, nil if not.  
<a name="6776"></a>     */
<a name="6777"></a>    executeAgenda()
<a name="6778"></a>    {
<a name="6779"></a>        local item;
<a name="6780"></a>        local actor = getActor;
<a name="6781"></a>
<a name="6782"></a>        /* if we don't have an agenda, there are obviously no items */
<a name="6783"></a>        if (agendaList == nil)
<a name="6784"></a>            return nil;
<a name="6785"></a>        
<a name="6786"></a>        /* remove any items that are marked as done */
<a name="6787"></a>        while ((item = agendaList.lastValWhich({x: x.isDone})) != nil)
<a name="6788"></a>        {    
<a name="6789"></a>            actor.removeFromAllAgendas(item);
<a name="6790"></a>            actor.removeFromPendingAgenda(item);
<a name="6791"></a>        }
<a name="6792"></a>
<a name="6793"></a>        /* 
<a name="6794"></a>         *   Scan for an item that's ready to execute.  Since we keep the
<a name="6795"></a>         *   list sorted in ascending order of agendaOrder values, we can
<a name="6796"></a>         *   just pick the earliest item in the list that's ready to run,
<a name="6797"></a>         *   since that will be the ready-to-run item with the lowest
<a name="6798"></a>         *   agendaOrder number. 
<a name="6799"></a>         */
<a name="6800"></a>        item = agendaList.valWhich({x: x.isReady});
<a name="6801"></a>
<a name="6802"></a>        /* if we found an item, execute it */
<a name="6803"></a>        if (item != nil)
<a name="6804"></a>        {
<a name="6805"></a>            try
<a name="6806"></a>            {
<a name="6807"></a>                /* execute the item */
<a name="6808"></a>                item.invokeItemBase(self);
<a name="6809"></a>                
<a name="6810"></a>                /* 
<a name="6811"></a>                 *   if the item is done, remove it from all relevant agenda
<a name="6812"></a>                 *   lists
<a name="6813"></a>                 */
<a name="6814"></a>                if(item.isDone)
<a name="6815"></a>                    getActor.removeFromAllAgendas(item);
<a name="6816"></a>            }
<a name="6817"></a>            catch (RuntimeError err)
<a name="6818"></a>            {
<a name="6819"></a>                /* 
<a name="6820"></a>                 *   If an error occurs while executing the item, mark the
<a name="6821"></a>                 *   item as done.  This will ensure that we won't get
<a name="6822"></a>                 *   stuck in a loop trying to execute the same item over
<a name="6823"></a>                 *   and over, which will probably just run into the same
<a name="6824"></a>                 *   error on each attempt.  
<a name="6825"></a>                 */
<a name="6826"></a>                item.isDone = true;
<a name="6827"></a>
<a name="6828"></a>                /* re-throw the exception */
<a name="6829"></a>                throw err;
<a name="6830"></a>            }
<a name="6831"></a>
<a name="6832"></a>            /* tell the caller we found an item to execute */
<a name="6833"></a>            return true;
<a name="6834"></a>        }
<a name="6835"></a>        else
<a name="6836"></a>        {
<a name="6837"></a>            /* tell the caller we found no agenda item */
<a name="6838"></a>            return nil;
<a name="6839"></a>        }
<a name="6840"></a>    }    
<a name="6841"></a>    
<a name="6842"></a>    /* 
<a name="6843"></a>     *   Check whether ag is an AgendsItem belonging to our Actor. If it isn't, issue a warning
<a name="6844"></a>     *   message and return nil. Otherwise return true to allow our caller to go ahead adding this
<a name="6845"></a>     *   agendaItem to the relevant agendaList(s).
<a name="6846"></a>     */
<a name="6847"></a>    checkAgenda(ag)
<a name="6848"></a>    {
<a name="6849"></a>        if(!(objOfKind(ag, AgendaItem) &amp;&amp; ag.getActor == self))
<a name="6850"></a>        {
<a name="6851"></a>            DMsg(bad agenda item, '&lt;FONT COLOR=RED&gt;&lt;b&gt;WARNING!&lt;/b&gt;&lt;/FONT&gt;: attempt to add something
<a name="6852"></a>                to the agenda for &lt;&lt;getActor.theName&gt;&gt; that is not an AgendaItem belonging to that
<a name="6853"></a>                Actor. ');
<a name="6854"></a>            return nil;
<a name="6855"></a>        }
<a name="6856"></a>        
<a name="6857"></a>        return true;         
<a name="6858"></a>    }
<a name="6859"></a>;
<a name="6860"></a>
<a name="6861"></a>
<a name="6862"></a>
<a name="6863"></a>/* ------------------------------------------------------------------------ */
<a name="6864"></a>/*
<a name="6865"></a> *   An "agenda item."  Each actor can have its own "agenda," which is a
<a name="6866"></a> *   list of these items.  Each item represents an action that the actor
<a name="6867"></a> *   wants to perform - this is usually a goal the actor wants to achieve,
<a name="6868"></a> *   or a conversational topic the actor wants to pursue.
<a name="6869"></a> *   
<a name="6870"></a> *   On any given turn, an actor can carry out only one agenda item.
<a name="6871"></a> *   
<a name="6872"></a> *   Agenda items are a convenient way of controlling complex behavior.
<a name="6873"></a> *   Each agenda item defines its own condition for when the actor can
<a name="6874"></a> *   pursue the item, and each item defines what the actor does when
<a name="6875"></a> *   pursuing the item.  Agenda items can improve the code structure for an
<a name="6876"></a> *   NPC's behavior, since they nicely isolate a single background action
<a name="6877"></a> *   and group it with the conditions that trigger it.  But the main
<a name="6878"></a> *   benefit of agenda items is the one-per-turn pacing - by executing at
<a name="6879"></a> *   most one agenda item per turn, we ensure that the NPC will carry out
<a name="6880"></a> *   its self-initiated actions at a measured pace, rather than as a jumble
<a name="6881"></a> *   of random actions on a single turn.
<a name="6882"></a> *   
<a name="6883"></a> *   Note that NPC-initiated conversation messages override agendas.  If an
<a name="6884"></a> *   actor has an active ConvNode, AND the ConvNode displays a
<a name="6885"></a> *   "continuation message" on a given turn, then the actor will not pursue
<a name="6886"></a> *   its agenda on that turn.  In this way, ConvNode continuation messages
<a name="6887"></a> *   act rather like high-priority agenda items.  
<a name="6888"></a> */
<a name="6889"></a>class AgendaItem: object
<a name="6890"></a>    /* 
<a name="6891"></a>     *   My actor - agenda items should be nested within the actor using
<a name="6892"></a>     *   '+' so that we can find our actor.  Note that this doesn't add the
<a name="6893"></a>     *   item to the actor's agenda - that has to be done explicitly with
<a name="6894"></a>     *   actor.addToAgenda().  
<a name="6895"></a>     */
<a name="6896"></a>    getActor() { return location.getActor; }
<a name="6897"></a>
<a name="6898"></a>    /*
<a name="6899"></a>     *   Is this item active at the start of the game?  Override this to
<a name="6900"></a>     *   true to make the item initially active; we'll add it to the
<a name="6901"></a>     *   actor's agenda during the game's initialization.  
<a name="6902"></a>     */
<a name="6903"></a>    initiallyActive = nil
<a name="6904"></a>
<a name="6905"></a>    /* 
<a name="6906"></a>     *   Is this item ready to execute?  The actor will only execute an
<a name="6907"></a>     *   agenda item when this condition is met.  By default, we're ready
<a name="6908"></a>     *   to execute.  Items can override this to provide a declarative
<a name="6909"></a>     *   condition of readiness if desired.  
<a name="6910"></a>     */
<a name="6911"></a>    isReady = true
<a name="6912"></a>
<a name="6913"></a>    /*
<a name="6914"></a>     *   Is this item done?  On each turn, we'll remove any items marked as done from the actor's
<a name="6915"></a>     *   agenda list.  We remove items marked as done before executing any items, so done-ness
<a name="6916"></a>     *   overrides readiness; in other words, if an item is both 'done' and 'ready', it'll simply be
<a name="6917"></a>     *   removed from the list and will not be executed.
<a name="6918"></a>     *
<a name="6919"></a>     *   By default, we simply return nil.  Items can override this to provide a declarative
<a name="6920"></a>     *   condition of done-ness, or they can simply set the property to true when they finish their
<a name="6921"></a>     *   work.  For example, an item that only needs to execute once can simply set isDone to true
<a name="6922"></a>     *   in its invokeItem() method; an item that's to be repeated until some success condition
<a name="6923"></a>     *   obtains can override isDone to return the success condition.
<a name="6924"></a>     *
<a name="6925"></a>     *   In some cases, it may be more convenient to set the endCondirion property to define when
<a name="6926"></a>     *   isDone should be set to true.
<a name="6927"></a>     */     
<a name="6928"></a>    isDone = nil
<a name="6929"></a>    
<a name="6930"></a>    /* 
<a name="6931"></a>     *   If specified, an expression or method that evaluates to true when this AgendaItem has
<a name="6932"></a>     *   oompleted its task and wants to set isDone to true. This is checked both immediately before
<a name="6933"></a>     *   and immediately after invokeItem() is called (since calling invokeItem might change the
<a name="6934"></a>     *   game state). This is provided as a conveniant alteranative to handling isDone from with
<a name="6935"></a>     *   invokeItem(), which may still be necessary in some cases, such as when you want an
<a name="6936"></a>     *   AgendaItem simply to execute once (although you can also use the executeOnce property for
<a name="6937"></a>     *   that).
<a name="6938"></a>     */     
<a name="6939"></a>    endCondition = nil
<a name="6940"></a>    
<a name="6941"></a>    /* Flag: do we want this AgendaItem to execute once and once only? */
<a name="6942"></a>    executeOnce = nil
<a name="6943"></a>
<a name="6944"></a>    /*
<a name="6945"></a>     *   The ordering of the item relative to other agenda items.  When we
<a name="6946"></a>     *   choose an agenda item to execute, we always choose the lowest
<a name="6947"></a>     *   numbered item that's ready to run.  You can leave this with the
<a name="6948"></a>     *   default value if you don't care about the order.  
<a name="6949"></a>     */
<a name="6950"></a>    agendaOrder = 100
<a name="6951"></a>
<a name="6952"></a>    /*
<a name="6953"></a>     *   The caller is passed as a parameter so we can tell whether we're being
<a name="6954"></a>     *   called from an Actor or from a DefaultAgendaTopic, which may affect
<a name="6955"></a>     *   what we want to do -- for example the wording of what the actor says at
<a name="6956"></a>     *   this point.
<a name="6957"></a>     */
<a name="6958"></a>    invokeItemBase(caller)
<a name="6959"></a>    {
<a name="6960"></a>        /* Note what object we were called from */
<a name="6961"></a>        calledBy = caller;
<a name="6962"></a>        
<a name="6963"></a>        /* 
<a name="6964"></a>         *   Store this AgendaItem on libGlobal a the most recently invoked AgendaItem. We use this
<a name="6965"></a>         *   so that any code or objects we invoke in turn (such as, in particular, InitiateTopics)
<a name="6966"></a>         *   can see what invoked them.
<a name="6967"></a>         */
<a name="6968"></a>        libGlobal.agendaItem = self;
<a name="6969"></a>        
<a name="6970"></a>        try
<a name="6971"></a>        {
<a name="6972"></a>            /* If we've met our end condition, set isDone to true to show that we're done. */
<a name="6973"></a>            if(endCondition)
<a name="6974"></a>                isDone = true;
<a name="6975"></a>            
<a name="6976"></a>            /* Otherwise call our invokeItem() method */
<a name="6977"></a>            else
<a name="6978"></a>                invokeItem();
<a name="6979"></a>            
<a name="6980"></a>             /* 
<a name="6981"></a>              *   If we've met our end condition, set isDone to true to show that we're done. We
<a name="6982"></a>              *   test this again here in case invokeItem() changed the game state in a relevant
<a name="6983"></a>              *   way. Also set our isDone to true if ww've been set up to execute once only.
<a name="6984"></a>              */
<a name="6985"></a>            if(endCondition || executeOnce)
<a name="6986"></a>                isDone = true;
<a name="6987"></a>        }
<a name="6988"></a>        finally
<a name="6989"></a>        {
<a name="6990"></a>            /* 
<a name="6991"></a>             *   Resst libGlobal.agendaItem to nil so it's not carried over to a context in which
<a name="6992"></a>             *   it's no longer valid.
<a name="6993"></a>             */
<a name="6994"></a>            libGlobal.agendaItem = nil;
<a name="6995"></a>        }
<a name="6996"></a>    }
<a name="6997"></a>    
<a name="6998"></a>    /* 
<a name="6999"></a>     *   invokeItem can test the invokedByActor property to decide whether what
<a name="7000"></a>     *   the actor says should be a conversational gambit started on the actor's
<a name="7001"></a>     *   own initiative or as a (default) response to something the pc has just
<a name="7002"></a>     *   tried to say.     */
<a name="7003"></a>    
<a name="7004"></a>    invokedByActor = (calledBy == getActor)
<a name="7005"></a>    
<a name="7006"></a>    /* The object from whose agendaList this AgendaItem was invoked */
<a name="7007"></a>    calledBy = nil
<a name="7008"></a>    
<a name="7009"></a>    /*
<a name="7010"></a>     *   Execute this item.  This is invoked during the actor's turn when the
<a name="7011"></a>     *   item is the first item that's ready to execute in the actor's agenda
<a name="7012"></a>     *   list.  We do nothing by default.
<a name="7013"></a>     *    
<a name="7014"></a>     */
<a name="7015"></a>    invokeItem() { }
<a name="7016"></a>
<a name="7017"></a>    /*
<a name="7018"></a>     *   Reset the item.  This is invoked whenever the item is added to an
<a name="7019"></a>     *   actor's agenda.  By default, we'll set isDone to nil as long as
<a name="7020"></a>     *   isDone isn't a method; this makes it easier to reuse agenda
<a name="7021"></a>     *   items, since we don't have to worry about clearing out the isDone
<a name="7022"></a>     *   flag when reusing an item. 
<a name="7023"></a>     */
<a name="7024"></a>    resetItem()
<a name="7025"></a>    {
<a name="7026"></a>        /* if isDone isn't a method, reset it to nil */
<a name="7027"></a>        if (propType(&amp;isDone) != TypeCode)
<a name="7028"></a>            isDone = nil;
<a name="7029"></a>    }
<a name="7030"></a>    
<a name="7031"></a>    /*  
<a name="7032"></a>     *   Carry out any additional registration when we're added to our actor's
<a name="7033"></a>     *   agenda. We do nothing here, but this is needed on FollowAgendaItem.
<a name="7034"></a>     */
<a name="7035"></a>    registerItem() { }
<a name="7036"></a>    
<a name="7037"></a>    /* An optional tag, specified as a single-quoted string. */    
<a name="7038"></a>    name = nil
<a name="7039"></a>    
<a name="7040"></a>    /* 
<a name="7041"></a>     *   A convenience method that can be used from within our invokeItem to
<a name="7042"></a>     *   display some text only if the player character can see us (or, if the
<a name="7043"></a>     *   optional second parameter is supplied, sense us through some other
<a name="7044"></a>     *   sense, e.g. &amp;canHear or &amp;canSmell).
<a name="7045"></a>     */
<a name="7046"></a>    report(msg, prop=&amp;canSee) { senseSay(msg, getActor, prop); }
<a name="7047"></a>    
<a name="7048"></a>    /*  
<a name="7049"></a>     *   Another convensence method; calling actorSay() on an AgendaItem calls actorSay() on its
<a name="7050"></a>     *   associated Actor.
<a name="7051"></a>     */
<a name="7052"></a>    actorSay(msg) { getActor.actorSay(msg); }
<a name="7053"></a>    
<a name="7054"></a>    /* Calling initiateConversation) on its aasociated Actor. */
<a name="7055"></a>    initiateConversation(state, str)
<a name="7056"></a>    {
<a name="7057"></a>        getActor.initiateConversation(state, str);
<a name="7058"></a>    }
<a name="7059"></a>;
<a name="7060"></a>
<a name="7061"></a>
<a name="7062"></a>/*
<a name="7063"></a> *   A "conversational" agenda item.  This type of item is ready to execute
<a name="7064"></a> *   only when the actor hasn't engaged in conversation during the same
<a name="7065"></a> *   turn.  This type of item is ideal for situations where we want the
<a name="7066"></a> *   actor to pursue a conversational topic, because we won't initiate the
<a name="7067"></a> *   action until we get a turn where the player didn't directly talk to
<a name="7068"></a> *   us.  
<a name="7069"></a> */
<a name="7070"></a>class ConvAgendaItem: AgendaItem
<a name="7071"></a>    isReady = (getActor().convAgendaReady(otherActor) &amp;&amp; inherited())
<a name="7072"></a>
<a name="7073"></a>    /* 
<a name="7074"></a>     *   The actor we're planning to address - by default, this is the PC.
<a name="7075"></a>     *   If the conversational overture will be directed to another NPC,
<a name="7076"></a>     *   you can specify that other actor here. 
<a name="7077"></a>     */
<a name="7078"></a>    otherActor = (gPlayerChar)
<a name="7079"></a>    
<a name="7080"></a>    /* There's more work to do on a ConvAgendaItem when it's invoked */
<a name="7081"></a>    invokeItemBase(caller)
<a name="7082"></a>    {
<a name="7083"></a>        /* 
<a name="7084"></a>         *   Note that our actor is in conversation with the otherActor
<a name="7085"></a>         *   (normally gPlayerChar) and attempt an actor greeting, if one has
<a name="7086"></a>         *   been defined. It's useful to do this here since a ConvAgendaItem
<a name="7087"></a>         *   might very well initiate a conversation.
<a name="7088"></a>         */        
<a name="7089"></a>        local actor = getActor();
<a name="7090"></a>        
<a name="7091"></a>        /* Set a flag to show why this ConvAgendaItem has just been invoked */
<a name="7092"></a>        if(otherActor == gPlayerChar)                    
<a name="7093"></a>        {
<a name="7094"></a>            /* 
<a name="7095"></a>             *   If our actor is not already the player character's current
<a name="7096"></a>             *   interlocutor, then we've been invoked to start a new
<a name="7097"></a>             *   conversation
<a name="7098"></a>             */
<a name="7099"></a>            if(gPlayerChar.currentInterlocutor != actor)
<a name="7100"></a>                reasonInvoked = InitiateConversationReason;
<a name="7101"></a>            
<a name="7102"></a>            /*  
<a name="7103"></a>             *   Otherwise if we've been invoked from the actor object, note
<a name="7104"></a>             *   that we've been invoked from our actor's agendaList during a
<a name="7105"></a>             *   lull in the conversation.
<a name="7106"></a>             */
<a name="7107"></a>            else if(caller == actor)
<a name="7108"></a>                reasonInvoked = ConversationLullReason;
<a name="7109"></a>            
<a name="7110"></a>            /*  
<a name="7111"></a>             *   Otherwise note that we've been invoked from a
<a name="7112"></a>             *   DefaultAgendaTopic
<a name="7113"></a>             */
<a name="7114"></a>            else
<a name="7115"></a>                reasonInvoked = DefaultTopicReason;
<a name="7116"></a>            
<a name="7117"></a>            /* 
<a name="7118"></a>             *   Copy our reason invoked to libGlobal, to make available to code elsewhere, e.g. sn
<a name="7119"></a>             *   InititeTopic triggered by our invokeItem() method.
<a name="7120"></a>             */                 
<a name="7121"></a>            libGlobal.reasonInvoked = reasonInvoked;
<a name="7122"></a>            
<a name="7123"></a>            /* 
<a name="7124"></a>             *   Give the actor the chance to say hello, and note whether this
<a name="7125"></a>             *   resulted in any greeting being displayed. Note that
<a name="7126"></a>             *   Actor.actorSayHello() won't actually attempt to do anything if
<a name="7127"></a>             *   a conversation is already in progress.
<a name="7128"></a>             */
<a name="7129"></a>            greetingDisplayed = actor.actorSayHello();    
<a name="7130"></a>            
<a name="7131"></a>            /* 
<a name="7132"></a>             *   Note that our actor has conversed with the player character on
<a name="7133"></a>             *   this turn.
<a name="7134"></a>             */
<a name="7135"></a>            actor.noteConversed();
<a name="7136"></a>        }
<a name="7137"></a>        else
<a name="7138"></a>            otherActor.currentInterlocutor = actor;
<a name="7139"></a>        
<a name="7140"></a>        /* Then call the base handling */
<a name="7141"></a>        inherited(caller);     
<a name="7142"></a>        
<a name="7143"></a>        /* 
<a name="7144"></a>         *   It's possible that our invokeItem() method just tried to set up a
<a name="7145"></a>         *   convnode, but since the actor won't have gone through it's
<a name="7146"></a>         *   handleTopic method, it won't have moved any pendingKeys into the
<a name="7147"></a>         *   activeKeys, so we need to do that now. At the same time we need to
<a name="7148"></a>         *   tell the actor not to keep the pending keys beyond the next
<a name="7149"></a>         *   conversational turn. But we don't need to do any of this if we've
<a name="7150"></a>         *   been invoked from a DefaultAgendaTopic, since in that case we're
<a name="7151"></a>         *   being invoked as part of a conversational turn, which will handle
<a name="7152"></a>         *   the pending and active keys in any case.
<a name="7153"></a>         */
<a name="7154"></a>        
<a name="7155"></a>        if(reasonInvoked != DefaultTopicReason)
<a name="7156"></a>        {
<a name="7157"></a>            actor.activeKeys = actor.pendingKeys;        
<a name="7158"></a>            actor.keepPendingKeys = nil;
<a name="7159"></a>        }
<a name="7160"></a>    }
<a name="7161"></a>    
<a name="7162"></a>    /* 
<a name="7163"></a>     *   Flag; did invoking this item result in the display of a greeting (from
<a name="7164"></a>     *   an ActorHelloTopic)?
<a name="7165"></a>     */    
<a name="7166"></a>    greetingDisplayed = nil
<a name="7167"></a>    
<a name="7168"></a>    /* 
<a name="7169"></a>     *   Why was this ConvAgenda Item invoked?
<a name="7170"></a>     *.    1 = InitiateConversationReason = Actor initiating new conversation
<a name="7171"></a>     *.    2 = ConversationLullReason = Actor using lull in conversation
<a name="7172"></a>     *.    3 = DefaultTopicReason = Actor responding to DefaultAgendaTopic
<a name="7173"></a>     */            
<a name="7174"></a>    reasonInvoked = 0
<a name="7175"></a>    
<a name="7176"></a>;
<a name="7177"></a>
<a name="7178"></a>/*
<a name="7179"></a> *   A delayed agenda item.  This type of item becomes ready to execute
<a name="7180"></a> *   when the game clock reaches a given turn counter.  
<a name="7181"></a> */
<a name="7182"></a>class DelayedAgendaItem: AgendaItem
<a name="7183"></a>    /* we're ready if the game clock time has reached our ready time */
<a name="7184"></a>    isReady = (libGlobal.totalTurns &gt;= readyTime &amp;&amp; inherited())
<a name="7185"></a>
<a name="7186"></a>    /* the turn counter on the game clock when we become ready */
<a name="7187"></a>    readyTime = 0
<a name="7188"></a>
<a name="7189"></a>    /*
<a name="7190"></a>     *   Set our ready time based on a delay from the current time.  We'll
<a name="7191"></a>     *   become ready after the given number of turns elapses.  For
<a name="7192"></a>     *   convenience, we return 'self', so a delayed agenda item can be
<a name="7193"></a>     *   initialized and added to an actor's agenda in one simple
<a name="7194"></a>     *   operation, like so:
<a name="7195"></a>     *   
<a name="7196"></a>     *   actor.addToAgenda(item.setDelay(1)); 
<a name="7197"></a>     */
<a name="7198"></a>    setDelay(turns)
<a name="7199"></a>    {
<a name="7200"></a>        /* 
<a name="7201"></a>         *   initialize our ready time as the given number of turns in the
<a name="7202"></a>         *   future from the current game clock time 
<a name="7203"></a>         */
<a name="7204"></a>        readyTime = libGlobal.totalTurns + turns;
<a name="7205"></a>
<a name="7206"></a>        /* return 'self' for the caller's convenience */
<a name="7207"></a>        return self;
<a name="7208"></a>    }
<a name="7209"></a>;
<a name="7210"></a>
<a name="7211"></a>
<a name="7212"></a>/*
<a name="7213"></a> *   A special kind of agenda item for monitoring "boredom" during a
<a name="7214"></a> *   conversation.  We check to see if our actor is in a conversation, and
<a name="7215"></a> *   the PC has been ignoring the conversation for too long; if so, our
<a name="7216"></a> *   actor initiates the end of the conversation, since the PC apparently
<a name="7217"></a> *   isn't paying any attention to us. 
<a name="7218"></a> */
<a name="7219"></a>class BoredomAgendaItem: AgendaItem
<a name="7220"></a>    /* we construct these dynamically during actor initialization */
<a name="7221"></a>    construct(actor)
<a name="7222"></a>    {
<a name="7223"></a>        /* remember our actor as our location */
<a name="7224"></a>        location = actor;
<a name="7225"></a>    }
<a name="7226"></a>
<a name="7227"></a>    /* 
<a name="7228"></a>     *   we're ready to run if our actor is in an InConversationState and
<a name="7229"></a>     *   its boredom count has reached the limit for the state 
<a name="7230"></a>     */
<a name="7231"></a>    isReady()
<a name="7232"></a>    {
<a name="7233"></a>        local actor = getActor();
<a name="7234"></a>        local state = actor.curState;
<a name="7235"></a>        if(state == nil)
<a name="7236"></a>            state = actor;
<a name="7237"></a>
<a name="7238"></a>        return (inherited()
<a name="7239"></a>                &amp;&amp; gPlayerChar.currentInterlocutor == actor
<a name="7240"></a>                &amp;&amp; state.attentionSpan != nil
<a name="7241"></a>                &amp;&amp; actor.boredomCount &gt;= state.attentionSpan);
<a name="7242"></a>    }
<a name="7243"></a>
<a name="7244"></a>    /* on invocation, end the conversation */
<a name="7245"></a>    invokeItem()
<a name="7246"></a>    {
<a name="7247"></a>        local actor = getActor();
<a name="7248"></a>        local state = actor.curState;
<a name="7249"></a>        if(state == nil)
<a name="7250"></a>            state = actor;
<a name="7251"></a>
<a name="7252"></a>        /* tell the actor to end the conversation */
<a name="7253"></a>        actor.endConversation(endConvBoredom);
<a name="7254"></a>       
<a name="7255"></a>        /* 
<a name="7256"></a>         *   Mark us as done; we'll be reinstated the next time someone
<a name="7257"></a>         *   converses with our actor.
<a name="7258"></a>         */
<a name="7259"></a>        isDone = true;
<a name="7260"></a>    }
<a name="7261"></a>
<a name="7262"></a>    /* 
<a name="7263"></a>     *   by default, handle boredom before other agenda items - we do this
<a name="7264"></a>     *   because an ongoing conversation will be the first thing on the
<a name="7265"></a>     *   NPC's mind 
<a name="7266"></a>     */
<a name="7267"></a>    agendaOrder = 50
<a name="7268"></a>;
<a name="7269"></a>
<a name="7270"></a>/* 
<a name="7271"></a> *   An AgendaItem that can be used to trigger actor travel when the actor is
<a name="7272"></a> *   waiting for the player character to follow him/her/it.
<a name="7273"></a> */
<a name="7274"></a>class FollowAgendaItem: AgendaItem    
<a name="7275"></a>    
<a name="7276"></a>    invokeItem()
<a name="7277"></a>    {
<a name="7278"></a>         /* Note our actor */
<a name="7279"></a>        local actor = getActor;
<a name="7280"></a>               
<a name="7281"></a>        /* Note our actor's current ActorState */
<a name="7282"></a>        local stat = actor.curState;
<a name="7283"></a>        
<a name="7284"></a>        /* If we've exhausted our list of connectors, then we're done. */
<a name="7285"></a>        if(nextConnNum &gt;= connectorList.length)    
<a name="7286"></a>        {
<a name="7287"></a>            isDone = true;    
<a name="7288"></a>            actor.followAgendaItem = nil;
<a name="7289"></a>            return;
<a name="7290"></a>        }
<a name="7291"></a>        
<a name="7292"></a>        /* Get our next connector */
<a name="7293"></a>        local conn = nextConnector;       
<a name="7294"></a>        
<a name="7295"></a>        /* Let our actor know we're its currently active FollowAgendaItem */
<a name="7296"></a>        actor.followAgendaItem = self;
<a name="7297"></a>        
<a name="7298"></a>        /* 
<a name="7299"></a>         *   Travel via the next connector in our list if we're ready to move;
<a name="7300"></a>         *   we're ready to move when the player character has just issued a
<a name="7301"></a>         *   Follow command, which in turn sets the fuse to move the player
<a name="7302"></a>         *   character when we move.
<a name="7303"></a>         */
<a name="7304"></a>        if(getActor.followFuseID != nil) 
<a name="7305"></a>        {           
<a name="7306"></a>            /* Note our current actor's current location. */
<a name="7307"></a>            local oldLoc = actor.getOutermostRoom;
<a name="7308"></a>            
<a name="7309"></a>            /* Travel via the connector. */
<a name="7310"></a>            conn.travelVia(actor);
<a name="7311"></a>            
<a name="7312"></a>            /* 
<a name="7313"></a>             *   Check whether we actually went anywhere; it's possible the
<a name="7314"></a>             *   connector blocked our travel
<a name="7315"></a>             */
<a name="7316"></a>            if(actor.getOutermostRoom == oldLoc)
<a name="7317"></a>            {
<a name="7318"></a>                /* 
<a name="7319"></a>                 *   Note that our travel was blocked, and check whether the
<a name="7320"></a>                 *   travelBlocked method displayed anything.
<a name="7321"></a>                 */
<a name="7322"></a>                travelBlockReported = gOutStream.watchForOutput(
<a name="7323"></a>                    { : travelBlocked(conn)});
<a name="7324"></a>                
<a name="7325"></a>                /* Note that our actor hasn't actually gone anywhere. */
<a name="7326"></a>                actor.lastTravelInfo = nil;
<a name="7327"></a>                
<a name="7328"></a>            }
<a name="7329"></a>            /* Travel was successful */
<a name="7330"></a>            else
<a name="7331"></a>            {                
<a name="7332"></a>                /* Increment our next connector number. */
<a name="7333"></a>                nextConnNum++;
<a name="7334"></a>                
<a name="7335"></a>                /* Note that we've traveled on this turn */
<a name="7336"></a>                traveledThisTurn = libGlobal.totalTurns;
<a name="7337"></a>                
<a name="7338"></a>                /* 
<a name="7339"></a>                 *   Mark this Agenda Item as done if we've exhausted our list
<a name="7340"></a>                 *   of connectors
<a name="7341"></a>                 */
<a name="7342"></a>                if(nextConnNum &gt;= connectorList.length)
<a name="7343"></a>                {
<a name="7344"></a>                    isDone = true;                           
<a name="7345"></a>                }
<a name="7346"></a>            }
<a name="7347"></a>        }
<a name="7348"></a>        
<a name="7349"></a>        /* 
<a name="7350"></a>         *   If we're not ready to move, take the opportunity to "fidget", i.e.
<a name="7351"></a>         *   to execute a script defined either on this AgendaItem or on our
<a name="7352"></a>         *   current ActorState, provided that our actor hasn't conversed this
<a name="7353"></a>         *   term and that the player character can see our actor.
<a name="7354"></a>         */
<a name="7355"></a>        else if(!actor.conversedThisTurn &amp;&amp; Q.canSee(gPlayerChar, actor))
<a name="7356"></a>        {
<a name="7357"></a>            /* 
<a name="7358"></a>             *   If we have a Script class in our Superclass list, execute our
<a name="7359"></a>             *   script.
<a name="7360"></a>             */
<a name="7361"></a>            if(ofKind(Script))
<a name="7362"></a>                doScript();
<a name="7363"></a>            
<a name="7364"></a>            /*  
<a name="7365"></a>             *   Otherwise if our actor's current ActorState includes a Script
<a name="7366"></a>             *   class in its superclass list, execute its script.
<a name="7367"></a>             */
<a name="7368"></a>            else if(stat != nil &amp;&amp; stat.ofKind(Script))
<a name="7369"></a>                stat.doScript();      
<a name="7370"></a>        }
<a name="7371"></a>        
<a name="7372"></a>
<a name="7373"></a>    }
<a name="7374"></a>    
<a name="7375"></a>    /* Which turn did this FollowAgendaItem last cause our NPC to travel on? */
<a name="7376"></a>    traveledThisTurn = nil
<a name="7377"></a>    
<a name="7378"></a>    /* A pointer to the next connector to use */
<a name="7379"></a>    nextConnNum = 0
<a name="7380"></a>    
<a name="7381"></a>        
<a name="7382"></a>    /* 
<a name="7383"></a>     *   A list of TravelConnectors through which we want the player character
<a name="7384"></a>     *   to follow our associated actor.
<a name="7385"></a>     */
<a name="7386"></a>    connectorList = []
<a name="7387"></a>    
<a name="7388"></a>    /*  The next connector our NPC wants to lead the PC via */
<a name="7389"></a>    nextConnector = connectorList.element(nextConnNum + 1)
<a name="7390"></a>    
<a name="7391"></a>    /* 
<a name="7392"></a>     *   This method is called when our NPC attempts to travel via conn but the
<a name="7393"></a>     *   travel is blocked (by a locked door, for example). By default we do
<a name="7394"></a>     *   nothing here but game code can override this method to display an
<a name="7395"></a>     *   appropriate message or take any other action that might be needed in
<a name="7396"></a>     *   this situation.
<a name="7397"></a>     *
<a name="7398"></a>     *   If this method displays anything, the default "You wait in vain for the
<a name="7399"></a>     *   traveler to go anywhere" message will be suppressed.
<a name="7400"></a>     */
<a name="7401"></a>    travelBlocked(conn)
<a name="7402"></a>    {
<a name="7403"></a>    }
<a name="7404"></a>    
<a name="7405"></a>    /* 
<a name="7406"></a>     *   Flag: did the travelBlocked() method output any text? This is handled
<a name="7407"></a>     *   internally by the library and shouldn't normally be used by game author
<a name="7408"></a>     *   code.
<a name="7409"></a>     */
<a name="7410"></a>    travelBlockReported = nil
<a name="7411"></a>    
<a name="7412"></a>    
<a name="7413"></a>    /*   
<a name="7414"></a>     *   This method is invoked when our NPC arrives at his/her destination. By
<a name="7415"></a>     *   default we do nothing, but instances can override to provide code to
<a name="7416"></a>     *   handle the arrival, e.g. by changing the NPC's ActorState.
<a name="7417"></a>     */
<a name="7418"></a>    noteArrival() { }
<a name="7419"></a>    
<a name="7420"></a>    resetItem()
<a name="7421"></a>    {
<a name="7422"></a>        /* Carry out the inherited handling. */
<a name="7423"></a>        inherited;
<a name="7424"></a>              
<a name="7425"></a>        /* Reset our next connector pointer */
<a name="7426"></a>        nextConnNum = 0;
<a name="7427"></a>    }
<a name="7428"></a>    
<a name="7429"></a>    /* 
<a name="7430"></a>     *   The specialDesc to display when our actor is waiting for the PC to
<a name="7431"></a>     *   follow it. By default we just show a plain vanilla message to the
<a name="7432"></a>     *   effect, "The NPC is waiting for you to follow him/her north" or
<a name="7433"></a>     *   whatever, but game code may wish to override this to provide a more
<a name="7434"></a>     *   customized message.
<a name="7435"></a>     */
<a name="7436"></a>    specialDesc()
<a name="7437"></a>    {
<a name="7438"></a>        /* 
<a name="7439"></a>         *   Note our actor and the player character and create a couple of
<a name="7440"></a>         *   useful message parameter substitutions.
<a name="7441"></a>         */
<a name="7442"></a>        local myactor = getActor;
<a name="7443"></a>        local pc = gPlayerChar;       
<a name="7444"></a>        gMessageParams(myactor, pc);
<a name="7445"></a>        
<a name="7446"></a>        /*   
<a name="7447"></a>         *   Display our default message. We make use there is a nextDirection
<a name="7448"></a>         *   before we attempt to use it in our message, otherwise we simply use
<a name="7449"></a>         *   a bland "X is here."
<a name="7450"></a>         */
<a name="7451"></a>        local nd = nextDirection;
<a name="7452"></a>        
<a name="7453"></a>        if(nd != nil)
<a name="7454"></a>            DMsg(waiting for follow, '{The subj myactor} {is} waiting for {the
<a name="7455"></a>                pc} {dummy} to follow {him myactor} {1}. ', nd.departureName);
<a name="7456"></a>        else
<a name="7457"></a>            DMsg(actor is here, '{The subj myactor} {is} {here}. '); 
<a name="7458"></a>    }
<a name="7459"></a>        
<a name="7460"></a>    nextDirection = getActor.getOutermostRoom.getDirection(nextConnector)
<a name="7461"></a>    
<a name="7462"></a>    /* 
<a name="7463"></a>     *   The specialDesc to use when our NPC has just traveled as a result of
<a name="7464"></a>     *   this TravelAgendaItem. By default we just show our specialDesc, but
<a name="7465"></a>     *   game code might want to customize this to something like "Bob crosses
<a name="7466"></a>     *   the room and waits for you to follow him through the green door."
<a name="7467"></a>     */
<a name="7468"></a>    arrivingDesc() { specialDesc; }
<a name="7469"></a>    
<a name="7470"></a>    /* 
<a name="7471"></a>     *   Show a specialDesc for this NPC when this TravelAgendaItem is active.
<a name="7472"></a>     *   If we've just moved this turn we display the arrivingDesc(), otherwise
<a name="7473"></a>     *   we show the specialDesc.
<a name="7474"></a>     */
<a name="7475"></a>    showSpecialDesc()
<a name="7476"></a>    {
<a name="7477"></a>        if(traveledThisTurn == libGlobal.totalTurns)
<a name="7478"></a>            arrivingDesc();
<a name="7479"></a>        else
<a name="7480"></a>            specialDesc();        
<a name="7481"></a>    }
<a name="7482"></a>    
<a name="7483"></a>    /* 
<a name="7484"></a>     *   Display a message to say that our actor is leaving via conn. This would
<a name="7485"></a>     *   normally describe the player character following our actor via conn.
<a name="7486"></a>     */
<a name="7487"></a>    sayDeparting(conn)
<a name="7488"></a>    {
<a name="7489"></a>        /* 
<a name="7490"></a>         *   By default we use the connector's standard sayActorFollowing()
<a name="7491"></a>         *   method.
<a name="7492"></a>         */
<a name="7493"></a>        conn.sayActorFollowing(gActor, getActor);
<a name="7494"></a>    }
<a name="7495"></a>    
<a name="7496"></a>    
<a name="7497"></a>    /* 
<a name="7498"></a>     *   Give this AgendaItem the opportunity to react to travel; in particular
<a name="7499"></a>     *   this might be used to allow the NPC to react to or even forbid travel
<a name="7500"></a>     *   in a direction other than the one s/he's trying to lead the PC.
<a name="7501"></a>     */
<a name="7502"></a>    beforeTravel(traveler, connector) { }
<a name="7503"></a>    
<a name="7504"></a>    /* Cancel this FollowAgendaItem before its normal termination. */
<a name="7505"></a>    cancel()
<a name="7506"></a>    {
<a name="7507"></a>        /* Note our actor */
<a name="7508"></a>        local actor = getActor;
<a name="7509"></a>        
<a name="7510"></a>        /* Note that we're done. */
<a name="7511"></a>        isDone = true;        
<a name="7512"></a>        
<a name="7513"></a>        /* Note that we're no longer our actor's current FollowAgendaItem */
<a name="7514"></a>        if(actor.followAgendaItem == self)
<a name="7515"></a>            actor.followAgendaItem = nil;
<a name="7516"></a>        
<a name="7517"></a>        /* Remove us from all agenda lists. */
<a name="7518"></a>        actor.removeFromAllAgendas(self);        
<a name="7519"></a>    }
<a name="7520"></a>    
<a name="7521"></a>    /*   
<a name="7522"></a>     *   Give this agendaItem a high priority to make sure it is used in
<a name="7523"></a>     *   response to a FOLLOW ccmmand in preference to any other AgendaItems
<a name="7524"></a>     *   that may be pending.
<a name="7525"></a>     */
<a name="7526"></a>    agendaOrder = 1
<a name="7527"></a>    
<a name="7528"></a>    registerItem()
<a name="7529"></a>    {
<a name="7530"></a>        /* Let our actor know we're its currently active FollowAgendaItem */
<a name="7531"></a>        getActor.followAgendaItem = self;
<a name="7532"></a>    }
<a name="7533"></a>;
<a name="7534"></a>
<a name="7535"></a>
<a name="7536"></a>/* 
<a name="7537"></a> *   An AgendaItem initializer.  For each agenda item that's initially
<a name="7538"></a> *   active, we'll add the item to its actor's agenda.  
<a name="7539"></a> */
<a name="7540"></a>PreinitObject
<a name="7541"></a>    execute()
<a name="7542"></a>    {
<a name="7543"></a>        forEachInstance(AgendaItem, function(item) {
<a name="7544"></a>            /* 
<a name="7545"></a>             *   If this item is initially active, add the item to its
<a name="7546"></a>             *   actor's agenda. 
<a name="7547"></a>             */
<a name="7548"></a>            if (item.initiallyActive)
<a name="7549"></a>                item.getActor().addToAgenda(item);
<a name="7550"></a>             
<a name="7551"></a>                        
<a name="7552"></a>        });
<a name="7553"></a>    }
<a name="7554"></a>;
<a name="7555"></a>
<a name="7556"></a>/* 
<a name="7557"></a> *   Create and store a table of string representation of object names that might be needed in
<a name="7558"></a> *   conversation tags, and set the globalParam names of actors that don't already have one to their
<a name="7559"></a> *   symbolic name (e.g. 'bob' on bob).
<a name="7560"></a> */
<a name="7561"></a>objTablePreinit: PreinitObject
<a name="7562"></a>    execute()
<a name="7563"></a>    {
<a name="7564"></a>        t3GetGlobalSymbols().forEachAssoc( new function(key, value)
<a name="7565"></a>        {
<a name="7566"></a>            if(dataType(value) == TypeObject &amp;&amp; (value.ofKind(Mentionable) ||
<a name="7567"></a>                                                 value.ofKind(AgendaItem) ||
<a name="7568"></a>                                                 value.ofKind(ActorState)))
<a name="7569"></a>                
<a name="7570"></a>                conversationManager.objNameTab[key] = value;
<a name="7571"></a>          
<a name="7572"></a>            if(objOfKind(value, Actor) &amp;&amp; value != Actor &amp;&amp; value.globalParamName == nil)
<a name="7573"></a>            {
<a name="7574"></a>                value.globalParamName = key;
<a name="7575"></a>                libGlobal.nameTable_[key] = value;
<a name="7576"></a>            }      
<a name="7577"></a>            
<a name="7578"></a>        } );        
<a name="7579"></a>        
<a name="7580"></a>    }
<a name="7581"></a>    
<a name="7582"></a>    executeBeforeMe = [pronounPreinit, thingPreinit]   
<a name="7583"></a>;
<a name="7584"></a>
<a name="7585"></a>
<a name="7586"></a>
<a name="7587"></a>
<a name="7588"></a>/* 
<a name="7589"></a> *   A special lister to display a topic inventory list from a list of topics
<a name="7590"></a> *   provided in the lst parameter.
<a name="7591"></a> */
<a name="7592"></a>suggestedTopicLister: object
<a name="7593"></a>
<a name="7594"></a>    /* Introduce the topic inventory listing */
<a name="7595"></a>    showListPrefix(lst, pl, explicit)  
<a name="7596"></a>    { 
<a name="7597"></a>        /* 
<a name="7598"></a>         *   Introduce the list. If it wasn't explicitly requested start by
<a name="7599"></a>         *   outputting a paragraph break and an opening parenthesis.
<a name="7600"></a>         */
<a name="7601"></a>        if(!explicit)
<a name="7602"></a>            "&lt;.p&gt;(";
<a name="7603"></a>        
<a name="7604"></a>        /* 
<a name="7605"></a>         *   Then introduce the list of suggestions with the appropriate form of
<a name="7606"></a>         *   'You could' (suitably adjusted for the person of the player
<a name="7607"></a>         *   character)
<a name="7608"></a>         */
<a name="7609"></a>        gCommand.actor = gPlayerChar;
<a name="7610"></a>        DMsg(suggestion list intro, '{I} could ');
<a name="7611"></a>    }
<a name="7612"></a>    
<a name="7613"></a>    /* End the list with a closing parenthesis or full stop as appropriate */
<a name="7614"></a>    showListSuffix(lst, pl, explicit)  
<a name="7615"></a>    { 
<a name="7616"></a>        /* 
<a name="7617"></a>         *   Finish the list. If it was explicitly requested we finish it with a
<a name="7618"></a>         *   full stop and a newline, otherwise we finish it with a closing
<a name="7619"></a>         *   parenthesis and a newline.
<a name="7620"></a>         */
<a name="7621"></a>        if(explicit)
<a name="7622"></a>            ".\n";
<a name="7623"></a>        else
<a name="7624"></a>            ")\n";
<a name="7625"></a>        
<a name="7626"></a>        /* If we have't explained the enumerating and hyperlinking options yet, explain them now. */
<a name="7627"></a>        if(!optionsExplained)
<a name="7628"></a>        {
<a name="7629"></a>            /* Explain the options */
<a name="7630"></a>            explainOptions();
<a name="7631"></a>            
<a name="7632"></a>            /* Note that we've now explained them so we won't do so again. */
<a name="7633"></a>            optionsExplained = true;
<a name="7634"></a>        }
<a name="7635"></a>    }
<a name="7636"></a>    
<a name="7637"></a>    /* Have the enumeration and hyperlinking options been explained to the player? */
<a name="7638"></a>    optionsExplained = nil
<a name="7639"></a>    
<a name="7640"></a>    explainOptions()
<a name="7641"></a>    {
<a name="7642"></a>        "\n&lt;.p&gt;&lt;.notification&gt;";
<a name="7643"></a>        if(systemInfo(SysInfoInterpClass) == SysInfoIClassHTML)
<a name="7644"></a>            DMsg(explain enumerating and hyperlinking,'Enumeration and/or hyperlinking of topic
<a name="7645"></a>                suggestions can be toggled on and off using the commands ENUM SUGGS and/or HYPER
<a name="7646"></a>                SUGGS respectively. '); 
<a name="7647"></a>        else DMsg(explain numbering, 'Enumeration of topic suggestions can be toggled on and off
<a name="7648"></a>            using the command ENUM SUGGS. ');
<a name="7649"></a>        
<a name="7650"></a>        "&lt;./notification&gt;&lt;.p&gt;";        
<a name="7651"></a>    }
<a name="7652"></a>    
<a name="7653"></a>    /* The message to display if there are no topics to suggest. */
<a name="7654"></a>    showListEmpty(explicit)  
<a name="7655"></a>    { 
<a name="7656"></a>        gCommand.actor = gPlayerChar;
<a name="7657"></a>        if(explicit)
<a name="7658"></a>            DMsg(nothing in mind, '{I} {have} nothing in mind to discuss
<a name="7659"></a>                with {1} just {then}. ',
<a name="7660"></a>                 gPlayerChar.currentInterlocutor.theObjName);
<a name="7661"></a>    }
<a name="7662"></a>    
<a name="7663"></a>    show(lst, explicit = true)
<a name="7664"></a>    {                 
<a name="7665"></a>        /* 
<a name="7666"></a>         *   Initialize the suggestion enumerator to clear out any leftover information from
<a name="7667"></a>         *   previous suggestion listings.
<a name="7668"></a>         */        
<a name="7669"></a>        suggestionEnumerator.initialize();
<a name="7670"></a>        /* 
<a name="7671"></a>             *   first exclude all items that don't have a name property, since
<a name="7672"></a>             *   there won't be anything to show.
<a name="7673"></a>         */        
<a name="7674"></a>        lst = lst.subset({x: x.name != nil &amp;&amp; x.name.length &gt; 0});
<a name="7675"></a>        
<a name="7676"></a>        /* 
<a name="7677"></a>         *   if the list is empty there's nothing for us to say, so say so and
<a name="7678"></a>         *   finish
<a name="7679"></a>         */        
<a name="7680"></a>        if(lst.length == 0)
<a name="7681"></a>        {
<a name="7682"></a>            showListEmpty(explicit);                
<a name="7683"></a>            return;
<a name="7684"></a>        }
<a name="7685"></a>        
<a name="7686"></a>        
<a name="7687"></a>        /* 
<a name="7688"></a>         *   Next we need to divide the list according to category
<a name="7689"></a>         *
<a name="7690"></a>         *
<a name="7691"></a>         *
<a name="7692"></a>         *   First we go through the list of suggestion types assigning each
<a name="7693"></a>         *   topic entry to the user specified type where the user has specified
<a name="7694"></a>         *   that it should be suggested at a specific type of Topic Entry (as
<a name="7695"></a>         *   opposed to the library default).
<a name="7696"></a>         */
<a name="7697"></a>        
<a name="7698"></a>        foreach(local cur in typeInfo)
<a name="7699"></a>        {
<a name="7700"></a>            /* 
<a name="7701"></a>             *   For each item in our typeInfo list (for which see below),
<a name="7702"></a>             *   extract that subset of topic entries from our main list for
<a name="7703"></a>             *   which the suggestAs property matches the suggestAs property in
<a name="7704"></a>             *   cur (which is the third element of cur). Set the corresponding
<a name="7705"></a>             *   list on this lister object (for which we obtain a property
<a name="7706"></a>             *   pointer from the first element of cur) to be that subset.
<a name="7707"></a>             */
<a name="7708"></a>            self.(cur[1]) = lst.subset({t: t.suggestAs == cur[3]});
<a name="7709"></a>            
<a name="7710"></a>            /* 
<a name="7711"></a>             *   Then remove the subset we've just identified from the list of
<a name="7712"></a>             *   topic entries to be processed, since we've just accounted for
<a name="7713"></a>             *   them
<a name="7714"></a>             */
<a name="7715"></a>            lst -= self.(cur[1]);
<a name="7716"></a>        }
<a name="7717"></a>        
<a name="7718"></a>        /* 
<a name="7719"></a>         *   Then go through every remaining item in our main list, assigning it
<a name="7720"></a>         *   to a sublist on the basis of which type of topic entry it is, which
<a name="7721"></a>         *   we'll determine on the basis of the property pointers in its
<a name="7722"></a>         *   includeInList.
<a name="7723"></a>         */        
<a name="7724"></a>        foreach(local cur in typeInfo)
<a name="7725"></a>        {
<a name="7726"></a>            /* 
<a name="7727"></a>             *   For each entry in our typeInfo list, find that subset of our
<a name="7728"></a>             *   list of topic entries that corresponds to the typeInfo. A topic
<a name="7729"></a>             *   entry will correspond to the cur typeInfo if the second element
<a name="7730"></a>             *   of cur (a property pointer such as &amp;askTopics) can be found in
<a name="7731"></a>             *   the includeInList of the topic entry, which we can test with
<a name="7732"></a>             *   our includes method (defined below). Add the subset thus
<a name="7733"></a>             *   created to the list contained in the property defined by the
<a name="7734"></a>             *   property pointer held in the first element of cur (e.g.
<a name="7735"></a>             *   &amp;sayList), which will be a property of this lister object.
<a name="7736"></a>             */
<a name="7737"></a>            self.(cur[1]) += lst.subset({t: includes(t, cur[2])});
<a name="7738"></a>            
<a name="7739"></a>            /* 
<a name="7740"></a>             *   Remove the sublist we've just created from our overall list of
<a name="7741"></a>             *   topic entries, since it's now accounted for.
<a name="7742"></a>             */
<a name="7743"></a>            lst -= self.(cur[1]);
<a name="7744"></a>        }
<a name="7745"></a>      
<a name="7746"></a>        
<a name="7747"></a>        /* 
<a name="7748"></a>         *   Introduce the list.
<a name="7749"></a>         */
<a name="7750"></a>        showListPrefix(lst, nil, explicit);
<a name="7751"></a>        
<a name="7752"></a>        /* Note that we haven't listed any items yet */
<a name="7753"></a>        local listStarted = nil;
<a name="7754"></a>        
<a name="7755"></a>        /* 
<a name="7756"></a>         *   Note that the actor we're listing suggestions for is the player
<a name="7757"></a>         *   character's current interlocutor.
<a name="7758"></a>         */
<a name="7759"></a>        local interlocutor = gPlayerChar.currentInterlocutor;
<a name="7760"></a>        
<a name="7761"></a>        /* Create a message parameter substitution for the interlocutor */
<a name="7762"></a>        gMessageParams(interlocutor);
<a name="7763"></a>        
<a name="7764"></a>        foreach(local cur in typeInfo)
<a name="7765"></a>        {
<a name="7766"></a>            listStarted = showSection(cur[1], listStarted, cur[4]) ||
<a name="7767"></a>                listStarted;
<a name="7768"></a>        }
<a name="7769"></a>        
<a name="7770"></a>        
<a name="7771"></a>        
<a name="7772"></a>        
<a name="7773"></a>        /* 
<a name="7774"></a>         *   Finish the list by appending its suffix 
<a name="7775"></a>         */
<a name="7776"></a>        showListSuffix(lst, nil, explicit);
<a name="7777"></a>        
<a name="7778"></a>    }
<a name="7779"></a>    
<a name="7780"></a>    
<a name="7781"></a>    showSection(prop, listStarted, sectionIntro)
<a name="7782"></a>    {
<a name="7783"></a>        local lst = self.(prop);
<a name="7784"></a>        
<a name="7785"></a>        /* 
<a name="7786"></a>         *   If the list is empty return nil to tell our caller we haven't
<a name="7787"></a>         *   displayed anything.
<a name="7788"></a>         */
<a name="7789"></a>        if(lst.length == 0)
<a name="7790"></a>            return nil;
<a name="7791"></a>        
<a name="7792"></a>        /* If the list has already begun, show our list separator */
<a name="7793"></a>        if(listStarted)
<a name="7794"></a>            say(orListSep);
<a name="7795"></a>        
<a name="7796"></a>        /* Show the appropriate intro for this section. */
<a name="7797"></a>        if(sectionIntro)
<a name="7798"></a>            say(self.(sectionIntro));
<a name="7799"></a>        
<a name="7800"></a>        /* Show the list */
<a name="7801"></a>        showList(lst, sectionIntro);
<a name="7802"></a>        
<a name="7803"></a>        /* Tell our caller we've displayed something. */
<a name="7804"></a>        return true;       
<a name="7805"></a>    }
<a name="7806"></a>    
<a name="7807"></a>    
<a name="7808"></a>    /* Show one of our sublists of particular kinds of suggest topics */
<a name="7809"></a>    showList(lst, sectionIntro)
<a name="7810"></a>    {
<a name="7811"></a>        local prfx = sectionIntro ? self.(sectionIntro) + ' ' : '';
<a name="7812"></a>        
<a name="7813"></a>        /* Sort the list */
<a name="7814"></a>        lst = lst.sort(SortAsc, {x, y: x.listOrder - y.listOrder});
<a name="7815"></a>        
<a name="7816"></a>        
<a name="7817"></a>        /* For each element in the list */
<a name="7818"></a>        for(local cur in lst, local i = 1 ;; ++i)
<a name="7819"></a>        {
<a name="7820"></a>            /* 
<a name="7821"></a>             *   If the current topic entry wants to include a sayPrefix,
<a name="7822"></a>             *   display the sayPrefix. In practice this only applies to
<a name="7823"></a>             *   SayTopics which may or may not want to introduce the name of a
<a name="7824"></a>             *   suggestion with 'say'.
<a name="7825"></a>             */
<a name="7826"></a>            if(cur.includeSayInName)
<a name="7827"></a>                say(sayPrefix);
<a name="7828"></a>            
<a name="7829"></a>            /* 
<a name="7830"></a>             *   If the enumerateSuggestions option is set, then we need to update the
<a name="7831"></a>             *   suggeestionEnumerator with each opttion displayed and add the appropriate number
<a name="7832"></a>             *   before each topic suggestion.
<a name="7833"></a>             */
<a name="7834"></a>            if(enumerateSuggestions)
<a name="7835"></a>            {
<a name="7836"></a>                /* 
<a name="7837"></a>                 *   The full name of this suggestion will be either 'say' or the section prefix
<a name="7838"></a>                 *   (e.g. you could tell him about') followed by the name of the TopicEntry we're
<a name="7839"></a>                 *   suggesting
<a name="7840"></a>                 .*/
<a name="7841"></a>                local fullname = (cur.includeSayInName ? sayPrefix : prfx) + cur.name;
<a name="7842"></a>                
<a name="7843"></a>                /* 
<a name="7844"></a>                 *   The number associated with this suggestion is the incremented
<a name="7845"></a>                 *   suggestionEnumerator's count.
<a name="7846"></a>                 */
<a name="7847"></a>                local num = ++suggestionEnumerator.count;
<a name="7848"></a>                
<a name="7849"></a>                /* Add the full name of this suggestion to suggestionEnumerator's suggestionList. */
<a name="7850"></a>                suggestionEnumerator.suggestionList[num] = fullname;
<a name="7851"></a>                
<a name="7852"></a>                /* Preceded the name of this suggestion with its num in parentheses. */
<a name="7853"></a>                "(&lt;&lt;num&gt;&gt;) ";
<a name="7854"></a>            }
<a name="7855"></a>            
<a name="7856"></a>            /* Display the name of the current suggestion */
<a name="7857"></a>            if(hyperlinkSuggestions)
<a name="7858"></a>                "&lt;&lt;aHref(prfx + cur.name, cur.name)&gt;&gt;";
<a name="7859"></a>            else
<a name="7860"></a>               say(cur.name);
<a name="7861"></a>            
<a name="7862"></a>            
<a name="7863"></a>            /* Output a comma or 'or', depending where we are in the list */
<a name="7864"></a>            if(i == lst.length - 1)
<a name="7865"></a>                DMsg(or, ' or ');
<a name="7866"></a>            if(i &lt; lst.length - 1)
<a name="7867"></a>                ", ";
<a name="7868"></a>            
<a name="7869"></a>        }
<a name="7870"></a>    }
<a name="7871"></a>    
<a name="7872"></a>    /* 
<a name="7873"></a>     *   Do we want the topic suggestions to be hyperlinked so that the player
<a name="7874"></a>     *   can just click on them? By default we don't but game code can override , or the
<a name="7875"></a>     *   player can use the HYPER SUGGS command to toggle this on and off.
<a name="7876"></a>     */
<a name="7877"></a>    hyperlinkSuggestions = nil
<a name="7878"></a>    
<a name="7879"></a>    /* 
<a name="7880"></a>     *   Do we want the topic suggestions to be numnered so that the player can just choose one by
<a name="7881"></a>     *   entering the approrpriae number. By default we don't but game code can override, or the
<a name="7882"></a>     *   player can use the ENUM SUGGS command to toggle this on and off.
<a name="7883"></a>     */
<a name="7884"></a>    enumerateSuggestions = nil
<a name="7885"></a>    
<a name="7886"></a>    /* 
<a name="7887"></a>     *   The typeInfo contains a list of lists that are used by the show method
<a name="7888"></a>     *   to build our various sublists. The first element of each list is a
<a name="7889"></a>     *   pointer to the list property to use on this lister object to hold the
<a name="7890"></a>     *   particular sublist. The second element of each list is a property
<a name="7891"></a>     *   pointer used to identify which sublist a TopicEntry belongs in,
<a name="7892"></a>     *   according to its own includeInList property. The third element is the
<a name="7893"></a>     *   type of topic entry a topic entry should be suggested as if it is
<a name="7894"></a>     *   explicitly requested in its suggestAs property. The fourth element is
<a name="7895"></a>     *   the text to use when introducing the corresponding section of the list
<a name="7896"></a>     *   (or nil if no introductory text is required).
<a name="7897"></a>     *
<a name="7898"></a>     */
<a name="7899"></a>    typeInfo = [
<a name="7900"></a>        [&amp;sayList, &amp;sayTopics, SayTopic, nil],
<a name="7901"></a>        [&amp;queryList, &amp;queryTopics, QueryTopic, &amp;queryPrefix],        
<a name="7902"></a>        [&amp;askList, &amp;askTopics, AskTopic, &amp;askPrefix],
<a name="7903"></a>        [&amp;tellList, &amp;tellTopics, TellTopic, &amp;tellPrefix],
<a name="7904"></a>        [&amp;talkList, &amp;talkTopics, TalkTopic, &amp;talkPrefix], 
<a name="7905"></a>        [&amp;giveList, &amp;giveTopics, GiveTopic, &amp;givePrefix],
<a name="7906"></a>        [&amp;showToList, &amp;showTopics, ShowTopic, &amp;showPrefix],
<a name="7907"></a>        [&amp;askForList, &amp;askForTopics, AskForTopic, &amp;askForPrefix],
<a name="7908"></a>        [&amp;yesList, &amp;miscTopics, YesTopic, nil],
<a name="7909"></a>        [&amp;noList, &amp;miscTopics, NoTopic, nil],
<a name="7910"></a>        [&amp;commandList, &amp;commandTopics, CommandTopic, &amp;tellToPrefix]
<a name="7911"></a>        
<a name="7912"></a>    ]
<a name="7913"></a>    
<a name="7914"></a>    
<a name="7915"></a>    /* Sublists of each kind of suggestion which can be listed in turn */
<a name="7916"></a>    sayList = []
<a name="7917"></a>    queryList = []
<a name="7918"></a>    askList = []
<a name="7919"></a>    tellList = []
<a name="7920"></a>    talkList = []
<a name="7921"></a>    giveList = []
<a name="7922"></a>    showToList = []
<a name="7923"></a>    yesList = []
<a name="7924"></a>    noList = []
<a name="7925"></a>    askForList = []
<a name="7926"></a>    commandList = []    
<a name="7927"></a>    
<a name="7928"></a>    
<a name="7929"></a>    /* 
<a name="7930"></a>     *   Test whether the topicEntry t includes prop in its includeInList.
<a name="7931"></a>     */    
<a name="7932"></a>    includes(t, prop)
<a name="7933"></a>    {
<a name="7934"></a>        return t.includeInList.indexOf(prop) != nil;
<a name="7935"></a>    }
<a name="7936"></a>    
<a name="7937"></a>    /* 
<a name="7938"></a>     *   The prefix to use when suggesting a SayTopic, if it explicitly wants
<a name="7939"></a>     *   the suggestion to start with 'say'.
<a name="7940"></a>     */
<a name="7941"></a>    sayPrefix = BMsg(say prefix, 'say ')
<a name="7942"></a>    queryPrefix = BMsg(ask query, 'ask {him interlocutor} ')
<a name="7943"></a>    askPrefix = BMsg(ask about, 'ask {him interlocutor} about ')
<a name="7944"></a>    tellPrefix = BMsg(tell about, 'tell {him interlocutor} about ')
<a name="7945"></a>    talkPrefix = BMsg(talk about, 'talk about ')    
<a name="7946"></a>    givePrefix = BMsg(give, 'give {him interlocutor} ')
<a name="7947"></a>    showPrefix = BMsg(show, 'show {him interlocutor} ')
<a name="7948"></a>    askForPrefix = BMsg(ask for, 'ask {him interlocutor} for ')
<a name="7949"></a>    tellToPrefix = BMsg(tell to, 'tell {him interlocutor} to ')
<a name="7950"></a>    
<a name="7951"></a>    /*  The conjunction to use at the end of a list of alternatives */
<a name="7952"></a>    orListSep = BMsg(or list separator, '; or ')
<a name="7953"></a>
<a name="7954"></a>;
<a name="7955"></a>
<a name="7956"></a>/* 
<a name="7957"></a> *   The suggestionEnumerator object is used by the library to keep track of the numbering of topics
<a name="7958"></a> *   suggestions when this option is enabled.
<a name="7959"></a> */
<a name="7960"></a>suggestionEnumerator: object
<a name="7961"></a>    /* The number of the current suggestion when numbered topic suggestions are being listed. */
<a name="7962"></a>    count = 0
<a name="7963"></a>    
<a name="7964"></a>    /* Our list (or Vector) of topic suggestions. */
<a name="7965"></a>    suggestionList = nil
<a name="7966"></a>    
<a name="7967"></a>    /* Initialize the suggestionEnumerator for the start of a new list of suggested topics. */
<a name="7968"></a>    initialize()
<a name="7969"></a>    {
<a name="7970"></a>        /* Reset our enumeration count to 0 */
<a name="7971"></a>        count = 0;
<a name="7972"></a>        
<a name="7973"></a>        /* Reset our suggestion list to a new empty Vector. */
<a name="7974"></a>        suggestionList = new Vector(20);
<a name="7975"></a>    }    
<a name="7976"></a>;
<a name="7977"></a>
<a name="7978"></a>/* 
<a name="7979"></a> *   Preparser to convert a command that consists just of a number into the appropriate
<a name="7980"></a> *   conversational commmand under the appropriate circumstances when we have recently displayed a
<a name="7981"></a> *   list of suggested conversational topics.
<a name="7982"></a> */
<a name="7983"></a>enumSuggestionsPreparser: StringPreParser
<a name="7984"></a>    doParsing(str, which)   
<a name="7985"></a>    {
<a name="7986"></a>        /* 
<a name="7987"></a>         *   We only want to modify str here if this is a new command and a conversation is in
<a name="7988"></a>         *   progress and the suggestedTopicLister's enumerateSuggestions property is set to true.
<a name="7989"></a>         */
<a name="7990"></a>        if(which == rmcCommand &amp;&amp; gPlayerChar.currentInterlocutor &amp;&amp;
<a name="7991"></a>           suggestedTopicLister.enumerateSuggestions)
<a name="7992"></a>        {
<a name="7993"></a>            /* Try converting str to an integer */
<a name="7994"></a>            local num = toInteger(str);
<a name="7995"></a>            
<a name="7996"></a>            /* 
<a name="7997"></a>             *   If we have a number and that number is in the range of the number of topic
<a name="7998"></a>             *   suggestions listed then replace str with the corresponding conversational command.
<a name="7999"></a>             */
<a name="8000"></a>            if(num &amp;&amp; num &lt;= suggestionEnumerator.count &amp;&amp; num &gt; 0)
<a name="8001"></a>            {
<a name="8002"></a>                /* 
<a name="8003"></a>                 *   Change str to the corresponding item in suggestionEnumerator's suggestion list.
<a name="8004"></a>                 */
<a name="8005"></a>                str = suggestionEnumerator.suggestionList[num];
<a name="8006"></a>                
<a name="8007"></a>                /* 
<a name="8008"></a>                 *   Echo the new command back to the player so the player can see what's now being
<a name="8009"></a>                 *   executed.
<a name="8010"></a>                 */
<a name="8011"></a>                "&lt;.inputline&gt;\^&lt;&lt;str&gt;&gt;&lt;./inputline&gt;\n";
<a name="8012"></a>            }            
<a name="8013"></a>        }       
<a name="8014"></a>        
<a name="8015"></a>        /* Return our string, modified or unmodified as the case may be. */
<a name="8016"></a>        return str;
<a name="8017"></a>    }    
<a name="8018"></a>;
<a name="8019"></a>
<a name="8020"></a>
<a name="8021"></a>
<a name="8022"></a>modify Follow
<a name="8023"></a>    /* For this action to work all known actors also need to be in scope */
<a name="8024"></a>    addExtraScopeItems(whichRole?)
<a name="8025"></a>    {
<a name="8026"></a>        scopeList = scopeList.appendUnique(Q.knownScopeList.subset({x:
<a name="8027"></a>            x.ofKind(Actor)}));
<a name="8028"></a>    }
<a name="8029"></a>;
<a name="8030"></a>
<a name="8031"></a>/* 
<a name="8032"></a> *   The ProxyActor class can be used to continue the definition of a complex
<a name="8033"></a> *   actor over more than one file. Simply place a ProxyActor object at the head
<a name="8034"></a> *   of a second or subsequent file for the same actor and then set its location
<a name="8035"></a> *   to the Actor object its standing in for. You can then locate TopicGroups,
<a name="8036"></a> *   TopicEntries, ActorStates, AgendaItems, ConvNodes etc., within the
<a name="8037"></a> *   ProxyActor just as if it were the Actor.
<a name="8038"></a> */
<a name="8039"></a>
<a name="8040"></a>class ProxyActor: object
<a name="8041"></a>    /* My Actor is my location */
<a name="8042"></a>    getActor = location.getActor
<a name="8043"></a>    
<a name="8044"></a>    /* Pass a call to addTopic() up to my actor */
<a name="8045"></a>    addTopic(obj)
<a name="8046"></a>    {
<a name="8047"></a>        getActor.addTopic(obj);
<a name="8048"></a>    }
<a name="8049"></a>    
<a name="8050"></a>    /* I am active if my location (i.e. my actor) is active). */
<a name="8051"></a>    active = location.active
<a name="8052"></a>    
<a name="8053"></a>    /* 
<a name="8054"></a>     *   Set the location to the Actor I'm standing in for in a new file. This
<a name="8055"></a>     *   can be done via the @ notation in the template.
<a name="8056"></a>     */
<a name="8057"></a>    location = nil
<a name="8058"></a>;
<a name="8059"></a>
<a name="8060"></a>
<a name="8061"></a>
<a name="8062"></a>stanceInitializer: PreinitObject
<a name="8063"></a>    stances = nil
<a name="8064"></a>    
<a name="8065"></a>    execute()
<a name="8066"></a>    {
<a name="8067"></a>        if(stances)
<a name="8068"></a>        {
<a name="8069"></a>            foreach(local cur in stances)
<a name="8070"></a>                cur[1].setStanceToward(cur[3], cur[2]);
<a name="8071"></a>        }
<a name="8072"></a>    }
<a name="8073"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>httpsrv.h</title></head><body>
<table class=ban><tr><td><h1>httpsrv.h</h1><td align=right><a href="../file/httpsrv.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#pragma once
<a name="3"></a>
<a name="4"></a>/*
<a name="5"></a> *   Copyright 2010 Michael J. Roberts.
<a name="6"></a> *   
<a name="7"></a> *   This file is part of TADS 3.
<a name="8"></a> *   
<a name="9"></a> *   This module defines the HTTPServer intrinsic class.  This class is used
<a name="10"></a> *   to set up a network HTTP server, which has a number of potential
<a name="11"></a> *   applications:
<a name="12"></a> *   
<a name="13"></a> *   - Run a game in a client/server configuration, so that the user
<a name="14"></a> *   interface is running in a Web browser on one machine, and the game
<a name="15"></a> *   itself is running on a separate server machine on the network.  This
<a name="16"></a> *   lets the game run on handheld devices that might be too slow to run the
<a name="17"></a> *   game directly, allows running the game without any software
<a name="18"></a> *   installation, and makes the game more portable by depending only on a
<a name="19"></a> *   browser being available rather than requiring a TADS interpreter.
<a name="20"></a> *   
<a name="21"></a> *   - Run a game in with a browser-based UI, so that it can take advantage
<a name="22"></a> *   of HTML DOM and Javascript.  Modern browsers are more powerful than HTML
<a name="23"></a> *   TADS, so it's possible to create a more elaborate and customized game UI
<a name="24"></a> *   by running in a browser.
<a name="25"></a> *   
<a name="26"></a> *   - Create a multi-user game, by running the game on a server and writing
<a name="27"></a> *   the game to accept connections from more than one player.  
<a name="28"></a> */
<a name="29"></a>
<a name="30"></a>/*
<a name="31"></a> *   HTTP Server Object.  This implements a multi-threaded, background server
<a name="32"></a> *   that runs concurrently with the game program.  The server listens for
<a name="33"></a> *   and accepts incoming connection requests from clients, and then handles
<a name="34"></a> *   HTTP protocol transactions with connected clients.  Client requests are
<a name="35"></a> *   routed to the byte code program via network events, which the program
<a name="36"></a> *   can retrieve via the getNetEvent() function.
<a name="37"></a> *   
<a name="38"></a> *   Construction: to set up an HTTP server, simply create an HTTPServer
<a name="39"></a> *   object with 'new':
<a name="40"></a> *   
<a name="41"></a> *.     local srv = new HTTPServer(hostname, portnum?, maxUploadSize?);
<a name="42"></a> *   
<a name="43"></a> *   'hostname' is a string giving the domain name or IP address that the
<a name="44"></a> *   server will bind to for accepting connections.  For a server that
<a name="45"></a> *   accepts connections from separate client machines, this is simply the
<a name="46"></a> *   external IP address of the local machine.  (This is specified as an
<a name="47"></a> *   argument because some machines have more than one network interface, and
<a name="48"></a> *   thus have more than one IP address or domain name.)
<a name="49"></a> *   
<a name="50"></a> *   'portnum' is the TCP/IP port number wehre the server will listen for
<a name="51"></a> *   incoming connections.  If this is omitted or nil, the operating system
<a name="52"></a> *   will automatically select an available port number and assign it to the
<a name="53"></a> *   server.  Using a specific port number allows you to create a service on
<a name="54"></a> *   a "well known" port, which makes it easier for clients to find the
<a name="55"></a> *   service; but a given port can only be used by one server at a time, so
<a name="56"></a> *   using a pre-selected port number runs the risk that some other process
<a name="57"></a> *   will already be using the same port.
<a name="58"></a> *   
<a name="59"></a> *   'maxUploadSize' is the maximum size in bytes for any single request's
<a name="60"></a> *   content.  Content sizes over this limit will be rejected.  Some HTTP
<a name="61"></a> *   requests, such as POST, can include uploaded content from the client,
<a name="62"></a> *   and the HTTP protocol itself supports essentially unlimited sizes for
<a name="63"></a> *   these objects.  Uploads consume resources on the server, though, so it's
<a name="64"></a> *   often desirable to set a size limit to prevent errant or malicious
<a name="65"></a> *   clients from overwhelming the server with a very large upload.
<a name="66"></a> *   Depending on the specific function of your server, you might or might
<a name="67"></a> *   not wish to set a limit.  If you omit this argument or set it to nil,
<a name="68"></a> *   unlimited upload sizes will be allowed.  Note that this limit applies to
<a name="69"></a> *   each individual upload separately; it's not a lifetime limit for the
<a name="70"></a> *   server or for any session.
<a name="71"></a> *   
<a name="72"></a> *   Creating an HTTPServer object with 'new' automatically starts the
<a name="73"></a> *   server.  The object will create a background thread that will listen for
<a name="74"></a> *   incoming connections on the given network address and port number, so
<a name="75"></a> *   the server is active as soon as the 'new' finishes.  You can create any
<a name="76"></a> *   number of servers, as long as they have different port numbers.  When a
<a name="77"></a> *   connection request is received, the server will accept the connection
<a name="78"></a> *   and automatically create another background thread to handle requests on
<a name="79"></a> *   that connection.  Each incoming request will be forwarded to the game
<a name="80"></a> *   program to handle, via the network message queue.  
<a name="81"></a> */
<a name="82"></a>intrinsic class HTTPServer 'http-server/030000': Object
<a name="83"></a>{
<a name="84"></a>    /*
<a name="85"></a>     *   Shut down the server.  This immediately disconnects the server from
<a name="86"></a>     *   its network port; no further client connections will be accepted
<a name="87"></a>     *   once the server shuts down.  In addition, all of the server threads
<a name="88"></a>     *   that were started by this server object will be notified to
<a name="89"></a>     *   terminate. 
<a name="90"></a>     *   
<a name="91"></a>     *   If 'wait' is omitted or is nil, the routine sends the shutdown
<a name="92"></a>     *   notification to the main server and to its server threads, then
<a name="93"></a>     *   immediately returns.  This means that one or more of the server's
<a name="94"></a>     *   background threads might continue to run for a while after
<a name="95"></a>     *   shutdown() returns.  The main practical consideration is that the
<a name="96"></a>     *   port number used by the server might not be immediately available
<a name="97"></a>     *   for use by a new server object, since the port won't be closed until
<a name="98"></a>     *   the server actually exits.  
<a name="99"></a>     *   
<a name="100"></a>     *   If 'wait' is true, this routine won't return until all of the server
<a name="101"></a>     *   threads have actually terminated.
<a name="102"></a>     *   
<a name="103"></a>     *   The return value is true if all server threads have terminated, nil
<a name="104"></a>     *   if any server threads are still running.  It's legal to call this
<a name="105"></a>     *   routine repeatedly, so you can make repeated calls to shutdown(nil)
<a name="106"></a>     *   to poll for completion.  This is useful if you need to wait until
<a name="107"></a>     *   the server shuts down to move on to a next step, but you have other
<a name="108"></a>     *   work you can perform in the meantime.  If you don't have any other
<a name="109"></a>     *   work, you can avoid burning CPU time by calling shutdown(true),
<a name="110"></a>     *   which waits (without consuming CPU time) for the server to exit.  
<a name="111"></a>     */
<a name="112"></a>    shutdown(wait?);
<a name="113"></a>
<a name="114"></a>    /*
<a name="115"></a>     *   Get the listening address.  This returns a string giving the
<a name="116"></a>     *   original binding address specified when the object was constructed.
<a name="117"></a>     *   This can contain either a host name or an IP address, since either
<a name="118"></a>     *   form can be used in the constructor.  
<a name="119"></a>     */
<a name="120"></a>    getAddress();
<a name="121"></a>
<a name="122"></a>    /*
<a name="123"></a>     *   Get the listening IP address.  This returns the numerical IP address
<a name="124"></a>     *   where the server is listening for connections.  
<a name="125"></a>     */
<a name="126"></a>    getIPAddress();
<a name="127"></a>
<a name="128"></a>    /*
<a name="129"></a>     *   Get the port number.  This returns an integer giving the TCP/IP
<a name="130"></a>     *   network port number on which this server is listening for incoming
<a name="131"></a>     *   connections.  Clients connect to the port by including it in the
<a name="132"></a>     *   HTTP URL, after the host name.  For example, if the server is on
<a name="133"></a>     *   port 10815, the client would connect to a URL of the form
<a name="134"></a>     *   http://myserver.com:10815/index.htm.  
<a name="135"></a>     */
<a name="136"></a>    getPortNum();
<a name="137"></a>}
<a name="138"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 07/01/2025 from adv3Lite version 2.1.1.8</div>
</body>
</html>

<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>main.t</title></head><body>
<table class=ban><tr><td><h1>main.t</h1><td align=right><a href="../file/main.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>
<a name="5"></a>/*
<a name="6"></a> *   **************************************************************************
<a name="7"></a> *   main.t
<a name="8"></a> *
<a name="9"></a> *   This module forms part of the adv3Lite library (c) 2012-13 Eric Eve. Based
<a name="10"></a> *   in part on code in the adv3 Library (c) Michael J. Roberts.
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>/*
<a name="14"></a> *   Main program entrypoint.  The core run-time start-up code calls this
<a name="15"></a> *   after running pre-initialization and load-time initialization.  This
<a name="16"></a> *   entrypoint is called when we're starting the game normally; when the
<a name="17"></a> *   game is launched through a saved-position file, mainRestore() will be
<a name="18"></a> *   invoked instead.  
<a name="19"></a> */
<a name="20"></a>main(args)
<a name="21"></a>{
<a name="22"></a>    libGlobal.commandLineArgs = args;
<a name="23"></a>    mainCommon(&amp;newGame);
<a name="24"></a>}
<a name="25"></a>
<a name="26"></a>/*
<a name="27"></a> *   Main program entrypoint for restoring a saved-position file.  This is
<a name="28"></a> *   invoked from the core run-time start-up code when the game is launched
<a name="29"></a> *   from the operating system via a saved-position file.  For example, on
<a name="30"></a> *   Windows, double-clicking on a saved-position file on the Windows
<a name="31"></a> *   desktop launches the interpreter, which looks in the save file to find
<a name="32"></a> *   the game executable to run, then starts the game and invokes this
<a name="33"></a> *   entrypoint.  
<a name="34"></a> */
<a name="35"></a>mainRestore(args, restoreFile)
<a name="36"></a>{
<a name="37"></a>    libGlobal.commandLineArgs = args;
<a name="38"></a>    mainCommon(&amp;restoreAndRunGame, restoreFile);
<a name="39"></a>}
<a name="40"></a>
<a name="41"></a>/*
<a name="42"></a> *   Common main entrypoint - this handles starting a new game or restoring
<a name="43"></a> *   an existing saved state. 
<a name="44"></a> */
<a name="45"></a>mainCommon(prop, [args])
<a name="46"></a>{
<a name="47"></a>    
<a name="48"></a>    try
<a name="49"></a>    {
<a name="50"></a>        /* at the start of the session, set up the UI subsystem */
<a name="51"></a>        if (mainGlobal.restartID == 0)
<a name="52"></a>        {
<a name="53"></a>            /* initialize the UI */
<a name="54"></a>            initUI();
<a name="55"></a>
<a name="56"></a>            /* 
<a name="57"></a>             *   tell the system library to call our UI shutdown function
<a name="58"></a>             *   at program exit 
<a name="59"></a>             */
<a name="60"></a>            mainAtExit.addHandler(terminateUI);
<a name="61"></a>        }
<a name="62"></a>
<a name="63"></a>        /* initialize the display */
<a name="64"></a>        initDisplay();
<a name="65"></a>
<a name="66"></a>       
<a name="67"></a>        
<a name="68"></a>        /* call the appropriate gameMain method */
<a name="69"></a>        gameMain.(prop)(args...);
<a name="70"></a>    }
<a name="71"></a>    catch (QuittingException q)
<a name="72"></a>    {
<a name="73"></a>        /* 
<a name="74"></a>         *   This exception is a signal to quit the game, which we will now
<a name="75"></a>         *   proceed to do by returning from this function, which exits the
<a name="76"></a>         *   program. 
<a name="77"></a>         */
<a name="78"></a>    }
<a name="79"></a>}
<a name="80"></a>
<a name="81"></a>
<a name="82"></a>/* ------------------------------------------------------------------------ */
<a name="83"></a>/*
<a name="84"></a> *   Run the game.  We start by showing the description of the initial
<a name="85"></a> *   location, if desired, and then we read and interpret commands until
<a name="86"></a> *   the game ends (via a "quit" command, winning, death of the player
<a name="87"></a> *   character, or any other way of terminating the game).
<a name="88"></a> *   
<a name="89"></a> *   This routine doesn't return until the game ends.
<a name="90"></a> *   
<a name="91"></a> *   Before calling this routine, the caller should already have set the
<a name="92"></a> *   global variable gPlayerChar to the player character actor.
<a name="93"></a> *   
<a name="94"></a> *   'look' is a flag indicating whether or not to look around; if this is
<a name="95"></a> *   true, we'll show a full description of the player character's initial
<a name="96"></a> *   location, as though the player were to type "look around" as the first
<a name="97"></a> *   command.  
<a name="98"></a> */
<a name="99"></a>runGame(look)
<a name="100"></a>{
<a name="101"></a>    /* show the starting location */
<a name="102"></a>    if (look)
<a name="103"></a>    {
<a name="104"></a>        gActor = gPlayerChar;
<a name="105"></a>        /* run the initial "look around" in a dummy command context */
<a name="106"></a>        gPlayerChar.outermostVisibleParent().lookAroundWithin();
<a name="107"></a>        
<a name="108"></a>        /* 
<a name="109"></a>         *   execute the sceneManager (if it exists) to for any Scene that's
<a name="110"></a>         *   meant to start with the game.
<a name="111"></a>         */
<a name="112"></a>        if(defined(sceneManager) &amp;&amp; sceneManager.executeEvent());
<a name="113"></a>    }
<a name="114"></a>
<a name="115"></a>    /* run the main command loop until the game ends */
<a name="116"></a>    try {
<a name="117"></a>      mainCommandLoop();
<a name="118"></a>    } catch (QuittingException qe) {
<a name="119"></a>      // exit normally
<a name="120"></a>    } catch (EndOfFileException eofe) {
<a name="121"></a>      // exit normally
<a name="122"></a>    }
<a name="123"></a>}
<a name="124"></a>
<a name="125"></a>/* ------------------------------------------------------------------------ */
<a name="126"></a>/* 
<a name="127"></a> *   The main command loop. This repeatedly prompts the player for a command and
<a name="128"></a> *   then processes the command until the game ends.
<a name="129"></a> */
<a name="130"></a>
<a name="131"></a>mainCommandLoop()
<a name="132"></a>{
<a name="133"></a>
<a name="134"></a>    local txt;
<a name="135"></a>
<a name="136"></a>    /* 
<a name="137"></a>     *   Set the current actor to the player character at the start of the game
<a name="138"></a>     *   (to ensure we have a current actor defined).
<a name="139"></a>     */
<a name="140"></a>    gActor = gPlayerChar;
<a name="141"></a>    
<a name="142"></a>    /* 
<a name="143"></a>     *   Repeat this loop, which asks for a command and then parses it, until
<a name="144"></a>     *   the game comes to an end.
<a name="145"></a>     */
<a name="146"></a>    do
<a name="147"></a>    {
<a name="148"></a>        /* Display score notifications if the score module is included. */
<a name="149"></a>        if(defined(scoreNotifier) &amp;&amp; scoreNotifier.checkNotification())
<a name="150"></a>            ;
<a name="151"></a>        
<a name="152"></a>        /* run any PromptDaemons if the events module is included */
<a name="153"></a>        if(defined(eventManager) &amp;&amp; eventManager.executePrompt())
<a name="154"></a>            ;
<a name="155"></a>        
<a name="156"></a>        try
<a name="157"></a>        {
<a name="158"></a>            /* Output a paragraph break */
<a name="159"></a>            "&lt;.p&gt;";
<a name="160"></a>            
<a name="161"></a>            /* Read a new command from the keyboard. */
<a name="162"></a>            
<a name="163"></a>            txt = readCommandLine();           
<a name="164"></a>            
<a name="165"></a>            /* Pass the command through all our StringPreParsers */
<a name="166"></a>            txt = StringPreParser.runAll(txt, Parser.rmcType());
<a name="167"></a>            
<a name="168"></a>            /* 
<a name="169"></a>             *   If the txt is now nil, a StringPreParser has fully dealt with
<a name="170"></a>             *   the command, so go back and prompt for another one.
<a name="171"></a>             */        
<a name="172"></a>            if(txt == nil)
<a name="173"></a>                continue;
<a name="174"></a>            
<a name="175"></a>            /* Parse and execute the command. */
<a name="176"></a>            Parser.parse(txt);
<a name="177"></a>        }
<a name="178"></a>        catch(TerminateCommandException tce)
<a name="179"></a>        {
<a name="180"></a>            
<a name="181"></a>        }
<a name="182"></a>        
<a name="183"></a>        /* Update the status line. */
<a name="184"></a>        statusLine.showStatusLine();
<a name="185"></a>        
<a name="186"></a>    } while (true);    
<a name="187"></a>    
<a name="188"></a>}
<a name="189"></a>
<a name="190"></a>/* Show the command prompt, read the player's input and return the result */
<a name="191"></a>readCommandLine()
<a name="192"></a>{
<a name="193"></a>    /* Read a new command from the keyboard. */
<a name="194"></a>    "&lt;.inputline&gt;";
<a name="195"></a>    DMsg(command prompt, '&gt;');
<a name="196"></a>    local txt = inputManager.getInputLine();
<a name="197"></a>    "&lt;./inputline&gt;\n";   
<a name="198"></a>    
<a name="199"></a>    return txt;    
<a name="200"></a>}
<a name="201"></a>
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/01/2025 from adv3Lite version 2.1.1.14</div>
</body>
</html>

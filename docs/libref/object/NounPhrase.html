<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>NounPhrase</title></head><body>
<table class=ban><tr><td align=left><span class=title>NounPhrase</span><span class=type>class</span><td align=right><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1682">1682</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_SubClassTree_">Subclass<br>Tree</a>
<td><a href="#_ObjectSummary_">Global<br>Objects</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   A NounPhrase object represents a noun phrase within a command line.   This class handles the mapping from the text of the noun phrase in the   input to the game-world objects that the noun phrase refers to. <p>   This object encompasses a core noun phrase plus all of its qualifiers.   Qualifiers can themselves be noun phrases: possessives, locationals,   and contents phrases contain subsidiary noun phrases, so we represent   these qualifiers with subsidiary NounPhrase objects. 
<p>
<code>class 
<b>NounPhrase</b> :  &nbsp; object</code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>NounPhrase</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; object</code><br>
<a name="_SubClassTree_"></a><p><div class=mjhd><span class=hdln>Subclass Tree</span> &nbsp; </div><p>
<code><b>NounPhrase</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/LiteralPhrase.html">LiteralPhrase</a></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/NumberPhrase.html">NumberPhrase</a></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/TopicPhrase.html">TopicPhrase</a></code><br>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Global Objects</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
<a href="#contPrep">contPrep</a>&nbsp; 
<a href="#contQual">contQual</a>&nbsp; 
<a href="#coreProd">coreProd</a>&nbsp; 
<a href="#determiner">determiner</a>&nbsp; 
<a href="#disambigNameList">disambigNameList</a>&nbsp; 
<a href="#errName">errName</a>&nbsp; 
<a href="#errNameProd">errNameProd</a>&nbsp; 
<a href="#exclusions">exclusions</a>&nbsp; 
<a href="#locQual">locQual</a>&nbsp; 
<a href="#locType">locType</a>&nbsp; 
<a href="#matches">matches</a>&nbsp; 
<a href="#objs">objs</a>&nbsp; 
<a href="#ordinal">ordinal</a>&nbsp; 
<a href="#parent">parent</a>&nbsp; 
<a href="#possQual">possQual</a>&nbsp; 
<a href="#prod">prod</a>&nbsp; 
<a href="#pronoun">pronoun</a>&nbsp; 
<a href="#quantifier">quantifier</a>&nbsp; 
<a href="#role">role</a>&nbsp; 
<a href="#tokens">tokens</a>&nbsp; 
</code><p>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#addContents">addContents</a>&nbsp; 
<a href="#addExclusionItem">addExclusionItem</a>&nbsp; 
<a href="#addLiteral">addLiteral</a>&nbsp; 
<a href="#addLocation">addLocation</a>&nbsp; 
<a href="#addMatches">addMatches</a>&nbsp; 
<a href="#addOrdinal">addOrdinal</a>&nbsp; 
<a href="#addPossessive">addPossessive</a>&nbsp; 
<a href="#addQuantifier">addQuantifier</a>&nbsp; 
<a href="#ambigError">ambigError</a>&nbsp; 
<a href="#applyContQual">applyContQual</a>&nbsp; 
<a href="#applyDisambig">applyDisambig</a>&nbsp; 
<a href="#applyExclusion">applyExclusion</a>&nbsp; 
<a href="#applyLocational">applyLocational</a>&nbsp; 
<a href="#applyPossessive">applyPossessive</a>&nbsp; 
<a href="#buildObjList">buildObjList</a>&nbsp; 
<a href="#clone">clone</a>&nbsp; 
<a href="#construct">construct</a>&nbsp; 
<a href="#contains">contains</a>&nbsp; 
<a href="#disambiguate">disambiguate</a>&nbsp; 
<a href="#expandErrName">expandErrName</a>&nbsp; 
<a href="#isAllEquivalent">isAllEquivalent</a>&nbsp; 
<a href="#isMultiple">isMultiple</a>&nbsp; 
<a href="#matchNameScope">matchNameScope</a>&nbsp; 
<a href="#matchVocab">matchVocab</a>&nbsp; 
<a href="#matchVocabPoss">matchVocabPoss</a>&nbsp; 
<a href="#resolveAll">resolveAll</a>&nbsp; 
<a href="#resolveReflexives">resolveReflexives</a>&nbsp; 
<a href="#selectObjects">selectObjects</a>&nbsp; 
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<a name="contPrep"></a>
<table class=decl><tr><td><code>contPrep</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2960">2960</a>]</table><div class=desc>the preposition of the contents qualifier<p>
</div>
<a name="contQual"></a>
<table class=decl><tr><td><code>contQual</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2957">2957</a>]</table><div class=desc>the contents qualifier phrase, if any ("the bucket OF WATER")<p>
</div>
<a name="coreProd"></a>
<table class=decl><tr><td><code>coreProd</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2935">2935</a>]</table><div class=desc>   the grammar match for the core noun phrase; this is the part that   names a single object, stripped of all qualifiers (such as   possessives, articles, quantifiers, and locational phrases) <p>
</div>
<a name="determiner"></a>
<table class=decl><tr><td><code>determiner</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2973">2973</a>]</table><div class=desc>the determiner, if any, as a Determiner object<p>
</div>
<a name="disambigNameList"></a>
<table class=decl><tr><td><code>disambigNameList</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2982">2982</a>]</table><div class=desc>the name list from the disambiguation query<p>
</div>
<a name="errName"></a>
<table class=decl><tr><td><code>errName</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1732">1732</a>]</table><div class=desc>   By default, use the original input text of my "core" production as   the name we show for this noun phrase in error messages.  The core   production is the noun phrase minus any qualifiers (articles,   possessives, locational phrases, etc). <p>   As we successfully resolve qualifiers, we'll expand this to   include the qualifying phrases.  Any error we find after resolving   a qualifier will necessary apply to the qualified form, so we want   to include the qualifier in any error message. <p>   For example, if the original phrase is BUCKET OF FISH ON TABLE,   we'll start out with the core phrase of BUCKET.  We'll next   resolve the contents qualifier, OF FISH.  Assuming that we find a   BUCKET OF FISH, that becomes the new error name.  If we then fail   to find such an object ON TABLE, we'll be able to report that   there's no BUCKET OF FISH on the table.  This is better than   reporting that we don't see any BUCKET on the table, because there   could in fact be a different bucket on the table. <p>
</div>
<a name="errNameProd"></a>
<table class=decl><tr><td><code>errNameProd</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1735">1735</a>]</table><div class=desc>the source of the error name is initially the core production<p>
</div>
<a name="exclusions"></a>
<table class=decl><tr><td><code>exclusions</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2979">2979</a>]</table><div class=desc>   the exclusion list, if any (this is the list following EXCEPT or   BUT in a phrase like ALL EXCEPT THE RED ONES) <p>
</div>
<a name="locQual"></a>
<table class=decl><tr><td><code>locQual</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2947">2947</a>]</table><div class=desc>the locational qualifier phrase, if any ("the box ON THE SHELF")<p>
</div>
<a name="locType"></a>
<table class=decl><tr><td><code>locType</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2954">2954</a>]</table><div class=desc>   The locational qualifier relationship, as a LocType object.  (This   is stored on the locational qualifier noun phrase itself, not on   the underlying noun phrase it qualifies.) <p>
</div>
<a name="matches"></a>
<table class=decl><tr><td><code>matches</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2833">2833</a>]</table><div class=desc>   List of NPMatch objects.  This is populated during the matchName   phase with the list of possible vocabulary matches, and then   reduced during disambiguation to the final set. <p>
</div>
<a name="objs"></a>
<table class=decl><tr><td><code>objs</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2840">2840</a>]</table><div class=desc>   List of resolved objects.  This is populated after disambiguation   from the 'matches' set - it contains the same objects, but simply   the objects rather than the NPMatch wrappers. <p>
</div>
<a name="ordinal"></a>
<table class=decl><tr><td><code>ordinal</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2970">2970</a>]</table><div class=desc>   The ordinal value, if any, as a number: for "the third one", this   is 3.  This is intended for use in disambiguation replies, to let   the user pick out an item by its position in the offered list. <p>
</div>
<a name="parent"></a>
<table class=decl><tr><td><code>parent</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2925">2925</a>]</table><div class=desc>the NounPhrase we qualify, if we're a possessive or locational<p>
</div>
<a name="possQual"></a>
<table class=decl><tr><td><code>possQual</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2944">2944</a>]</table><div class=desc>the possessive qualifier, if any ("BOB'S box")<p>
</div>
<a name="prod"></a>
<table class=decl><tr><td><code>prod</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2928">2928</a>]</table><div class=desc>the grammar production match object for this noun phrase<p>
</div>
<a name="pronoun"></a>
<table class=decl><tr><td><code>pronoun</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2941">2941</a>]</table><div class=desc>the pronoun, if any, as a Pronoun object<p>
</div>
<a name="quantifier"></a>
<table class=decl><tr><td><code>quantifier</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2963">2963</a>]</table><div class=desc>the quantifier, if any, as a number: for "five books", this is 5<p>
</div>
<a name="role"></a>
<table class=decl><tr><td><code>role</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2922">2922</a>]</table><div class=desc>   the Command list we're a part of (&amp;dobjNPs, &amp;iobjNPs, etc: the   Command overrides this to the actual list property for a primary   noun phrase, and for qualifiers such as possessives, this   inherited version looks it up via the parent) <p>
</div>
<a name="tokens"></a>
<table class=decl><tr><td><code>tokens</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2938">2938</a>]</table><div class=desc>the literal tokens making up the noun phrase<p>
</div>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="addContents"></a>
<table class=decl><tr><td><code>addContents (prep, prod)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2853">2853</a>]</table><div class=desc>add a contents qualifier, returning the new noun phrase<p>
</div>
<a name="addExclusionItem"></a>
<table class=decl><tr><td><code>addExclusionItem (prod)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2888">2888</a>]</table><div class=desc>add an exclusion list item<p>
</div>
<a name="addLiteral"></a>
<table class=decl><tr><td><code>addLiteral (tok)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2843">2843</a>]</table><div class=desc>add a literal to this phrase<p>
</div>
<a name="addLocation"></a>
<table class=decl><tr><td><code>addLocation (locType, prod)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2863">2863</a>]</table><div class=desc>add a locational qualifier, returning the new noun phrase<p>
</div>
<a name="addMatches"></a>
<table class=decl><tr><td><code>addMatches (vec, lst, match)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1906">1906</a>]</table><div class=desc>   Add matching objects to a match vector.  'lst' can be a list or   vector of objects, or a single object.  'match' is the MatchXxx   flag value returned from the object name match, if applicable. <p>
</div>
<a name="addOrdinal"></a>
<table class=decl><tr><td><code>addOrdinal (num)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2882">2882</a>]</table><div class=desc>add an ordinal, given as an integer value<p>
</div>
<a name="addPossessive"></a>
<table class=decl><tr><td><code>addPossessive (prod)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2846">2846</a>]</table><div class=desc>add a possessive qualifier, returning the new noun phrase<p>
</div>
<a name="addQuantifier"></a>
<table class=decl><tr><td><code>addQuantifier (num)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2876">2876</a>]</table><div class=desc>add a quantifier, given as an integer value<p>
</div>
<a name="ambigError"></a>
<table class=decl><tr><td><code>ambigError (cmd)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2472">2472</a>]</table><div class=desc>   Throw an ambiguous noun phrase error for the current match list. <p>
</div>
<a name="applyContQual"></a>
<table class=decl><tr><td><code>applyContQual ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2137">2137</a>]</table><div class=desc>   Apply this contents qualifier phrase's qualification.  This   filters the underlying (parent) noun list to keep only objects   that contain the object(s) named in this noun list. <p>
</div>
<a name="applyDisambig"></a>
<table class=decl><tr><td><code>applyDisambig (cmd, ambigMatches, nameList)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2545">2545</a>]</table><div class=desc>   Apply this noun phrase as a disambiguation reply to the given   original list of matches to an ambiguous noun phrase. <p>
</div>
<a name="applyExclusion"></a>
<table class=decl><tr><td><code>applyExclusion (cmd)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2204">2204</a>]</table><div class=desc>   Apply an exclusion item.  This resolves the vocabulary for the   exclusion phrase and filters the matching item(s) noun phrase out   of the parent list. <p>
</div>
<a name="applyLocational"></a>
<table class=decl><tr><td><code>applyLocational ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2166">2166</a>]</table><div class=desc>   Apply this locational phrase's qualification.  This filters the   underlying (parent) noun list to keep only objects located within   the object(s) named in this noun phrase. <p>
</div>
<a name="applyPossessive"></a>
<table class=decl><tr><td><code>applyPossessive ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2100">2100</a>]</table><div class=desc>   Apply this possessive phrase's qualification.  This filters the   underlying (parent) noun list to keep only objects owned by the   object(s) named in this noun phrase. <p>
</div>
<a name="buildObjList"></a>
<table class=decl><tr><td><code>buildObjList ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2823">2823</a>]</table><div class=desc>Build the 'objs' list from the match list<p>
</div>
<a name="clone"></a>
<table class=decl><tr><td><code>clone ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1695">1695</a>]</table><div class=desc>clone - create a modifiable copy based on this original noun phrase<p>
</div>
<a name="construct"></a>
<table class=decl><tr><td><code>construct (parent, prod)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1684">1684</a>]</table><div class=desc>create<p>
</div>
<a name="contains"></a>
<table class=decl><tr><td><code>contains (np)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1770">1770</a>]</table><div class=desc>   Does this NounPhrase contain the given NounPhrase?  Returns true   if NounPhrase is self, or one of our qualifier noun phrases   contains it. <p>
</div>
<a name="disambiguate"></a>
<table class=decl><tr><td><code>disambiguate (cmd, num, action)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2383">2383</a>]</table><div class=desc>   Disambiguate the match list to select the given target number of   objects. <p>
</div>
<a name="expandErrName"></a>
<table class=decl><tr><td><code>expandErrName (np)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1742">1742</a>]</table><div class=desc>   Expand the error-message name to include the given qualifier.   We'll find the common parent of the core production and the given   qualifier's production, and use its text as the new error name. <p>
</div>
<a name="isAllEquivalent"></a>
<table class=decl><tr><td><code>isAllEquivalent (matchList)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2373">2373</a>]</table><div class=desc>   Determine whether all matches in the matchList are impossible to   disambiguate. <p>
</div>
<a name="isMultiple"></a>
<table class=decl><tr><td><code>isMultiple ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2909">2909</a>]</table><div class=desc>   Does this noun phrase refer to multiple objects structurally?   This is true if any the matches used plural words, or the   determiner is All, or we have a quantifier greater than 1. <p>
</div>
<a name="matchNameScope"></a>
<table class=decl><tr><td><code>matchNameScope (cmd, scope)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1920">1920</a>]</table><div class=desc>   Find the vocabulary matches for a given noun phrase within a given   scope list.  Add all of the matches to the given vector. <p>
</div>
<a name="matchVocab"></a>
<table class=decl><tr><td><code>matchVocab (cmd)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1786">1786</a>]</table><div class=desc>   Get the list of objects matching the vocabulary words in our noun   phrase.  Populates our 'matches' property with a vector of matching   objects.  This doesn't look at any of our qualifiers, or attempt   to disambiguate contextually; it simply finds everything in scope   that the noun phrase could refer to. <p>
</div>
<a name="matchVocabPoss"></a>
<table class=decl><tr><td><code>matchVocabPoss (cmd)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#1986">1986</a>]</table><div class=desc>   Match vocabulary for a possessive qualifier phrase. <p>   Possessive matching has somewhat different rules than for ordinary   noun phrases. <p>   First, possessive pronouns (HIS, HER, ITS, THEIR) *can* act like   reflexives, in that they can refer back to earlier clauses in the   same predicate: ASK BOB ABOUT HIS MOTHER.  However, they can also   refer to previous commands: SEARCH BOB; TAKE HIS WALLET.  The   deciding factor is whether or not there's an earlier noun phrase   in the command that matches in gender and number; if so, we use   the reflexive meaning, otherwise we use the external referent. <p>   Second, the scope for ordinary noun phrases has to be expanded to   include the owners of the objects in scope.  If we have a wallet   that we know belongs to Bob, we should be able to refer to it as   "Bob's wallet" whether or not Bob himself is in scope.  So, for   the purposes of the possessive, Bob is in scope even if he   wouldn't be for an ordinary noun phrase. <p>
</div>
<a name="resolveAll"></a>
<table class=decl><tr><td><code>resolveAll (cmd)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2742">2742</a>]</table><div class=desc>   Resolve ALL.  This is called on a separate pass after   selectObjects(), because two-object verbs sometimes resolve ALL in   one slot according to the selection in the other slot. <p>
</div>
<a name="resolveReflexives"></a>
<table class=decl><tr><td><code>resolveReflexives (cmd)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2787">2787</a>]</table><div class=desc>   Resolve reflexive pronouns.  Our Command calls this AFTER   resolving all of the regular noun phrases, because reflexives   refer back to other nouns in the same command. <p>
</div>
<a name="selectObjects"></a>
<table class=decl><tr><td><code>selectObjects (cmd)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#2255">2255</a>]</table><div class=desc>   Select the objects from among the vocabulary matches.  This   narrows the list of possible vocabulary matches for our noun   phrase to find the actual object or objects the player is   referencing. <p>   When this is called, we've already filled in the match list with   all objects in scope that match the vocabulary of the core noun   phrase (including non-reflexive pronouns and ALL), and we've   applied any possessive, locational, and exclusion qualifiers.   What we're left with is the list of in-scope objects that meet all   of the specifications contained in the entire noun phrase.  In   other words, we've squeezed all available information out of the   noun phrase itself.  If the result is ambiguous, then, we'll have   to look beyond the noun phrase, to the broader semantic content of   the overall command. <p>   There are three possible "goals" for what our final object list   should look like after disambiguation.  Only one goal applies to   each particular noun phrase; which it is depends on the grammar of   the phrase: <p>   1.  Definite mode: TAKE BOOK, TAKE THE BOOK, TAKE BOTH BOOKS, TAKE   THE THREE BOOKS.  The goal in definite mode is to choose the given   number of objects, *and* to make sure that the player could *only*   have meant those precise objects.  In other words, we're not   allowed to make an arbitrary choice: in natural language, the   definite mode says that the speaker believes the listener knows   which *particular* object or objects the speaker is referring to.   If we're not absolutely sure which objects the player is talking   about, we have a disagreement with the player's apparent   expectations and must ask for clarification. <p>   2.  Indefinite mode: TAKE A BOOK, TAKE ANY BOOK, TAKE TWO BOOKS.   The goal is to choose the given number of objects from the   possible matches, arbitrarily choosing from the available objects. <p>   3. Plural mode: TAKE BOOKS, TAKE THE BOOKS, TAKE ALL BOOKS.  The   goal here is to choose all of the matching objects. <p>
</div>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 03/03/2025 from adv3Lite version 2.2.0.3</div>
</body>
</html>

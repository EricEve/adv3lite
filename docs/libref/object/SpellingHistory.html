<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>SpellingHistory</title></head><body>
<table class=ban><tr><td align=left><span class=title>SpellingHistory</span><span class=type>class</span><td align=right><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#444">444</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_SubClassTree_">Subclass<br>Tree</a>
<td><a href="#_ObjectSummary_">Global<br>Objects</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   SpellingHistory: this maintains the history of attempted spelling   corrections for the current command.  We process each word separately,   so each word has its own entry in the history. <p>   The point of maintaining a history is that it allows us to backtrack   if we decide that an earlier guess at a corrected word isn't going to   result in a working command after all.  If an earlier correction had   other equally good options, we can go back and try the other options   by unwinding the history. 
<p>
<code>class 
<b>SpellingHistory</b> :  &nbsp; object</code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>SpellingHistory</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; object</code><br>
<a name="_SubClassTree_"></a><p><div class=mjhd><span class=hdln>Subclass Tree</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Global Objects</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
<a href="#corrections">corrections</a>&nbsp; 
<a href="#cstack">cstack</a>&nbsp; 
<a href="#parser">parser</a>&nbsp; 
<a href="#startTime">startTime</a>&nbsp; 
</code><p>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#checkSpelling">checkSpelling</a>&nbsp; 
<a href="#clear">clear</a>&nbsp; 
<a href="#construct">construct</a>&nbsp; 
<a href="#hasCorrections">hasCorrections</a>&nbsp; 
<a href="#noteSpelling">noteSpelling</a>&nbsp; 
<a href="#rollback">rollback</a>&nbsp; 
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<a name="corrections"></a>
<table class=decl><tr><td><code>corrections</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#786">786</a>]</table><div class=desc>   The indices of the words we've corrected so far.  We keep track of   the corrections we've made so that we don't try to further correct   a word we've already corrected.  (We *do* try multiple candidates   per slot, but we do that by backtracking.) <p>
</div>
<a name="cstack"></a>
<table class=decl><tr><td><code>cstack</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#795">795</a>]</table><div class=desc>   The attempted correction stack.  Each time we correct a word,   we'll add a SpellingCorrection item to the stack.  If we decide a   correction didn't work after all (i.e., didn't yield a valid   parsing), the stack lets us retract it and try a different   correction candidate. <p>
</div>
<a name="parser"></a>
<table class=decl><tr><td><code>parser</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#775">775</a>]</table><div class=desc>our parser object<p>
</div>
<a name="startTime"></a>
<table class=decl><tr><td><code>startTime</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#778">778</a>]</table><div class=desc>starting time (in GetTimeTicks time)<p>
</div>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="checkSpelling"></a>
<table class=decl><tr><td><code>checkSpelling (toks, err)</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#470">470</a>]</table><div class=desc>   Check for spelling errors in a token list, and attempt automatic   spelling correction.  We'll scan the token list for a word that   isn't in the dictionary.  If we find one, and spelling correction   is enabled, we'll attempt to automatically correct the error. <p>   'toks' is the token list for the command line, and 'err' is the   ParseError object indicating what error triggered the spelling   check. <p>   Returns a new token list if we correct a spelling error, nil   otherwise. <p>
</div>
<a name="clear"></a>
<table class=decl><tr><td><code>clear ( )</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#800">800</a>]</table><div class=desc>   Clear the history <p>
</div>
<a name="construct"></a>
<table class=decl><tr><td><code>construct (parser)</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#445">445</a>]</table><div class=desc><i>no description available</i><p>
</div>
<a name="hasCorrections"></a>
<table class=decl><tr><td><code>hasCorrections ( )</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#455">455</a>]</table><div class=desc>have we made any corrections?<p>
</div>
<a name="noteSpelling"></a>
<table class=decl><tr><td><code>noteSpelling (newToks)</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#699">699</a>]</table><div class=desc>   Note spelling changes between the original token list and the   given token list. <p>
</div>
<a name="rollback"></a>
<table class=decl><tr><td><code>rollback (toks, err)</code><td align=right><code><a href="../file/spelling.t.html">spelling.t</a>[<a href="../source/spelling.t.html#660">660</a>]</table><div class=desc>   Roll back spelling changes to the last one that actually improved   matters.  'toks' is the latest token list, and 'err' is the   parsing error that we encountered attempting to parse this token   list. <p>   If 'err' is a curable error, we'll leave things as they are.  The   curable error means that the token list is now well-formed, but is   missing some information we need to actually execute it.  Since   it's well-formed, our spelling corrections must have made some   kind of sense, so we'll assume they were correct. <p>   If the error isn't curable, though, our spelling corrections   didn't result in a working command.  The way we pick candidate   words tends to give us lots of false matches, so the fact that we   didn't end up with meaningful syntax overall suggests that our   guess for an individual word was a spurious match. <p>   To determine what we keep and what we roll back, we look at   whether a change improved the intelligibility of the command.   There are basically three stages of intelligibility that we can   distinguish: (1) completely unintelligible, (2) valid verb   structure but unknown noun phrases, and (3) valid verb structure   AND resolvable noun phrases. <p>   We want to keep any attempted spelling corrections that   successfully advanced us from one stage to the next, because the   improved intelligibility is pretty good evidence that our   corrections were in fact correct.  We DON'T want to keep any   corrections that didn't advance the process, because we can't tell   if they actually helped.  We're intentionally conservative about   spelling correction, because spurious corrections are worse in an   IF context than in most applications.  In IF, a spurious   correction could be a spoiler, by revealing the existence of a   dictionary word too early in the game.  To reduce spurious   corrections, we only accept corrections that actually make the   command more parseable. <p>
</div>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/01/2025 from adv3Lite version 2.1.1.14</div>
</body>
</html>

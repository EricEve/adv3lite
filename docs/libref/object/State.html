<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>State</title></head><body>
<table class=ban><tr><td align=left><span class=title>State</span><span class=type>class</span><td align=right><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#954">954</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_SubClassTree_">Subclass<br>Tree</a>
<td><a href="#_ObjectSummary_">Global<br>Objects</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   A State represents a changeable condition of a Mentionable that can be   used as part of the object's name in command input.  For example, a   state could be used to represent whether a match is lit or unlit: the   words 'lit' and 'unlit' could then be used to describe the object,   according to its current condition. <p>   The actual current condition of a given object is given by a property   of the Mentionable, which we define as part of the State object.  So   testing whether an object is lit or unlit is just a matter of checking   the corresponding property of the object. <p>   The parser considers an object to have the state, for parsing   purposes, if the object defines any value for the state property. <p>   Most of the State object's definition is its vocabulary, which is   obviously language-specific.  We therefore leave it to the language   modules to define the individual State instances.  Games can also add   new states as needed, of course. 
<p>
<code>class 
<b>State</b> :  &nbsp; <a href="../object/LState.html">LState</a></code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>State</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/LState.html">LState</a></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; object</code><br>
<a name="_SubClassTree_"></a><p><div class=mjhd><span class=hdln>Subclass Tree</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Global Objects</span> &nbsp; </div><p>
<code>
<a href="../object/DirState.html">DirState</a>&nbsp; 
<a href="../object/LitUnlit.html">LitUnlit</a>&nbsp; 
<a href="../object/OpenClosed.html">OpenClosed</a>&nbsp; 
</code>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
<a href="#adjectives">adjectives</a>&nbsp; 
<a href="#all">all</a>&nbsp; 
<a href="#stateProp">stateProp</a>&nbsp; 
<a href="#vocabTab">vocabTab</a>&nbsp; 
<a href="#vocabWords">vocabWords</a>&nbsp; 
</code><p>
<p>Inherited from <code>LState</code> :<br>
<code>
<a href="../object/LState.html#additionalInfo">additionalInfo</a>&nbsp; 
</code><p>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#appliesTo">appliesTo</a>&nbsp; 
<a href="#classInit">classInit</a>&nbsp; 
<a href="#construct">construct</a>&nbsp; 
<a href="#getVocab">getVocab</a>&nbsp; 
<a href="#matchName">matchName</a>&nbsp; 
</code><p>
<p>Inherited from <code>LState</code> :<br>
<code>
<a href="../object/LState.html#addToName">addToName</a>&nbsp; 
<a href="../object/LState.html#getAdditionalInfo">getAdditionalInfo</a>&nbsp; 
<a href="../object/LState.html#initWord">initWord</a>&nbsp; 
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<a name="adjectives"></a>
<table class=decl><tr><td><code>adjectives</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#1027">1027</a>]</table><div class=desc>   State/adjective initializer list. <p>   States are generally represented in names by adjectives added to   the object name, both in displaying output and in parsing input.   For example, a Lit/Unlit state would add 'lit' in the lit state   and 'unlit' in the unlit state.  So we provide an easy way of   initializing a state object: just list the states and their   corresponding adjectives. <p>   Make one entry in this list for each possible state; the entry is   a list, [stateval, [adjectives]], where 'stateval' is the state   variable value, and [adjectives] is a list of strings giving the   corresponding adjectives.  The first adjective in the list is the   display adjective - this is the one that addToName() will use to   generate an object name for display.  The rest are used to parse   input; they'll all be matched to the state. <p>
</div>
<a name="all"></a>
<table class=decl><tr><td><code>all</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#1043">1043</a>]</table><div class=desc>class property: master list of all State objects<p>
</div>
<a name="stateProp"></a>
<table class=decl><tr><td><code>stateProp</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#963">963</a>]</table><div class=desc>   The Mentionable property that indicates the current condition of   an object that has this State.  The range of values that this   property takes on in the Mentionable is up to the State to define.   For some states, this will be a simple boolean: Lit/Unlit,   Open/Closed, On/Off, etc.  For others, this might be an integer   range or a set of string values. <p>
</div>
<a name="vocabTab"></a>
<table class=decl><tr><td><code>vocabTab</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#1007">1007</a>]</table><div class=desc>state vocabulary lookup table (built automatically during preinit)<p>
</div>
<a name="vocabWords"></a>
<table class=decl><tr><td><code>vocabWords</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#1040">1040</a>]</table><div class=desc>   *Full* vocabulary initializer list.  If the 'adjectives' list   isn't sufficiently flexible for your needs, you can use this   initializer list instead.  This consists of a list of sublist   entries, [stateval, word, flags].  'stateval' is a state value,   'word' is a string giving a vocabulary word to match, and 'flags'   is a combination of MatchXxx flags for the word. <p> <br>    [[nil, 'unlit', MatchAdj], <br>     [true, 'lit', MatchAdj]] <p>
</div>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="appliesTo"></a>
<table class=decl><tr><td><code>appliesTo (obj)</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#970">970</a>]</table><div class=desc>   Does this state apply to the given object?  By default, we   consider any object that defines the state property to exhibit the   state. <p>
</div>
<a name="classInit"></a>
<table class=decl><tr><td><code>classInit ( )</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#1088">1088</a>]</table><div class=desc>class initialization<p>
</div>
<a name="construct"></a>
<table class=decl><tr><td><code>construct ( )</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#1046">1046</a>]</table><div class=desc>construction<p>
</div>
<a name="getVocab"></a>
<table class=decl><tr><td><code>getVocab (state)</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#1000">1000</a>]</table><div class=desc>   Get the vocabulary words that apply to the given state.  For   example, a Lit/Unlit object might return 'lit' if state is true   and 'unlit' if state is nil. <p>
</div>
<a name="matchName"></a>
<table class=decl><tr><td><code>matchName (tok, state, cmp)</code><td align=right><code><a href="../file/thing.t.html">thing.t</a>[<a href="../source/thing.t.html#984">984</a>]</table><div class=desc>   Match a token from the object name for the given state value.   Mentionable.matchName() calls this to see if a token applies   because of the object's current conditdion.  'tok' is the token   string; 'state' is the object's value for the state property; and   'cmp' is the string comparator to use for the string comparisons.   Returns a combination of MatchXxx flags, or zero if the token   doesn't match the current condition. <p>   For example, a Lit/Unlit state would return MatchAdj for 'lit' if   'state' is true, 0 otherwise. <p>
</div>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 25/01/2025 from adv3Lite version 2.1.1.14</div>
</body>
</html>

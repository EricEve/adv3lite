<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>GrammarProd</title></head><body>
<table class=ban><tr><td align=left><span class=title>GrammarProd</span><span class=type>class</span><td align=right><a href="../file/gramprod.h.html">gramprod.h</a>[<a href="../source/gramprod.h.html#44">44</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_SubClassTree_">Subclass<br>Tree</a>
<td><a href="#_ObjectSummary_">Global<br>Objects</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   The GrammarProd intrinsic class is a specialized type that's designed   for creating parsers.  An object of this type is created automatically   by the TADS 3 compiler for each 'grammar' statement.  This class   encapsulates the prototype token list and mapping information defined in   a 'grammar' statement, and provides a method to match its prototype to   an input token string. <p>   GrammarProd implements a "parser" in a limited computerese sense, which   is essentially a program that produces "sentence diagrams" a la   elementary school grammar lessons.  GrammarProd is thus only a small   part of what we think of as "the parser" in an IF context.  The broader   parser starts with the sentence diagrams that GrammarProd produces, and   must then interpret their meanings and carry out the intentions they   express. <p>   Parsers built with GrammarProd trees can handle grammars with left or   right recursion, and can handle ambiguous grammars (meaning that a   single input can have multiple ways of matching the grammar).  This is   especially important for natural language parsing, since virtually all   natural languages have ambiguous grammars.  When a match is ambiguous, a   GrammarProd parser builds all of the possible match trees, allowing you   to choose the best match based on context and semantic content. <p>   You can also create new productions dynamically with new GrammarProd().   Use addAlt() to populate a new production with token matching rules. 
<p>
<code>intrinsic class 
<b>GrammarProd</b> :  &nbsp; <a href="../object/Object.html">Object</a></code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>GrammarProd</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/Object.html">Object</a></code><br>
<a name="_SubClassTree_"></a><p><div class=mjhd><span class=hdln>Subclass Tree</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Global Objects</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
</code><p>
<code>
</code><p>
<i>(none)</i>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#addAlt">addAlt</a>&nbsp; 
<a href="#clearAlts">clearAlts</a>&nbsp; 
<a href="#deleteAlt">deleteAlt</a>&nbsp; 
<a href="#getGrammarInfo">getGrammarInfo</a>&nbsp; 
<a href="#parseTokens">parseTokens</a>&nbsp; 
</code><p>
<p>Inherited from <code>Object</code> :<br>
<code>
<a href="../object/Object.html#callInherited">callInherited</a>&nbsp; 
<a href="../object/Object.html#cf">cf</a>&nbsp; 
<a href="../object/Object.html#checkDisplay">checkDisplay</a>&nbsp; 
<a href="../object/Object.html#createIterator">createIterator</a>&nbsp; 
<a href="../object/Object.html#createLiveIterator">createLiveIterator</a>&nbsp; 
<a href="../object/Object.html#display">display</a>&nbsp; 
<a href="../object/Object.html#displayAlt">displayAlt</a>&nbsp; 
<a href="../object/Object.html#forEach">forEach</a>&nbsp; 
<a href="../object/Object.html#getPropList">getPropList</a>&nbsp; 
<a href="../object/Object.html#getPropParams">getPropParams</a>&nbsp; 
<a href="../object/Object.html#getSuperclassList">getSuperclassList</a>&nbsp; 
<a href="../object/Object.html#isClass">isClass</a>&nbsp; 
<a href="../object/Object.html#isTransient">isTransient</a>&nbsp; 
<a href="../object/Object.html#mapAll">mapAll</a>&nbsp; 
<a href="../object/Object.html#ofKind">ofKind</a>&nbsp; 
<a href="../object/Object.html#propDefined">propDefined</a>&nbsp; 
<a href="../object/Object.html#propInherited">propInherited</a>&nbsp; 
<a href="../object/Object.html#propType">propType</a>&nbsp; 
<a href="../object/Object.html#valToSymbol">valToSymbol</a>&nbsp; 
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="addAlt"></a>
<table class=decl><tr><td><code>addAlt (alt, matchObj, dict?, symtab?)</code><td align=right><code><a href="../file/gramprod.h.html">gramprod.h</a>[<a href="../source/gramprod.h.html#84">84</a>]</table><div class=desc>   Add a new alternative set of alternatives to the rule list for this   grammar production. <p>   'alt' is a string with the token list specifying the alternative(s)   to add.  This uses the same syntax as the rule list in a static   'grammar' statement.  You can use '|' symbols to add multiple   alternatives. <p>   'matchObj' is the match object class, which is the class of the   object that parseTokens() reutrns in the match list to represent a   match to this production.  This corresponds to the base class   defined in a static 'grammar' statement. <p>   'dict' is an optional Dictionary object.  Literal tokens used in the   token list will be automatically added to the dictionary if they're   not already defined. <p>   'symtab' is an optional LookupTable with the global symbol table.   This must be provided if any symbolic tokens are used in the rule   list (property names, sub-production names, etc).  In most cases   this is simply the symbol table that t3GetGlobalSymbols() returns   during preinit. <p>
</div>
<a name="clearAlts"></a>
<table class=decl><tr><td><code>clearAlts (dict?)</code><td align=right><code><a href="../file/gramprod.h.html">gramprod.h</a>[<a href="../source/gramprod.h.html#123">123</a>]</table><div class=desc>   Delete all alternatives from the rule list for this grammar   production.  This resets the rule to an empty production with no   alternatives to match, which is convenient if you want to redefine   the entire rule set with a subsequent addAlt() call. <p>   'dict' is an optional Dictionary object to adjust for the deletion.   If a non-nil 'dict' is given, we'll remove all of the production's   literals from the dictionary. <p>
</div>
<a name="deleteAlt"></a>
<table class=decl><tr><td><code>deleteAlt (id, dict?)</code><td align=right><code><a href="../file/gramprod.h.html">gramprod.h</a>[<a href="../source/gramprod.h.html#111">111</a>]</table><div class=desc>   Delete onen or more alternatives from the rule list for this grammar   production.  'id' identifies the rule(s) to delete: <p>   - By tag: if 'id' is a string, the method deletes each alternative   whose match object's grammarTag property equals 'id'.  For static   rules defined with 'grammar' statements, the compiler sets   grammarTag to the tag used in the statement defining the rule.  This   makes it easy to delete all of the rules defined by a given   'grammar' statement. <p>   - By match object class: if 'id' is an object, the method deletes   every alternative whose match object equals 'id' or is a subclass of   'id'.  This makes it easy to delete a group of dynamically added   rules that share a match object. <p>   - By index: if 'id' is an integer, it gives the index of the rule to   delete.  This corresponds to an index in the list returned by   getGrammarInfo(). <p>   'dict' is an optional Dictionary object to adjust for the deletion.   If a non-nil 'dict' is given, we'll remove literals from the   dictionary that were defined by the alternative and no longer used   in the production. <p>
</div>
<a name="getGrammarInfo"></a>
<table class=decl><tr><td><code>getGrammarInfo ( )</code><td align=right><code><a href="../file/gramprod.h.html">gramprod.h</a>[<a href="../source/gramprod.h.html#58">58</a>]</table><div class=desc>   Retrieve a detailed description of the production.  This returns a   list of GrammarAltInfo objects that describe the rule alternatives   that make up this production. <p>
</div>
<a name="parseTokens"></a>
<table class=decl><tr><td><code>parseTokens (tokenList, dict)</code><td align=right><code><a href="../file/gramprod.h.html">gramprod.h</a>[<a href="../source/gramprod.h.html#51">51</a>]</table><div class=desc>   Parse the token list, starting at this production, using the given   dictionary to look up tokens.  Returns a list of match objects.  If   there are no matches to the grammar, simply returns an empty list. <p>
</div>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 26/02/2025 from adv3Lite version 2.2</div>
</body>
</html>

<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>Pronoun</title></head><body>
<table class=ban><tr><td align=left><span class=title>Pronoun</span><span class=type>class</span><td align=right><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4665">4665</a>], <a href="../file/english.t.html">english.t</a>[<a href="../source/english.t.html#2388">2388</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_SubClassTree_">Subclass<br>Tree</a>
<td><a href="#_ObjectSummary_">Global<br>Objects</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   Base class for pronouns.  We represent each type of pronoun with an   object, to abstract pronouns away from the vocabulary. <p>   The base library defines a set of pronouns that are common to most   languages: It, Him, Her, Them, You, Y'all, Me, and Us, plus reflexive   forms of It, Him, Her, and Them.  Some languages might not employ all   of these (French, for example, has no neuter gender, so there's no   equivalent of It), and some might need additional pronouns (e.g.,   French needs a feminine third-person plural).  If a pronoun we define   here has no equivalent in a given language, the language module should   simply omit any grammar mentioning it.  If the language has pronouns   that aren't in the basic set, the language module can provide   definitions for its own additional Pronoun objects, along with the   corresponding grammar rules. <p>   The library itself only directly references one pronoun object: You.   The parser specifically references this pronoun because it binds to   the addressee of a command, which has a special role in the parsing   process.  Apart from You, though, the library's use of pronouns is   directed by the grammar: if a given Pronoun doesn't appear in the   grammar anywhere, the library will never use it.  (Other than in   iterations over Pronoun instances, anyway; but these will be harmless   because the parser is just trying to be inclusive.)  This means that   language modules are free to ignore pronouns (other than You) from the   standard set when they're not a good match for the language's needs.   For example, if you need distinct Animate and Inanimate forms of Him   and Her, you could simply define four new Pronoun objects for these   forms, and use them in place of Him and Her throughout your grammar. <p>   Note that these objects are NOT grammar rules or dictionary words.   These are abstract objects representing the "binding" of the pronouns   - basically the set of grammatical attributes (gender, number) that   determine whether a given noun phrase is a valid antecedent for a   given pronoun.  That's why we don't define separate Pronoun objects   the different grammatical cases (nominative, accusative, dative, etc):   case is a feature of the grammar, and we're one step removed from that   here. 
<p><i>Modified in <a href="../file/english.t.html">english.t</a>[<a href="../source/english.t.html#2388">2388</a>]:</i><br>
   Modifications to Pronoun to ensure that aName, theName and theObjName   return the appropriate results. 
<p>
<code>class 
<b>Pronoun</b> :  &nbsp; object</code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>Pronoun</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; object</code><br>
<a name="_SubClassTree_"></a><p><div class=mjhd><span class=hdln>Subclass Tree</span> &nbsp; </div><p>
<code><b>Pronoun</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/ReflexivePronoun.html">ReflexivePronoun</a></code><br>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Global Objects</span> &nbsp; </div><p>
<code>
<a href="../object/Her.html">Her</a>&nbsp; 
<a href="../object/Him.html">Him</a>&nbsp; 
<a href="../object/It.html">It</a>&nbsp; 
<a href="../object/Me.html">Me</a>&nbsp; 
<a href="../object/Them.html">Them</a>&nbsp; 
<a href="../object/Us.html">Us</a>&nbsp; 
<a href="../object/Yall.html">Yall</a>&nbsp; 
<a href="../object/You.html">You</a>&nbsp; 
</code>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
<a href="#all">all</a>&nbsp; 
<a href="#aName">aName</a>&nbsp; 
<a href="#ante">ante</a>&nbsp; 
<a href="#person">person</a>&nbsp; 
<a href="#reflexive">reflexive</a>&nbsp; 
<a href="#theName">theName</a>&nbsp; 
<a href="#theObjName">theObjName</a>&nbsp; 
</code><p>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#construct">construct</a>&nbsp; 
<a href="#matchObj">matchObj</a>&nbsp; 
<a href="#resolve">resolve</a>&nbsp; 
<a href="#setAntecedents">setAntecedents</a>&nbsp; 
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<a name="all"></a>
<table class=decl><tr><td><code>all</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4729">4729</a>]</table><div class=desc>   Class property - list of all regular Pronoun objects.  (Note that   this excludes the reflexive pronouns, because the ReflexivePronoun   class has its own separate 'all' list for its instances.) <p>
</div>
<a name="aName"></a>
<table class=decl><tr><td><code>aName</code><td align=right><code><a href="../file/english.t.html">english.t</a>[<a href="../source/english.t.html#2389">2389</a>]</table><div class=desc><i>no description available</i><p>
</div>
<a name="ante"></a>
<table class=decl><tr><td><code>ante</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4716">4716</a>]</table><div class=desc>my antecedent or list of antecedents<p>
</div>
<a name="person"></a>
<table class=decl><tr><td><code>person</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4686">4686</a>]</table><div class=desc>   The grammatical person of the pronoun.  Pronouns come in three   persons: first (me, us), second (you), and third (her, them).  We   represent these as 1, 2, and 3. <p>
</div>
<a name="reflexive"></a>
<table class=decl><tr><td><code>reflexive</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4722">4722</a>]</table><div class=desc>   the corresponding reflexive pronoun, if any - this is set up   automatically during preinit <p>
</div>
<a name="theName"></a>
<table class=decl><tr><td><code>theName</code><td align=right><code><a href="../file/english.t.html">english.t</a>[<a href="../source/english.t.html#2390">2390</a>]</table><div class=desc><i>no description available</i><p>
</div>
<a name="theObjName"></a>
<table class=decl><tr><td><code>theObjName</code><td align=right><code><a href="../file/english.t.html">english.t</a>[<a href="../source/english.t.html#2391">2391</a>]</table><div class=desc><i>no description available</i><p>
</div>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="construct"></a>
<table class=decl><tr><td><code>construct ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4732">4732</a>]</table><div class=desc>on initialization, add me to the master list of pronoun objects<p>
</div>
<a name="matchObj"></a>
<table class=decl><tr><td><code>matchObj (obj)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4710">4710</a>]</table><div class=desc>   Does this pronoun match the given object or list of objects?  By   default, we won't match lists, and we'll ask the object if it   thinks we're a match. <p>
</div>
<a name="resolve"></a>
<table class=decl><tr><td><code>resolve ( )</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4679">4679</a>]</table><div class=desc>   Resolve the pronoun during parsing.  The usual way of doing this   is to return the list of antecedents we store as part of the   pronoun object.  This lets each type of pronoun store an   appropriate list of antecedents. <p>   For a reflexive pronoun, return the Pronoun object for the   ordinary form of the pronoun.  This tells the parser that it needs   to find a match for the pronoun within the command itself, rather   than looking for an external antecedent.  Second person is   inherently reflexive, in that it refers to the addressee(s), so   this should return 'self' for a second-person pronoun. <p>
</div>
<a name="setAntecedents"></a>
<table class=decl><tr><td><code>setAntecedents (obj)</code><td align=right><code><a href="../file/parser.t.html">parser.t</a>[<a href="../source/parser.t.html#4703">4703</a>]</table><div class=desc>   Set the antecedent(s) for future pronoun usage based on the   objects mentioned in the current command input or narrative   output.  'obj' can be a single antecedent object, or it can be a   list.  Even a singular pronoun can have a list of antecedents:   some commands have more than one noun phrase, and there's no way   of knowing which one the user might want to refer to with a   pronoun in a future command.  We can't know until we see the   context of the future pronoun use.  For example, UNLOCK DOOR WITH   KEY could be followed by OPEN IT, in which case IT is probably the   door; or by DROP IT, in which case IT is probably the key.  The   best thing to do is to save both the door and the key as possible   antecedents, so that we can choose the most suitable object when   we actually see a pronoun in a subsequent command. <p>
</div>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 20/10/2025 from adv3Lite version 2.2.1.1</div>
</body>
</html>

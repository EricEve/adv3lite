<html>
<!-- DERIVED FILE - DO NOT EDIT -->

<head>
<title>The Command Execution Cycle</title>
<link rel="stylesheet" href="techman.css" type="text/css">
</head>
<body>
<div class="topbar"><img src="topbar.jpg" border=0></div>
<div class="nav">
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="advtop.htm">Advanced Topics</a> &gt; 
The Command Execution Cycle
<br><span class="navnp"><a class="nav" href="t3banish.htm"><i>Prev:</i> Banishing (and Changing) Awkward Messages</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="t3transcript.htm"><i>Next:</i> Manipulating the Transcript</a> &nbsp;&nbsp;&nbsp; </span>

</div>
<div class="main">

<h1>The Command Execution Cycle</h1>


<p><i>by Eric Eve</i>

<p>A first sight (or even second, third or fourteenth sight) the command execution cycle in the adv3Lite library  is pretty complex. This article aims to unpack it step-by-step, both to give game authors a clearer idea of what is happening, and to indicate places where it may be useful to intervene.</p>
<p>To detail every single by-way and wrinkle of the command execution cycle would probably be more confusing than helpful, concealing the main contours of the process behind a mass of not particularly interesting detail. In this article we shall therefore simplify some of the processes involved, so that the usual course of events stands out, unencumbered by a plethora of potential exceptions. If you want the complete picture, you'll have to examine the library source code (some links to which are given as appropriate) and try to puzzle it out!</p>
<p>The command execution cycle is, if not a series of wheels within wheels, at least cycles within cycles or subroutines within subroutines. In an attempt to make this less confusing and more easy to follow, we shall try to follow the main line of execution one level at a time. We'll start by giving an overview of the main scheduling loop that runs each turn, and then trace the execution of a player's command piece by piece.</p>
<p>Much of the execution of a command that has been successfully parsed (to the point where any objects involved have been resolved) is carried out by the <a href='#doActionOnce'>doActionOnce()</a> method, which also calls the majority of the most commonly customized routines. Many readers (especially first-time readers) may therefore prefer to skip straight to that part of the article rather than trying to take in all the preceding material.</p> 
<br>

<h2>Broadbrush Overview</h2>
<p>At a rough broadbrush approxination, the command execution loop works as follows:</p>
<ol>
<li><a href='#maincommand'>mainCommandLoop</a> reads the player's command, applies any modifications from StringPreParsers, and passes it to Parser.parse() to parse (interpet).</li>
<li>The <a href='#parser'>parser</a> attempts to work out what action, actor, and objects are intended in the player's command and creates a new Command object to encapsulate its understanding of the command.</li>
<li>The <a href='#command'>Command</a> object then selects the appropriate Doer or Doers to handle the command.</li>
<li>The <a href='#doer'>Doer</a> object can do whatever it likes with the information passed to it by the Command object, but the usual behaviour is to pass the command information on to the relevant Action by calling the action's exec(cmd) method, where <i>cmd</i> is the Command object.</li>
<li>The relevant <a href='#action'>Action</a> then does the bulk of the work related to the specific action concerned, which includes carrying out the before action processing, the action processing, and the after action processing.</li>
</ol>

<p>We shall next explore each of these steps in more detail.</p>

<h2 id='maincommand'>Top Level Loop &ndash; mainCommandLoop</h2>
<p>The overall command execution in adv3Lite is carried out by the <code>mainCommandLoop()</code> function, which does the following:</p>
<ol>
<li>Sets the current actor to gPlayerChar to ensure there is a current actor (the current actor may be changed later in the cycle).</li>
<li>Displays any pending score notifications.</li>
<li>Executes any current PromptDaemons.</li>
<li>Outputs a paragraph break.</li>
<li>Calls <code>readCommandLine()</code> which:
<ol>
<li>Displays the command prompt.</li>
<li>Reads the player's command and stores it in the local variable <i>txt</i>.</li>
</ol></li>
<li>Allows any active StringPreParsers to modidfy <i>txt</i>.</li>
<li>If as a result, <i>txt</i> is now nil skips the rest of the loop and goes back to step 1.</li>
<li>Calls <a href='#parser'>Parser</a>.parse(txt) to parse and execute the command.</li>
<li>Updates the status line.</li>
<li>Goes back to Step 1 to execute the next cycle.</li>
</ol>

<h2><a name='parser'>Parsing the Player's Command</a></h2>
<p>The main parsing loop is contained in <a href='../libref/source/parser.t.html#211'>Parser.parse()</a>. <p>Various things can complicate this process. The command may be directed towards another actor (e.g. BOB, PUT RED BALL IN BOX), or the player may have entered several commands at once (e.g. PUT RED BALL IN BOX, TAKE BOX, GO NORTH); or the Player have entered an OOPS command to correct a misspelling, or be responding to a parser query such as a disambiguation prompt, or be entering a sepecial command form such as an implicit SAY command (the text of what the player wants the player character to say without explictly using the command SAY); the parsing loop has to cope with these possibilities.</p>
<p>The full details of this process are far too complex to go into here, and most game authors will not usually either want or need to know about them. Here we shall give a simplified account that should suffice for most purposes. With that caveat, Parser.parse(<i>str</i>) carries out the following steps:</p>
<ol>
<li>Resets the special verb handler.</li>
<li><a href='../sysman/tok.htm'>Tokenizes </a> the input string (<i>str</i>), producing a list of tokens encapsulating each of the separate words and punctuation marks in the player's input.</li>
<li>If there are no outstanding parser queries, set the current actor to the player character (if there is an outstanding query, the current actor may already have been set).</li>
<li>Note any spelling corrects the spelling corrector has made.</li>
<li>If there are no tokens at all (because the player has entered an empty command) carry out the empty command by calling <code>emptyCommand()</code>, which either carries out a LOOK command (if autoLook is true) or otherwise displays "I beg your pardon?". Either the Parser then stops there.</li>
<li>Otherwise the parser checks for an OOPS command and if there is one correcting a current error, adjusts the command tokens from step 2 to take account of it.</li>
<li>Updates the vocabulary of any game objects that use <a href='../manual/thing.htm#altvocab'>alternating or variable vocabulary</a>.</li>
<li>Give the special verb manner the chance to amend the command tokens to take account of any <a href='../manual/specialaction.htm'>SpecialVerbs</a> the player may have used.</li>
<li>If there's an outstanding parser question (such as a dismbiguation, 'Which do you mean?' or a missing object, 'What do you want to frob?'), and the question takes priority over new commands, try parsing the input against the question if it's the first command on the input line.</li>
<li>Otherwise, construct a list of new <a href='#commandobj'>Command</a> objects which could correspond to the player's input.
This involves the construction of a new CommandList object which:
<ol>
<li>Creates a list of commands by parsing the tokens passed to the CommandList constuctor by calling its Production's (typically a VerbRule) parseTokens() method. This stage identifes the possible actions the command may refer to.</li> 
<li>Sorts the command list in order of <a href='../libref/object/Command.html#calcPriority'>priority</a>.</li>
<li>Iterates through every command in the command list to call its resolveNouns() method, which in simplified form, does the following:
<ol>
<li>Calls the matchVocab() method on each noun phrase, which again, in simplified turns, takes care of any pronouns and calls matchName(tokens) on every Thing in scope for the current action to obtain a list of matching objects.</li>
<li>Calls buildObjLists() to construct a tentative list of matching objects.</li>
<li>Determines the actor if the noun we're looking for occupies the actor role (e.g. bob in a command that starts "bob, jump")</li>
<li>Select the objects from the available matches according to the grammatical mode (definite, indefinite, plural), by calling selectObjects() on each of the objects in our match list. Roughly speaking, this does the following:
<ol>
<li>If we're looking for a definite match (e.g. "THE BOOK") and we have one possible match, simply choose that match. If we have more than one, attempt to disambiguate among the possibilities by calling our disambiguate() method which:
<ol>
<li>First calls scoreObjects() on the current action, which in turn:
<ol>
<li>Calls the <b>verify</b> routine for the current action on every item in the list of objects we want to choose between. If this is TIAction we're using multimethods for, first call the appropriate verifyWhatever() multimethod. In any case next call the verifyPreCondition() method on all PreConditions that apply to the object for the current action. Then call the verify() sections of any dobjFor() and (for TIActions) iobjFor() blocks.</li>
<li>Adds 100 to the resultant verify score (the lowest logicalRank that emerges from the verify routine).</li>
<li>Make a note of this adjusted score and its associated verifyResult if it's better than any previous score we've encountered so far.</li>
<li>Note whether the verifyResult has resulted in a change of object via a remap.</li>
<li>Make a note of which object came out best in whichever role we're currentllu interested in.</li>
<li>Call scoreObject() on any object we're interested, which adds the object's vocabLikelihood to the score and carries out a couple of other tweaks in special circumstances.</li>
</ol></li>
<li>Sorts the objects in descending order of score.</li>
<li>If the number of objects with the highest score is the number of objects we're looking for, then selects them.</li>
<li>Otherwise, if we have two many best matches, through a disambiguation error so the parser can ask the player to clarify their choice.</li>
</ol></li>
<li>If we're looking for an indefinite match (e.g. "TWO BOOKS) call scoreObjects() on the action and sort the result in descending order of score and choose the first however many objects we want.</li>
<li>If we're looking for a match to ALL, simply select all the matching objects.</li>
</ol></li>
<li>Goes back and re-resolve any ALL lists.  For two-object commands, resolving ALL in one slot sometimes depends on resolving the
bject in the other slot first.</li>
<li>Resolves any reflexives.</li>
<li>Check for any empty roles (such as a missing indirect object for a TIAction) and throws an error if it finds one.</li>
<li>Calls buildObjLists() again to  Clear out the old object lists, then build them anew.  The old object lists were tentative, before disambiguation; we want to  replace them now with the final lists.</li>
</ol></li>
<li>If any errors are encountered, notes the first curable one and then continues interating through the list of commands.</li>
</ol></li>
</li> 
<li>If the previous step failed to find any resolvabe commands, try treating the player's input as the answer to any outstanding parser queries that don't take precedence over a new command.</li>
<li>If we still don't have any resolvable commands and this is the first command on the line and there is a conversation currently in progress (gPlayerChar.currentInterlocutor isn't nil), and the player character can still talk to their current interlocutor and the player character's current interlocutor allows implicit say commands, then treat the player's input as an implicit SAY command.</li>
<li>Otherwise, if the first word of the command doesn't match a possible verb, try parsing it as a noun phrase and, if that works, make the noun the direct object of our default action (GO TO for a Room or EXAMINE for any other thing), provided our defaultActions property is true (as it is by default).</li>
<li>If we've applied a spelling correction, and the command match didn't consume the entire input, make sure what's left of the input has a valid parsing as another command.  This ensures that we don't get a false positive by excessively shortening a command, which we can sometimes do by substituting a word like "then" for another word.</li>
<li> If we didn't find a parsing at all, issue a generic "I don't understand" error.  If we found a parsing, but not a resolution, reject it if it's a spelling correction.  We only want completely clean spelling corrections, without any errors.</li>
<li>If, one the other hand, the parser has found a resolvable command, we now execute it:
<ol>
<li>First ensure that we don't have multiple objects occupying a slot that the action's grammar (VerbRule) defines as only allowing a single object (singleDobj, singleIobj). If we do, then reject the command and explain the problem.</li>
<li>Otherwise, execute the <a href='##command'>command</a> by calling its exec() method. This is outcome we hope will occur in the majority of cases.</li>
<li>If this wasn't the last command on the command line, go back and parse the next one.</li>
</ol></li>
<li>If, however, we were unable to find a valid command, see if our command list contains a curable command, i.e. a command that could be rectified by the player responding to parser query.</li>
<li>If we can't find a curable command, try applying the spelling corrector. If that works, try executing the corrected command </li>
<li>If all has failed, throw an error and report the problem to the player and then stop trying to pause this command.</li>
</ol>

<h2 id="command">Executing the Command</h2>

<p>Once the initial parsing has resolved the player's command to an
action and a set of objects the action should act on (if there are any; for an IAction or most SystemActions
there plainly won't be), the Parser calls the appropriate Command object's exec() method, which:</p>
<ol>
<li>Carries out a number of housekeeping tasks, such as resetting a number of values, which need not detain us here.</li>
<li>Calls execGroup(cmd) on the relevant action to give it a chance to act on the entire group of objects involved (e.g. if the command was TAKE ALL or DROP THE PEN, THE GREEN BOOK AND THE GLASS KEY). In the library this does nothing on any actions part from GIVE TO and SHOW TO, where it resets a couple of properties used to summarise the effects of the action.</li>
<li>If there are no noun roles (because this is an intransitive action) just run our <a href='#execiter'>execIter()</a> method for this action.</li>
<li>Otherwise, first combine any duplicate direct objects into a single object (this is relevant if, for example, the player has types X LEAVES, TWIGS, TREES and BRANCHES and these are all synonyms for the same Decoration object).</li>
<li>Get the matches for each role (DirectObject, IndirecObject, etc.)</li>
<li>Sort the roles into canonical order (DirectObject, IndirecObject, AccessoryObject)</li>
<li>Call our execCombos() method for each set of objects in each role, starting with the DirectObject role: this method does the following for each set of objects:
<ol>
<li>Sets the current object for this role.</li>
<li>If there's more than one role, recursively call execCombos() for the next role.</li>
<li id="execiter">Otherwise, if we have reached the final role, call execIter(list), where <i>list</i> is a list in the form [action, dobj, iobj...]. This it turn does the following:
<li>Gives the special verb manager the opportunity to veto this command if we've been executing a <a href='../manual/specialaction.htm'>SpecialVerb</a>.
</li>Calls preAction(list) on the current actor (for example, to allow it to veto the action if the actor is bound or blindfolded).</li>
<li>Calls execDoer(list). This finds the list of <a href='../manual/doer.htm'>Doers</a> that match this action and its current set of objects (as specified in <i>list</i> and <a href='#doer'>executes</a> the one with the highest priority. This will lead to the bulk of the action handling on this turn.</li>
</ol></li>
<li id='post-action'> After the current Doer/Action has finished dealing with the action, Command.exec() resumes control by carrying out some post-action processing. This starts with displaying all the afterReports that were created by calls to reportAfter() during execution of the action.</li>
<li>Next carry out the afterAction() routine for the current action, unless it's a SystemAction or the action failed. This does the following:
<ol>
<li>If the lighting conditions change, display a description of current location if it's now lit or announce the onset of darkness if it's now dark.</li>
<li>Call afterAction() on all current <a href='../manual/scene.htm'>Scenes</a>.
<li>Call notifyAfter() on the actor's current Room. This first calls the Room's roomAfterAction() method and then calls regionAfterAction() on all the regions that contain the Room.</li>
<li>Call afterAction() on every object currently in scope for the actor.</li>
</ol></li>
<li>Call turnSequence() on the current action. This does the following:
<ol>
<li>Calls regionDaemon() on every region that contains the player character's current room.</li>
<li>Calls roomDaemon() on the player character's current room.</li>
<li>Calls executeTurn() on the eventManager object, which executes all current Events (Fuses and Daemons) in order of their priority.</li>
<li>Advances the turn counter.</li>
</ol>
</li>
<li>Call advanceTime() on the current action. This does nothing in the main library but is provided as a hook for the
<a href='../../extensions/docs/objtime.htm'>Objective Time</a> extension to use to add to the time taken by implicit actions.</li>
</ol>
<br>

<h2 id="doer">The Doer</h2>
<p>Once the current Command has identfied the appropriate <a href='../manual/doer.htm'>Doer</a> to handle the command, it calls that Doer's exec(curCommand) command, where <i>curCommand</i> is the current Command object. If the actor for the current command is the player character, we carry out various housekeeping tasks and allow the Doer to redirect the action to a different action, before calling our execAction() method. Otherwise we call handleCommand on the actor (who would then be a Non-Player Character). The normal result of calling execAction is to call our current action's exec(curCmd) method.</p>
<p>In sum a Doer, can intervene to change the action into something completely different, handle it itself, or stop the action althogether but the usual outcome is that the Doer will pass the command straight through to the action's exec() method.</p>

<h2 id="action">Carrying Out the Action</h2>
<p>As just stated, in most cases the relevant Doer will pass control to the appropriate action's exec(cmd) method, where <i>cmd</i> is the current <a href='#commandobj'>Command object</a>. What happens then depends on what type of action it is: SystemAction, IAction, TIAction or whatever, but we'll start with what virtually all actions do in common.</p>

<h3>exec(cmd)</h3>
<p>Action.exec(cmd) mostly does the following:</p>
<ol>
<li>Resets actionFailed to nil.</li>
<li>Resets scopeList to an empty list.</li>
<li>Sets libGlobal.curActor to cmd.actor.</li>
<li>Notes the actor's current room in the action's oldRoom property.</li>
<li>Notes that room's illumination state (lit or unlit) in the action's wasIlluminated property.</li>
<li>Executes the action-processing cycle by calling <a href='#execcycle'>execCycle(cmd)</a>.</li>
</ol>
<p>A few types of action vary this slightly:</p>
<ul>
<li><b>LiteralAction</b>s additionally store cmd.dobj.name (their literal object) in their <code>literal</code> property.</li>
<li><b>TopicAction</b>s additionally store cmd.dobj (the current topic) in their <code>curTopic</code> property.</li>
<li><b>NumericAction</b>s additionally store cmd.dobj.numVal (the numeric value associated with the action) in their <code>num</code> property.</li>
<li><b>SystemAction</b>.exec(cmd) simply calls execCycle(cmd) without doing anything else.</li>
<li>A few specific actions defined in the library do their own thing in exec(cmd). These include Again, ExamineOrGoto, TakeFrom (which calls inherited(cmd) on one comditional branch) and TellTo.</li>
</ul>

<h3 id = 'execcycle'>execCycle(cmd)</h3>
<p>Tbis does the following:<p>
<ol>
<li>Unless it's a SystemAction, first calls beforeAction(), which in turn:
<ol>
<li>Calls checkActionPreconditions() and stops the action if this returns nil.</li>
<li>Calls actorAction() on the current actor.</li> 
<li>Calls notifyBefore() on the sceneManager.</li>
<li>Calls notifyBefore() on the actor's current room. This in turn:
<ol>
<li>Calls roomBeforeAction() on the room.</li>
<li>Calls regionBeforeAction() on every Region that (directly or indirectly) contains the room.</li>
</ol></li>
<li>Calls buildScopeList() to build the scope list for the current action if it hasn't already been built.</li>
<li>Calls beforeAction() on every item in the scope list.</li>
</ol></li>
<li>Calls <a href='#execaction'>execAction(cmd)</a>.</li>
<li>If the action is repeatable, stores a clone of the action at libGlobal.lastAction.</li>
</ol>

<p><b>SystemAction</b> omits step 1. A <b>TravelAction</b> first sets its <code>direction</code> property to cmd.verbProd.dirMatch.dir (the direction entered by the player) unless it already has a non-nil <code>predefinedDirection</code> property. A <b>TAction</b> or <b>TIAction</b> first checks whether ALL was used with an action for which allowAll is nil, and if so displays a message saying that the current command does not allow ALL and then stops the action.</p>

<h3 id="execaction">execAction(cmd)</h3>

<br>
<h3><a name='doActionMain'>doActionMain</h3>
<p>As we have just seen, doAction() does a number of things, but the bulk of the action processing is left to doActionMain, which is called as the central step of doAction(). What precisely doActionMain does depends on whether it's being called on an IAction, a TAction, or a TIAction. If it's an IAction doActionMain() simply calls doActionOnce(). For a TAction or a TIAction doActionMain basically iterates over the list of objects (if there's more than one direct or indirect object involved in the command, because it was applied to multiple objects), calling doActionOnce() for each of them in turn. If only one direct object and (where appropriate) indirect object was specified (e.g. GET RED BALL or PUT RED BALL IN BROWN BOX) then doActionOnce() will only be called once.</p>
<p>The surrounding code in doActionMain() is responsible for such things as setting the objects for the current iteration, announcing the appropriate object for the current iteration (if there's more than one direct object, say), and breaking out of the iteration if the cancelIteration property has been set. For a TIAction, doActionMain also remembers the list of direct and indirect objects as potential pronoun antecedents.</p>
<br>
<h3><a name='doActionOnce'>doActionOnce()</a></h3>
<p>As noted above, doActionMain() is responsible for iterating over a set of objects where there may be more than one direct object or more than one indirect object involved in a command. For each direct object in a TAction or pair of direct and indirect objects in a TIAction, the action processing is handled by <a href='../libref/source/action.t.html#1238'>doActionOnce()</a>. The same method is also used to execute an IAction, TopicAction, and any other kind of action. Where the different types of action vary is in the definition of the methods doActionOnce() calls to carry out the various steps.</p>

<p>The steps carried out by doActionOnce() are:</p>

<ol>
<li>checkRemapping(). Before doing any actual execution, check the command for            remapping.  If this ends up doing any remapping, the remapping routine will simply replace the current command, so the remapping call will terminate the current action             with 'exit' and thus never return here. For an IAction, checkRemapping does nothing (there are no objects involved which might carry out remapping). For a TAction the direct object is checked for possible remapping of this action. For a TIAction both the direct and the indirect objects are checked for remapping but the order depends on the value of the resolveFirst property (which may be either DirectObject or IndirectObject).</li>
<li>If the action is an implicit action, run verifyAction(); if the result is that the action would normally be allowed, but is not allowed as an implicit action (because it is verifies to nonObvious or dangerous), then abort the implicit action. See <a href='#verify'>below</a> for what verifyAction does.</li>
<li>If the action is an implicit action, announce the implicit action (through a call to Action.maybeAnnounceImplicit()).</li>
<li>Carry out verification using verifyAction(). If verifyAction returns a result for which allowAction is nil (in other words, the action failed verification), show the message explaining why the action failed verification (via result.showMessage, which displays the message from the illogical macro or equivalent that ruled the action out) and terminate the action. See <a href='#verify'>below</a> for what verifyAction() does in more detail; generally it will call the appropriate verify methods on any objects involved in the command, and the verifyPreCondition() methods on all the preconditions.</li>
<li>Check the PreConditions for the action via a call to checkPreConditions. See <a href='#checkPreCond'>below</a> for what this does on different types of action. In general it will call the checkPreCondition method of each PreCondition relevant to the action. The first time through these methods will be allowed to carry out an implicit action in order to satisfy the PreCondition. If any implicit action is carried out we return to step 4 for a second pass, since the implicit action may have changed the game state, and hence the verification results we would get. If there is a second time through, no further implicit actions are allowed at this stage (so there's never more than two passes through steps 4 and 5).</i>
<li>Disable the sense cache (it may already have been disabled by an implicit action), since the game state may change from now on.</li>
<li>If gameMain.beforeRunsBeforeCheck is true, run the before notifiers, through a call to runBeforeNotifiers(). This in turn first runs beforeAction() on the current action (by default this does nothing, but game authors are free to override it to do something), then roomBeforeAction on the actor's containers (the Room or NestedRoom where the actor is located, which will in turn call roomBeforeAction on its containers, if it's a NestedRoom), and then beforeAction() on every other object in scope (or more precisely, on every other item in the action's notify list; this can be added to with an explicit call to addBeforeAfterObj(obj) on the action). If gameMain.beforeRunsBeforeCheck is nil, this all takes place at step 10 instead.</li>
<li>Run the actorAction() method on the current actor (by default this does nothing, but it is available for game authors to override).</li>
<li>Check the action, by calling checkAction() on the current action. What this does depends on the type of action (IAction, TAction, or TIAction), for details see <a href='#check'>below</a>. In general, though, this calls the check() parts of the dobjFor() and iobjFor() action handlers on the objects involved in the commands.</li>
<li>If gameMain.beforeRunsBeforeCheck is nil, run the before notifiers, through a call to runBeforeNotifiers. See Step 7 for details of what happens.</li>
<li>Execute the action through a call to execAction() on the current action. IActions or the equivalent must be overridden to define their action handling here. TActions and TIActions call the action parts of the dobjFor() and iobjFor() action handlers on the direct and (in the case of a TIAction) indirect object. For a SystemAction game authors should normally override execSystemAction rather than execAction. See <a href='#exec'>below</a> for more details of what execAction() does on various kinds of action.</li>
<li>Call the afterAction() method of every item in the notify list (roughly speaking, all the other items in scope plus those added to the notify list by a call to addBeforeAfterObj(obj) on the action).</li>
<li>Call the roomAfterAction() method of the actor's container (the Room or NestedRoom immediately containing the actor). This in turn will result the roomAfterAction of the container's containers being called (in the case of a NestedRoom).</li>
<li>Call the afterAction() method on the action. By default this does nothing, but it is available to be overridden by game authors.</li>
</ol>
<p>This completes the processing of the action. Remember that doActionOnce() will be called for each object in turn if there's a list of objects involved in the command (e.g. TAKE RED BALL, GREEN PEN AND BLACK HAMMER). Once all the objects have been processed runScheduler will then let NPCs take a turn, and will then execute any current Fuses and Daemons (see above). All that remains now is to explore in a bit more detail what verifyAction(), checkAction and execAction() do on the different kinds of action.</p>
<br>
<h2>Action-Type Specific Handling.</h2>
<p>We have now outlined the entire command execution cycle, but a few points of detail remain. In particular, we need to explore in just a little more detail what <a href='#verify'>verifyAction()</a>, <a href='#checkPreCond'>checkPreConditions()</a>, <a href='#check'>checkAction()</a> and <a href='#exec'>execAction()</a> do on the various kinds of action. For this purpose, we are mainly concerned with three broad classes of action:</p>
<ul>
<li><b>IAction</b> &mdash; actions that involve neither an indirect nor a direct object. For present purposes this includes SystemAction, TopicAction and LiteralAction as well as IAction itself.</li>
<li><b>TAction</b> &mdash; actions that involve a direct object but not an indirect object. For present purposes this includes TopicTAction and LiteralTAction as well as TAction itself.</li>
<li><b>TIAction</b> &mdash; actions that involve both a direct object and an indirect object; TIAction is the only category of action of this type (although there are, of course, many idifferent individual TIActions defined in the standard library).</li>
</ul>
<p>Note, then, that we are not interested in the grammatical form of the command (PUT BALL IN BAG or LOOK UP GREEK MYTHOLOGY IN BIG RED BOOK), but in the number of slots for simulation objects &ndash; objects of class Thing or one of its subclasses &ndash; that are required for the action: zero, one or two.</p>
<br>
<h3><a name='verify'>verifyAction</a></h3> 
<p><b>IAction</b>: This simply returns the list of VerifyResults from callVerifyPreCond(). This in turn calls verifyPreCondition on any preconditions attached to the action itself; these PreConditions may be listed in the preCond property of the action. In the standard library only JumpAction has a PreCondition (actorStanding), but game authors may like to add PreConditions to custom actions. Note that you can't, however, just override verifyAction() to include a naked illogical() macro or whatever, since this won't work.</p>
<p><b>TAction</b>: This proceeds in several stages:
<ol>
<li>Call the verifiers on any PreConditions attached to the <i>action</i> (as opposed to its direct object); this is the same at the callVerifyPreCond() for IAction, except that the list of VerifyResults returned will be augmented by the following two steps.</li>
<li>Check whether we should use dobjFor(All) or dobjFor(Default) handling on the direct object. The former overrides any more specific action handling on the object; the latter only comes into play if no specific handling for this action is defined on the object. If it turns out we should use one of these catch-all handlers, then run the appropriate one (verifyDobjAll or verifyDobjDefault) and add the results to our list of VerifyResults.</li>
<li>If we're not using a catch-all verify property (from the previous step) run the action-specific verify method on the direct object (e.g. verifyDobjTake for TakeAction), and add the results to our list of VerifyResults.</li>
<li>Run the verifiers (i.e. the verifyPreCondition() methods) of each PreCondition listed in the appropriate preCond property for the current action on the direct object (e.g. run verifyPreCondition on each PreCondition listed in preCondDobjTake if the action is a TakeAction). Any results from this step are added to our list of VerifyResults.</li>
<li>Finally, check that there are handlers defined for this action on the direct object, through a call to verifyHandlersExist. This checks that the object defines or inherits at least one out of verify, check and action handling (e.g. verifyDobjTake, checkDobjTake, or actionDobjTake for a TakeAction); if it doesn't, we add an illogical result ("You can't do that") to our list of VerifyResults.</li>
</ol>
</p> 
<p><b>TIAction</b>: This proceeds much like the handling for TAction, with a few extra stages for the indirect object. We first perform the same step 1 (callVerifyPreCond) to run the verifiers on the <i>action's</i> PreConditions. We then perform steps 2 to 4 on the direct object, as for a TAction. Following that we repeat the same steps (2 to 4) on the indirect object. Finally, we carry out Step 5 &ndash; call verifyHandlersExist() &ndash; as for TAction, except that we check both objects (direct and indirect) for the existence of a handler, and add an illogical result if neither object provides one.</p>
<br>
<h3><a name='checkPreCond'>checkPreConditions</a></h3>
<p><b>IAction</b>: This simply executes the checkPreCondition() method of every PreCondition listed in the <i>action's</i> preCond property. The PreConditions first are sorted in ascending order of their preCondOrder property.</p>

<p><b>TAction</b>: This is similar to the processing for IAction, except that the PreConditions listed in the direct object's preCond property (e.g. dobjPreCondTake for a TakeAction) are added to the list before it is sorted and checkPreCondition() executed on each PreCondition in the list.</b>

<p><b>TIAction</b>: This is similar to the processing for TAction, except that the PreConditions from the indirect object's appropriate preCond propety (e.g. preCondIobjPutIn for a PutInAction) are also added to the list.</p>
<br>

<h3><a name='check'>checkAction</a></h3>
<p><b>IAction</b>: By default this does nothing on an instransitive action. Game authors could override this if desired (e.g. to check for some condition and use reportFailure() plus exit to terminate the command).</p>
<p><b>TAction</b>: This tries the catch-all properties (checkDobjAll and checkDobjDefault) on the direct object. If a dobjFor(All) is found, this takes precedence. If a dobjFor(Default) is found, this will be used only if there's no applicable checkDobjForXXX (e.g. checkDobjForTake, in the case of a TakeAction) defined on or inherited by the direct object. If no catch-all property is applicable, run the appropriate check method  (e.g. checkDobjForTake, in the case of a TakeAction) on the direct object.</p>
<p><b>TIAction</b>: This is similar to the TAction processing, except that we (1) check for catch-all check handling on the indirect object; (2) check for catch-all handling on the direct object; (3) if no catch-all handling was applicable to the direct object, execute the appropriate check() method on the direct object (e.g. checkDobjPutIn for a PutInAction); (4) if no catch-all handling was applicable to the indirect object, execute the appropriate check() method on the indirect object (e.g. checkIobjPutIn for a PutInAction).</p>
<br>

<h3><a name='exec'>execAction</a></h3>
<p><b>IAction</b>: The execAction() method defined on the IAction class does nothing (except display a message saying "You can't do that"); specific IAction classes have to override this method to carry out the action.</p>

<p><b>SystemAction</b>: This is a special case of IAction. The specific action processing for a SystemAction is carried out by its execSystemAction method. SystemAction.execAction first checks that the command to carry out a SystemAction isn't being directed to an NPC (which would be nonsensical). The transcript is then flushed and disabled to allow the SystemAction to prompt for interactive responses. Then execSystemAction() is executed, and finally the transcript is activated again.</p>

<p><b>TAction</b>: First check whether the catch-all properties (actionDobjAll or actionDobjDefault) should be executed on the direct object; if actionDobjAll is defined it takes precedence over the specific action handling; only if there is no specific action handling for this action on the direct object with the default handling be used. If no catch-all action method is used, execute the action-specific action method on the direct action (e.g. actionDobjTake for a TakeAction).</p>

<p><b>TIAction</b>: First check the catch-all properties (actionIobjAll and actionIobjDefault) on the indirect object to see if either of them should execute (according to the normal rules, for which see the execAction handling on TAction). Then do the same for the catch-all action properties (actionDobjAll and actionDobjDefault) on the direct object. What happens next depends on the value of the actions execFirst property. If this is DirectObject then we execute the appropriate action() method (e.g. actionDobjPutIn) on the direct object first, if the direct object's catch-all handling hasn't been used, and then the appropriate action method (e.g. actionIobjPutIn) on the indirect object, if the indirect object's catch-all action handling hasn't been used. If execFirst is IndirectObject we execute the indirect object's action method before the direct object's. By default execFirst is set to the value of the resolveFirst property on the action, but it can be overridden separately.</p>
<hr>
<h2><a name='topic'>A Note on ResolvedTopics</a></h2>
<p>The discussion on <a href='#execCmd'>noun resolution</a> above mainly concentrated on actions that resolve to one or two simulation objects (TActions and TIActions). We should give a brief explanation of what happens with the resolution of a topic in a TopicAction or TopicTAction.</p>
<p>The topic part of such an action, (generally) represented by gTopic in the appropriate VerbRule, resolves to a single <a href='../libref/object/ResolvedTopic.html'>ResolvedTopic</a> object. Such ResolveTopic objects maintain three lists of in-game objects (Topics or Things) that they potentially match:</p>
<ol>
<li>inScopeList</li>
<li>likelyList</li>
<li>otherList</li>
</ol>
<p>During resolution of a <i>topic</i> these lists are filled with lists of objects (Things or Topics already defined in the game) that the vocabularly entered by the player could match. For example, if the player typed ASK BOB ABOUT BALL, every Thing and Topic with 'ball' in its vocabWords would be placed in one of these three lists. If what the player typed matches nothing in the game (e.g. ASK BOB ABOUT FLOBDAVERYGUTS), a ResolvedTopic object is created with all three lists empty.</p>
<p>The default <a href='../libref/object/TopicResolver.html'>TopicResolver</a> puts its entire list of matched objects (Things and Topics) into the first of these lists. This is the strategy used by ConsultAction; if the player types LOOK UP BALL IN BOOK, there's no reason to prefer any one meaning of BALL to another (should BALL match a number of Things and Topics in the game).</p>
<p>For a conversational command (like ASK BOB ABOUT BALL or TELL JANE ABOUT BALL), the lists are separated out:</p>
<ol>
<li>inScopeList &mdash; contains all matched objects that are in conversation scope for the actor doing the talking, where the default definition of conversation scope is physical scope plus all the other objects and topics the actor knows about.</li>
<li>likelyList &mdash; contains all other matched objects for which actor.isLikelyTopic(obj) returns true; by default this is defined to be objects the actor knows about, but this could be overridden by game authors if desired. The default definition would seem always to leave this list empty, since objects or topics the actor knows about are included in the inScopeList.</li>
<li>otherList &mdash; contains a list of any other matched objects not included in the first two lists.</li>
</ol>

<p>The matchTopic() method of a TopicMatchTopic (e.g. AskTopic or TellTopic) checks first the inScopeList and then the likelyList of the ResolvedTopic from the current conversational command in order to find a match (so something the player character doesn't know about yet can't be matched). ResolvedTopic.getBestMatch() returns the first item from the inScopeList (if the inScopeList is not empty), or failing that, the first item from the likelyList (if the likelyList is not empty), or failing that, the first item from the otherList (if the otherList is not empty) or, failing that, nil,</p>
<p>Whether or not a ResolvedTopic matches any Topics or Things in its three lists of matched objects, we can retrieve information about what text the ResolvedTopic was matching (i.e. what the player typed) using the following methods:</p>
<ul>
<li>getTopicText() &mdash; returns a string containing what the player typed to match this topic. The macro gTopicText returns gTopic.getTopicText.toLower(), which could be used to test the player's input, for example.</li>
<li>getTopicTokens() &mdash; returns the original tokens of the topic phrase, in canonical
     tokenizer format.</li>
<li>getTopicWords() &mdash; returns just the original text strings from the token list</li>     
</ul>

<p>It may occasionally be useful to define an action to use a ResolvedTopic where it might have seemed more natural to use a Thing. For example, suppose you wanted to implement a Find command which allows players to type commands like FIND THE MAGIC TREASURE. This might be better implemented as a TopicAction than a TAction:</p>
<p><pre>
DefineTopicAction(Find)
   execAction()
   {
	   /*  detailed handling here */
   }
;

VerbRule(Find)
  (('find') | ('look' | 'search' | 'hunt') 'for') singleTopic
  : FindAction
  verbPhrase = 'find/finding (what)'
  ;
</pre></p>
<p>The reasons for doing it this way are (a) you don't have to worry about scope (and generally the player will be trying to find objects that aren't in scope) and more importantly, (b) the parser won't give any spoilery error messages like "The word 'treasure' is not necessary in this game. " On the other hand it's then up to you to look at the inScopeList of the ResolvedTopic object the parser creates and decide how you want to prioritize it.</p>

</div>
<hr class="navb"><div class="navb">
<i>TADS 3 Technical Manual</i><br>
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="advtop.htm">Advanced Topics</a> &gt; 
The Command Execution Cycle
<br><span class="navnp"><a class="nav" href="t3banish.htm"><i>Prev:</i> Banishing (and Changing) Awkward Messages</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="t3transcript.htm"><i>Next:</i> Manipulating the Transcript</a> &nbsp;&nbsp;&nbsp; </span>

</div>
</body>
</html>


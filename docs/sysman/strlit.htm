<html>
<!-- DERIVED FILE - DO NOT EDIT -->

<head>
<title>String Literals</title>

<link rel="stylesheet" href="sysman.css" type="text/css">
</head>
<body>
<div class="topbar"><img src="topbar.jpg" border=0></div>
<div class="nav">
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="langsec.htm">The Language</a> &gt; 
String Literals
<br><span class="navnp"><a class="nav" href="types.htm"><i>Prev:</i> Fundamental Datatypes</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="enum.htm"><i>Next:</i> Enumerators</a> &nbsp;&nbsp;&nbsp; </span>

</div>
<div class="main">
<h1>String Literals</h1>

<p>TADS is a language for Interactive Fiction, and IF is made mostly
of text.  Naturally, text is a big area of specialization for TADS,
where the language breaks from its C and Java roots.  This chapter
describes the special string literal features in TADS.


<h2>The basics</h2>

<p>A string literal is a block of text enclosed in quote marks -
either single quotes or double quotes, depending on the kind of
string, which we'll come to shortly.

<p>Within the quotes, you can write <i>almost</i> any text.  There are
a few <a href="#specials">special codes</a> that TADS interprets
specially, which we'll discuss later; but apart from those, text
within a string is just literal text for TADS to store and/or display.

<p><div class="code"><pre>
"This is a string in double quotes."
'This is a string in single quotes.'
</pre></div>

<p>Unlike most other C-like languages, TADS allows a string to continue
across multiple lines without any special syntax.  A TADS string
starts with a quote mark and keeps going until the next instance of
the same kind of quote mark.

<p><div class="code"><pre>
"This is a string.  A string can go on for
any number of lines... it keeps going until
we come to another copy of the same quote
mark that started the string, which we're
finally coming to... now!"
</pre></div>

<p>When a string is broken across lines, TADS treats it as though it
were written on one line, with a space character in place of each line
break. 

<p>Note in the example above that we're free to use the <i>other</i>
kind of quote within a string.  If a string starts with a double
quote mark, we can freely use single quotes within the string - they
just count as ordinary text, because the string goes on until we
come to another copy of the same mark that started the string.

<p>But what if you want to use a double quote mark within a
double-quoted string, or single within single?  You do this by
"escaping" the quote mark, which you do by putting a backslash
character in front of it.  (The backslash is this one: "\".  It looks
like a plank that's leaning to the left, and left equals backwards if
you think about it in terms of left-to-right reading order.  Backwards
slash &rarr; backslash.  "Escaping," by the way, means that you're
removing the special meaning of the quote mark as the end-of-string
marker, and turning it into an ordinary literal character within the
string.)

<p><div class="code"><pre>
"Bob said, \"Well, this looks like a quote
within a quote!\""

'It\'s less obvious that you need the escapes
here, isn\'t it?'
</pre></div>

<p>Note in the latter example how you need to escape apostrophes
within single-quoted strings.  TADS would otherwise think
an apostrophe is the matching single quote that ends the string.


<h2>Two kinds of string literal</h2>

<p>

<p>TADS has two different types of string literal, which are
named according to the kind of quote mark that encloses them in the program
source code: <i>single-quoted strings</i> and <i>double-quoted
strings</i>.  The names might be a bit awkward, but they make
up for it by being obvious, in that you can tell the type of
a string just by looking at its surrounding quote marks.

<p>The functional difference isn't at all obvious, though.  It's
certainly not something you could guess looking at the syntax.  It's
not even something you'd guess from other programming languages.  So
it's something we need to explain.

<p>Here's the difference:

<p>A string in <i>single quotes</i> is a string "value": a piece of
data that you can assign to a variable, pass as a function argument,
chop up with substring operators, combine with concatenation
operators, and do all the other things that you can do with
strings in other programming languages.

<p><div class="code"><pre>
// assign a string value to the variable 'str'
local str = 'This is a string value, because it\'s in single quotes.';

// now we can manipulate this string value with method calls, etc
str = str.substr(5);
</pre></div>

<p>A string in <i>double quotes</i> is a concise way of
saying "Print this now!"  A double-quoted string <i>isn't</i> a
value.  You can't assign it to a variable or otherwise manipulate
it.  Whenever the current execution point reaches a double-quoted
string, TADS simply prints out the string, and moves on to the next
line of code.

<p><div class="code"><pre>
"This string prints itself out as soon as it's executed. You can't
assign it to a variable - it has no value to manipulate.";
</pre></div>

<h2><a name="tripleQuotes">Triple quotes</a></h2>

<p>Single quotes, double quotes... and now triple quotes?

<p>Don't worry: this isn't a third type of string.  It's just another
way of writing the first two kinds.

<p>A triple-quoted string is a string surrounded by <i>three
copies</i> of its quote mark on each side - three quote marks at the
beginning, and three more at the end.  You might wonder why you'd want
to use three quotes when one would do.  What you gain is the ability
to use the quote mark character freely as literal text within the
string, without worrying about "escaping" it with a backslash.  The
compiler knows that the string doesn't end until it sees the closing
triplet, so you can safely use the quote mark individually (or even in
pairs) within the string without creating any confusion.

<p>A few other C-like languages have adopted similar triple-quote
schemes, since it's more convenient and nicer looking for strings that
contain quote marks as part of their literal text.  This is a
particularly common occurrence in an interactive fiction language like
TADS, where many strings contain passages of story text.

<p>Here's a simple example:

<p><div class="code"><pre>
desc = """The sign reads "Beware of Backslash!""""
</pre></div>

<p>This example is actually a little less simple than it looks.  It
happens to illustrates a subtle (and nice) feature of triple quotes.
Note how the string ends with <i>four</i> quote marks.  Triple-quoted
strings that end with <i>N</i>&gt;3 consecutive quote marks treat the
first <i>N</i>-3 quotes as part of the string, and the last three as
the delimiter.  So when printed, this message looks just as you'd
want it to:

<p><div class="code"><pre>
The sign reads "Beware of Backslash!"
</pre></div>

<p>Here's how you write a string that displays 10 quote marks in a row:

<p><div class="code"><pre>
"""""""""""""""";
</pre></div>

<p>That's three for the opening delimiter, three for the ending delimiter,
and ten quotes for display.  It's a little strange looking, but it's a heck of
a lot better than <tt>"\"\"\"\"\"\"\"\"\"\""</tt>, which looks more like an
attempt at an ASCII graphic.

<p>You can use triple-quoting with single- and double-quoted strings,
and in both cases the type of quote character determines the type
of string it is, just as with ordinary once-quoted strings:

<p>
<pre>
   local s = '''This is a 'string value', since it's in single quotes.''';
   """This string is printed out "immediately", since it's in double quotes.""";
</pre>

<p>There's one other special feature to be aware of.  Most people will
probably never encounter this, because it gets into something that
doesn't tend to come up naturally in story text.  But this is a
programming language, after all, so we have to consider the weird
cases, too.  The question is what happens if you want to write, say,
five quotes in a row as literal text within a triple-quoted string?
We've already seen how to write a bunch of quotes at the <i>end</i> of
the string: write the quotes and then just add three more as the
ending delimiter.  But what about in the middle of the string?

<p>In this situation we reluctantly have to fall back on the
backslash, since there's just no other way that the compiler could
know that you intend for the string to continue after the glob of
quotes.  But here's where the special feature comes in: you only have
to use one backslash for a whole row of quotes.  When the compiler
encounters a backslash followed by a quote within a triple-quoted
string, it applies the backslash to the entire run of consecutive
quotes that follow the backslash.

<p><div class="code"><pre>
"""For whatever reason, I want to write a \"""""quintuple quoted\"""""
string within this \"""triple quoted\""" string!""";
</pre></div>

<p>Other than the tripled delimiters and the treatment of escaped
quote runs, triple-quoted strings work exactly like their ordinary
counterparts.  In particular, there's no difference in how they
behave at run-time, and no difference in how embedded &lt;&lt; &gt;&gt;
expressions are handled.



<h2>Line breaks</h2>

<p>We mentioned earlier that the compiler treats line breaks in
strings as though they were spaces.  Let's look at that in more
detail.

<p>By default - and we'll see in a moment that there are some
other options apart from the default - when the compiler encounters
a line break within a string, it does two things:

<ul class=doublespace>
   <li>It removes the line break and replaces it with a space
   character, making it seem as though you had
   written the whole string on one line.

   <li>It deletes all of the spaces at the beginning of the next line.
</ul>

<p>The reason for deleting the spaces at the start of the next line
after a line break is that most people like to indent their code
to make it more readable.  The compiler assumes that all of the
spaces at the start of a line are for indentation, purely for
code readability, and aren't really part of the string.

<p>In some cases, you might want a line break and the subsequent
indentation to be part of the string.  For example, if you're writing
preformatted display code for an HTML <span class="code">&lt;PRE&gt;</span> section, you might
want to use spacing at the start of a line for indentation in the
displayed text.  You can do this by writing an explicit <span class="code">\n</span> (newline)
sequence at the end of each line, just before the line break.  When
the compiler sees a line ending in <span class="code">\n</span>, it keeps all of the
spacing at the start of the next line.

<p><div class="code"><pre>
f()
{
    local a = 'test\n
     string';
}
</pre></div>

<p>Because the first line of the string ends in an explicit <span class="code">\n</span>,
the compiler preserves the spaces at the start of the second line,
so the string is stored as though you had written
<span class="code">local a = 'test\n</span><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><span class="code">string';</span>.

<p>What we've seen so far is the compiler's default handling.  In
addition to this default behavior, there are two other "modes"
that do slightly different things with line breaks.

<p>The default mode that we've been talking about so far is called
"collapse" mode, because the compiler collapses all of the spacing at
each line break into a single space character.  You don't have to do
anything special to select this mode, since it's the default, but 
you can also turn it on explicitly by adding this to your
source file, on a line by itself:

<p><div class="code"><pre>
#pragma newline_spacing(collapse)
</pre></div>

<p>Once you set a newline spacing mode, it sticks until the end of the
source file, or until you change it with another #pragma.  If you set
the mode in an included file, it automatically returns to the
enclosing file's mode at the end of the included file, so you don't
have to worry when using #include that the file will change the mode
on you.

<p>The second newline spacing option is "delete" mode:

<p><div class="code"><pre>
#pragma newline_spacing(delete)
</pre></div>

<p>In delete mode, the compiler entirely deletes each line break, and
all of the indentation on the next line.  The result is that the two
lines surrounding a line break are mashed together with no spacing at
all between them.  Why would you want this?  In some languages,
especially ideographic languages such as Chinese, it's standard to
write text with no spacing between words.  The "collapse" mode is
inconvenient for writing long strings in this kind of language because
it introduces unwanted spacing between characters wherever you happen
to insert a line break in the source code just to keep line lengths
within the page boundaries.  "Delete" mode is good for this type of
language because it lets you break up long lines as needed, but joins
everything together without any unwanted extra spaces when the text is
actually displayed at run-time.

<p>Remember the trick we saw earlier with writing <span class="code">\n</span> at the end of
a line to preserve exact spacing?  That works the same way in delete
mode.

<p>The final mode is called "preserve" mode:

<p><div class="code"><pre>
#pragma newline_spacing(preserve)
</pre></div>

<p>In preserve mode, the compiler keeps line breaks and whitespace
intact, exactly as written in the source code.  Each line break is
replaced by a <span class="code">\n</span> (newline) character, and any indentation
at the start of the next line is preserved exactly as written.
Preserve mode is useful when you want precise control over the
character-by-character contents of a string, such as when you're
writing text to a file, or when you're writing an HTML
<span class="code">&lt;PRE&gt;</span> section.



<h2>Regular expression literals</h2>

<p>There's another bit of syntax that looks very similar to the string
literal syntax, but doesn't define an ordinary string.  You can define a
static <a href="rexpat.htm">RexPattern</a> object, which represents
a <a href="regex.htm">regular expression</a>, using the "R" string
syntax:

<p><div class="code"><pre>
local r = R'%w+';
</pre></div>

<p>The regular expression literal syntax consists of a capital "R"
followed immediately (with no intervening spaces) by an open quote.
Single and double quotes are interchangeable for regular expression
literals.

<p>For more details, see <a href="rexpat.htm#rexlit">regular
expression literals</a> in the RexPattern section.



<h2>Plain vs. typographical quotes</h2>

<p>Before we go on, there's a common point of confusion that we should
address.  Most computer fonts include a whole raft of different
quote marks, but when you're writing TADS source code, it's important
that you only use plain, "straight" quotes to mark string literals.

<p>The "straight quotes" are so called because their appearance in
most fonts is straight up and down, without any tilt to the left or
right.  They're <i>usually</i> the quotes you get when you press this
key (on a standard US QWERTY keyboard, at least):

<p>
   <img src="quotekey.jpg" style="margin-left:3em;">

<p>The thing that's confusing is that most computer fonts include
an additional set of quotes known as "curly" or "typographical"
quotes.  These are split into left and right versions, which curl
or tilt in opposite directions.  The visual difference is subtle,
but it helps to see the two kinds side by side:

<p>
   <img src="quotemarks.jpg" style="margin-left:3em;">

<p>Be sure that you always enclose strings in straight quotes.  As we
said earlier, that's <i>usually</i> the kind of quote that you get
when you press the plain-quote key.  However, many word processing
programs have a "smart quotes" mode that automatically substitutes
curly quotes when you press that key.  If you're using that kind of
program, you'll need to turn off the "smart quotes" mode while writing
TADS code.

<p>Not all fonts show plain quotes as <i>exactly</i> straight up and
down.  Some fonts show a slight tilt even for plain quotes, for
aesthetic value.  That's purely visual, of course, and it doesn't
matter to TADS since TADS doesn't know or care what font you're using
in your text editor.  If you can't tell for sure which quote is which,
one trick to try is to change your editor program's font to a monospaced,
"typewriter style" font such as Courier.  That should make
it easy to distinguish the different quote types visually.  Once you've
confirmed that you're using the correct quotes, you can switch back
to whatever font you prefer.

<p>Note that it's okay to use curly quotes <i>within</i> a string,
since any text is allowed there.  TADS is only picky about the quotes
that <i>surround</i> a string (or "delimit" it, in techno jargon).


<h2><a name="specials"></a>Special characters in strings</h2>

<p>Earlier, we mentioned that there are a few special codes that
TADS interprets within strings.  Let's look at the full list.

<p>The first is the quote marks themselves.  The quote mark that opens
a string is also the character that ends the string, so if you want to
use that quote mark within the string you need to "escape" it by
putting a backslash "\" in front of it.

<p><div class="code"><pre>
"Bob said, \"Remember those backslashes!\""
</pre></div>

<p>(Of course, no backslash is needed within <a
href="#tripleQuotes">triple-quoted</a> strings, unless you want to use
three or more of the quote marks in a row.)

<p>The second is the <a href="#embeddings">embedded expression</a> syntax.
This consists of two less-than signs "<span class="code">&lt;&lt;</span>", followed by an expression
to evaluate, followed by two greater-than signs "<span class="code">&gt;&gt;</span>".  TADS interprets
any <span class="code">&lt;&lt;</span> sequence in a string as the start of an embedding, so if you
actually want your string to literally include two less-than signs in a row,
you must escape one of them (either one will do).

<p><div class="code"><pre>
'The sign reads "\&lt;&lt;Danger!&gt;&gt;"'
</pre></div>

<p>The third is the backslash character itself.  Since it has this
special meaning of escaping other special characters, it is itself
a special character.  Naturally, then, if you want to use a backslash
literally in a string, you escape it by adding <i>another</i> backslash
in front of it.  In other words, you write two backslashes in a row
to indicate one literal backslash.

<p><div class="code"><pre>
"This is what a backslash looks like: \\."
</pre></div>

<p>In addition to escaping special characters, the backslash is also
used to generate additional special characters.  For example,
<span class="code">\n</span> represents a newline character.  A full list of these
special combinations is <a href="#backslash">below</a>.

<p>Those are all of the characters that affect how the <i>compiler</i>
reads your string contents: quotes, <span class="code">&lt;&lt;</span> sequences, and backslashes.
Everything else, the compiler reads literally, and stores in your
compiled program as you wrote it.

<p>Once your program is running, though, there's another layer of
string interpretation that you need to be aware of.  Whenever you
<i>display</i> a string, by printing it to the console for the user to
see, the TADS <i>interpreter</i> processes any HTML markups in the
printed text.  The compiler simply ignores HTML codes, leaving it to
the interpreter to process them.

<p>There are two kinds of HTML markups: tags and entities.

<p>An HTML tag is a sequence enclosed in <span class="code">&lt;angle brackets&gt;</span>, such as
<span class="code">&lt;B&gt;</span> or <span class="code">&lt;A HREF="link"&gt;</span>.  (Note that "angle brackets" is just
another term for less-than and greater-than signs.  They're exactly
the same characters, <i>not</i> a new kind of quote mark.) In TADS,
HTML tags are mostly used to control text formatting.  TADS uses most
of the standard HTML 3.2 tags, which you can find more about in any HTML
reference.  Some common tags that TADS recognizes:

<ul>
   <li><span class="code">&lt;b&gt;text&lt;/b&gt;</span> - show <i>text</i> in boldface
   <li><span class="code">&lt;i&gt;text&lt;/i&gt;</span> - show <i>text</i> in italics
   <li><span class="code">&lt;u&gt;text&lt;/u&gt;</span> - show <i>text</i> underlined
   <li><span class="code">&lt;a href="URL"&gt;text&lt;/a&gt;</span> - show <i>text</i> hyperlinked to <i>URL</i>
   <li><span class="code">&lt;font name="Arial"&gt;text&lt;/font&gt;</span> - show <i>text</i>
        in the typeface Arial
   <li><span class="code">&lt;font color="red"&gt;text&lt;/font&gt;</span> - show <i>text</i> in red
   <li><span class="code">&lt;font size=4&gt;text&lt;/font&gt;</span> - show <i>text</i> a little larger than normal
   <li><span class="code">&lt;font size=7&gt;text&lt;/font&gt;</span> - show <i>text</i> in very large type
   <li><span class="code">&lt;body bgcolor="gray"&gt;</span> - change the window background color to gray
   <li><span class="code">&lt;h1&gt;heading&lt;/h1&gt;</span> - display <i>heading</i> as a large section heading
   <li><span class="code">&lt;h2&gt;heading&lt;/h2&gt;</span> - display <i>heading</i> as a sub-heading
   <li><span class="code">&lt;h3&gt;heading&lt;/h3&gt;</span> - display <i>heading</i> as a sub-sub-heading
   <li><span class="code">&lt;font bgcolor="blue"&gt;text&lt;/font&gt;</span> - show <i>text</i> with a blue
        background
   <li><span class="code">&lt;center&gt;text&lt;/center&gt;</span> - show <i>text</i> centered in the window
   <li><span class="code">&lt;img src="picture.jpg"&gt;</span> - display an image
   <li><span class="code">&lt;sound src="music.mp3"&gt;</span> - start playing back an audio file
   <li><span class="code">&lt;p&gt;</span> - start a new paragraph
   <li><span class="code">&lt;br&gt;</span> - show a line break
   <li><span class="code">&lt;ul&gt; &lt;li&gt;list item &lt;li&gt;list item &lt;/ul&gt;</span> - show a bullet list
   <li><span class="code">&lt;table&gt;...&lt;/table&gt;</span> - format a table
</ul>

<p>An HTML entity is spelled-out version of a single character.
Entities are written as <span class="code">&amp;name;</span> - ampersand, name, semicolon.  For
example, <span class="code">&amp;lt;</span> is the entity markup for a less-than sign, <span class="code">&amp;gt;</span>
is a greater-than sign, and <span class="code">&amp;amp;</span> is an ampersand.  (You can check
any HTML reference for a full list.)

<p>The <span class="code">&amp;</span> is what triggers an entity interpretation, so if you want
to use an <span class="code">&amp;</span> literally in displayed text, you need to spell it out
as <span class="code">&amp;amp;</span>.  (Were you thinking of using a backslash?  Remember, the
backslash only escapes characters at the compiler level.  An <span class="code">&amp;</span> in
a string isn't special to the compiler - it's only special to the HTML
display engine.  To sneak special characters past the HTML display
system, you have to use HTML entities, not backslashes.)

<h3>Compiler vs. HTML interpretation</h3>

<p>As we've just seen, there are two quite separate stages where TADS
interprets the contents of your strings.  For the most part you won't
find yourself worrying about the details.  On occasion, though, it can
save you a ton of hair-pulling if you have a good understanding of
what's really going on as a string makes its way from your source code
file, into the compiled program's memory at run-time, and finally
out to the display.

<p>There are two key things to know.  The first one is how a given
string is actually <b>stored</b> in memory.  The second is how a
given stored string is <b>displayed</b> when printed.

<p>The <i>compiler</i> special characters - quotes, backslashes, and
<span class="code">&lt;&lt;</span> sequences - affect what's <i>stored</i> in your compiled
program.  The <i>HTML</i> sequences only affect what's
<i>displayed</i> on the user's screen at run-time.  The compiler
doesn't do anything to interpret HTML; it simply copies HTML markups
character-for-character into the compiled program, where they're
stored as part of the text in a string.  There, the power of the
HTML lies dormant, until the string is printed to the screen.

<p>Here's an example showing the three stages of a string's lifecycle:
the way it appears in the original source code; the way it's stored
in the compiled ".t3" file (which is the same way it's loaded into
memory when the program runs); and the way it looks when the user sees
it on the display.  (Note that this is just a program fragment -
it's not a complete working program.)

<p>
   <img src="stringexample1.jpg" style="margin-left:3em;">

<p>It's worth taking a few minutes to make sure you understand the
various pieces of the picture.

<p>First, note how the backslashes in
the source code disappear in the compiled version.  This is because
the compiled version stores strings as objects; they no longer need
quotes to mark where they start and stop, so the embedded quotes can
be stored directly, without escapes.  The same applies to the <span class="code">&lt;&lt;</span>
sequence in the "<span class="code">&lt;\&lt;Danger&gt;&gt;</span> string: the backslash disappears from
the stored copy because the compiler has finished interpreting it,
making it unnecessary to escape the compiler-only <span class="code">&lt;&lt;</span> sequence.

<p>The removal of the backslashes is important when you manipulate
a string in the program.  <span class="code">x.substr(2, 1)</span> extracts the second
character of the string.  Since the backslash is no longer there,
the second character is now the second <span class="code">&lt;</span> character.

<p>Second, observe that the HTML sequences are <i>not</i> removed from the
strings or translated in any way.  They're just copied
character-for-character to the compiled version.  The <span class="code">&amp;lt;</span>
entities, for example, are actually stored as the chararacters <span class="code">&amp;</span>
<span class="code">l</span> <span class="code">t</span> <span class="code">;</span> - they're not converted to <span class="code">&lt;</span> characters.  Note
also that your program code can tell the difference: when you compare
a stored <span class="code">&lt;</span> character to the string <span class="code">'&lt;'</span>, you get a match.  When
you compare it to the string <span class="code">'&amp;lt;'</span>, it <i>doesn't</i> match,
because the latter is actually stored as <span class="code">&amp;</span> <span class="code">l</span> <span class="code">t</span> <span class="code">;</span> and
thus doesn't match a string stored as <span class="code">&lt;</span>.

<p>Third, you can see that when the running program writes out any of
these strings to the display, the HTML is
finally interpreted.  The <span class="code">&amp;lt;</span> sequences finally turn into <span class="code">&lt;</span>
characters, and the tags such as <span class="code">&lt;B&gt;</span> serve their control function
rather than appearing as literal text.

<p>Displaying a string doesn't change the stored copy of
the string, of course.  The display process is strictly one-way, from the
program memory to the display window.  A string stored in memory still
has its original HTML markups after it's displayed.  That way if you
print the string again, you get the same display result.


<h2><a name="embeddings"></a>Embedded expressions</h2>

<p>The "interactive" part of interactive fiction usually means that
conditions in the game world change as the player progresses through
the game.  That game world is presented through the text the program
displays, so as the world evolves, so must the text.  This makes it
especially important to have a convenient way to write text that
varies according to the world model.

<p>In most programming languages, the standard approach to write
varying text is to build it up by combining some static fragments with
others that change depending on the current state of the game.  To
take a simple example, suppose we want to describe a door that can be
opened and closed.  Most of the description never changes, but the
part that mentions the current state of the door does.  So our first
attempt at a description procedure might look like this:

<p><div class="code"><pre>
"It's a sturdy-looking oak door, ten feet high. A weathered
wrought iron knocker is centered just above your eye level.
The door ";
if (door.isOpen)
  "stands open.";
else
  "is firmly shut.";
</pre></div>

<p>That works fine, but it takes a fair amount of typing.  And if you
consider the number of messages in a typical game that might need the
same treatment, it can add up to <i>a lot</i> of typing.  It's also
a bit hard to read, since the string elements are so disjoint, broken
up as they into several statements.  And if you're writing
this as an object property value, it adds even more to the required
syntax, since you have to go from a plain property definition like this:

<p><div class="code"><pre>
desc = "It's a sturdy-looking oak door, ten feet high."
</pre></div>

<p>...to a method-style definition, like this:

<p><div class="code"><pre>
desc { "It's a sturdy-looking oak door, ten feet high."; }
</pre></div>

<p>It's not a lot of extra syntax, but again, in a typical game you'll
be writing these sorts of snippets many times, so they add up.

<p>What's more, some descriptions can get quite a lot more complex
than our door example.  Room descriptions in particular tend to have
lots of moving parts.  Think about how complex this approach would
get if you had five or six varying passages interposed.

<p>This is where embedded expressions come in.  Expression embedding
(some programming languages call it "interpolation") is a special
syntax that lets you insert variables, expressions,
and even control flow code, right into a string.  This
can be much more succinct than writing it out as a series of separate
statements, as we did above.

<p>The embedding syntax is simple.  Anywhere in a string, you can
write <span class="code">&lt;&lt;</span> - two less-than signs - to drop into "expression mode."
At that point you can write any expression.  An expression can be the
name of a local variable, a constant value such as a string or number,
a call to a function or method, a sum with "+", or just about
anything else you could write in an ordinary expression outside
of the string.  At the end of the expression, write <span class="code">&gt;&gt;</span> - two
greater-than signs, the mirror image of the <span class="code">&lt;&lt;</span> that started the
embedding.  That returns you to string mode, so you're back to writing
static literal text in the string.

<p>When a double-quoted string is displayed, TADS first displays the
part of the string up to the first <span class="code">&lt;&lt;</span>, then it evaluates the
expression inside that first <span class="code">&lt;&lt; &gt;&gt;</span> section.  This expression could
be another double-quoted string, or a call to a method that prints
something out.  Or, it could be a call to a function that returns a
string value, or a number, or some other value.  If the expression
returns a value, TADS prints out this value, assuming it has a
printable form.  Strings and numbers are printed in the obvious way.
Most other objects don't have any kind of automatic printed form,
though; embeddings should only use values that are printable.  Next,
TADS prints the next part of the string - the part up to the
<i>next</i> <span class="code">&lt;&lt;</span> embedding, or to the end of the string if
this was the last one.  This process repeats until the whole string
and all of its embeddings have been printed.

<p><div class="code"><pre>
local i = 3, j = 'boo';
"The value of i is &lt;&lt;i&gt;&gt;, and j is &lt;&lt;j&gt;&gt;!&lt;br&gt;";
   // prints out: The value of i is 3, and j is boo!
</pre></div>

<p>Going back to our door example, we can use an embedding to rewrite it
like this:

<p><div class="code"><pre>
"It's a sturdy-looking oak door, ten feet high. A weathered
wrought iron knocker is centered just above your eye level.
The door &lt;&lt;door.isOpen ? "stands open" : "is firmly shut"&gt;&gt;.";
</pre></div>

<p>Rather than ending the string at the point where we need the
varying message about the door's status, we use <span class="code">&lt;&lt; &gt;&gt;</span> to embed an
expression that prints the variable part.  The expression uses the
<span class="code">? :</span> conditional operator to test the current status, displaying
one string if the door is open and another if it's closed.  At the
end of the expression we go back into the string text, where we add
the closing period and end the message.

<p>This is obviously a lot less typing than the original way we wrote
it, and it's a bit easier to read, too.  It also lets you use the
simpler property-value syntax if the string is used as an object
property:

<p><div class="code"><pre>
desc = "It's a sturdy-looking oak door, ten feet high. A weathered
       wrought iron knocker is centered just above your eye level.
       The door &lt;&lt;isOpen ? "stands open" : "is firmly shut"&gt;&gt;.";
</pre></div>

<h3>Nested embeddings</h3>

<p>Starting in version 3.1.3, it's legal to put one embedding inside
another.  For example:

<p><div class="code"><pre>
"The refrigerator door is &lt;&lt;
  isOpen ? "open&lt;&lt;isLit ? " and the light inside is on" : ""&gt;&gt; : "closed"&gt;&gt;. ";
</pre></div>

<p>The most common situation where nesting comes in handy is with
conditional expressions, such as in our example above.  Note
that you can often accomplish the same thing with more readable
code using the <span class="code">&lt;&lt;if&gt;&gt;</span> notation, described later in this chapter.
For our example above, we could instead write this:

<p><div class="code"><pre>
"The refrigerator door is &lt;&lt;if isOpen&gt;&gt;open&lt;&lt;if isLit&gt;&gt; and the
light inside is on&lt;&lt;end&gt;&gt;&lt;&lt;else&gt;&gt;closed&lt;&lt;end&gt;&gt;. ";
</pre></div>

<p>There's a limit on the nesting depth (currently 10 levels).  The
compiler will display an error if you exceed the maximum depth.



<h3><a name="embedSgl"></a>Embeddings in single-quoted strings</h3>

<p>Starting in TADS 3.1, single-quoted strings can also contain
embeddings.  The syntax is exactly the same as for double-quoted
strings: an embedding starts with <span class="code">&lt;&lt;</span> and ends with <span class="code">&gt;&gt;</span>,
and between the two brackets you write an ordinary expression.

<p>When a single-quoted string is evaluated, the process is almost the
same as for double-quoted strings.  Rather than printing anything,
though, TADS concatenates the pieces together to create a string
result value.  The new string starts with the part of the source
string up to the first <span class="code">&lt;&lt;</span>.  Then TADS evaluates the first <span class="code">&lt;&lt; &gt;&gt;</span>
expression, and concatenates the value to the result string.
TADS then concatenates the next source string segment to the result.
This process repeats as before.  At the end of it we have a string
value that combines all of the static bits with all of the embedded
expression values, in the order in which they appear in the source
code.

<p><div class="code"><pre>
local i = 3, j = 'boo';
local s = 'The value of i is &lt;&lt;i&gt;&gt;, and j is &lt;&lt;j&gt;&gt;!';
   // s now contains 'The value of i is 3, and j is boo!'
</pre></div>

<p>A single-quoted string is assembled into a final value <i>at the
moment of evaluation</i>.  It won't change to reflect changes in
the underlying variables.  Let's continue our example:

<p><div class="code"><pre>
"s is: &lt;&lt;s&gt;&gt;\n";
i = 7;
j = 'boo hoo';
"s is now: &lt;&lt;s&gt;&gt;\n";
</pre></div>

<p>This prints out:

<p><div class="code"><pre>
s is: The value of i is 3, and j is boo!
s is now: The value of i is 3, and j is boo!
</pre></div>

<p>Even though we changed <span class="code">i</span> and <span class="code">j</span> after setting <span class="code">s</span>, <span class="code">s</span>
doesn't change - it just stores the character string assembled in
the original assignment.  Usually, this is just what you want.  But
if for some reason you want a "live" string that automatically
updates every time you use it, you can use an anonymous function:

<p><div class="code"><pre>
local i = 3, j = 'boo';
local s = {: 'The value of i is &lt;&lt;i&gt;&gt;, and j is &lt;&lt;j&gt;&gt;!'};
"s is: &lt;&lt;s()&gt;&gt;\n";

i = 7;
j = 'boo hoo';
"s is now: &lt;&lt;s()&gt;&gt;\n";
</pre></div>

<p>This prints:

<p><div class="code"><pre>
s is: The value of i is 3, and j is boo!
s is now: The value of i is 7, and j is boo hoo!
</pre></div>

<p>Note that you'll usually want to avoid calling routines that print
out messages from within single-quoted string embeddings.  Messages
that are printed out aren't returned as values, so they won't be
concatenated into the string result - they'll just appear on the
screen <i>at the time the string is evaluated</i>, which will
probably be out of context.



<h3><a name="embed_sprintf">sprintf-style formatting</h3>

<p>Starting in 3.1.1, you can specify a
<a href="tadsgen.htm#sprintf">sprintf()</a> formatting code directly in
an embedded expression, to customize how the value is displayed.  To do
this, place the <span class="code">%</span> code immediately after the opening <span class="code">&lt;&lt;</span>,
without any intervening spaces.  For example:

<p><div class="code"><pre>
local x = 100;
"x in octal is &lt;&lt;%o x&gt;&gt;\n";
</pre></div>
   
<p>The compiler internally turns this into a call to sprintf() with
the given format code, as though you had written:

<p><div class="code"><pre>
"x in octal is &lt;&lt;sprintf('%o', x)&gt;&gt;\n";
</pre></div>

<p>Since it's really just a call to sprintf(), you can use any format
code that sprintf() accepts.


<h3><a name="strtpl">Custom embedding syntax with string templates</h3>

<p>The basic embedded expression syntax is powerful, since it lets you
write any TADS expression.  The drawback is that it makes a sort of
Frankenstein's monster out of a string, switching back and forth
between English text and programming code.  The code syntax tends to
interrupt the flow of the English text, making it harder to see how
the final output will look.

<p>The "string template" syntax can help with this.  A string template
is a custom phrase that you define for use in string embeddings.  The
compiler converts the phrase into a function call.  This lets you get
the effect of a function call without having to write the technical
looking function call syntax.

<p>For example, suppose we want to print out the current score,
but in words rather than as digits - "twenty points" rather
than "20 points".  The general-purpose way of doing this is
to make a call to a number-speller function:

<p><div class="code"><pre>
"Your current score is &lt;&lt;spellInt(score)&gt;&gt; points.";
</pre></div>

<p>To make this read a little better, we could define a template
for the spellInt() function.  Rather than explicitly calling the
function, we write an English-like phrase.  Here's how we define
the template:

<p><div class="code"><pre>
string template &lt;&lt;* in words&gt;&gt; spellInt;
</pre></div>

<p>The definition starts with the keywords <span class="code">string template</span>.
Next comes the list of keywords for the template, enclosed in
the same <span class="code">&lt;&lt; &gt;&gt;</span> brackets used for an embedding.  Finally,
you give the name of the function to call when the template is
invoked.

<p>The {*} in the template means "the expression part goes here".
This can come at the beginning (as in this example), at the end, or in
the middle of the phrase - whatever works best for the wording you're
using.  When the compiler matches the template in an embedding, it
takes the part that matched the <span class="code">*</span> and treats them as another
embedding:

<p><div class="code"><pre>
"Your current score is &lt;&lt;score in words&gt;&gt; points.";
</pre></div>

<p>The compiler matches this to our <span class="code">&lt;&lt;* in words&gt;&gt;</span> template.
The part that matches the <span class="code">*</span> is <span class="code">score</span>, so the compiler
turns this into a function call to <span class="code">spellInt(score)</span>.  You could
just as well write:

<p><div class="code"><pre>
"Doubling your score would give you &lt;&lt;score*2 in words&gt;&gt; points.";
</pre></div>

<p>This time the <span class="code">*</span> matches <span class="code">score*2</span>, so the compiler turns
this into a call to <span class="code">spellInt(score*2)</span>.

<p>The <span class="code">*</span> in a template is optional.  If you write a template
without a <span class="code">*</span>, it will only match an embedding that's exactly the
phrase given in the template (with no added words), and the compiler
calls its associated function with no arguments.  For example:

<p><div class="code"><pre>
string template &lt;&lt;player location&gt;&gt; playerLoc;
playerLoc() { return gPlayerChar.location.name; }
</pre></div>

<p>Now we can write

<p><div class="code"><pre>
"You are in &lt;&lt;player location&gt;&gt;."
</pre></div>

<p>It's possible to create ambiguous templates, where two or more
templates could match the same input.  If there's any ambiguity, the
compiler goes in the order of definition: the first template defined
wins.

<p>Template invocations can be nested.  After the compiler matches
one template, it goes back over the tokens that matched the <span class="code">*</span>
and checks them for another template match.  If it finds one, it
checks again for a third template match, and so on.  There's one
exception: if the entire template matched is <span class="code">&lt;&lt;*&gt;&gt;</span>, the
compiler doesn't check for another template, since this would
just keep matching that same <span class="code">&lt;&lt;*&gt;&gt;</span> template over and over.

<p>Here's an example of how we could use nested templates:

<p><div class="code"><pre>
string template &lt;&lt;* in words&gt;&gt; spellInt;
string template &lt;&lt;twice *&gt;&gt; times2;

"x doubled is &lt;&lt;twice x in words&gt;&gt;.";
</pre></div>

<p>The order of the templates in a situation like this is important.
Since <span class="code">&lt;&lt;* in words&gt;&gt;</span> is defined first, it matches first, so the
compiler turns this into a call to <span class="code">spellInt(twice x)</span>.  But
before doing that, the compiler checks what's left over - <span class="code">twice x</span> -
to see if it matches another template.  It does, so the compiler
turns that into <span class="code">times2(x)</span>.  The overall result is then
<span class="code">spellInt(times2(x))</span>.

<p>A <span class="code">string template</span> statement has to be at the "top level" of
your program, outside of any function or object definitions.  String
template definitions are <b>local to a single
source module</b>, so the best way to make them available throughout
your program is to put them all in a central ".h" header file
that you #include in each source file.



<h3><a name="embeddedIf">Embedded conditions with <span class="code">&lt;&lt;if&gt;&gt;</span></a></h3>

<p>We've seen how we can embed conditional tests in strings using the
<span class="code">?:</span> operator.  That's a very flexible approach, but the syntax can
be a little awkward.  Using it to place multiple strings in an
embedding makes for a lot of quote marks, and interrupts the
reading flow of the text.

<p>The embedded expression syntax has a special if-then-else
feature that can make code more readable.  Here's a another way to
write the open/closed door example we saw earlier:

<p><div class="code"><pre>
desc = "It's a sturdy-looking oak door, ten feet high. A weathered
       wrought iron knocker is centered just above your eye level.
       The door &lt;&lt;if isOpen&gt;&gt;stands open&lt;&lt;else&gt;&gt;is firmly shut&lt;&lt;end&gt;&gt;. ";
</pre></div>

<p><span class="code">&lt;&lt;if&gt;&gt;</span> evaluates the expression you give it as a condition.
If the condition is true, it continues on to the text immediately
following the <span class="code">&lt;&lt;if&gt;&gt;</span>.  If the condition is false, the <span class="code">&lt;&lt;if&gt;&gt;</span>
skips that text, and instead looks for a matching <span class="code">&lt;&lt;else&gt;&gt;</span>.  If
it finds one, it continues from there.  Otherwise it keeps going
until it finds the matching <span class="code">&lt;&lt;end&gt;&gt;</span> label, and proceeds from
there.

<p>You can leave out the <span class="code">&lt;&lt;else&gt;&gt;</span>, in which case the <span class="code">&lt;&lt;if&gt;&gt;</span>
simply skips ahead to the <span class="code">&lt;&lt;end&gt;&gt;</span> if the condition is false.  In
fact, you can even leave out the <span class="code">&lt;&lt;end&gt;&gt;</span>, in which case the
<span class="code">&lt;&lt;if&gt;&gt;</span> automatically ends at the end of the overall string.  This
lets you write nice concise code for simple cases like this:

<p><div class="code"><pre>
desc = "It's an old rag. &lt;&lt;if isDamp&gt;&gt;It seems a bit damp. "
</pre></div>

<p>You can write an <span class="code">&lt;&lt;if&gt;&gt;</span> with multiple branches, using
the sequence <span class="code">&lt;&lt;else if&gt;&gt;</span>:

<p><div class="code"><pre>
desc = "The ball is made of &lt;&lt;if color == 1&gt;&gt;bright red&lt;&lt;
       else if color == 2&gt;&gt;green&lt;&lt;else if color == 3&gt;&gt;navy blue&lt;&lt;end&gt;&gt;
       plastic. "
</pre></div>

<p>The entire series of
<span class="code">&lt;&lt;if&gt;&gt;</span>...<span class="code">&lt;&lt;else if&gt;&gt;</span>...<span class="code">&lt;&lt;else if&gt;&gt;</span>...<span class="code">&lt;&lt;else&gt;&gt;</span> branches
counts as a single "if", so only one <span class="code">&lt;&lt;end&gt;&gt;</span> is needed for
the whole thing.  By the same token, only one plain <span class="code">&lt;&lt;else&gt;&gt;</span>
is allowed for the whole sequence, and it must be the last branch.
At run time, exactly one of the branches will be taken, since
the branches are all mutually exclusive.

<p>You can also nest an <span class="code">&lt;&lt;if&gt;&gt;</span> within another <span class="code">&lt;&lt;if&gt;&gt;</span> for more
complex conditions:

<p><div class="code"><pre>
desc = "The refrigerator door is &lt;&lt;if isOpen&gt;&gt;open&lt;&lt;if isLit&gt;&gt; and the
       light inside is on&lt;&lt;end&gt;&gt;&lt;&lt;else&gt;&gt;closed&lt;&lt;end&gt;&gt;. "
</pre></div>

<p>Nesting works in the obvious way, with each <span class="code">&lt;&lt;end&gt;&gt;</span> and <span class="code">&lt;&lt;else&gt;&gt;</span>
pairing up with an <span class="code">&lt;&lt;if&gt;&gt;</span> from the "inside out" in the nesting
order.  So in the string above, the first <span class="code">&lt;&lt;end&gt;&gt;</span> pairs up with
<span class="code">&lt;&lt;if isLit&gt;&gt;</span> - which makes the <span class="code">&lt;&lt;else&gt;&gt;</span> go with <span class="code">&lt;&lt;if isOpen&gt;&gt;</span>,
since <span class="code">&lt;&lt;if isLit&gt;&gt;</span> is finished
at that point.  If we run the string with the different combinations
of <span class="code">isOpen</span> and <span class="code">isLit</span>, here's what we'll get:

<p><div class="code"><pre>
isOpen=nil, isLit=nil:   The refrigerator door is closed.
isOpen=nil, isLit=true:  The refrigerator door is closed.
isOpen=true, isLit=nil:  The refrigerator door is open.
isOpen=true, isLit=true: The refrigerator door is open and the light inside is on.
</pre></div>

<p>You can nest <span class="code">&lt;&lt;if&gt;&gt;</span>'s to any depth - you're not limited to
just putting one <span class="code">&lt;&lt;if&gt;&gt;</span> inside another.  Of course, whether the
result remains readable is another matter.

<p>Speaking of readability, there are two extra keywords you can
use with <span class="code">&lt;&lt;if&gt;&gt;</span> structures.  First, you can use <span class="code">&lt;&lt;unless&gt;&gt;</span>
in place of <span class="code">&lt;&lt;if&gt;&gt;</span> to test that a condition <i>isn't</i> true.
<span class="code">&lt;&lt;unless x&gt;&gt;</span> means exactly the same thing as <span class="code">&lt;&lt;if !x&gt;&gt;</span>, but
most people find it a little less taxing on the brain to rephrase
a negative like this, and in any case it cuts down on punctuation.

<p><div class="code"><pre>
desc = "An old sepia photo of a group of dour, serious men in suits.
        &lt;&lt;unless moved&gt;&gt;It hangs on the wall at a crooked angle. "
</pre></div>

<p>You can use <span class="code">&lt;&lt;else&gt;&gt;</span> with <span class="code">&lt;&lt;unless&gt;&gt;</span> as well:

<p><div class="code"><pre>
desc = "An imposing metal box five feet on a side, painted a drab green.
        &lt;&lt;unless isOn&gt;&gt;It sits inertly in the center of the chamber.
        &lt;&lt;else&gt;&gt;It hums and vibrates with an internal energy that seems
           only barely contained. "
</pre></div>

<p>The second variation is that you can substitute the word
"otherwise" for "else".  These are pure synonyms; both are allowed
simply to let you use the wording you find more intuitive.  Note
that <span class="code">&lt;&lt;otherwise unless&gt;&gt;</span> is valid as well - it simply
means the same thing as <span class="code">&lt;&lt;else if !...&gt;&gt;</span>.


<h3><a name="oneof"></a>Random (and other) selections with <span class="code">&lt;&lt;one of&gt;&gt;</span></h3>

<p>Another special syntax makes it easy to create messages with
alternatives that are chosen randomly or sequentially.  This is handy
for reducing repetition in messages that are displayed repeatedly,
such as atmospheric messages or random NPC behavior.

<p>The basic structure of a message with random alternatives looks
like this:

<p><div class="code"><pre>
"The sphere is currently glowing a ghostly &lt;&lt;one of&gt;&gt;red&lt;&lt;or&gt;&gt;green&lt;&lt;or&gt;&gt;blue&lt;&lt;at random&gt;&gt;. ";
</pre></div>

<p>The list of alternatives starts with <span class="code">&lt;&lt;one of&gt;&gt;</span>.  After this
you simply write the alternatives, separated by <span class="code">&lt;&lt;or&gt;&gt;</span>.  At the
end of the list, you write one of the following, which not only
ends the list but also specifies how to pick an alternative each time
the message is displayed:

<ul class=doublespace>

   <li><span class="code">&lt;&lt;cycling&gt;&gt;</span> - run through the alternatives in the order listed,
      and after showing them all, start over again at the first item.

   <li><span class="code">&lt;&lt;stopping&gt;&gt;</span> - run through the alternatives in order, and
      after showing them all, just keep showing the last item from
      then on.

   <li><span class="code">&lt;&lt;purely at random&gt;&gt;</span> - choose an alternative at random
      each time the message is displayed.  Each item has the same
      probability, so if there are three alternatives, each one will
      be chosen about a third of the time.  "Purely" at random
      means that each pick is completely independent of the previous
      picks, the same as rolling dice or flipping a coin.

   <li><span class="code">&lt;&lt;then purely at random&gt;&gt;</span> - run through the items in order once,
      and after showing them all, behave like <span class="code">&lt;&lt;purely at random&gt;&gt;</span>.

   <li><span class="code">&lt;&lt;at random&gt;&gt;</span> - same as <span class="code">&lt;&lt;purely at random&gt;&gt;</span>, except
      that the same item won't be chosen twice in a row, to reduce
      the appearance of obvious repetition.  Don't use this when
      there are only two options, since this forces an alternating
      sequence, A B A B A B...

   <li><span class="code">&lt;&lt;then at random&gt;&gt;</span> - run through the items in order once,
      and after showing them all, behave like <span class="code">&lt;&lt;at random&gt;&gt;</span>.

   <li><span class="code">&lt;&lt;as decreasingly likely outcomes&gt;&gt;</span> - this is similar to
      <span class="code">&lt;&lt;purely at random&gt;&gt;</span>, but with skewed probabilities.
      The items are assigned relative probabilities starting at 1
      for the last item, 2 for the second to last, 3 for the third
      to last, and so on.  This makes the first item <i>N</i> times as
      likely as the last in an <i>N</i>-item list.

   <li><span class="code">&lt;&lt;shuffled&gt;&gt;</span> - shuffle the items into a random order,
      like a deck of cards, and run through the whole list in that order.
      After showing all of the items, shuffle them again and start
      over.  This reduces repetition by going through the whole
      list before repeating an item.

   <li><span class="code">&lt;&lt;then shuffled&gt;&gt;</span> - run through the items once in the
      order written, and after showing them all, act like <span class="code">&lt;&lt;shuffled&gt;&gt;</span>.

   <li><span class="code">&lt;&lt;half shuffled&gt;&gt;</span> - similar to <span class="code">&lt;&lt;shuffled&gt;&gt;</span>, but only
      shows half the items before re-shuffling.  Oddly,
      the very lack of repetition in shuffled mode is sometimes
      discernible as a pattern in its own right.  This approach can
      help reduce that effect.

   <li><span class="code">&lt;&lt;then half shuffled&gt;</span> - run through the items once in the
      order written, and after showing them all, act like <span class="code">&lt;&lt;half shuffled&gt;&gt;</span>.

   <li><span class="code">&lt;&lt;sticky random&gt;&gt;</span> - pick an item at random the first time
      the message is displayed, then show that same item every time.
      This is useful for "replay" variation, since it lets you set up
      a detail that varies each time the game is played, but which
      remains consistent within a single run-through.

</ul>

<p><span class="code">&lt;&lt;one of&gt;&gt;</span> structures can be nested, and <span class="code">&lt;&lt;if&gt;&gt;</span> and <span class="code">&lt;&lt;one of&gt;&gt;</span>
   can be nested within one another.

<p>For each <span class="code">&lt;&lt;one of&gt;&gt;</span> structure, the compiler creates an unnamed
object of class OneOfIndexGen, as the "index generator" for the list.
This class is defined in the system library file _main.t, which is
normally included automatically in the build.  ("Normally" means
as long as you don't use the compiler's <span class="code">-nodef</span> option to exclude _main.t.)


<h3><a name="firstTimeOnly">One-time only messages with <span class="code">&lt;&lt;first time&gt;&gt;</span></h3>

<p>Some passages are only meant to be seen once, the first time
they're encountered.  The <span class="code">&lt;&lt;first time&gt;&gt;</span> syntax makes this
easy:

<p><div class="code"><pre>
desc = "Tightly packed sandstone blocks line the walls of this
   musty chamber.  The floor is cracked and tilts at odd angles,
   and the ceiling sags so low in places you have to crouch.
   &lt;&lt;first time&gt;&gt;You realize you're probably the first person
   to set foot here in at least a thousand years.&lt;&lt;only&gt;&gt;"
</pre></div>

<p>The text between <span class="code">&lt;&lt;first time&gt;&gt;</span> and the matching <span class="code">&lt;&lt;only&gt;&gt;</span>
will only be displayed the first time the overall string is displayed.
After that it'll disappear from the enclosing text.

<p>Alert readers will notice that <span class="code">&lt;&lt;first time&gt;&gt;</span>...<span class="code">&lt;&lt;only&gt;&gt;</span>
is the same as <span class="code">&lt;&lt;one of&gt;&gt;</span><i>first time text</i><span class="code">&lt;&lt;or&gt;&gt;</span><span class="code">&lt;&lt;stopping&gt;&gt;</span>.
In fact, the compiler processes <span class="code">&lt;&lt;first time&gt;&gt;</span> by rewriting it
exactly as such.  So the extra syntax isn't really needed, but
this is such a common motif in IF authoring that it's nice to have
a more concise way of writing it.
   
<h3>More on evaluation timing, and a warning on side effects</h3>

<p>It's important to keep in mind that a string with an embedded
expression is "live".  The embedded expression is re-evaluated every
time the string itself is evaluated, and the new, current value is
used in the result.

<p>Let's look more closely at how this evaluation timing works.
When you write a string as part of a function, it's fairly simple
to see when it gets evaluated: it's evaluated when that particular
line of code is executed.

<p><div class="code"><pre>
test(x)
{
   local s = 'The current value of x is &lt;&lt;x&gt;&gt;.';
   s = s + '\n';
   return s;
}
</pre></div>

<p>Here, the embedding is evaluated just once each time through
the test() function.  Once we evaluate the <span class="code">&lt;&lt;x&gt;&gt;</span> expression, we
have our final string.  The next line where we append a newline
to the string doesn't re-evaluate the expression, since we already
have our final string.  Likewise, when we <span class="code">return s</span>, we return
that final string value we already computed, so we don't evaluate
the expression again.

<p>It's a little more subtle when we put the string into a property
value:

<p><div class="code"><pre>
orb: Thing 'orb' 'orb'
    desc = "The orb is glowing a bright &lt;&lt;color&gt;&gt;. "
    color = '&lt;&lt;one of&gt;&gt;red&lt;&lt;or&gt;&gt;blue&lt;&lt;or&gt;&gt;green&lt;&lt;cycling&gt;&gt;'
;
</pre></div>

<p>It might appear at first glance that we're assigning a final value
of the string to <span class="code">color</span>, just as we did in the function.  But that's
not what happens; the <span class="code">color</span> property in this case is actually a
method.  The compiler treats it exactly as though you'd written this:

<p><div class="code"><pre>
color()
{
   return '&lt;&lt;one of&gt;&gt;red&lt;&lt;or&gt;&gt;blue&lt;&lt;or&gt;&gt;green&lt;&lt;cycling&gt;&gt;';
}
</pre></div>

<p>This means that each time you evaluate <span class="code">orb.color</span>, you'll get a
new result, since the "one of" selection occurs dynamically on each
evaluation.  So each time we EXAMINE ORB, it will change color.

<p>This internal conversion to a method always happens when you
use embedded expressions.  In fact, it happens when you use any sort
of dynamic expression in a method definition.  The same thing happens
if you write something like this:

<p><div class="code"><pre>
orb: Thing
   weight = (rand(5))
;
</pre></div>

<p>Any time a property definition contains a dynamic expression value,
the compiler automatically turns the property into a method that
evaluates the expression and returns the result.  Strings with
embedded expressions are just a special way of writing a dynamic
expression, so they get the same treatment.

<p>You should be especially careful with embedded expressions that
have side effects.  A "side effect" expression is one that makes some
global change in the program, such as <span class="code">++</span> or <span class="code">--</span> expressions,
assignments, or calls to functions that print text.  For example:

<p><div class="code"><pre>
blob: Thing 'blob' 'blob'
   desc = "It just keeps growing; it's now up to &lt;&lt;++size&gt;&gt; feet across! "
   size = 0
;
</pre></div>

<p>Every time we evaluate <span class="code">desc</span>, the size will go up by a foot.
That means that EXAMINE BLOB will cause it to grow.

<p>Things get even more complicated when we combine properties, lists,
and string embeddings.  Consider this example:

<p><div class="code"><pre>
atmosphereList: object
   eventList = [
      'To err is human; to really screw things up you need
      &lt;&lt;one of&gt;&gt;a computer&lt;&lt;or&gt;&gt;a committee of experts&lt;&lt;or&gt;&gt;an
      Act of Parliament&lt;&lt;or&gt;&gt;Vulcan logic&lt;&lt;or&gt;&gt;a roomful of
      lawyers&lt;&lt;cycling&gt;&gt;. ' ,

      'This message has displayed &lt;&lt;if ++count == 1&gt;&gt;once&lt;&lt;
      else if count == 2&gt;&gt;twice&lt;&lt;else&gt;&gt;&lt;&lt;count&gt;&gt; times&lt;&lt;end&gt;&gt;. '
   ]
        
   count = 0

   getNext()
   {
       if (curIndex &gt; eventList.length())
           curIndex = 1;

       return eventList[curIndex++];
   }
   curIndex = 1
;
</pre></div>

<p>Here's what's displayed if we repeatedly print out the result
of calling <span class="code">atmosphereList.getNext()</span>:

<p><div class="code"><pre>
To err is human; to really screw things up you need a committee of experts.

This message has displayed 4 times.

To err is human; to really screw things up you need a computer.

This message has displayed 8 times.

To err is human; to really screw things up you need a roomful of lawyers.

This message has displayed 12 times.
</pre></div>

<p>If you look carefully at the <span class="code">&lt;&lt;one of&gt;&gt;</span> list, you'll see that
the order of the messages is different from what's in the list: for
example, rather than seeing "a computer" in the first message, we see "a
committee of experts", which is the second list entry.  Even more obvious
is the counter displayed every other time: it jumps by increments of 4,
rather than one at a time, as the <span class="code">++count</span> would seem to suggest.

<p>What's going on?  To understand this, you have to remember the
general rule for a property containing an expression: the compiler
turns it into a method that evaluates the expression and returns the
result.  Now, a list that contains expressions in its element values
is just like a string that contains embedded expressions: the compiler
treats the list as an expression that consists of assembling a list
dynamically out of the component expressions.  If we deconstruct what
the compiler does with the <span class="code">eventList</span> property, we get something like
this:

<p><div class="code"><pre>
eventList()
{
   return new List(
      'To err is human; to really screw things up you need '
      + oneOfHandler('a computer', 'a committee of experts',
                     'an Act of Parliament', 'Vulcan logic',
                     'a roomful of lawyers')
      + '.',

      'This message has been displayed '
      + (++count == 1 ? 'once' : count == 2 ? 'twice' : (count + 'times'))
      + '. '
   );
}
</pre></div>

<p>That's pseudo-code, of course, not the actual code the compiler
generates internally; but it should give you a clearer picture of
what's going on.  Each time we evaluate <span class="code">atmosphereList.eventList</span>,
we have to build that entire list anew, and that means that we have to
build each of the strings anew, which triggers the various side
effects: cycling through the "one of" list, and incrementing the
<span class="code">count</span> property.  This means that <i>each</i> of the following
will trigger <i>all</i> of the side effects:

<p><div class="code"><pre>
atmosphereList.eventList
atmosphereList.eventList[1]
atmosphereList.eventList.length()
atmosphereList.eventList[++curIndex]
</pre></div>

<p>The thing that's surprising is that an expression like
<span class="code">atmosphereList.eventList[1]</span> would trigger the side effects not
only in element <span class="code">[1]</span>, but in element <span class="code">[2]</span> as well.  But that is
indeed what happens: before TADS can even start thinking about
retrieving element <span class="code">[1]</span>, it has to construct the whole list
dynamically, which means it evaluates all of the individual element
expressions, not just the expression for element <span class="code">[1]</span>.

<p>You'll notice that the <span class="code">getNext()</span> method evaluates the <span class="code">eventList</span>
property twice - once to get its length, and again to retrieve the
element value.  That's why we see the second <span class="code">&lt;&lt;one of&gt;&gt;</span> element
on the first go-round: we're actually working with the second
evaluation of the list, so we get the second <span class="code">&lt;&lt;one of&gt;&gt;</span> item.
That's also why we see "4 times" on the second message.  By then,
that <span class="code">++count</span> expression has been evaluated four times: twice
for the first <span class="code">getNext()</span> call, and twice again for the second.


<h2><a name="backslash"></a>Full list of backslash codes</h2>

<p>We've already seen how the backslash "\" is used to escape
quote marks, <span class="code">&lt;</span> signs, and the backslash itself - meaning that
it removes their special meaning and makes them into ordinary
literal text characters.

<p>The backslash has another use, which is that it <i>adds</i> special
meanings to some ordinary characters.  It's sort of a role reversal
from what we've seen so far, but it makes a certain kind of sense, if
you think about a quote mark's regular meaning as "end this string"
and its special backslash meaning as "a literal quote mark."

<p>Here are all of the special backslash sequences:

<style type="text/css">
<!--
table#specials {
    margin-left: 3em;
    margin-right: 3em;
    line-height: 140%;
}
table#specials td {
    text-align: left;
    padding-bottom: 1.5ex;
    vertical-align: top;
}
table#specials td.1 {
    font-face: "Courier New, Courier, monospace";
    width: 5em;
    padding-right: 1em;
}
//-->
</style>

<p>
<table id="specials">

   <tr><td class=1>\\<td>A (single) literal backslash character

   <tr><td class=1>\&lt;<td>A literal <span class="code">&lt;</span> character.  The only time
      it's necessary to write <span class="code">\&lt;</span> rather than just <span class="code">&lt;</span> is when
      you use two (or more) <span class="code">&lt;</span>'s in a row: you must escape the second
      (and third, etc) to prevent the compiler from treating <span class="code">&lt;&lt;</span>
      as the start of an embedded expression.  Very important:
      writing <span class="code">\&lt;</span> does <b>not</b> prevent the display layer from
      reading the <span class="code">&lt;</span> as the start of an HTML tag.  For that, you
      must write the less-than sign as "<span class="code">&amp;lt;</span>".

   <tr><td class=1>\&gt;<td>A literal <span class="code">&gt;</span> character.  It's never necessary
      to escape <span class="code">&gt;</span>, but it's harmless to do so.  This doesn't prevent
      the HTML parser from treating the <span class="code">&gt;</span> as the end of a tag;
      use "<span class="code">&amp;gt;</span>" for that.

   <tr><td class=1>\"<td>A literal double-quote character

   <tr><td class=1>\'<td>A literal single-quote character

   <tr><td class=1>\^<td>Caps mode: capitalize the next character to
      be displayed, <i>if</i> it's alphabetic.  (^ is the circumflex,
      usually shift-6 on a QWERTY keyboard.)

   <tr><td class=1>\v<td>Un-caps mode: convert the next character to
      be displayed to lower-case, <i>if</i> it's alphabetic.  (That's
      not a special arrow character, just an ordinary lower-case "v".)

   <tr><td class=1>\ <td>(Backslash-space) Show a quoted space. In
      plain text interpreters <b>only</b>, this shows an extra space even 
      if a space character is adjacent.  It also prevents the display system
      from adding an extra space after a period or other double-spaced
      punctuation mark.

   <tr><td class=1>\b<td>Show a blank line.  This ends the current
      line and adds an extra blank line after it.

   <tr><td class=1>\n<td>Newline. This ends the current line and starts
      a new one. This is similar to the HTML tag <span class="code">&lt;br&gt;</span>, with the
      exception that two or more consecutive <span class="code">\n</span> marks are consolidated,
      so they don't show any blank lines.  The interpreter groups a run
      of <span class="code">\n</span> marks into a single line break.  This is designed to
      help with a common situation in IF coding, which is that you
      often construct output in fragments from different sections of
      the program.  These different sections don't always know what
      other text will be displayed just before or after their text,
      since the adjacent text will likely come from some distant part
      of the code.  Consolidating line breaks allows one section to show
      a line break without having to worry too much about whether the
      previous of next section will also show a line break; if there's
      another adjacent line break, the two will be automatically combined,
      avoiding messy output with too many blank lines.  Of course, this
      means that you can't use an explicit series of \n codes to display
      blank lines - when you want to do that, you need to use \b.

   <tr><td class=1>\r<td>Carriage Return, ASCII 13.  This character
      has no formatting significance to TADS, so there's no reason to
      use it when writing output to the display or to text files.  In fact,
      it's best to avoid it, because using it inevitably gets into the
      details of line endings.  That's a long-standing mess; each
      operating system has its own conventions, and no one is willing
      to adopt a common standard because it would cause so much
      compatibility upheaval.  Fortunately, TADS is pretty good at
      working around this mess automatically, as long as
      you stick with <span class="code">\n</span> in program code.  TADS translates <span class="code">\n</span>
      to and from the local conventions when reading and writing text
      files, the display, and most anything else external.
      Mixing in <span class="code">\r</span> characters of your own
      could interfere with this.  The main reason TADS allows
      <span class="code">\r</span> at all in source code is for the sake of
      programmers coming from a C/C++/Java background, where <span class="code">\r</span>
      has the same meaning.  It's also useful for low-level binary
      I/O, since CR characters  are used in several platforms'
      newline conventions (notably DOS/Windows), as well as in most
      of the text-oriented Web protocols.

   <tr><td class=1>\t<td>Tab.  This advances the horizontal position
      to the next tab stop.  Tab stops are every 8 characters in
      plain text interpreters.  In graphical interpreters, tabs
      usually simulate the text-mode tab layout - but this is
      often only an approximation, because proportional fonts are
      usually used in GUI systems.  Because of these platform
      differences, it's best to avoid tabs in displayed output;
      HTML formatting gives you better control.  As with <span class="code">\r</span>, the
      main legitimate use of <span class="code">\t</span> is for low-level binary I/O.

   <tr><td class=1>\u<i>hhhh</i><td>Encodes a Unicode character by
      entering its hexadecimal value <i>hhhh</i>.  For example,
      <span class="code">\u0041</span> produces a capital A.

   <tr><td class=1>\<i>ooo</i><td>Encodes an ASCII character by
      entering its octal value.  For example, \081 produces a
      capital A.  (This is redundant with <span class="code">\u</span>, but it's more
      familiar for people with a C language background.)

   <tr><td class=1>\x<i>hh</i><td>Encodes an ASCII character by
      entering its two-digit hex value.  For example, <span class="code">\x41</span>
      produces a capital A.  (This is redundant with <span class="code">\u</span>, but
      it's included for the sake of Java programmers.)

</table>

<p>You shouldn't use any \ combinations that aren't listed above,
because while they don't have any special meaning now, they might
be given a special meaning in a future version.  The compiler
doesn't complain about unknown \ combinations, and simply leaves
the entire sequence (including the \) intact in the string.



</div>
<hr class="navb"><div class="navb">
<i>TADS 3 System Manual</i><br>
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="langsec.htm">The Language</a> &gt; 
String Literals
<br><span class="navnp"><a class="nav" href="types.htm"><i>Prev:</i> Fundamental Datatypes</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="enum.htm"><i>Next:</i> Enumerators</a> &nbsp;&nbsp;&nbsp; </span>

</div>
</body>
</html>

<html>
<!-- DERIVED FILE - DO NOT EDIT -->

<head>
<title>String</title>
<link rel="stylesheet" href="sysman.css" type="text/css">
</head>
<body>
<div class="topbar"><img src="topbar.jpg" border=0></div>
<div class="nav">
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="builtins.htm">The Intrinsics</a> &gt; 
String
<br><span class="navnp"><a class="nav" href="framedesc.htm"><i>Prev:</i> StackFrameDesc</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="strbuf.htm"><i>Next:</i> StringBuffer</a> &nbsp;&nbsp;&nbsp; </span>

</div>
<div class="main">

<h1>String</h1>

<p>"String" is a native TADS 3 datatype, but it's also an intrinsic
class.  Any string value is an instance of the String class, so
you can call methods defined by the class on any string value. 

<h2>Value semantics</h2>

<p>Strings have "value semantics".  This means that a given string
value's text is immutable: once you've created a string, the text
within that string never changes.  All of the methods and operators
that might appear to change the value of a string actually create a
new string with the modified value, leaving the original value intact.
For example, consider this code:

<p><div class="code"><pre>
local x = 'foo';
local y = x;
x += 'bar';
</pre></div>

<p>Superficially, it appears that the last line changes the string in
<span class="code">x</span>.  In fact, the original string is not changed - if we display the
value of <span class="code">y</span>, we'll see that <span class="code">y</span> still contains <span class="code">'foo'</span>.  When the
the last line above is executed, it creates a new string to
hold the concatenated value, and assigns the result to <span class="code">x</span>.

<p>Value semantics make it very easy to work with strings, because you
don't have to worry about whether a function might modify a string you
pass to it: this can never happen, because a given string's text is
constant.

<h2>Operators</h2>

<p>The addition operator <span class="code">+</span> can be used to concatenate two strings
yielding a string that consists of the contents of the right-hand
string appended to the end of the contents of the left-hand string.

<p><div class="code"><pre>
local x = 'foo';
local y = 'bar';
local z = x + y;  // z = 'foobar'
</pre></div>

<p>You can use the <span class="code">+=</span> operator to replace the left-hand variable
with the resulting string.

<p><div class="code"><pre>
local x = 'foo';
local y = 'bar';
x += y;  // x = 'foobar'
</pre></div>


<h2>String vs StringBuffer</h2>

<p>There's a related class called <a
href="strbuf.htm">StringBuffer</a>, that's designed especially for
complex string construction tasks.  StringBuffer objects can be edited
in place, meaning that you can change the text contained in a
StringBuffer object, rather than creating a new object for every
modification.  Refer to the StringBuffer documentation for more
information.

<h2>String methods</h2>


<a name="compareTo"></a>
<p><span class="code">compareTo(<i>str</i>)</span>
<div class=fdef>

Compares this string to the second string <i>str</i>, returning an
integer less than 0 if this string sorts before <i>str</i>, 0 if
the two strings are identical, or greater than 0 if this string
sorts after <i>str</i>.

<p>The comparison uses the Unicode character numbers as the collation
order.  As a result, strings using accented accented characters
probably won't be sorted in the correct linguistic order for a given
language.  Different languages use different collation rules, which
usually don't match the Unicode character order.

</div>

<a name="compareIgnoreCase"></a>
<p><span class="code">compareIgnoreCase(<i>str</i>)</span>
<div class=fdef>

Compares this string to the second string <i>str</i>, ignoring
differences in upper/lower case.  For example, "A" and "a" are treated
as equal.  Returns an integer less than 0 if this string sorts before
<i>str</i>, 0 if the two strings are identical, or greater than 0 if
this string sorts after <i>str</i>. 

<p>The method compares the case-folded versions of the strings.
See <a href="#toFoldedCase">toFoldedCase()</a> for more on case
folding.  Case folding is designed to erase case differences by
converting both strings to a canonical lower-case format.

<p>The comparison uses the Unicode character numbers of the
case-folded characters as the collation order.  This means that
strings using accented accented characters probably won't be sorted in
the correct linguistic order for a given language.  Different
languages use different collation rules, which usually don't match the
Unicode character order.

</div>

<a name="digestMD5"></a>
<p><span class="code">digestMD5()</span>
<div class=fdef>

Calculates the 128-bit RSA MD5 message digest of the string, returning
a string of 32 hex digits representing the digest value.

<p>MD5 was originally designed for cryptographic applications, but it
has some known weaknesses and is no longer considered secure.  Even
so, it's still considered a good checksum, and it's widely used for
message integrity checking.  It's also part of several Internet
standards (e.g., HTTP digest authentication).  In an Interactive
Fiction context, <a href="http://babel.ifarchive.org/">Babel</a> uses
MD5 to generate IFIDs for older games.  If you're looking for a secure
hash, consider SHA-2 (see <a
href="#sha256"><span class="code">sha256()</span></a>) instead of MD5.

</div>


<a name="endsWith"></a>
<p><span class="code">endsWith(<i>str</i>)</span>
<div class=fdef>

Returns <span class="code">true</span> if this string ends with <i>str</i>, <span class="code">nil</span> if not.
This string ends with <i>str</i> if this string is at least as long as
<i>str</i>, and the last <span class="code">str.length()</span> characters of this string
are the same as the characters of <i>str</i>.

</div>

<a name="find"></a>
<p><span class="code">find(<i>target</i>, <i>index</i>?)</span>
<div class=fdef>

Finds the substring or regular expression <i>target</i> within this
string.

<p>If the search is successful, the method returns the
character index where the match starts (the first character of the
string is at index 1).  If the target isn't found, the method
returns <span class="code">nil</span>.
If <i>target</i> is a regular expression, the
method has the side effect of updating the
<a href="tadsgen.htm#rexGroup">rexGroup()</a> registers to reflect the
search results.


<p><i>target</i> can be a string value or a
<a href="rexpat.htm">RexPattern</a> object.  If it's a string,
<span class="code">find()</span> simply searches for the literal text of the string.  If
<i>target</i> is a RexPattern, the method searches for a match to the
regular expression pattern.


<p>For regular expression searches, you can get more detailed
information on the match result using
<a href="tadsgen.htm#rexGroup">rexGroup()</a>.  You can alternatively use the
<a href="tadsgen.htm#rexSearch">rexSearch()</a> function,
which directly returns more information on the match.  

<p>If <i>index</i> is given, it sets the starting index in the subject
string for the search; an <i>index</i> of 1 means that the search
starts at the first character.  If the index value is omitted, the
default value is 1.  The starting index value can be used to search
for another occurrence of the same target following a previous search,
for example.  A negative value for <i>index</i> is an index from the
end of the string: -1 is the last character, -2 the second to last,
etc.  Note that the return value is still an index from the start of
the whole string, regardless of the starting index value.  For regular
expression searches, the start of the string for the purposes of
"^" and other special operators is still the start of the overall
string, regardless of the <i>index</i> value.

<p>Examples:

<p><div class="code"><pre>
'abcdef'.find('cd') yields 3
'abcdef'.find('g') yields nil
'abcdef'.find('c', 3) yields 3
'abcdef'.find('c', 4) yields nil
'abcabcabc'.find('c', 4) yields 6
'abcabcabc'.find('c', 7) yields 9
'abcdef123456'.find(R'%d+') yields 7
</pre></div>

</div>

<a name="findAll"></a>
<p><span class="code">findAll(<i>target</i>, <i>func</i>?)</span>
<div class=fdef>

Searches the subject string (self) for all occurrences of a given
substring or regular expression pattern, returning a list of matches.

<p>On success, the return value is a list of the matches.  If <i>func</i>
is omitted, each element is a string with the text of the corresponding
match.  If <i>func</i> is provided, each element is the return value of
<i>func</i> for the corresponding match.

<p><i>target</i> can be a string or a <a href="rexpat.htm">RexPattern</a>
object.  If it's a string, the function searches for exact matches
to the string.  If it's a pattern, the function searches for matches
to the regular expression.

<p><i>func</i> is an optional callback function.  If provided, the
method calls <i>func</i> for each match, and uses the value returned
by <i>func</i> as the match's entry in the return list.  <i>func</i>
is invoked as <span class="code">func(<i>match</i>, <i>index</i>, <i>group1</i>...)</span>, where <i>match</i>
is a string with the text of the match, <i>index</i> is the character
index in the subject string of the start of the match, and <i>group1</i>
is the text of the first parenthesized group in the regular expression,
if there is one.  Arguments are added for any additional parenthesized
groups.  All of the arguments are optional; the method calls <i>func</i>
with as many arguments as its actually expects, so if you don't need
to know the index or group values, you can simply omit the parameter
variable for them.  If <i>func</i> requires more group parameters than
there are actual matching groups, the method passes <span class="code">nil</span> values
for the extra group parameters.

<p>Examples:

<p><div class="code"><pre>
'one two three'.findAll(R'%w+') yields ['one', 'two', 'three']
'one two three'.findAll(R'%w+', {m: m.toUpper()} yields ['ONE', 'TWO', 'THREE']
'one two three'.findAll(R'%w+', {m, idx: idx}) yields [1, 5, 9]
'one two three'.findAll(R'(%w)%w*', {m, i, g1: g1} yields ['o', 'w', 't']
'one two three'.findAll(R'(%w)%w*', {m, i, g1, g2: g2} yields [nil, nil, nil]
</pre></div>

</div>

<a name="findLast"></a>
<p><span class="code">findLast(<i>target</i>, <i>index</i>?)</span>
<div class=fdef>

Searches the subject string (self) for the last (rightmost) match to
a given substring or regular expression pattern.  This works like
the <a href="#find">find()</a> method, but searches backwards, starting
at the end of the string and working towards the beginning.

<p>On success, the return value is an integer giving the character
index of the start of the rightmost match.  If no match is found, the
result is <span class="code">nil</span>.
If <i>target</i> is a regular expression, the
method has the side effect of updating the
<a href="tadsgen.htm#rexGroup">rexGroup()</a> registers to reflect the
search results.

<p><i>target</i> is a string containing the substring to find,
or a <a href="rexpat.htm">RexPattern</a> object with a regular
expression to match.

<p>For regular expression searches, you can get more detailed
information on the match result using
<a href="tadsgen.htm#rexGroup">rexGroup()</a>.  You can alternatively use the
<a href="tadsgen.htm#rexSearchLast">rexSearchLast()</a> function,
which directly returns more information on the match.  

<p><i>index</i> is the optional starting position for the search.  The
function looks for a match before but not including the character at
this index.  If <i>index</i> is omitted, the default is to search the
entire string from the end.  Equivalently, you can set <i>index</i> to
the length of the string plus one, to indicate the imaginary character
position just after the end of the string.  Specifying 0 for
<i>index</i> means the same thing.  If <i>index</i> is negative, it's
an offset from the end of the string: -1 is the last character, -2 is
the second to last, and so on.  Note that -1 (or, equivalently,
<span class="code">self.length()</span>) means that you want to
search the portion of the string up to but not including the last
character, since the match can't include the starting character.

<p>Examples:

<p><div class="code"><pre>
'abcdef'.findLast('cd') yields 3
'abcdef'.findLast('g') yields nil
'abcabcabc'.find('c') yields 9
'abcabcabc'.find('c', 0) yields 9
'abcabcabc'.find('c', 9) yields 6
'abcabcabc'.find('c', -1) yields 6
'abc123'.find(R'%d+') yields 4
</pre></div>

<p>For regular expression targets, the <span class="code">&lt;FirstBegin&gt;</span> and
<span class="code">&lt;FirstEnd&gt;</span> modes (see <a href="regex.htm">regular expressions</a>)
work in mirror image compared to ordinary forward searches.  The
easiest way to think about this is to picture the reverse search as a
forward search viewed in a mirror.  For a reverse search,
<span class="code">&lt;FirstBegin&gt;</span> means that the match with its <i>right</i> end
closest to the starting point is selected as the winner, while
<span class="code">&lt;FirstEnd&gt;</span> means that the match with its <i>left</i> end closest
to the starting point is selected.  Since the search proceeds right to
left, closer to the starting point means further right, at a higher
index.

<p>Note that we use the terms right, left, and right-to-left loosely
in the discussion above.  In particular, we're ignoring that different
languages and scripts are written on paper in different directions.
We're talking purely about the order of characters in the string,
using "left" to mean towards the beginning of the string and "right"
to mean towards the end, regardless of whether the string contains
Roman characters or Arabic characters or anything else.

</div>


<a name="findReplace"></a>
<p><span class="code">findReplace(<i>oldStr</i>, <i>newStr</i>, <i>flags</i>?, <i>index</i>?, <i>limit</i>?)</span>
<div class=fdef>

Finds one or more instances of the substring <i>oldStr</i> within the
subject string (i.e., <span class="code">self</span>), and replaces them with the new
substring <i>newStr</i>.

<p>The method returns a new string with the replacements performed.
If <i>target</i> is a regular expression, the method also has the side
effect of updating the <a href="tadsgen.htm#rexGroup">rexGroup()</a>
registers to reflect the search results.


<p><i>oldStr</i> is the search string.  This can be a string value,
in which case the method searches for the literal text of the string,
or a <a href="rexpat.htm">RexPattern</a> object, in which case the
method searches for matches to the pattern.

<p><i>newStr</i> is the replacement string.  Matches to <i>oldStr</i>
within the subject string are replaced with this value.  <i>newStr</i>
can be a string value, in which case the literal text of the string is
used as the replacement text, or it can be a function to invoke to
determine the replacement text (<a href="#findReplaceFuncs">see
below</a>).

<p>If <i>oldStr</i> is a RexPattern, <span class="code">%</span> characters in <i>newStr</i>
have the same special meaning they have in the replacement text in the
<a href="tadsgen.htm#rexReplace">rexReplace()</a> function: <span class="code">%1</span> is
replaced by the subject string text that matched the first
parenthesized group in the regular expression, <span class="code">%2</span> by the text
matching the second group, and so on; <span class="code">%*</span> is replaced by the text
matching the entire regular expression pattern; and <span class="code">%%</span> is replaced
by a single percent sign.  When <i>oldStr</i> is a string value, <span class="code">%</span>
characters in <i>newStr</i> have no special meaning and are simply
used literally as replacement text.

<p><i>oldStr</i> and <i>newStr</i> can also be specified as lists;
see <a href="#findReplaceLists">below</a> for details.

<p><i>flags</i> is optional.  If it's missing, the default is
<span class="code">ReplaceAll</span>, to replace all occurrences of the search
string within the subject string.  If provided, <i>flags</i>
is a bitwise combination (with the <span class="code">|</span> operator) of the
following flag values:

<ul class=doublespace>

   <li><span class="code">ReplaceOnce</span>: replace only the first occurrence of the
   search string.  This is ignored if <i>limit</i> is specified.

   <li><span class="code">ReplaceAll</span>: replace all occurrences of the search string.
   This is ignored if <i>limit</i> is specified.  <span class="code">ReplaceAll</span>
   is the default if <span class="code">ReplaceOnce</span> isn't specified, and it
   supersedes <span class="code">ReplaceOnce</span> if both are specified.

   <li><span class="code">ReplaceIgnoreCase</span>: ignore case (that is, capitalization)
   when searching for <i>oldStr</i>.  By default, the search is
   case-sensitive, so capitals can only match capitals and minuscules
   can only match minuscules.

   <li><span class="code">ReplaceFollowCase</span>: each time a match is replaced, change
   lower-case letters in the replacement text to follow the
   capitalization pattern of the matched text.  There are three
   possibilities: if all of the letters in the matched text are
   capitals, all letters in the replacement text are capitalized;
   if all of the letters in the match are lower-case, the
   replacement text isn't changed; if the match has a mix of
   capitals and lower-case letters, the first lower-case letter
   in the replacement text is capitalized, and the rest are left
   unchanged.

   <li><span class="code">ReplaceSerial</span>: use the serial replacement mode.  See
   <a href="#findReplaceLists">below</a> for details.

</ul>

<p>Note that you should never use 0 as the <i>flags</i> value.  For
compatibility with older versions, 0 has a special meaning equivalent
to <span class="code">ReplaceOnce</span>.  If you have no other flags to specify, always use
either <span class="code">ReplaceOnce</span> or <span class="code">ReplaceAll</span>, or simply omit the
<i>flags</i> argument entirely.

<p>If <i>index</i> is specified, it gives the starting index in self
for the search.  Any matches that start before this starting point
will not be replaced.  If <i>index</i> is 1, the search starts at the
first character; this is the default if <i>index</i> is omitted.  A
negative value is an index from the end of the string: -1 is the last
character, -2 the second to last, and so on.  Note that a negative
index doesn't change the direction of the search; it still runs
left-to-right.

<p>If <i>limit</i> is included, it specifies the maximum number of
replacements to perform.  This can be <span class="code">nil</span> to indicate that all
matches are to be replaced, or an integer giving the maximum number of
matches to replace.  0 (zero) means that no matches are to be
replaced, in which case the original subject string is returned
unchanged.  If a <i>limit</i> argument is present, it overrides the
<span class="code">ReplaceAll</span> and <span class="code">ReplaceOnce</span> flags - those flags are ignored if
<i>limit</i> is present.  If <i>limit</i> is omitted, the limit is
taken from the flags.

<p><b><a name="findReplaceLists"></a>Search lists:</b> Instead of
searching for just a single search string, you can search for several
strings at once, by using a list as the <i>oldStr</i> argument.
This will search for each of the items in the list, and replace each
one with the <i>newStr</i> replacement string.

<p>If you supply a list for the search term, you can optionally also
supply a list for the <i>newStr</i> replacement value.  If you do,
each match to an element of <i>oldStr</i> is replaced with the
corresponding element of the <i>newStr</i> list - that is, the item at
the same list index.  If there are more <i>oldStr</i> elements than
<i>newStr</i> elements, matches to the excess <i>oldStr</i> elements
are replaced with empty strings.  Excess <i>newStr</i> elements are
simply ignored.

<p>If <i>newStr</i> isn't a list, it's used as the replacement for all
of the search strings.  Note that this is different from passing a
one-element list for <i>newStr</i>, because in that case it would only
specify a replacement for <i>oldStr</i>[1], and the remaining
<i>oldStr</i> elements would all be replaced with empty strings.

<p>Here's an example that replaces each of the special HTML characters
with their markup codes, using a single <span class="code">findReplace()</span> call:

<p><div class="code"><pre>
str = str.findReplace(['&amp;', '&lt;', '&gt;'], ['&amp;amp;', '&amp;lt;', '&amp;gt;']);
</pre></div>

<p>When you use a list of search terms, there are two modes for
iterating through the list.  The default is "parallel" mode.  In this
mode, <span class="code">findReplace()</span> starts by searching for all of the search
terms at once.  It then replaces the single leftmost match with its
corresponding replacement text.  (If two of the search strings match
at the same position, the one at the lower <i>oldStr</i> index takes
precedence.)  If <span class="code">ReplaceOnce</span> was specified, we're done.
Otherwise, <span class="code">findReplace()</span> next repeats the search in the
<i>remainder</i> of the string, after (to the right of) that first
replacement, again searching for all of the terms, and again replacing
the single leftmost match among them.  This repeats until there are no
more matches.

<p>The other mode is "serial" mode, which you select by including
<span class="code">ReplaceSerial</span> in the flags.  In this mode, <span class="code">findReplace()</span>
starts by searching <i>only</i> for the first <i>oldStr</i> element.
It replaces every match for the first term, or just the first match if
<span class="code">ReplaceOnce</span> is specified.  If a match was found and
<span class="code">ReplaceOnce</span> was specified, we're done.  Otherwise, we start over
with the <i>updated</i> string - containing all replacements for the
first term - and search this new string for the <i>second</i> search
term.  We once again replace all occurrences of this term.  We repeat
this process for each additional term in the <i>oldStr</i> list.

<p>The key difference between the parallel and serial modes is that
serial mode rescans each replaced result string for each term.  This
means that replacement text from the first search term is subject to
further replacement by the second search term, and that's subject to
yet more replacement by the third term, and so on.  In contrast,
parallel mode never rescans replacement text, so once a replacement
is made, it won't be further modified.

<p><a name="findReplaceFuncs"></a><b>Replacement function:</b> The
replacement value <i>newStr</i> is normally given as a literal string
to substitute for each occurrence of the search string.  For more
flexibility, though, you can instead provide a function, which
<span class="code">findReplace()</span> calls for each match to determine the replacement
text for that match.  This allows you to vary the replacement text
according to the exact text of the match (which can vary if you're
using the <span class="code">ReplaceIgnoreCase</span> flag or you're using a list of search
strings), the position of the match within the subject string, or
whatever other conditions you choose.

<p>The callback function can be a regular or anonymous function.  It's
called like this, once for each match found in the subject string:

<p><div class="code"><pre>
newStrFunc(match, index, orig);
</pre></div>

<p><i>match</i> is the text actually matched in the subject string.
<i>index</i> is the character index within the string of the start of
the match (the first character is at index 1, as usual).  <i>orig</i>
is the entire original subject string.

<p>You can omit one or more of the parameters when you define the
callback function, because <span class="code">findReplace</span> will only supply as many
arguments as the function actually wants.  The arguments are always in
the same order, though - the names don't matter, just the order.  This
means that if you provide a callback that only takes one argument, it
gets the match string value; with two arguments, they'll be assigned
the match string and match index, respectively.

<p>The function must return a string value giving the replacement text
(it can alternatively return <span class="code">nil</span>, which is treated as an empty
string).

<p>If you use a list of search strings and a list of corresponding
replacements, each element of the replacement list can be a separate
function.  The replacement list can also be a mix of strings and
functions.


</div>

<a name="htmlify"></a>
<p><span class="code">htmlify(<i>flags</i>?)</span>
<div class=fdef>

Converts HTML markup-significant characters in the string to
appropriate HTML sequences, and returns the resulting string.  If the
flags argument is not included, the method acts as though flags has
the value 0 (zero).  By default, this method scans the string for the
characters <span class="code">&amp;</span> (ampersand) and <span class="code">&lt;</span> (less than), and converts these
characters to the sequences <span class="code">&amp;amp;</span> and <span class="code">&amp;lt;</span> respectively.  This
conversion ensures that, when the string is rendered in HTML mode, the
display shows ampersands and less-than signs where they appeared in
the original string's text.  In addition, you can specify a
combination (using the bitwise OR operator, <span class="code">|</span>) of the following
flags to perform additional conversions:

<ul class=doublespace>

<li><span class="code">HtmlifyTranslateSpaces</span>: converts each space character after
the first space in a run of multiple spaces to the sequence <span class="code">&amp;nbsp;</span>
(the HTML non-breaking space character).  This ensure that a run of
multiple spaces will be rendered visually with the same number of
spaces as were in the original string.  Without this flag, a run of
spaces will appear visually as a single space when rendered as HTML,
because HTML renderers combine adjacent spaces in HTML source (each
run of multiple spaces is displayed as a single space).  The method
leaves the first space in a run of whitespace as an ordinary space
character so that the HTML renderer can still break the line for
word-wrapping purposes at the space.

<li><span class="code">HtmlifyTranslateTabs</span>: converts each tab character (<span class="code">\t</span>) in the
string to the sequence <span class="code">&lt;tab&gt;</span>.

<li><span class="code">HtmlifyTranslateNewlines</span>: converts each newline character (<span class="code">\n</span>)
in the string to the sequence <span class="code">&lt;br&gt;</span>.

<li><span class="code">HtmlifyTranslateWhitespace</span>: this is simply a combination of
<span class="code">HtmlifyTranslateSpaces</span>, <span class="code">HtmlifyTranslateTabs</span>, and
<span class="code">HtmlifyTranslateNewlines</span>.

</ul>


<p>This method is useful if you obtain a string from an external
source, such as from the user (via the <span class="code">inputLine()</span> function, for
example) or from a text file, and you then want to display the string
in HTML mode.  Without conversions, any markup-significant characters
in the string might not be displayed properly, since the HTML parser
would attempt to interpret the characters as HTML formatting codes.
You can use this method to ensure that a string obtained externally is
displayed verbatim in HTML mode.

</div>

<a name="length"></a>
<p><span class="code">length()</span>
<div class=fdef>

Returns the number of characters in the string.

</div>

<p><span class="code">mapToByteArray(<i>charset</i>?)</span>
<div class=fdef>

Creates a <a href="bytearr.h">ByteArray</a> object based on the
contents of the string.  This is equivalent to calling
<span class="code">new ByteArray()</span> with this string and character set as arguments.

<p>If a <i>charset</i> value is included and isn't <span class="code">nil</span>, it must be
either a <a href="charset.htm">CharacterSet</a> object, or a string
giving the name of a character set.  The method maps the string to
bytes using the given character set, and creates a new ByteArray
object with the mapped bytes as the contents.  The usual
default/missing character defined by the mapping is substituted for
any unmappable characters.

<p>If the character set represented by <i>charset</i> is unknown
(i.e,.  there's no mapping available for the character set in the
run-time TADS installation), an <span class="code">UnknownCharSetException</span> is thrown.
You can determine whether the the character set is known using the <a
href="charset.htm#isMappingKnown">isMappingKnown()</a> method on the
CharacterSet object.

<p>If <i>charset</i> is omitted or <span class="code">nil</span>, the method creates
a ByteArray with one byte per character of the string, using the
Unicode character code of each character as the byte value.  Since
a byte can only hold values from 0 to 255, a numeric overflow
error will be thrown if the string contains any characters outside
of this range.


</div>


<a name="match"></a>
<p><span class="code">match(<i>target</i>, <i>index</i>?)</span>
<div class=fdef>

Checks for a match to the given <i>target</i> value, at the given
starting position in the subject string (self).

<p>If <i>target</i> is
a string, this method tries to match the literal text of the string;
if <i>target</i> is a <a href="rexpat.htm">RexPattern</a> object,
the method tries to match the regular expression.

<p>If <i>index</i> is specified, it's an integer giving the
starting position to check for the match.  1 is the first character
in the string; a negative index is from the end of the string (-1
is the last character, -2 is the second to last, and so on).  If
<i>index</i> is omitted, the method checks for a match at the start
of the string (as though <i>index</i> were 1).

<p>If <i>target</i> matches, the return value is an integer giving the
length of the match.  When <i>target</i> is a string, a successful
match simply returns the length of <i>target</i>, since the entire
target string must match exactly.  When <i>target</i> is a RexPattern,
a successful match returns the number of characters of the subject
string that the regular expression matches.  The entire regular
expression must match, but it need not match the entire subject
string.  (If you want to explicitly match the entire subject string,
you can end the pattern with '$', since that will allow the pattern to
match only if the '$' symbol lines up with the end of the subject
string after the match.)

<p>If the string doesn't match <i>target</i>, the return value is
<span class="code">nil</span>.  Note that it's possible for a successful match to return 0:
if <i>target</i> is an empty string, that will match any subject with
a length of zero; and some regular expression patterns can match zero
characters successfully (e.g., 'a*', which matches zero or more 'a'
characters).

<p>This method is similar to <a href="#find">find()</a>.  The
difference between the two is that match() only looks for a match at
the specified starting position, without searching any further in the
string, whereas find() searches for a match at each character of the
string from the starting point onwards, until either finding a match
or exhausting the string.

</div>


<a name="packBytes"></a>
<p><span class="code">packBytes(<i>format</i>, ...)</span>
<div class=fdef>

Packs a list of values into bytes, creating a new String object
representing the byte values.  This is a static method that you call
directly on the String class.  For example:

<p><div class="code"><pre>
local s = String.packBytes('s*', 1, 2, 3);
</pre></div>

<p><i>format</i> is a format string describing the packed formats for
the values.  The remaining arguments are the values to be packed.

<p>The
return value is a new String object containing the packed bytes.  The
bytes are represented as characters, so each character in the new
string will have a Unicode value from 0 to 255.

<p>There are a couple of uses for packing bytes into strings.  One is
when you want to create a packed byte list that will eventually find
its way into a file or other external object, but you need to create a
temporary version in memory first.  Packing the bytes into a string
can be a convenient way to accomplish this.  Another potential use is
for generating text for a structured text format, such as for
spreadsheet input.  The byte packer makes it easy to generate formats
with fixed-width text fields.

<p>Note that the string returned might not be particularly
human-readable, since many format codes generate binary byte values
that will look like random gibberish if displayed.

<p>See <a href="pack.htm">Byte Packing</a> for more information.


</div>

<a name="sha256"></a>
<p><span class="code">sha256()</span>
<div class=fdef>

Calculates the 256-bit SHA-2 (Secure Hash Algorithm 2) hash of the
string, returning a string of 64 hex digits representing the hash
value.  SHA-2 is a one-way hash function designed for cryptographic
applications.  It computes a fixed-length hash value that's designed
to be irreversible and effectively unique for any given input.

<p>Secure hashes are useful when you want to store or transmit
information in such a way that another party can prove it knows the
original information, without actually revealing the information.  For
example, passwords are often stored in a hashed format, because this
prevents a third party who steals the password file from being able to
recover the original password values, while still allowing password
entries to be verified, by computing the matching hash value on an
entered password.

</div>


<a name="specialsToHtml"></a>
<p><span class="code">specialsToHtml(<i>stateObject</i>?)</span>
<div class=fdef>

Returns a new string with any special TADS formatting characters in
the "self" string translated to their standard HTML equivalents.  The
result string can then be used as HTML source code in a standard Web
browser to achieve the same display effect as the original string when
displayed in a TADS interpreter.

<p>The main purpose of this function is to make it easier to port
games between the traditional TADS user interface and the Web UI.  The
TADS formatting characters, such as '\n' and '\b', are specific to
TADS - they can't be used directly in a standard Web browser.  The Web
UI uses a standard browser as the user interface, though, so to write
a game for the Web UI, you must either avoid the TADS formatting codes
and use only standard HTML, or translate strings containing the TADS
codes into standard HTML.  The former option would require a lot of
work for an existing game; it's inconvenient even for new work, since
most TADS authors are in the habit of using the TADS codes, and the
TADS codes are more concise than the HTML equivalents.  This function
makes it easy to implement the translation approach, allowing you to
continue to use TADS formatting codes even with the Web UI.

<p>Note that game authors won't generally have to call this function
directly, because the Web UI library will do this automatically in
most cases.  You should only need this function if you're writing a
library extension or creating a custom Web UI window type.

<p><i>stateObject</i> is an optional object, of class SpecialsToHtml.
This keeps track of the state of the output stream from one call to
the next.  Many of the TADS formatting codes are context-sensitive, so
when you're writing a series of strings to the display, it's important
keep track of the global context across strings.  You should use a
separate object for each window or output stream.

<p>If you omit the state object or pass <span class="code">nil</span>, the function will
treat each string as the start of a new stream, with no context from
past calls to the function.  To reset the stream context (for example,
after clearing the window), call its <span class="code">resetState()</span> method.

<p>The function performs the following translations:

<ul class=doublespace>

   <li><span class="code">\n</span> is translated to <span class="code">&lt;BR&gt;</span> when it occurs within a line
   of text, or nothing if it occurs at the start of a new line (ensuring
   that it ends a line, but doesn't produce any blank lines).

   <li><span class="code">\b</span> is translated to <span class="code">&lt;BR&gt;</span> if it occurs at the start of
   a new line, or <span class="code">&lt;BR&gt;&lt;BR&gt;</span> if it occurs within a line of text
   (ensuring that it always produces one blank line).

   <li><span class="code">\^</span> is removed, but causes the next non-markup
   character to be converted to upper-case.

   <li><span class="code">\v</span> is removed, but causes the next non-markup
   character to be converted to lower-case.

   <li><span class="code">\</span>&nbsp; (quoted space) is converted to <span class="code">&amp;nbsp;</span> if it's followed
   by another quoted space, or to a regular space if followed by anything
   else.  This reproduces the standard TADS quoted space behavior: a
   quoted space doesn't combine with adjacent quoted spaces, but does
   allow a line break.  Any regular space characters adjacent to the
   quoted space in the source string are removed.

   <li><span class="code">\t</span> is converted to a series of <span class="code">&amp;nbsp;</span> characters followed
   by one regular space, sufficient to pad the current line to the next
   multiple of four characters in length.  This is a very rough
   approximation of the way <span class="code">\t</span> works in the console UI, but note
   how the algorithm merely counts <i>characters</i>, and doesn't take
   into account font metrics.  

   <p>(Because this doesn't take into account
   font metrics, it's mostly only useful with monospaced fonts.  But
   if you're using the Web UI, you have access to the much greater
   capabilities of full HTML layout, so you shouldn't have much use
   for tabs anyway.)

   <li><span class="code">&lt;Q&gt;</span>...<span class="code">&lt;/Q&gt;</span> tag sequences are converted to
   <span class="code">&amp;ldquo;...&amp;rdquo;</span> and <span class="code">&amp;lsquo;...&amp;rsquo;</span> sequences, alternating
   at each nesting level, with double quotes at the outermost level.

   <li><span class="code">&lt;BR HEIGHT=N&gt;</span> tags are converted to a series of <i>N</i> <span class="code">&lt;BR&gt;</span>
   tags when used at the start of a line, or <i>N</i>+1 <span class="code">&lt;BR&gt;</span> tags when
   used within a line of text.

   <li><span class="code">&lt;P&gt;</span>, <span class="code">&lt;DIV&gt;</span>, <span class="code">&lt;CENTER&gt;</span>, <span class="code">&lt;TABLE&gt;</span>, <span class="code">&lt;TD&gt;</span>, <span class="code">&lt;TH&gt;</span>,
      and <span class="code">&lt;CAPTION&gt;</span>
   tags (both open and close tags) are left exactly as given, but are
   recognized as line breaks for the purposes of translating <span class="code">\n</span>, <span class="code">\b</span>,
   and <span class="code">&lt;BR HEIGHT=N&gt;</span>.
   

</ul>

<p>The <i>stateObject</i> value is for internal use within the
function, and you shouldn't have to access its properties directly.
For reference, though, they are:

<ul class=doublespace>

   <li><span class="code">flags_</span> is an integer containing a number of bit fields:
   <ul>
      <li>0x0001 - on (non-zero) if the stream is in the midst of a line
      of text, off (zero) at the start of a new line

      <li>0x0002 - on if the capitalization flag ('\^') is pending

      <li>0x0004 - on if the lower-case flag ('\v') is pending

      <li>0x0008 - on if an HTML tag is in progress

      <li>0x0010 - on if within a double-quoted attribute value in an HTML tag

      <li>0x0020 - on if within a single-quoted attribute value in an HTML tag

      <li>0x0040 - on if the last character was an ordinary space

      <li>0x0080 - on if the last character was a quoted space ('\ ')

      <li>0x0100 - on if the &lt;Q&gt; tag quote nesting level is odd,
      off if the level is even (at even levels, double quotes are
      used; at odd levels, single quotes are used)

      <li>0x0200 - on if an HTML entity (&amp; sequence) is in progress
      (only used with specialsToText())

      <li>0x3000 - the current tab stop column (shift this value right
      12 bits to get the integer value: that is, compute
      <span class="code">((obj.flags_ &amp; 0x3000) &gt;&gt; 12)</span>.  This is the number of characters
      in the line since the last multiple of 4 columns.
      
   </ul>

   <li><span class="code">tag_</span> is a string containing the text of the tag in progress.
   When a string ends in mid-tag, this contains the fragment of the tag
   up to the end of the string, so that the next call can resume parsing
   the tag where the last call left off.

</ul>


</div>

<a name="specialsToText"></a>
<p><span class="code">specialsToText(<i>stateObject</i>?)</span>
<div class=fdef>

Returns a new string with any special TADS formatting characters in
the "self" string translated to their plain text equivalents.  This
function is similar to specialsToHtml(), but converts the string to
plain text rather than HTML.  The conversion is designed to replicate
the effect of displaying the string through the TADS console output
mechanism, as it would appear on a character-mode terminal.

<p><i>stateObject</i> has the same meaning as in specialsToHtml().

<p>This function performs the following conversions:

<ul class=doublespace>

   <li><span class="code">\n</span> is translated to <span class="code">\n</span> when it occurs within a line
   of text, or nothing if it occurs at the start of a new line (ensuring
   that it ends a line, but doesn't produce any blank lines).

   <li><span class="code">\b</span> is translated to <span class="code">\n</span> if it occurs at the start of
   a new line, or <span class="code">\n\n</span> if it occurs within a line of text
   (ensuring that it always produces one blank line).

   <li><span class="code">\^</span> is removed, but causes the next non-markup
   character to be converted to upper-case.

   <li><span class="code">\v</span> is removed, but causes the next non-markup
   character to be converted to lower-case.

   <li><span class="code">\</span>&nbsp; (quoted space) is converted to a regular space.

   <li><span class="code">&lt;Q&gt;</span>...<span class="code">&lt;/Q&gt;</span> tag sequences are converted to <span class="code">"..."</span> and
   <span class="code">'...'</span> sequences, alternating at each nesting level, with double
   quotes at the outermost level.

   <li><span class="code">&lt;BR HEIGHT=N&gt;</span> tags are converted to a series of <i>N</i> <span class="code">\n</span>
   characters when used at the start of a line, or <i>N</i>+1 <span class="code">\n</span>
   characters when used within a line of text.

   <li><span class="code">&lt;P&gt;</span> is converted to <span class="code">\n</span> if it appears at the start of
   a line, or <span class="code">\n\n</span> within a line.

   <li><span class="code">&lt;DIV&gt;</span>, <span class="code">&lt;CENTER&gt;</span>, <span class="code">&lt;TABLE&gt;</span>, <span class="code">&lt;TD&gt;</span>, <span class="code">&lt;TH&gt;</span>,
      and <span class="code">&lt;CAPTION&gt;</span>
   tags (both open and close tags) are converted to <span class="code">\n</span>.

   <li><span class="code">&lt;Tag&gt;</span> for any tag not mentioned above is simply stripped out.
   
   <li><span class="code">&amp;nbsp;</span> is converted to a space.

   <li><span class="code">&amp;gt;</span> is converted to &gt;.
   
   <li><span class="code">&amp;lt;</span> is converted to &lt;.
   
   <li><span class="code">&amp;amp;</span> is converted to &amp;.
   
   <li><span class="code">&amp;quot;</span>, <span class="code">&amp;ldquo;</span>, and <span class="code">&amp;rdquo;</span> are converted to " (a
   plain double-quote).
   
   <li><span class="code">&amp;lsquo;</span> and <span class="code">&amp;rsquo;</span> are converted to '
   (a plain single-quote).
   
   <li><span class="code">&amp;dddd;</span> (where the <i>d</i>s are digits) is converted to
   the Unicode character with value <i>dddd</i>.


</ul>


</div>



<a name="splice"></a>
<p><span class="code">splice(<i>index</i>, <i>deleteLength</i>, <i>insertString</i>?)</span>
<div class=fdef>

Returns a new string consisting of the original text of this string
with the following two edits: first, the <i>deleteLength</i>
characters starting at index <i>index</i> are deleted; second, the
string <i>insertString</i> is inserted in their place.  The
<i>insertString</i> argument is optional; if omitted, only the
deletion is performed.  If you only want to insert new text, simply
pass 0 for <i>deleteLength</i>.

<p>This function's effect can be achieved by concatenating together
substrings of the original string, but <span class="code">splice()</span> is more concise
and somewhat clearer.  It's also a little more efficient, since it
bypasses the need to create the two intermediate substrings.

</div>


<a name="split"></a>
<p><span class="code">split(<i>delim</i>?, <i>limit</i>?)</span>
<div class=fdef>

Splits a string into substrings defined by the given delimiter.
Returns a list of the substrings.

<p><i>delim</i> is the delimiter, which can be one of the following:

<ul class=doublespace>

   <li>A string.  <span class="code">split</span> searches for exact matches to this
   substring within the subject string, and splits the string at
   each instance.

   <li>A <a href="rexpat.htm">RexPattern</a> object.  The method
   searches for matches to the regular expression, and splits the
   string at each match found.

   <li>An integer, which must be at least 1.  The method splits the
   string into substrings of exactly this length (except that the
   last substring in the list might be shorter, since it'll have
   whatever's left over at the end).

</ul>

<p>If <i>delim</i> is omitted or <span class="code">nil</span>, the default is 1 (i.e.,
split the string into one-character substrings).

<p><i>limit</i> is an optional integer giving the maximum number of
elements to return in the result list.  When the method reaches this
limit, it stops searching and returns the remainder of the string
after the last split as the final element of the list.  If
<i>limit</i> is 1, no splits are possible, so the result is simply a
single-element list containing the entire original string.  If
<i>limit</i> is omitted or <span class="code">nil</span>, the method splits the string at
every instance of the delimiter without a limit.

<p>The delimiter string or pattern <b>isn't</b> included in the result list.

<p>Examples:

<p>
<span class="code">'one,two,three'.split(',')</span> returns <span class="code">['one', 'two', 'three']</span><br>
<span class="code">'one,two,  three,   four'.split(R',&lt;space&gt;*')</span>
   returns <span class="code">['one', 'two', 'three', 'four']</span><br>
<span class="code">'one,two,three'.split(',', 2)</span> returns <span class="code">['one', 'two,three']</span><br>
<span class="code">'abcdefghi'.split(2)</span> returns <span class="code">['ab', 'cd', 'ef', 'gh', 'i']</span>

</div>

<p><span class="code">startsWith(<i>str</i>)</span>
<div class=fdef>

Returns true if this string starts with <i>str</i>, <span class="code">nil</span> if not.
This string starts with <i>str</i> if this string is at least as long
as <i>str</i>, and the first <span class="code">str.length()</span> characters match the
characters of <i>str</i>.

</div>

<p><span class="code">substr(<i>start</i>, <i>length</i>?)</span>
<div class=fdef>

Returns a new string consisting of a substring of this string.  The
substring starts at character index <i>start</i> (the first character
in the string is at index 1).  If <i>length</i> is specified, the
result string is at most <i>length</i> characters long; if
<i>length</i> is not specified, the result runs to the end of the
source string.

<p>If <i>start</i> is negative, it indicates an offset
from the end of the string: -1 indicates that the substring is to
start at the last character, -2 at the second-to-last, and so on.

<p>If <i>length</i> is negative, it indicates the number
of characters to <i>discard</i> from the end of the string.  With a
<i>length</i> of -1, the result is the whole rest of the string
starting at <i>start</i> minus the last character; with -2, it's the
rest after <i>start</i> minus the last 2 characters; and so on.

<p>Examples:

<p><div class="code"><pre>
'abcdef'.substr(3) yields 'cdef'
'abcdef'.substr(3, 2) yields 'cd'
'abcdefghi'.substr(-3) yields 'ghi'
'abcdefghi'.substr(-3, 2) yields 'gh'
'abcdefghi'.substr(1, -1) yields 'abcdefgh'
'abcdefghi'.substr(2, -2) yields 'bcdefg'
'abcdefghi'.substr(4, -2) yields 'defg'
'abcdefghi'.substr(4, -4) yields 'de'
'abcdefghi'.substr(-4, -2) yields 'fg'
</pre></div>

</div>


<a name="toFoldedCase"></a>
<p><span class="code">toFoldedCase()</span>
<div class=fdef>

Returns a new string consisting of the characters of the original
string converted to "folded" case, as defined in the Unicode character
database.  Folded case is designed to erase case differences between
strings, so that two or more strings can be matched or sorted without
regard to case differences.

<p>The case folding of each character is defined by the Unicode
character tables, but the result is usually the same as converting the
character to upper case and then to lower case.  For most characters,
this is the same as simply converting to lower case, but it differs
for a few cases where the upper-case mapping of a lower-case character
results in more than one character.  For example, the German sharp S,
&#223;, converts to upper case as 'SS', so its case folding is lower
case 'ss'.  This allows the strings 'WEISS' and 'wei' to match when
case-folded, for example.  There are a number of other ligatures and
accented characters that undergo similar expansions when case-folded.

</div>


<a name="toLower"></a>
<p><span class="code">toLower()</span>
<div class=fdef>

Returns a new string consisting of the characters of the original
string converted to lower-case.  Only alphabetic characters are
affected; other characters are copied to the new string unchanged.
The conversion uses the case conversions specified in the Unicode
character database, so accented and non-Roman alphabetic characters
are properly converted.

</div>



<a name="toTitleCase"></a>
<p><span class="code">toTitleCase()</span>
<div class=fdef>

Returns a new string consisting of the characters of the original
string converted to title case.  Title case is the same as upper case
for most characters.  It differs for characters that represent
multiple visual characters with a single Unicode character unit, such
as ligatures.  The title case conversion of a ligature consists of the
first character of the ligature in upper case and the rest in lower
case.  For example, the "ffi" ligature, U+FB03, converts to title case
as the letters F, f, i (capital F, small f, small i), and the German
sharp S, &#223;, converts as Ss.

<p>Note that this routine isn't designed to render a string with the
correct capitalization for a title.  This method simply converts each
character individually to title case, without regard to word
boundaries.  This is meant to be used as a building block for a full
title converter; you can use this routine to convert the first
character of each word to title case once you identify the word
boundaries, identify words that aren't capitalized, etc.

</div>



<a name="toUnicode"></a>
<p><span class="code">toUnicode(<i>idx</i>?)</span>
<div class=fdef>

Converts one or all of the characters of this string to Unicode
character codes.

<p>If the <i>idx</i> argument is provided, it specifies the character
index within the string of the single character to convert (the first
character is at index 1), and the method returns an integer containing
the Unicode code point for the character at that index.  A negative
value for <i>idx</i> is an index from the end of the string: -1 is the
last character, -2 the second to last, and so on.

<p>If <i>idx</i> is omitted, the function returns a list of character
codes.  Each element in the list is an integer giving the Unicode code
point value for the corresponding character in the source string.  The
list has one element per character in the source string.

<p>This function can be used to decompose a string into its individual
characters, which is sometimes an easier or more efficient way to
manipulate a string.  You can convert a list of Unicode code point
values back into a string using the <span class="code">makeString()</span> function in the
<a href='tadsgen.htm'>tads-gen</a> function set.

</div>

<a name="toUpper"></a>
<p><span class="code">toUpper()</span>
<div class=fdef>

Returns a new string consisting of the characters of the original
string converted to upper-case.  Only alphabetic characters are
affected; other characters are copied to the new string unchanged.
The conversion uses the case conversions specified in the Unicode
character database, so accented and non-Roman alphabetic characters
are properly converted.

</div>

<p><span class="code">unpackBytes(<i>format</i>)</span>
<div class=fdef>

Unpacks the string, treating the string's characters as byte values
and interpreting the bytes according to the format string.

<p>The string must only contain characters with Unicode values from 0
to 255, since the unpacker treats each character as a byte value.  If
the unpacker encounters any characters outside this range, it'll throw
an error.

<p><i>format</i> is the format string describing the byte formats of
the values to unpack.  The return value is a list containing the
unpacked values.

<p>The string to be unpacked can be one that you previously created
with String.packBytes(), but it doesn't have to be.  As long as the
source string's characters are all in the 0-255 range, the unpacker
will be able to interpret each character as a byte.  For example,
you can use this method to parse plain text strings that use
fixed-width fields:

<p><div class="code"><pre>
local lst = '123456'.unpack('a3 a3');
</pre></div>

<p>This returns the list ['123', '456'].

<p>See <a href="pack.htm">Byte Packing</a> for more information.

</div>

<a name="urlDecode"></a>
<p><span class="code">urlDecode()</span>
<div class=fdef>

Translates a URL-encoded string to plaintext, returning a new string
containing the translated text.  This reverses the effect of
<span class="code">urlEncode()</span>:

<ul>
   <li>%xx sequences are converted to the corresponding characters
   <li>+ is converted to a space character
   <li>everything else is left as-is
</ul>

<p>In addition, the method converts any multi-byte %xx sequences that
form valid UTF-8
characters into the corresponding characters.  For example, the
sequence %C3%A1 represents the character '&aacute;', so
<span class="code">'%C3%A1'.urlDecode()</span> returns <span class=code>'&aacute;'</span>.
Any %xx sequence that doesn't form a valid UTF-8 character is
converted to '?'.

</div>

<a name="urlEncode"></a>
<p><span class="code">urlEncode()</span>
<div class=fdef>

Encodes a string for use in a URL parameter value, returning a new
string containing the encoded text.  This function performs the
following substitutions:

<ul>
   <li>Plain ASCII letters, digits, '-', and '_' characters are
   left unchanged
   <li>Space characters are converted to '+' 
   <li>Other characters are converted to their "%xx" representations
</ul>

<p>The "%xx" representation encodes a special character using its
hexadecimal ASCII or Unicode byte value.  For example, a comma ","
is encoded as "%2C".  Characters outside of the plain ASCII range
(\u0000 to \u007F) are encoded using the multi-byte UTF-8 representation.
For example, '&aacute;' is encoded as '%C3%A1'.

<p>Note that this method is appropriate for encoding <i>components</i>
of URL strings, not <i>entire</i> URL strings.  Applying this method
to an entire URL would encode all of the scheme and path characters
(such as the ":" and "//" in the "http://" prefix), which would make
the string unusable as a URL.  This method is intended only for
encoding the building blocks of URL strings, such as the value portion
of a "?name=value" query parameter.

</div>

</div>
<hr class="navb"><div class="navb">
<i>TADS 3 System Manual</i><br>
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="builtins.htm">The Intrinsics</a> &gt; 
String
<br><span class="navnp"><a class="nav" href="framedesc.htm"><i>Prev:</i> StackFrameDesc</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="strbuf.htm"><i>Next:</i> StringBuffer</a> &nbsp;&nbsp;&nbsp; </span>

</div>
</body>
</html>

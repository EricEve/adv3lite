<html>
<!-- DERIVED FILE - DO NOT EDIT -->

<head>
<title>Object Definitions</title>
<link rel="stylesheet" href="sysman.css" type="text/css">
</head>
<body>
<div class="topbar"><img src="topbar.jpg" border=0></div>
<div class="nav">
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="langsec.htm">The Language</a> &gt; 
Object Definitions
<br><span class="navnp"><a class="nav" href="inherit.htm"><i>Prev:</i> The Object Inheritance Model</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="inlineobj.htm"><i>Next:</i> Inline Objects</a> &nbsp;&nbsp;&nbsp; </span>

</div>
<div class="main">


<h1>Object Definitions</h1>

<p>Objects are the main data structures in a TADS program.

<p>An object is a collection of values, called properties, and
functions, called methods.  Each property and each method has a
property name, which is a symbol that you can use to refer to that
property or method.

<p>An object also has one or more superclasses, also known as base
classes.  An object with a given superclass is said to be a subclass
of the superclass.  In object-oriented programming in general, classes
are used to create a taxonomy of the various types of things that the
program works with; a superclass corresponds to a more general
category in the taxonomy, and a subclass is a specialization of its
superclass.  For example, if we were creating a taxonomy for
furniture, we might have a general base class called Furniture, a
specialized subclass of Furniture called Chair, and an even more
specialized subclass of Chair called Recliner.  In TADS, this
relationship between a generalized superclass and its specialized
subclass is expressed through property inheritance.  A TADS object
inherits all of the properties and methods of its superclasses, as
though the object defined them itself; but by the same token, any
property or method that the object actually does define itself
overrides the inherited version.  So when you define a subclass, the
subclass is automatically just like its superclass (so a Chair starts
off behaving just like any other piece of Furniture), but can also
define its own specializations (overriding properties) that define the
ways it differs from the base class.  Inheritance means that you don't
have to define the same basic features common to every piece of
furniture in every subclass, since they all inherit the basic
definitions from the base class; you only have to define the special
features that work differently in each subclass.

<p>An object can be either static or dynamic.  A static object is one
that's defined directly in your program's source code; it exists
throughout execution of the program.  A dynamic object is one that's
created on the fly while the program runs, using the <span class="code">new</span> operator.
A dynamic object it comes into existence when the <span class="code">new</span> expression
is executed, and exists only as long as it's reachable, meaning that
an active local variable or a property of another object contains a
reference to the object.  Once a dynamic object is no longer
referenced anywhere, TADS automatically deletes the object (through a
process called <a href="gc.htm">garbage collection</a>).

<p>Most TADS programs define lots of static objects, for things like
rooms and the items found within the game world.  An object doesn't
necessarily have to represent a particular item in the game world,
though; objects can also be used for components of items, or for
abstract programming entities.

<h2>Basic object definition syntax</h2>

<p>The most general way to define an object is like this:

<p><div class="syntax"><pre>
<span class=synPar>objectName</span> <span class=synLit>:</span> <span class=synPar>class1</span> <span class=synMark>[</span> <span class=synLit>,</span> <span class=synPar>class2</span> <span class=synMark>...</span> <span class=synMark>]</span> 
   <span class=synPar>propName</span> <span class=synLit>=</span> <span class=synPar>value</span>
   <span class=synPar>methodName</span> <span class=synLit>(</span> <span class=synPar>arg1</span> <span class=synMark>[</span> <span class=synLit>,</span> <span class=synPar>arg2</span> <span class=synMark>...</span> <span class=synMark>]</span>  <span class=synLit>)</span> <span class=synLit>{</span> <span class=synPar>methodBody</span> <span class=synLit>}</span>
<span class=synLit>;</span>
</pre></div>

<p>The first line names the object, and defines its superclass list.
An object must always have at least one superclass, but you can use
the special class name "object" if you want a generic object that is
not based on another object that your program defines.  Note, however,
that if you use "object" as the superclass, it must be the only
superclass.

<p>If you specify more than one superclass, the order of the classes
determines the inheritance order.  The first (left-most) superclass
has precedence for inheritance, so any properties or methods that it
defines effectively override the same properties and methods defined
in subsequent superclasses.

<p>Alternatively, you can write the same thing in a slightly different
way, by enclosing the list of properties in braces:

<p><div class="syntax"><pre>
<span class=synPar>objectName</span> <span class=synLit>:</span> <span class=synPar>class1</span> <span class=synMark>[</span> <span class=synLit>,</span> <span class=synPar>class2</span> <span class=synMark>...</span> <span class=synMark>]</span> 
<span class=synLit>{</span>
   <span class=synPar>propName</span> <span class=synLit>=</span> <span class=synPar>value</span>
   <span class=synPar>methodName</span> <span class=synLit>(</span> <span class=synPar>arg1</span> <span class=synMark>[</span> <span class=synLit>,</span> <span class=synPar>arg2</span> <span class=synMark>...</span> <span class=synMark>]</span>  <span class=synLit>)</span> <span class=synLit>{</span> <span class=synPar>methodBody</span> <span class=synLit>}</span>
<span class=synLit>}</span>
</pre></div>

<p>When you use this alternative syntax, you must place the entire
property list within the braces.  A semicolon is not required at the
end of the object definition using this syntax, because the closing
brace unambiguously ends the definition.  (It's legal to add a
semicolon after the closing brace, though, because a semicolon by
itself is always acceptable as an empty top-level statement.)  You may
optionally place a semicolon after each property definition; the
compiler simply ignores any such semicolons, because it knows the
property list doesn't end until the closing brace.

<p>The two object definition formats - with braces or without - are
identical in meaning; they differ only in appearance.  You can use
either format for any object; the compiler automatically recognizes
which form you're using for each object.

<p>The language allows the two formats purely for your convenience.
Because of the wide range of objects and classes that adventure game
programs tend to define, many objects tend to look better in one
format or the other.  Some authors might find that small objects
composed mostly of data look less cluttered and more compact without
the braces, while larger objects with lots of code benefit from the
more visually structured appearance of the brace format.  Other
authors might simply prefer the brace format in all cases because it's
similar to Java and C++ notation.

<h2>Replacing and modifying objects</h2>

<p>When you're using a library in your program, it's often useful to
be able to replace an object defined in the library with a definition
of your own.  For example, the library might provide a default
implementation for an object that you want to replace with a custom
version, or you might simply want to replace that part of the
library's functionality with a different approach entirely.

<p>You can replace an object or class using the <span class="code">replace</span> keyword.
You put this keyword immediately before your new object definition;
the object definition is otherwise the same as a normal object
definition.  For example:

<p><div class="code"><pre>
replace class LibClass: object
   prop1 = 10
;
</pre></div>

<p><span class="code">replace</span> effectively deletes the original object and replaces it
with your new definition.  You can change everything about the object,
including its superclasses.

<p>While <span class="code">replace</span> is useful, it's even more frequently the case
that you want to supplement a library class or object, instead of
replacing it.  For example, you might want to add some new methods to
the library class, or you might want to override one or two of the
existing methods with new versions.  For this, you use the <span class="code">modify</span>
keyword.  Unlike <span class="code">replace</span>, the <span class="code">modify</span> keyword doesn't let you
change the superclass list: the modified object will have the same
superclasses as the original.  So, when you use <span class="code">modify</span>, you don't
include a new superclass list in the definition; instead, you jump
directly to the properties and methods that you wish to override.

<p><div class="code"><pre>
modify LibClass
  test(x) { return x*2; }
;
</pre></div>

<p>When you use <span class="code">modify</span>, the compiler doesn't delete the original
object.  Instead, it takes the symbol name away from the original,
and gives it to your new object instead.  The old object is kept
around exactly as it was, but without its name.  Your new object
is set up so that it's a subclass of the original (now nameless)
object.  This means that you can use <span class="code">inherited</span> to inherit
the original library implementation of any method you override:

<p><div class="code"><pre>
modify LibClass
  test(x) { return inherited(x) * 2; }
;
</pre></div>

<p>In some cases, you might not want this inheritance behavior: you
might want instead to replace the original class's method rather than
just overriding it, so that you can inherit directly from the original
class's superclass.  For these situations, you can use the <span class="code">replace</span>
keyword on the <i>method</i> definition in the modifier object:

<p><div class="code"><pre>
modify LibClass
  replace test(x) { return inherited(x) * 2; }
;
</pre></div>

<p>The difference between this example and the previous one is that
the <span class="code">inherited(x)</span> in the first example invokes the original
LibClass version of the <span class="code">test()</span> method, whereas the
<span class="code">inherited(x)</span> in the second version invokes the version that the
original LibClass itself inherited from its superclass.

<p>The <b>order</b> of <span class="code">modify</span> and <span class="code">replace</span> definitions is
important.  This is because you can repeatedly modify or replace the
same object - you can apply a <span class="code">modify</span> to an object that's already
been modified, and then apply yet another <span class="code">modify</span> to the same
object later, as many times as you want.  So the only way that the
compiler can sort out which version is the "final" version of the
object is to put the <span class="code">modify</span> and <span class="code">replace</span> definitions in
some kind of well-defined order.

<p>The order that the compiler uses to apply <span class="code">modify</span> and
<span class="code">replace</span> definitions is simply the order in which the definitions
appear in the source code.  Within a single file, each <span class="code">modify</span>
affects the nearest previous definition of the same object within the
file.  You can also modify and replace objects defined in other files,
in which case the order of the operations is determined by the order
of the modules in the project (.t3m) file list.

<p>An important consequence of the ordering rule is that a <span class="code">modify</span>
or <span class="code">replace</span> can never precede the base definition of the object
being modified.  The compiler will display an error if it encounters a
<span class="code">modify</span> or <span class="code">replace</span> before the base definition of the object.


<h2>Property sets</h2>

<p>In some situations, you'll need to define a group of related
properties and methods that share some common root name, and possibly
some common parameters as well.  This situation sometimes occurs, for
example, when you're using a library that defines a naming convention
for the methods that your code provides to handle the individual
processing steps for an event: all of the methods pertain to different
phases of the same event, so the library gives all of the methods a
common portion to their names to help make it clear that they're
related.

<p>The compiler provides a short-hand syntax that makes it easier to
define sets of properties with related names.  The propertyset keyword
introduces a group of property definitions, and specifies a pattern
string that defines the naming convention.  A propertyset pattern
string looks like a regular symbol name enclosed in single quotes,
except that it contains a single asterisk ("*"), which specifies where
the non-common part of the name goes.  Everything else in the string
is the common part of the names of the properties in the set.

<p>For example, suppose you're using a library that defines a set of
method calls that process mouse clicks.  All of the mouse click
methods have a common root name of "onMouse," but then add a suffix
for the individual method: onMouseDown, onMouseMove, onMouseUp.  For
this set of names, the pattern string would be 'onMouse*' - the
asterisk at the end tells the compiler that the only part that differs
from one property to another is at the end of the string.

<p>After the propertyset keyword and the pattern string, you place a
set of otherwise normal property definitions, enclosed in a set of
braces to mark the bounds of the set.  So, the general syntax for a
property set is:

<p><div class="syntax"><pre>
<span class=synLit>propertyset</span> <span class=synLit>'</span><span class=synPar>pattern</span><span class=synLit>'</span>
<span class=synLit>{</span>
   <span class=synPar>propertyList</span>
<span class=synLit>}</span>
</pre></div>

<p>Optionally, you can include a parameter list after the pattern.
The parameter list is a set of common formal parameters that each
method in the set will have, in addition to any parameters the
individual methods define.  Like the name pattern, the parameter list
uses an asterisk ("*") to indicate where the added parameters of each
method go in the list.

<p><div class="syntax"><pre>
<span class=synLit>propertyset</span> <span class=synLit>'</span><span class=synPar>pattern</span><span class=synLit>'</span> <span class=synMark>(</span> <span class=synPar>params</span><span class=synLit>,</span> <span class=synLit>*,</span> <span class=synPar>params</span> <span class=synMark>)</span>  <span class=synLit>{</span> <span class=synPar>propertyList</span> <span class=synLit>}</span>
</pre></div>

<p>This all goes within an object definition - you can put a property
set anywhere a single property could go, and property sets can be
intermingled with regular property definitions (so regular properties
can come before and after a property set).

<p>Here's an example, using the mouse events we proposed above:

<p><div class="code"><pre>
class myWindow: myWidget
  x = 0
  y = 0
  width = 0
  height = 0
  propertyset 'onMouse*'
  {
    Down(x, y, clicks) { ... }
    Move(x, y) { ... }
    Up(x, y) { ... }
  }
;
</pre></div>

<p>The property set syntax is essentially a textual substitution
facility, in that the compiler actually translates the properties
within the property set to their full names based no the pattern
string.  So, the definition of Down in the example above is exactly
the same as though it had been made outside of the property set with a
name of onMouseDown.

<p>Property sets can also specify common parameters to the methods
defined within.  In the example above, each method has the same first
two parameters, x and y, so we can further reduce the amount of typing
by putting these common parameters in the propertyset definition:

<p><div class="code"><pre>
propertyset 'onMouse*' (x, y, *)
{
   Down(clicks) { ... }
   Move { ... }
   Up { ... }
}
</pre></div>

<p>The propertyset definition specifies that every item defined within
has x and y as the first two parameters, and that any additional
parameters go after the two common parameters.  So, the line that
reads "Down(clicks)" actually defines "onMouseDown(x, y, clicks)"
after the propertyset definition is expanded.

<p>You can put a propertyset definition inside another propertyset
definition.  Note, though, that the fully-expanded property names
within a propertyset must be legal symbol names - in particular, they
must fit within the 40-character limit for a TADS identifier.

<h2>Static property initialization</h2>

<p>Most property initializations contain simple compile-time
constants, such as numbers or strings.  However, it is sometimes
useful to be able to initialize a property to a value that isn't a
constant, but which you want computed once and stored.  For example,
you might want to use the "new" operator to create an object and store
a reference to it in a property, but you want to do this just once
when the program starts running.  These types of initializations are
called "static," because they don't change after the program starts
running.

<p>The language provides a simple way to specify non-constant static
initializations.  In a property definition, place the keyword "static"
just before the value to be computed:

<p><div class="code"><pre>
desk: object
   topSurface = static new Surface()
;
</pre></div>

<p>You can place any expression after the "static" keyword.

<p>The compiler evaluates all of the static initializer expressions
just before running <a href='libpre.htm'>pre-initialization</a>.  The
compiler evaluates each static initializer just once, and stores the
result value in the property.  When the property is evaluated at
run-time, the expression is not re-evaluated - the whole point is that
the value is computed once and stored.

<p>Note that static initializers only run when pre-initialization
runs.  So, if you compile your program for debugging, the compiler
won't execute the static initializers, but will leave them for
evaluation at the start of normal execution.

<p>The order in which the compiler executes the static initializers is
arbitrary; however, where there are dependencies among static
initializers, the compiler automatically performs the initializations
in the order required to resolve the dependencies correctly.

<p>For the technically inclined, the technique the compiler uses to
resolve dependency ordering correctly is fairly simple.  The compiler
effectively re-writes each static initializer like so:

<p><div class="code"><pre>
prop = { self.prop = expr; return self.prop; }
</pre></div>

<p>So, if the expression references another property with a static
initializer, it doesn't matter whether or not that initializer has
been executed yet.  If it has, evaluating the property simply
retrieves the value that was already computed and stored in the
property.  If it hasn't, though, evaluating the property not only
evaluates the static initializer expression, but stores the resulting
value in the property; so, when the compiler does get around to
invoking that other static initializer, it finds the property has
already been initialized, so the extra invocation has no effect.

<p>You might note that static initializers are purely a syntactic
convenience, since you can do anything a static initializer can do
using the more general pre-initialization mechanism instead.  However,
there is one practical difference worth noting: the code that is
generated to execute the expression of a static initializer is not
included in the image file.  The compiler knows that a static
initializer expression is only needed during the compilation phase, so
it can eliminate the code generated for the expression when producing
the image file.  The compiler can't make the same assumption about
pre-initialization code, since the same code could be invoked again
during normal execution.

<h2>Anonymous objects</h2>

<p>In many cases, you will not have any need to give an object a name
when you define it.  The compiler accommodates these cases with the
"anonymous object" syntax.

<p>To define an object with no name, simply start the definition with
the class list.  Everything else about the object definition is the
same as for a named object.  For example:

<p><div class="code"><pre>
Item sdesc = "red box" ;
Readable { sdesc = "book" }
</pre></div>

<p>Because an anonymous object doesn't have a symbol that you can use
to refer to the object, you must use some other mechanism to
manipulate the object.  For example, you can use the firstObj() and
nextObj() functions, since iterations with these functions include
anonymous objects.

<h2>Nested objects</h2>

<p>In addition to defining regular properties and methods, you can
define a property as a "nested" object.  This syntax allows you to
define one object within another, and at the same time initialize a
property of the outer object to refer to the inner object.  For
example:

<p><div class="code"><pre>
bottomOfStairs: Room
   name = "Bottom of Stairs"
   desc = "This dark, narrow chamber is just large enough
           to enclose the rusted iron staircase that spirals upwards,
           its top lost in the dusty murk above."
   up: MsgConnector
   {
      desc = "You force yourself to climb the hundreds of stairs..."
      destination = topOfStairs
   }
;
</pre></div>

<p>This example defines, in addition to the object bottomOfStairs, a
separate object of class MsgConnector whose properties desc and
destination are initialized as shown.  The MsgConnector instance has
no name, but evaluating bottomOfStairs.up will yield a reference to
the object.

<p>Whatever it looks like, bottomOfStairs.up is a perfectly normal
property - it's not the name of an object, but is simply a property
that contains a reference to an object.

<p>The example above is almost the same as this:

<p><div class="code"><pre>
bottomOfStairs: Room
   name = "Bottom of Stairs"
   desc = "This dark, narrow chamber is just large enough
           to enclose the rusted iron staircase that spirals upwards,
           its top lost in the dusty murk above."
   up = connector123
;

connector123: MsgConnector
   desc = "You force yourself to climb the hundreds of stairs..."
   destination = topOfStairs
;
</pre></div>

<p>The only difference between the first example and the second is
that the MsgConnector object in the second example has a name
("connector123"), whereas the MsgConnector the first example is
anonymous.  Otherwise, the two examples are equivalent.

<p>The nested object syntax is purely a convenience feature.  You can
always write an equivalent set of object definitions without using any
nesting, simply by defining each nested object as a separate, named
object.  Nesting is sometimes a more compact notation, though, and is
especially useful when defining small "helper" objects.

<p>Note that the nested object's property list must be enclosed in
braces.  You can use template properties in a nested object; these may
appear immediately before or immediately after the object's opening
brace, just as in a regular object definition.

<h3>Finding the enclosing object</h3>

<p>The compiler automatically defines the property lexicalParent in
each nested object as a reference to the lexically enclosing object.
For example, consider the following object definition:

<p><div class="code"><pre>
outer: object
   desc = "This is 'outer'"
   inner: object
   {
     desc = "This is 'inner' - enclosing: &lt;&lt;lexicalParent.desc&gt;&gt;"
   }
;
</pre></div>

<p>If we evaluate outer.inner.desc, we'll see the following displayed:

<p><div class="code"><pre>
This is 'inner' - enclosing: This is 'outer'
</pre></div>

<p>Note that lexicalParent is defined as a property of each nested
object.  This makes it possible for a class specifically designed for
instantiation as nested objects to determine the lexically enclosing
object for each of its instances.


<h2>Inline objects</h2>

<p>The static object definitions we've seen so all go outside of any
function or method code.  You can also define objects directly within
expressions, using the <a href="inlineobj.htm">inline object</a>
syntax.  Inline objects are especially useful when you need to create
a small ad hoc object to serve as an argument to a function.


<h2>Class definition syntax</h2>

<p>You can define a class instead of an object by adding the keyword
"class" before the object name:

<p><div class="syntax"><pre>
<span class=synLit>class</span> <span class=synPar>className</span> <span class=synLit>:</span> <span class=synPar>superclass1</span> <span class=synMark>[</span> <span class=synLit>,</span> <span class=synPar>superclass2</span> <span class=synMark>...</span> <span class=synMark>]</span> 
    <span class=synPar>propertiesAndMethods</span>
<span class=synLit>;</span>
</pre></div>

<p>A class definition is otherwise syntactically identical to an
ordinary object definition.  In particular, you can define properties
and methods for the class just like you can for an object.

<p>Classes behave very much like objects, with a few important
differences:

<ul>

<li>Classes are not included by default in iterations using the
firstObj() and nextObj() functions in the <a
href='tadsgen.htm'>tads-gen intrinsic function set</a>.  (You can,
however, use flags to indicate that you want <i>only</i> classes
instead of objects, or that you want <i>both</i> classes <i>and</i>
ordinary objects.)

<li>The compiler does not include classes when building dictionary
entries based on vocabulary property definitions.

<li>The compiler doesn't count classes in the <span class="code">+</span> location
hierarchy.  This means that you can freely define new classes in the
midst of a hierarchy of objects defined with the <span class="code">+</span> syntax, without
breaking up the location hierarchy.  The compiler knows to leave
<span class="code">class</span> objects out of the <span class="code">+</span> depth counting.

</ul>

<p>You can tell at run-time whether a given object is a class or a
regular object by calling the object's <span class="code">isClass()</span> method.


<h2>Contained objects</h2>

<p>Most TADS games have some sort of "containment" model that relates
objects to one another in a location hierarchy.  In these models, each
object has a container, and containers may in turn be inside other
containers.

<p>The TADS 3 compiler can keep track of a simple containment
hierarchy that gives each object a single container.  This is an
optional feature, so games that use more complex containment models
than the compiler provides do not have to use this feature; however,
games that use a single-container location model can take advantage of
the compiler's location tracking mechanism to simplify object
definitions.

<p>To use the compiler's location tracking, you must first tell the
compiler which property you are using to specify an object's
container.  This is called the "+ property" or "plus property,"
because the object syntax for a contained object uses plus signs.  To
define the plus property, use this statement:

<p><div class="code"><pre>
+ property locationProp ;
</pre></div>

<p>This statement must occur as a top-level statement, outside of any
object or function definitions, and must precede any objects that make
use of the containment syntax.  If you are using this feature, you
should put this statement at the start of your source files.  This
statement has compilation unit scope, so you'll have to put a copy of
this statement at the top of each source file if you're using separate
compilation.  (If you're using the adv3 library, note that the standard
library header "adv3.h" includes a definition like this for you.)

<p>Once you specify the plus property, you can define objects using
the "+" notation: before each object definition, you can insert one or
more plus signs to indicate that the object's location in the
containment tree.  An object with no "+" signs has no implicit
container; an object with one "+" sign is implicitly contained by the
most recent object with no "+" signs; an object with two "+" signs is
implicitly contained by the most recent object with one "+" sign; and
so on.

<p>The inner workings of the "+" property are simple: whenever you use
one or more "+" signs to define an object, the compiler automatically
initializes that object's "+" property to the implied container.

<p>For example:

<p><div class="code"><pre>
// define the '+' property
// (we need this only once per source file)
+ property location;

iceCave: Room
   sdesc = "Ice Cave"
;

+ nastyKnife: Item
   sdesc = "nasty knife"
;

+ rustyKnife: Item
   sdesc = "rusty knife"
;
</pre></div>

<p>We start by specifying that "location" is the "+" property.  We
then define the object iceCave with no "+" signs, which specifies no
implicit setting for its location property.  Next, we define the
object nastyKnife using one "+" sign: this indicates that
nastyKnife.location is initialized to iceCave, because iceCave is the
most recent object defined with no "+" signs.  Finally, we defined
rustyKnife with one "+" sign; again, this object's location is
initialized to iceCave, because it's still the last object with no "+"
signs.

<p>You can use the "+" syntax to any depth.  Here's an example with
several levels of containers:

<p><div class="code"><pre>
+ property location;

office: Room
   sdesc = "Office"
;

+ desk: Surface
   sdesc = "desk"
;

++ fileBox: Container
   sdesc = "file box"
;

+++ greenFile: Container
   sdesc = "green file folder"
;

++++ letter: Readable
   sdesc = "letter"
;

++++ memo: Readable
   sdesc = "memo"
;

+++ redFile: Container
   sdesc = "red file folder"
;

++ pen: Item
   sdesc = "pen"
;

+ chair: Chair
   sdesc = "chair"
;
</pre></div>

<p>The desk and chair are located directly in the office, the file box
and pen are on the desk, the green and red files are in the file box,
and the letter and memo are in the green file.  Each object except
office has a location property set to its container.

<h3>Anonymous contained objects</h3>

<p>You can combine the anonymous object syntax and the contained
object syntax for an especially concise way of defining objects.  We
could rewrite the example above much more compactly:

<p><div class="code"><pre>
office: Room
   sdesc = "Office"
;

+ Surface sdesc = "desk" ;

++ Container sdesc = "file box" ;

+++ Container sdesc = "green file folder" ;
++++ Readable sdesc = "letter" ;
++++ Readable sdesc = "memo" ;

+++ Container sdesc = "red file folder" ;

++ Item sdesc = "pen" ;

+ Chair sdesc = "chair" ;
</pre></div>

<h2>sourceTextOrder</h2>

<p>The compiler automatically adds the property sourceTextOrder to
each non-class object, and sets the property to an integer giving the
relative order of the object definition in its source file.  The
sourceTextOrder value is guaranteed to increase monotonically
throughout a source file.

<p>This property is useful because it lets you reliably determine the
order of objects in a source file.  There's no other way to do this;
for example, you can't count on object loops, using firstObj() and
nextObj(), to iterate over the game's objects in any particular order.
It's often useful to be able to construct a run-time data structure
(such as a list or a tree) so that the objects appear in the same
order as they did in the source file, and sourceTextOrder is the way
to do this.

<p>The sourceTextOrder value is only useful for determining the
relative order of objects in a single source module.  The compiler
resets the counter at the start of each new source file, so it's not
meaningful to compare this property for objects defined in different
modules.

<h2><a name="sourceTextGroup">sourceTextGroup</a></h2>

<p>The compiler can optionally add another property to each object
that gives you information on which module defined the object.
If you compile with the "-Gstg" option, <i>or</i> use the
directive <tt>#pragma sourceTextGroup(on)</tt>, the compiler
adds the property sourceTextGroup to each non-class object, and
sets the property to refer to an anonymous object.  One such
anonymous object is created per source module, so you can tell
that two objects were defined in the same source module when
the two objects have the same sourceTextGroup value.

<p>The anonymous object itself has two properties, which the compiler
automatically sets when creating the object.  The first is
sourceTextGroupName: this is set to a string giving the name of the
defining module, as it appeared in the compiler command line, makefile
(.t3m), or library (.tl) file.  The second is sourceTextGroupOrder:
this is an integer giving the relative order of the defining module
among all of the modules in the overall program.

<p>You can use sourceTextGroup in conjunction with sourceTextOrder to
establish the order of source-file appearance for objects throughout
the entire program.  For a given object x,
x.sourceTextGroup.sourceTextGroupOrder gives you the position of the
defining module among all of the modules making up the program;
x.sourceTextOrder then gives you the relative order of x within its
own source module.


<h2>Object templates</h2>

<p>In addition to the generic property list syntax, the TADS compiler
provides an alternative property definition syntax using object
templates.  (These have nothing to do with what C++ calls templates,
which are parameterized types.)  An object template lets you define an
object's properties positionally, rather than by naming each property
explicitly in the object definition.  Templates provide a concise
syntax for defining properties that you use frequently.

<p>To define objects using templates, you must first define the
templates themselves.  You define a template using the object template
statement:

<p><div class="syntax"><pre>
<span class=synPar>objectName</span> <span class=synLit>template</span> <span class=synMark>[</span> <span class=synPar>item1</span> <span class=synMark>[</span> <span class=synLit>,</span> <span class=synPar>item2</span> <span class=synMark>...</span> <span class=synMark>]</span>  <span class=synMark>]</span>  <span class=synLit>;</span>
</pre></div>

<p>You can also define a template that is specific to instances of a
class and all of its subclasses (including subclasses of subclasses,
to any depth):

<p><div class="syntax"><pre>
<span class=synPar>className</span> <span class=synLit>template</span> <span class=synMark>[</span> <span class=synPar>item1</span> <span class=synMark>[</span> <span class=synLit>,</span> <span class=synPar>item2</span> <span class=synMark>...</span> <span class=synMark>]</span>  <span class=synMark>]</span>  <span class=synLit>;</span>
</pre></div>

<p>Each item in the list is a placeholder for a property; it specifies
the name of the property to assign to the position, and how you will
write the property value.  Each item in a template can be written in
one of these formats:

<ul>

<li>As a single-quoted string

<li>As a double-quoted string

<li>As a list

<li>As an operator character followed by a value, where the operator
is one of these:  + - * / % -> &amp; ! ~ ,

<li>The inherited keyword

</ul>

<p>Each item is written as an example of how you will supply the
item's value in each object, with the item's property name taking the
place of the actual value.  For a single-quoted string, write the
property name in single quotes; for a double-quoted string, write the
property name in double quotes; for a list, write the property name in
square brackets; and when you use an operator, write the operator and
then the property name.

<p>An item can be made optional by adding a question mark ("?")
immediately after the item.  When the template definition is matched
to an object definition, the compiler will allow an optional item to
be omitted.  The "?" symbol applies only to the immediately preceding
item; there's no grouping syntax that would allow a single "?" to
apply to multiple items.  If you want to make multiple items optional,
you must put a question mark after each optional item.

<p>Two or more alternatives can be given for a single item by
separating the alternatives with the vertical bar ("|") symbol.
Exactly one of the alternative template items will be matched to an
object definition.  The "|" symbol applies only to the directly
adjacent items; there's no syntax for grouping alternatives involving
multiple items.  A group of alternatives can be optional, but only as
a group: if any item in an alternative group is marked as optional,
then the entire group is optional.

<p>If one of the items in the template list is the keyword inherited,
it indicates that the template "inherits" the templates of its
superclasses, and that the superclass items are to appear at the same
point in the template as the inherited keyword.  The effect is exactly
the same as if you had defined a set of templates with each superclass
template substituted for the inherited keyword in the new template,
plus one extra definition with nothing substituted for inherited.  To
illustrate, suppose that you make the following definitions:

<p><div class="code"><pre>
class A: object;
class B: A;

A template 'name';
A template 'name' "desc";
B template 'author' inherited;
</pre></div>

<p>The last template, for class B, is identical to defining each
possible inherited template explicitly.  In other words, you could
replace the last line above with the following:

<p><div class="code"><pre>
B template 'author';
B template 'author' 'name';
B template 'author' 'name' "desc";
</pre></div>

<p>The inherited keyword can appear at any point in the item list;
superclass template items are substituted at the point at which
inherited appears.  This provides flexibility so that you can inherit
the items from the superclass templates at the beginning, end, or in
the middle of the new template's item list.

<h3>Template examples</h3>

<p>As an example of using templates, here's a template definition that
specifies three properties: the first is the location, which is marked
with an "at" sign; the second is the short description in double
quotes; and the third is the long description in double quotes.

<p><div class="code"><pre>
object template @location "sdesc" "ldesc";
</pre></div>

<p>Once you define a template, you can use it in object definitions.
To use a template, simply put the data definitions for the template's
items before the object definition's normal property list, immediately
after the object's class list.  For example, to use the template
above, we could write this:

<p><div class="code"><pre>
poemBook: Book @schoolDesk "poem book" 
   "It's a book of poems. "
   readPoem(num)
   {
      if (num == 1) ; // etc
   }
   poem1 = "The first poem is by someone named Wadswurth. "
;
</pre></div>

<p>Note that you don't have to put any properties after the template
data for the object, but if you do, you define them using exactly the
same syntax that you use for a non-template object.

<p>Here's an example of a template with an optional item:

<p><div class="code"><pre>
Thing template 'name' "desc"? ;

cardTable: Thing 'card table';
lamp: Thing 'lamp' "It's a fairly ordinary desk lamp. ";
</pre></div>

<p>The single template matches both object definitions, because the
"desc" item can be omitted or included as desired.

<p>An example using alternation:

<p><div class="code"><pre>
Message template 'name' "messageText" | [messageList];

Message 'one' "This is message one.";
Message 'two' ['Message 2a.', 'Message 2b.', 'Message 2c.'];
</pre></div>

<p>In this example, the second item in the template can either be a
double-quoted string, or it can be a list.  (The contents of the list
don't matter to the template.)

<h3>How the compiler selects templates</h3>

<p>Templates don't have names.  The compiler figures out which
template you want to use purely based on the superclass and on types
of the values in the object definition.  For the Book example above,
the compiler sees that you want to use template data consisting of a
value with the "@" symbol followed by two double-quoted strings; the
compiler scans its list of templates and comes up with the template we
defined earlier.  This means that you must take care not to define two
identical templates, because the compiler will not be able to tell
them apart.  If you do define identical templates, then the compiler
will "break the tie" by using the one defined earliest in the source
file.

<p>Note that using optional and alternative items can sometimes create
duplicate templates that aren't obviously duplicates.  For example,
consider these templates:

<p><div class="code"><pre>
Thing template 'vocab' 'name'?;
Thing template 'vocab' 'name' 'desc'?;

Thing 'book' 'It\'s a dusty old tome. ';
</pre></div>

<p>In this case, it's pretty clear to a human reader that the object
definition meant to use the second template - but the compiler will
pick the first, because it matches just as well and it occurs earlier
in the source file.

<p>Another situation where templates can be ambiguous in form is
multiple inheritance.  For example:

<p><div class="code"><pre>
A template 'name';
B template 'desc';

myObj: B, A 'this is myObj!';
</pre></div>

<p>In this case, the object inherits a matching template from each of
its superclasses.  In this case, though, the compiler has a better way
of choosing among the templates than just using the source file order:
it uses the superclass inheritance order.  So, even though A's
template is defined before B's, the fact that myObj inherits from B
first, then from A, means that B's template is chosen over A's.  So in
this case, myObj.desc is the property that's set to the string 'this
is myObj!'.

<h3>Template inheritance</h3>

<p>You can use template inheritance to include superclass templates as
continuations of templates for more specialized classes.  For example,
suppose we wanted to define a couple of basic templates for our Thing
class, like so:

<p><div class="code"><pre>
Thing template 'name';
Thing template 'name' "desc";
</pre></div>

<p>These two templates allow us to define any Thing instance with a name, and optionally with a description.  Now, suppose we define Book as a subclass of Thing, and we want to allow Book instances to define an additional property giving the author of the book.  Since Book is a Thing, we still want each Book to be able to define the basic Thing properties.  The obvious way to do this would be to create a template for Book with only the author property, plus another with the author and name, and another with the author, name, and description:  

<p><div class="code"><pre>
Book template 'author';
Book template 'author' 'name';
Book template 'author' 'name' "desc";
</pre></div>

<p>If we had more than two Thing templates, though, this would become
tedious.  It would also create a maintenance problem: if we ever
wanted to add more Thing templates or change the existing Thing
templates, we'd have to remember to make the corresponding changes to
the Book templates as well.

<p>Fortunately, the compiler offers a better way to define the
extended Book templates: template inheritance.  If you want a template
for a subclass - Book, in this case - to include the templates of its
superclasses in addition to its own templates, you can simply add the
inherited keyword at the point in the template where you want the
inherited templates to go.

<p>For our Book template, we'd use template inheritance like so:

<p><div class="code"><pre>
Book template 'author' inherited;
</pre></div>

<p>This single statement is exactly equivalent to the three we gave
earlier, but it's obviously a lot less work to type this definition,
and the definition automatically adjusts to any changes you make to
the Thing templates.

<h3>Templates and object definition syntax variations</h3>

<p>If you use braces around your property list, you can put the
template properties either immediately before or immediately after the
open brace:

<p><div class="code"><pre>
// template properties can go outside the braces...
book1: Book @shelf "red book"
{
   ldesc = "It's a red book."
}

// ...or immediately after an open brace
book2: Book
{
   @shelf "blue book"
   ldesc = "It's a blue book."
}
</pre></div>

<p>You can use templates with anonymous objects, as well as with
objects that use the "+" containment specification syntax:

<p><div class="code"><pre>
+ Container "back-pack" "It's a green back-pack. " ;
++ Item "puzzle cube" "You haven't seen one of these in year. ";
</pre></div>

<h3>Scope and placement of template definitions</h3>

<p>The scope of a template is limited to a single compilation unit.
If you are separating your program into several source files, each
file must separately define the templates it uses.  The easiest way to
define templates in several files is to put the "object template"
statements into a header file, and then include the header in each
file; this way, you only have to write the templates once, and if you
modify them later, you only need to make changes in one place.

<p>Object template statements must appear as top-level statements,
outside of any function or object definitions.  A template can only be
used after it has been defined, so you should normally define your
templates near the start of each source file.  Typically, games and
libraries should define the templates they use in a header file so
that all source modules can include the same template definitions.

<h3>Templates and dictionary properties</h3>

<p>You cannot use a <a href='dict.htm'>dictionary property</a> in an
object template.  Dictionary properties are excluded because of the
special syntax they use (a dictionary property can have its value set
to a list of single-quoted strings, without any grouping brackets for
the list).  If you could use a dictionary property in a template, it
would be possible to create ambiguous templates, because the compiler
might not be able to tell if a single-quoted string were meant to be
another entry in the same property list or a separate property in the
template.

<a name="transient"></a>
<h2>Persistent and transient objects</h2>

<p>The T3 VM has a built-in subsystem that can save a snapshot of the
state of all of the objects in the system, and later restore the same
set of objects.  This type of saving and restoring is referred to as
"persistence," because it lets a set of objects outlive a particular
VM session; one could save a set of objects to a file on the
computer's hard disk, exit the program, turn off the computer, and
return later - even weeks or months later - and restore the state of
the objects just as they were when they were saved.
 
<p>The VM provides two other mechanisms related to saving and
restoring.  First, the VM is capable of "restarting" the program,
which resets all of the objects in the program to their initial state,
as they were when the program was initially loaded.  Second, the VM
can save multiple in-memory snapshots of the program, called
"savepoints," and then roll back changes since a snapshot; this is
called the "undo" mechanism, because it allows changes made since a
given point in time to be reversed.

<p>Taken together, these four features - save, restore, undo, restart
- are called the "persistence" mechanisms of the T3 VM.

<p>The persistence mechanisms are all completely automatic.  To save
the current state, for example, the program simply calls a function
(saveGame(), in the <a href='tadsgen.htm'>tads-gen function set</a>),
providing the name of a file; the VM automatically creates a file with
the given name and writes the state of all of the objects in the
system to the file.  To restore the same state later, the program
calls another function (restoreGame()), providing the name of the file
previously saved.

<p>In some cases, it is desirable to prevent an object from being
saved, restored, undone, or reset.  For example, if an object is used
to keep track of some part of the user interface, you probably
wouldn't want to save and restore the object, because you wouldn't
want the user interface's state to be affected by a Restore operation.
When an object isn't part of the persistent state of the program, the
object is called "transient."

<p>Transient objects are extremely useful for certain tasks because
they "survive" the restore, undo, and restart operations.  For
example, if you've played the Infocom game <i>Planetfall</i>, you
might remember that Floyd the robot makes little remarks when you save
a game or undo.  You could implement even more elaborate behavior of
this kind by using a transient object to keep track of how many times
the player has performed these operations.  Since a transient object
isn't overwritten by a restore or undo, you can use it to keep track
of the whole history of the session.  You could also use a transient
object to keep track of option settings that affect the overall
session, so that the settings aren't lost by being reset to the saved
version if the user should restore a saved game.  Another use might
be a session timer that remembers how long the program has been
running, irrespective of restores and undos.

<p>The terminology - "transient" and "persistent" - can be confusing
unless you have the right perspective.  If you think in terms of the
running program, the terminology seems backwards: transient objects
seem more permanent than the persistent ones, because they survive
operations like Restore and Restart.  Instead, think about persistence
in terms of saving data to a hard disk: persistent objects can be
saved and restored, but transient objects are fleeting, lasting only
as long as the VM is running.

<p>By default, every object is persistent.  This means that the VM
automatically saves, restores, resets, and undoes every object, unless
you specify otherwise.

<p>To make an object transient, you use the "transient" keyword in
TADS.  This keyword can be used in two different ways.

<p>First, when you're defining an object directly in your source code,
you can preface the object definition with the "transient" keyword.
The object definition is otherwise exactly like any other.  For
example:

<p><div class="code"><pre>
transient mainOutputStream: OutputStream
   // etc
;
</pre></div>

<p>Second, when you're creating an object dynamically, you can place
the "transient" keyword immediately after the "new" operator:

<p><div class="code"><pre>
local x = new transient Vector(10);
</pre></div>

<p>In addition, the <a href='tadsobj.htm'>TadsObject</a> intrinsic
class provides the createTransientInstance() method to create a
transient instance of a class.

<p>Note that transient objects won't be reset by the low-level
restartGame() function, but they will be affected by the regular
initialization steps if you're using the <a hef='startup.htm'>default
startup code</a>.  The startup code doesn't pay any attention to
transient-ness when running the initialization steps - in particular,
it will execute InitObject and (if necessary) PreinitObject instances
regardless of whether they're persistent or transient.

<p>Some intrinsic class types are inherently transient.  For example,
a <a href="framedesc.htm"><span class="code">StackFrameDesc</span></a> object is always
transient.  For such objects you don't have to specify <span class="code">new transient</span>
when you create them; they'll just be naturally transient
because of the way they're implemented within the system.

<h3>Interactions between transient and persistent objects</h3>

<p>For the most part, you don't have to worry about whether an
object is transient or persistent for ordinary use.  The two kinds of
objects work the same way most of the time; the differences only
appear during restore, undo, and restart operations.

<p>When you save a game, the system simply omits any transient objects
from the saved state.  But what happens if you have a persistent
object that refers to a transient object through one of its
properties?  In this case, the system simply saves a <span class="code">nil</span> value for
the property that points to the transient object, because the
transient object itself isn't stored in the file.  When you restore
the game, the persistent object will be restored, and the property
that contained the transient object reference will be <span class="code">nil</span>.


</div>
<hr class="navb"><div class="navb">
<i>TADS 3 System Manual</i><br>
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="langsec.htm">The Language</a> &gt; 
Object Definitions
<br><span class="navnp"><a class="nav" href="inherit.htm"><i>Prev:</i> The Object Inheritance Model</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="inlineobj.htm"><i>Next:</i> Inline Objects</a> &nbsp;&nbsp;&nbsp; </span>

</div>
</body>
</html>

<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>Command</title></head><body>
<table class=ban><tr><td align=left><span class=title>Command</span><span class=type>class</span><td align=right><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#15">15</a>], <a href="../file/english.t.html">english.t</a>[<a href="../source/english.t.html#2105">2105</a>]</table><p>
<table class=nav><tr>
<td><a href="#_SuperClassTree_">Superclass<br>Tree</a>
<td><a href="#_SubClassTree_">Subclass<br>Tree</a>
<td><a href="#_ObjectSummary_">Global<br>Objects</a>
<td><a href="#_PropSummary_">Property<br>Summary</a>
<td><a href="#_MethodSummary_">Method<br>Summary</a>
<td><a href="#_Properties_">Property<br>Details</a>
<td><a href="#_Methods_">Method<br>Details</a>
</table><div class=fdesc>
   A Command describes the results of parsing one player predicate - that   is, a single verb phrase, with all its parts.  This includes the   action to be performed and the objects to perform it on.  It also   includes information on the text of the player's input, and how it   maps onto the grammar structures defined by the language module. <p>   The Command object is built in several steps, so its contents aren't   complete until all of the steps are completed. 
<p><i>Modified in <a href="../file/english.t.html">english.t</a>[<a href="../source/english.t.html#2105">2105</a>]:</i><br>
   Modification to the Command class so that when reconstructing a command   string from its tokens a separate apostrophe-S token is concatenated with   the previous word when storing the name (which undoes the effect on   building the name of what the English-language tokenizer does with   apostrophe-S). 
<p>
<code>class 
<b>Command</b> :  &nbsp; object</code>
</div>
<a name="_SuperClassTree_"></a><p><div class=mjhd><span class=hdln>Superclass Tree</span> &nbsp; (in declaration order)</div><p>
<code><b>Command</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; object</code><br>
<a name="_SubClassTree_"></a><p><div class=mjhd><span class=hdln>Subclass Tree</span> &nbsp; </div><p>
<code><b>Command</b></code><br>
<code> &nbsp; &nbsp; &nbsp; &nbsp; <a href="../object/FuncCommand.html">FuncCommand</a></code><br>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Global Objects</span> &nbsp; </div><p>
<i>(none)</i>
<a name="_PropSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Properties</span> &nbsp; </div><p>
<code>
<a href="#acc">acc</a>&nbsp; 
<a href="#accInfo">accInfo</a>&nbsp; 
<a href="#accNPs">accNPs</a>&nbsp; 
<a href="#accs">accs</a>&nbsp; 
<a href="#action">action</a>&nbsp; 
<a href="#actions">actions</a>&nbsp; 
<a href="#actor">actor</a>&nbsp; 
<a href="#actorNPs">actorNPs</a>&nbsp; 
<a href="#actorPerson">actorPerson</a>&nbsp; 
<a href="#actors">actors</a>&nbsp; 
<a href="#afterReports">afterReports</a>&nbsp; 
<a href="#aobj">aobj</a>&nbsp; 
<a href="#badMulti">badMulti</a>&nbsp; 
<a href="#cmdErr">cmdErr</a>&nbsp; 
<a href="#disambig">disambig</a>&nbsp; 
<a href="#disambigIdx">disambigIdx</a>&nbsp; 
<a href="#dobj">dobj</a>&nbsp; 
<a href="#dobjInfo">dobjInfo</a>&nbsp; 
<a href="#dobjNPs">dobjNPs</a>&nbsp; 
<a href="#dobjs">dobjs</a>&nbsp; 
<a href="#endOfSentence">endOfSentence</a>&nbsp; 
<a href="#implicitActionReports">implicitActionReports</a>&nbsp; 
<a href="#iobj">iobj</a>&nbsp; 
<a href="#iobjInfo">iobjInfo</a>&nbsp; 
<a href="#iobjNPs">iobjNPs</a>&nbsp; 
<a href="#iobjs">iobjs</a>&nbsp; 
<a href="#lastAction">lastAction</a>&nbsp; 
<a href="#madeTopic">madeTopic</a>&nbsp; 
<a href="#matchedAll">matchedAll</a>&nbsp; 
<a href="#matchedMulti">matchedMulti</a>&nbsp; 
<a href="#miscWordLists">miscWordLists</a>&nbsp; 
<a href="#missingNouns">missingNouns</a>&nbsp; 
<a href="#nextTokens">nextTokens</a>&nbsp; 
<a href="#npList">npList</a>&nbsp; 
<a href="#npListSorted">npListSorted</a>&nbsp; 
<a href="#npToResolve">npToResolve</a>&nbsp; 
<a href="#originalAction">originalAction</a>&nbsp; 
<a href="#parseTree">parseTree</a>&nbsp; 
<a href="#predActive">predActive</a>&nbsp; 
<a href="#predPriority">predPriority</a>&nbsp; 
<a href="#priority">priority</a>&nbsp; 
<a href="#reflexiveAnte">reflexiveAnte</a>&nbsp; 
<a href="#tokenLen">tokenLen</a>&nbsp; 
<a href="#verbProd">verbProd</a>&nbsp; 
</code><p>
<a name="_MethodSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Methods</span> &nbsp; </div><p>
<code>
<a href="#addDisambigNP">addDisambigNP</a>&nbsp; 
<a href="#addNounListItem">addNounListItem</a>&nbsp; 
<a href="#addNounProd">addNounProd</a>&nbsp; 
<a href="#afterReport">afterReport</a>&nbsp; 
<a href="#buildCommandString">buildCommandString</a>&nbsp; 
<a href="#buildObjLists">buildObjLists</a>&nbsp; 
<a href="#calcPriority">calcPriority</a>&nbsp; 
<a href="#changeAction">changeAction</a>&nbsp; 
<a href="#clone">clone</a>&nbsp; 
<a href="#cloneNP">cloneNP</a>&nbsp; 
<a href="#construct">construct</a>&nbsp; 
<a href="#emptyNounRole">emptyNounRole</a>&nbsp; 
<a href="#exec">exec</a>&nbsp; 
<a href="#execCombos">execCombos</a>&nbsp; 
<a href="#execDoer">execDoer</a>&nbsp; 
<a href="#execIter">execIter</a>&nbsp; 
<a href="#fetchDisambigReply">fetchDisambigReply</a>&nbsp; 
<a href="#fixPriority">fixPriority</a>&nbsp; 
<a href="#forEachNP">forEachNP</a>&nbsp; 
<a href="#forEachObj">forEachObj</a>&nbsp; 
<a href="#getCommandPhrase">getCommandPhrase</a>&nbsp; 
<a href="#noteMiscWords">noteMiscWords</a>&nbsp; 
<a href="#npTokenLen">npTokenLen</a>&nbsp; 
<a href="#numNounSlots">numNounSlots</a>&nbsp; 
<a href="#resolveNouns">resolveNouns</a>&nbsp; 
<a href="#resolveReflexive">resolveReflexive</a>&nbsp; 
<a href="#saveReflexiveAnte">saveReflexiveAnte</a>&nbsp; 
<a href="#sortList">sortList</a>&nbsp; 
<a href="#startDisambigReply">startDisambigReply</a>&nbsp; 
<a href="#terseOK">terseOK</a>&nbsp; 
</code><p>
<a name="_Properties_"></a><p><div class=mjhd><span class=hdln>Properties</span> &nbsp; </div><p>
<a name="acc"></a>
<table class=decl><tr><td><code>acc</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1244">1244</a>]</table><div class=desc>the accessory object for the current iteration<p>
</div>
<a name="accInfo"></a>
<table class=decl><tr><td><code>accInfo</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1250">1250</a>]</table><div class=desc>the NPMatch object for the current accessory<p>
</div>
<a name="accNPs"></a>
<table class=decl><tr><td><code>accNPs</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1238">1238</a>]</table><div class=desc>the accessory phrases, as a list of NounPhrase objects<p>
</div>
<a name="accs"></a>
<table class=decl><tr><td><code>accs</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1241">1241</a>]</table><div class=desc>the list of resolved accessory objects, as NPMatch objects<p>
</div>
<a name="action"></a>
<table class=decl><tr><td><code>action</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1185">1185</a>]</table><div class=desc>the Action object giving the action to be performed<p>
</div>
<a name="actions"></a>
<table class=decl><tr><td><code>actions</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#341">341</a>]</table><div class=desc>A list of actions executed directly by this command or via a Doer<p>
</div>
<a name="actor"></a>
<table class=decl><tr><td><code>actor</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1194">1194</a>]</table><div class=desc>the resolved actor; we determine this before disambiguation<p>
</div>
<a name="actorNPs"></a>
<table class=decl><tr><td><code>actorNPs</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1197">1197</a>]</table><div class=desc>the actor(s) to whom the command is addressed, as a NounPhrase list<p>
</div>
<a name="actorPerson"></a>
<table class=decl><tr><td><code>actorPerson</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1211">1211</a>]</table><div class=desc>   The grammatical person in which we're addressing the actor.  This   is 2 for a second-person address, 3 for third-person orders.   (It's hard to think of a case for first-person orders, but <p>   The conventional IF syntax for giving orders is ACTOR, DO   SOMETHING, which addresses ACTOR in the second person (as YOU).   This means that second-person pronouns <p>
</div>
<a name="actors"></a>
<table class=decl><tr><td><code>actors</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1200">1200</a>]</table><div class=desc>the actor(s), as NPMatch objects<p>
</div>
<a name="afterReports"></a>
<table class=decl><tr><td><code>afterReports</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#354">354</a>]</table><div class=desc>   A list of strings containing reports to be displayed at the end of the   command execution cycle for this command. <p>
</div>
<a name="aobj"></a>
<table class=decl><tr><td><code>aobj</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1247">1247</a>]</table><div class=desc>synonym for the accessory object<p>
</div>
<a name="badMulti"></a>
<table class=decl><tr><td><code>badMulti</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1300">1300</a>]</table><div class=desc>   Error flag: we have a noun list (grammatically) where a single   noun is required.  When this occurs, this will be set to the role   where the error was noted. <p>
</div>
<a name="cmdErr"></a>
<table class=decl><tr><td><code>cmdErr</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1317">1317</a>]</table><div class=desc>   The error we encountered building the command, if any.  This is   usually a noun resolution error. <p>
</div>
<a name="disambig"></a>
<table class=decl><tr><td><code>disambig</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1262">1262</a>]</table><div class=desc>   Disambiguation replies.  Each time the player answers a   disambiguation question, we add the reply to this list.  We then   go back and re-resolve the noun phrases, fetching replies from the   list as we encounter the ambiguous objects again. <p>   Note that this is a list of list.  Each reply is a list of   NounPhrase objects, and we might have a series of replies, so one   list represents one reply. <p>
</div>
<a name="disambigIdx"></a>
<table class=decl><tr><td><code>disambigIdx</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1265">1265</a>]</table><div class=desc>the next available disambiguation reply<p>
</div>
<a name="dobj"></a>
<table class=decl><tr><td><code>dobj</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1220">1220</a>]</table><div class=desc>the current direct object for the current action iteration<p>
</div>
<a name="dobjInfo"></a>
<table class=decl><tr><td><code>dobjInfo</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1223">1223</a>]</table><div class=desc>the NPMatch object for the current iteration's direct object<p>
</div>
<a name="dobjNPs"></a>
<table class=decl><tr><td><code>dobjNPs</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1214">1214</a>]</table><div class=desc>the direct object phrases, as a list of NounPhrase objects<p>
</div>
<a name="dobjs"></a>
<table class=decl><tr><td><code>dobjs</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1217">1217</a>]</table><div class=desc>the list of resolved direct objects, as NPMatch objects<p>
</div>
<a name="endOfSentence"></a>
<table class=decl><tr><td><code>endOfSentence</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1275">1275</a>]</table><div class=desc>   Is this command at the end of a sentence?  The grammar match sets   this to true if the input syntax puts this predicate at the end of   a sentence.  For example, in the English grammar, this is set if   there's a period after this predicate.  This tells the parser that   the next predicate in the same line is the start of a new   sentence, so sentence-opening syntax is allowed. <p>
</div>
<a name="implicitActionReports"></a>
<table class=decl><tr><td><code>implicitActionReports</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#383">383</a>]</table><div class=desc>   A list of reports of previous implicit actions performed in the course   of executing this command which can be used if we need to collate a   report of a stack of implicit actions. <p>
</div>
<a name="iobj"></a>
<table class=decl><tr><td><code>iobj</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1232">1232</a>]</table><div class=desc>the indirect object for the current iteration<p>
</div>
<a name="iobjInfo"></a>
<table class=decl><tr><td><code>iobjInfo</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1235">1235</a>]</table><div class=desc>the NPMatch object for the current indirect object<p>
</div>
<a name="iobjNPs"></a>
<table class=decl><tr><td><code>iobjNPs</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1226">1226</a>]</table><div class=desc>the indirect object phrases, as a list of NounPhrase objects<p>
</div>
<a name="iobjs"></a>
<table class=decl><tr><td><code>iobjs</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1229">1229</a>]</table><div class=desc>the list of resolved indirect objects, as NPMatch objects<p>
</div>
<a name="lastAction"></a>
<table class=decl><tr><td><code>lastAction</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1188">1188</a>]</table><div class=desc>the Previous action performed by this command<p>
</div>
<a name="madeTopic"></a>
<table class=decl><tr><td><code>madeTopic</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1327">1327</a>]</table><div class=desc><i>no description available</i><p>
</div>
<a name="matchedAll"></a>
<table class=decl><tr><td><code>matchedAll</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1322">1322</a>]</table><div class=desc>Does this command apply to objects matched to ALL?<p>
</div>
<a name="matchedMulti"></a>
<table class=decl><tr><td><code>matchedMulti</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1325">1325</a>]</table><div class=desc>Does this command apply to objects matched to multiple objects?<p>
</div>
<a name="miscWordLists"></a>
<table class=decl><tr><td><code>miscWordLists</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1126">1126</a>]</table><div class=desc>   List of noun phrases containing misc word phrases.  The misc word   phrase grammar rules will notify us when they're visited in the   build process, and we'll note them here. <p>
</div>
<a name="missingNouns"></a>
<table class=decl><tr><td><code>missingNouns</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1132">1132</a>]</table><div class=desc>   Do we have any missing or empty noun phrases in the match?  The   verb and noun phrases will fill this in. <p>
</div>
<a name="nextTokens"></a>
<table class=decl><tr><td><code>nextTokens</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1311">1311</a>]</table><div class=desc>   The token list for the next predicate.  The first predicate   production fills this in during the build process with the token   list for the next predicate on the same command line, based on the   location of the conjunction or punctuation that ends the first   predicate.  This is just what's left of the token list after the   tokens used for our own predicate and after any conjunctions or   punctuation marks that separate our predicate from the next one. <p>
</div>
<a name="npList"></a>
<table class=decl><tr><td><code>npList</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1285">1285</a>]</table><div class=desc>   The noun phrase roles (as NounRole objects), in the order they   actually appear in the user input.  We build this list as the   VerbProduction adds our noun phrases.  The phrase order is   important when there are reflexive pronouns, because a reflexive   pronoun generally refers back to the nearest preceding phrase of   the same number and gender. <p>
</div>
<a name="npListSorted"></a>
<table class=decl><tr><td><code>npListSorted</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1293">1293</a>]</table><div class=desc>   A copy of the npList sorted to ensure that the direct and indirect   objects of a TIAction are verified in the order specified on that   action. <p>
</div>
<a name="npToResolve"></a>
<table class=decl><tr><td><code>npToResolve</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#895">895</a>]</table><div class=desc>   If the parser has just asked the player to supply a missing object via   the askMissingObject() function, we don't want to resolve the nouns for   every object role, but only for the role with which askMissingObject()   is currently concerned; askMissingObject() stores that role here so   that our resolvedNouns() method knows to resolve only the noun for this   role rather than for all the roles in the command. If npToResolve is   nil (as it normally will be) then it will be ignored, and all noun   roles will be resolved. <p>
</div>
<a name="originalAction"></a>
<table class=decl><tr><td><code>originalAction</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#347">347</a>]</table><div class=desc>   The originalAction this Command started out with, which may be changed   by a Doer (or some other mechanism) <p>
</div>
<a name="parseTree"></a>
<table class=decl><tr><td><code>parseTree</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1182">1182</a>]</table><div class=desc>   The parse tree (the root of the grammar match), if applicable.   Commands built from user input have a parse tree; those built   internally don't.  Note that the parse tree doesn't necessarily   include *all* of the user input, since we could have asked   questions (disambiguation, missing noun phrases) before the   command was completed.  The question replies will be represented   in noun phrases or other data added to the command after the   initial parse. <p>
</div>
<a name="predActive"></a>
<table class=decl><tr><td><code>predActive</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1170">1170</a>]</table><div class=desc>is our predicate currently active (see VerbProduction.isActive)<p>
</div>
<a name="predPriority"></a>
<table class=decl><tr><td><code>predPriority</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1167">1167</a>]</table><div class=desc>the predicate priority (see VerbProduction.priority)<p>
</div>
<a name="priority"></a>
<table class=decl><tr><td><code>priority</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1119">1119</a>]</table><div class=desc>the calculated priority<p>
</div>
<a name="reflexiveAnte"></a>
<table class=decl><tr><td><code>reflexiveAnte</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#986">986</a>]</table><div class=desc>table of reflexive pronoun antecedents<p>
</div>
<a name="tokenLen"></a>
<table class=decl><tr><td><code>tokenLen</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1150">1150</a>]</table><div class=desc>   The number of tokens from the command line that we matched for the   command.  The CommandProduction object sets this for us as it   builds the command from the parse tree.  We use this to determine   the priority order of the syntax matches, when there are multiple   matches: other things being equal, we'll take the longest match.   Longer matches are better because they come closer to using   everything the user typed, which is our eventual goal. <p>   This reflects the number of tokens used in the first predicate   phrase; it omits any additional predicates or conjunctions.  We   only count the first predicate because we always go back and   re-parse any additional text on the line from scratch after   executing the first predicate, in case the execution changes the   game state in such a way that the parsing changes. <p>
</div>
<a name="verbProd"></a>
<table class=decl><tr><td><code>verbProd</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1191">1191</a>]</table><div class=desc>the VerbProduction object for the command<p>
</div>
<a name="_Methods_"></a><p><div class=mjhd><span class=hdln>Methods</span> &nbsp; </div><p>
<a name="addDisambigNP"></a>
<table class=decl><tr><td><code>addDisambigNP (prod)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#705">705</a>]</table><div class=desc>   Add a disambiguation list item.  This adds a NounPhrase item to   the current reply list. <p>
</div>
<a name="addNounListItem"></a>
<table class=decl><tr><td><code>addNounListItem (role, prod)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#633">633</a>]</table><div class=desc>add a noun phrase to the given role (a NounRole)<p>
</div>
<a name="addNounProd"></a>
<table class=decl><tr><td><code>addNounProd (role, prod)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#615">615</a>]</table><div class=desc>   Add a noun production, building it out as though it had been part   of the original parse tree.  This can be used to add a noun phrase   after the initial parsing, such as when the player supplies a   missing object. <p>
</div>
<a name="afterReport"></a>
<table class=decl><tr><td><code>afterReport ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#365">365</a>]</table><div class=desc>   Run through our list of afterReports displaying each in turn. We do   this on the Command rather than on any of the Actions since actions may   invoke other actions (implicit, remapped, nested or replaced), while   the afterReports pertain to the command as a whole. <p>
</div>
<a name="buildCommandString"></a>
<table class=decl><tr><td><code>buildCommandString ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#334">334</a>], <a href="../file/english.t.html">english.t</a>[<a href="../source/english.t.html#2106">2106</a>]</table><div class=desc>   Rebuild the original command string from the tokens. We call this out   as a separate method so language-specific code can override it. <p>
</div>
<a name="buildObjLists"></a>
<table class=decl><tr><td><code>buildObjLists ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#902">902</a>]</table><div class=desc>   Build the object lists.  This runs through each NounPhrase in the   command to build its 'objs' list, then builds the corresponding   master list in the Command object. <p>
</div>
<a name="calcPriority"></a>
<table class=decl><tr><td><code>calcPriority ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1091">1091</a>]</table><div class=desc>   Calculate the parsing priority. <p>   When the parser looks for grammar rule matches to the input, it   considers *all* of the possible matches.  Natural language is full   of syntactic ambiguity, so a given input string can often be   parsed into several different, but equally valid, syntax trees.   It's often impossible to tell which parsing is correct based on   syntax alone - you often have to look at the overall meaning of   the sentence.  For example, GIVE BOOK TO BOB could be interpreted   as having a direct object (BOOK) and an indirect object (BOB), or   it could be seen as having only a direct object (BOOK TO BOB,   treating the TO as a prepositional phrase modifying BOOK rather   than as a part of the verb phrase structure).  The initial parsing   phase only looks at the syntax, so it has to consider all of the   valid phrase structures, even though a human speaker would   immediately dismiss many of them as nonsensical.  Once we find all   of the syntax matches, the parser puts them into priority order,   and then goes down the list looking for the first one that makes   sense semantically (which is defined roughly as having noun   phrases that refer to actual objects). <p>   The priority, then, represents our guess at the likelihood that   the grammar structure matches the user's intentions, based on the   syntax.  Our fundamental assumption is that the command is valid:   that is, it's well-formed grammatically, AND it expresses   something that's possible, or at least logical to try, within the   game-world context.  Given this, our strategy is to find a grammar   structure that gives us a command that we can actually carry out. <p>   The priority is a composite value, made up of weighted component   values.  We combine the components into a single scalar value   simply by adding up the parts multiplied by their weights.  (Or,   looked at another way, we combine the values using a high-radix   numbering system.)  The components are, from most significant to   least significant: <p>   - Grammatically correct commands sort ahead of commands with   structural errors. <p>   - The predicate priority, from the VerbProduction.  (This tells us   how "complete" the predicate structure is: a predicate with   missing information has a lower priority.  This is in keeping with   our assumption that the user's input is well-formed - we'll try   the most complete structures first before falling back on the   possibility that the user left out some information.) <p>   - Filled noun slots ahead of missing noun slots.  A missing noun   slot occurs when the player leaves one of the noun roles empty   (PUT BOX, TAKE).  We can fill in this information with automatic   defaults, so it's not necessarily a reason to reject the parsing,   but if there's another interpretation that has fully occupied noun   slots, try the occupied one first. <p>   - More noun phrase slots first.  For example, sort a command with   a direct and indirect object (two slots) ahead of one with only a   direct object.  More slots means that we found more "structure" in   the command; we can sometimes interpret the same command with less   structure by subsuming more words into a long noun phrase. <p>   - Longest noun phrases, in aggregate, first.  This is in terms of   tokens matched from the user input.  (We want to consider longer   noun phrases first because it's more likely that they'll match   exact objects, so there's less chance of ambiguity, *and* it's   more likely that if we're wrong about the structure, we'll simply   fail to find a matching object and move on to other parse trees.   Longer noun phrases are less likely to yield spurious matches   simply because they have more words that have to match.) <p>   - Grammatical noun phrases take priority over misc word phrases (a   misc word phrase is text in a noun phrase slot that doesn't match   any of the defined patterns in the grammar rules). <p>   - Longest command first, in terms of tokens matched from the user   input.  (The more user input we use the better, since that gives   us more confidence that we're correctly interpreting what the user   said.  When we leave extra tokens for later, we can't be sure that   we'll be able to make any sense of what's left over, whereas   tokens in the current match are known to fit a grammar rule.) <p>
</div>
<a name="changeAction"></a>
<table class=decl><tr><td><code>changeAction (newAct, newDo, newIo, newAo)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#497">497</a>]</table><div class=desc>Change the action to a new action with a new set of objects<p>
</div>
<a name="clone"></a>
<table class=decl><tr><td><code>clone ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#129">129</a>]</table><div class=desc>clone - create a new Command based on this Command<p>
</div>
<a name="cloneNP"></a>
<table class=decl><tr><td><code>cloneNP (np)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#154">154</a>]</table><div class=desc>clone a noun phrase that's part of this command<p>
</div>
<a name="construct"></a>
<table class=decl><tr><td><code>construct ([args])</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#41">41</a>]</table><div class=desc>   Create the command object.  There are several ways to create a   command: <p>   new Command(parseTree) - create from a parsed command syntax tree. <p>   new Command(action, dobjProd...) - create from a given Action and   a set of parsed syntax trees for the noun phrases.  The first noun   phrase is the direct object, the second is the indirect object,   and the third is the accessory. <p>   new Command(action, dobjs...) - create from a given Action and a   set of objects or object lists for the noun slots.  The first   argument after the Action, dobjs, can be a single Mentionable   object to use as the resolved direct object, or a list or vector   of Mentionables to use as the multiple direct objects.  The next   argument is in the same format and is used for the indirect   object.  The third is the accessory. <p>   new Command(actor, action, dobjs...) - create from a given actor   (as a Mentionable object), an Action object, and the object list. <p>   new Command() - create a blank Command, for setting up externally   or in a subclass. <p>
</div>
<a name="emptyNounRole"></a>
<table class=decl><tr><td><code>emptyNounRole (role)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#732">732</a>]</table><div class=desc>mark a noun phrase role as empty<p>
</div>
<a name="exec"></a>
<table class=decl><tr><td><code>exec ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#183">183</a>]</table><div class=desc>   Execute the action.  This carries out the entire command   processing sequence for the action.  If the action involves a list   of objects (as in TAKE ALL or DROP BOOK AND CANDLE), we iterate   over the listed objects, executing the action on each object in   turn. <p>
</div>
<a name="execCombos"></a>
<table class=decl><tr><td><code>execCombos (predRoles, n, lst)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#394">394</a>]</table><div class=desc>   Execute the command for each combination of objects for noun role index   'n' and above.  'lst' is a list containing a partial object combination   for roles at lower indices.  We iterate over each combination of the   remaining objects. predRoles is a list containing predicate roles (such   DirectObject, IndirectObject, AccessoryObject) relating to this action.   Callers are responsible for sorting predRoles into the correct order   before calling this method. <p>
</div>
<a name="execDoer"></a>
<table class=decl><tr><td><code>execDoer (lst)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#474">474</a>]</table><div class=desc>   Execute the command via the Doers that match the command's action   and objects.  'lst' is the object combination to execute: [action,   dobj, iobj, ...]. <p>
</div>
<a name="execIter"></a>
<table class=decl><tr><td><code>execIter (lst)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#441">441</a>]</table><div class=desc>   Execute one iteration of the command for a particular combination   of objects.  'lst' is the object combination to execute: this is   an [action, dobj, iobj, ...] list. <p>
</div>
<a name="fetchDisambigReply"></a>
<table class=decl><tr><td><code>fetchDisambigReply ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#724">724</a>]</table><div class=desc>   Fetch a disambiguation reply.  If we have more replies available,   this returns the next reply's noun phrase list, otherwise nil. <p>
</div>
<a name="fixPriority"></a>
<table class=decl><tr><td><code>fixPriority ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1108">1108</a>]</table><div class=desc>   Set a fixed priority.  This makes the priority a fixed value   rather than a calculated value.  We call this before sorting a   list of commands, so that we don't have to recalculate the   priority value repeatedly during the sort. <p>
</div>
<a name="forEachNP"></a>
<table class=decl><tr><td><code>forEachNP (func)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#870">870</a>]</table><div class=desc>carry out a callback for each noun phrase in each list<p>
</div>
<a name="forEachObj"></a>
<table class=decl><tr><td><code>forEachObj (func)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#524">524</a>]</table><div class=desc>   Invoke a callback for each object in the current command   iteration.  This invokes the callback on the direct object,   indirect object, accessory, and any other custom roles added by   the game. <p>
</div>
<a name="getCommandPhrase"></a>
<table class=decl><tr><td><code>getCommandPhrase ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1335">1335</a>]</table><div class=desc>   Get the command phrase entered by the player, with the words used to   match the direct, indirect and accessory objects replaced by (dobj),   (iobj) and (acc) respectively; e.g. PUT RED BALL ON TABLE becomes 'put   (dobj) on (iobj)' <p>
</div>
<a name="noteMiscWords"></a>
<table class=decl><tr><td><code>noteMiscWords (np)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1111">1111</a>]</table><div class=desc>note a noun phrase with a miscellaneous word list<p>
</div>
<a name="npTokenLen"></a>
<table class=decl><tr><td><code>npTokenLen ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1153">1153</a>]</table><div class=desc>Calculate the sum of the token lengths of our noun phrases<p>
</div>
<a name="numNounSlots"></a>
<table class=decl><tr><td><code>numNounSlots ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#1164">1164</a>]</table><div class=desc>Calculate the number of noun slots we have filled in<p>
</div>
<a name="resolveNouns"></a>
<table class=decl><tr><td><code>resolveNouns ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#746">746</a>]</table><div class=desc>resolve the noun phrases<p>
</div>
<a name="resolveReflexive"></a>
<table class=decl><tr><td><code>resolveReflexive (pronoun)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#968">968</a>]</table><div class=desc>   Resolve a reflexive pronoun on behalf of one of the NounPhrases   within this command. <p>
</div>
<a name="saveReflexiveAnte"></a>
<table class=decl><tr><td><code>saveReflexiveAnte (obj)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#940">940</a>]</table><div class=desc>   Save a potential antecedent for a reflexive pronoun coming up   later in the command.  Each time we visit a noun phrase during the   reflexive pronoun phase, we'll note its resolved objects here.   Since we visit the noun phrases in their order of appearance in   the command, we'll naturally always have the latest one mentioned   when we come to a reflexive pronoun.  This gives us the correct   resolution, which is the nearest preceding noun.  Note that the   noun phrase shouldn't call this routine to note reflexive   pronouns, since they don't bind to earlier reflexive pronouns -   they only bind to regular noun phrases. <p>
</div>
<a name="sortList"></a>
<table class=decl><tr><td><code>sortList (cmdLst)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#995">995</a>]</table><div class=desc>   Class method: Sort a list of Command matches, in priority order.   The priority order is the order for processing predicate grammar   matches: start at the highest priority, and work through the list   until you find one where the noun phrases resolve to valid   game-world objects; that's the one to execute. <p>
</div>
<a name="startDisambigReply"></a>
<table class=decl><tr><td><code>startDisambigReply (parent, prod)</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#689">689</a>]</table><div class=desc>   Start processing a new disambiguation reply.  This adds a reply to   a disambiguation question. <p>
</div>
<a name="terseOK"></a>
<table class=decl><tr><td><code>terseOK ( )</code><td align=right><code><a href="../file/command.t.html">command.t</a>[<a href="../source/command.t.html#569">569</a>]</table><div class=desc>   Are terse messages OK for this command?  A terse message is a   simple acknowledgment of a standard command, such as "Taken",   "Dropped", "Done", etc.  The action is so ordinary that the result   of a successful attempt should be obvious to the player; so the   only reply needed is an acknowledgment, not an explanation. <p>   Terse replies only apply to simple actions, and only when the   actor is the player character, AND there's no disambiguation   involved.  If the actor isn't the PC, an acknowledgment isn't   sufficient; we should instead describe the NPC carrying out the   action, since it's something we observe, not something we do.  If   any objects were disambiguated, we also want to describe the   action fully, because the ambiguity calls for a description of   precisely which objects were chosen.  Disambiguation guesses are   sometimes wrong, so when they're involved, it's not safe to assume   that the player and parser must both be thinking the same thing.   Showing a full description of the action will make it obvious to   the player when we guessed wrong, because the description won't   accord with what they had in mind.  A terse acknowledgment would   hide this difference, allowing the player to wrongly assume that   the parser did what they thought it was going to do and   potentially leading to confusion down the road. <p>
</div>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 28/03/2016 from adv3Lite version 1.5</div>
</body>
</html>

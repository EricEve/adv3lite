<html>
<head><link rel=stylesheet type="text/css" href="../libref.css"><title>multmeth.t</title></head><body>
<table class=ban><tr><td align=left><span class=title>multmeth.t</span><span class=type>file</span><td align=right><a href="../source/multmeth.t.html">source file</a></table><p>
<table class=nav><tr>
<td><b>Classes</b><br><a href="#_ClassSummary_">Summary</a><br>&nbsp;<td><b>Objects</b><br><a href="#_ObjectSummary_">Summary</a><br>&nbsp;<td><b>Functions</b><br><a href="#_FunctionSummary_">Summary</a><br><a href="#_Functions_">Details</a></table><div class=fdesc>
 <p>   This module provides the run-time component of "multi-methods" in TADS   3.  This works with the compiler to implement a multiple-dispatch   system. <p>   Multi-methods are essentially a combination of regular object methods   and "overloaded functions" in languages like C++.  Like a regular   object method, multi-methods are polymorphic: you can define several   incarnations of the same function name, with different parameter   types, the system picks the right binding for each invocation   dynamically, based on the actual argument values at run-time.  Unlike   regular methods, though, the selection is made on ALL of the argument   types, not just a special "self" argument.  In that respect,   multi-methods are like overloaded functions in C++; but multi-methods   differ from C++ overloading in that the selection of which method to   call is made dynamically at run-time, not at compile time. <p>   There are two main uses for multi-methods. <p>   First, most obviously, multi-methods provide what's known as "multiple   dispatch" semantics.  There are some situations (actually, quite a   few) where the ordinary Object Oriented notion of polymorphism -   selecting a method based on a single target object - doesn't quite do   the trick, because what you really want to do is select a particular   method based on the *combination* of objects involved in an operation.   Some canonical examples are calculating intersections of shapes in a   graphics program, where you want to select a specialized "Rectangle +   Circle" routine in one case and a "Line + Polygon" routine in another;   or performing file format conversions, where you want to select, say,   a specialized "JPEG to PNG" routine.  In an IF context, the obvious   use is for carrying out multi-object verbs, where you might want a   special routine for PUT (liquid) IN (vessel), and another for PUT   (object) IN (container). <p>   Second, multi-methods offer a way of extending a class without having   to change the class's source code.  Since a multi-method is defined   externally to any classes it refers to, you can create a method that's   polymorphic on class type - just like a regular method - but as a   syntactically stand-alone function.  This feature isn't as important   in TADS as in some other languages, since TADS lets you do essentially   the same thing with the "modify" syntax; but for some purposes the   multi-method approach might be preferable aesthetically, since it's   wholly external to the class rather than a sort of lexically separate   continuation of the class's code.  (However, as a practical matter,   it's not all that different; our implementation of multi-methods does   in fact modify the original class object, since we store the binding   information in the class objects.) 
</div>
<a name="_ClassSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Classes</span> &nbsp; </div><p>
<code>
<a href="../object/_MultiMethodInheritCtx.html">_MultiMethodInheritCtx</a>&nbsp; 
<a href="../object/_MultiMethodPlaceholder.html">_MultiMethodPlaceholder</a>&nbsp; 
<a href="../object/UnboundInheritedMultiMethod.html">UnboundInheritedMultiMethod</a>&nbsp; 
<a href="../object/UnboundMultiMethod.html">UnboundMultiMethod</a>&nbsp; 
</code>
<a name="_ObjectSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Global Objects</span> &nbsp; </div><p>
<code>
<a href="../object/_multiMethodEndOfList.html">_multiMethodEndOfList</a>&nbsp; 
<a href="../object/_multiMethodNonObjectBindings.html">_multiMethodNonObjectBindings</a>&nbsp; 
<a href="../object/_multiMethodRegistry.html">_multiMethodRegistry</a>&nbsp; 
</code>
<a name="FunctionSummary_"></a><p><div class=mjhd><span class=hdln>Summary of Global Functions</span> &nbsp; </div><p>
<code>
<a href="#_multiMethodBuildBindings">_multiMethodBuildBindings</a>&nbsp; 
<a href="#_multiMethodCall">_multiMethodCall</a>&nbsp; 
<a href="#_multiMethodCallInherited">_multiMethodCallInherited</a>&nbsp; 
<a href="#_multiMethodInherit">_multiMethodInherit</a>&nbsp; 
<a href="#_multiMethodInheritMain">_multiMethodInheritMain</a>&nbsp; 
<a href="#_multiMethodRegister">_multiMethodRegister</a>&nbsp; 
<a href="#_multiMethodSelect">_multiMethodSelect</a>&nbsp; 
<a href="#getMultiMethodPointer">getMultiMethodPointer</a>&nbsp; 
</code><p>
<a name="_Functions_"></a><p><div class=mjhd><span class=hdln>Global Functions</span> &nbsp; </div><p>
<a name="_multiMethodBuildBindings"></a>
<table class=decl><tr><td><code>_multiMethodBuildBindings ( )</code><td align=right><code><a href="../file/multmeth.t.html">multmeth.t</a>[<a href="../source/multmeth.t.html#518">518</a>]</table><div class=desc>   Build the method bindings.  The compiler generates a call to this   after all methods have been registered; we run through the list of   registered methods and generate the binding properties in the   referenced objects. <p>
</div>
<a name="_multiMethodCall"></a>
<table class=decl><tr><td><code>_multiMethodCall (baseFunc, args)</code><td align=right><code><a href="../file/multmeth.t.html">multmeth.t</a>[<a href="../source/multmeth.t.html#76">76</a>]</table><div class=desc>   Invoke a multi-method function.  For an expression of the form <p> <br>    f(a, b, ...) <p>   where 'f' has been declared as a multi-method, the compiler will   actually generate code that invokes this function, like so: <p> <br>    _multiMethodCall(baseFunc, params); <p>   'baseFunc' is a function pointer giving the base function; this is a   pointer to the common stub function that the compiler generates to   identify all of the multi-methods with a given name.  'params' is a   list giving the actual parameter values for invoking the function. <p>   Our job is to find the actual run-time binding for the function given   the actual parameters, and invoke it. <p>
</div>
<a name="_multiMethodCallInherited"></a>
<table class=decl><tr><td><code>_multiMethodCallInherited (fromFunc, [args])</code><td align=right><code><a href="../file/multmeth.t.html">multmeth.t</a>[<a href="../source/multmeth.t.html#105">105</a>]</table><div class=desc>   Invoke the base multi-method inherited from the given multi-method.   'fromFunc' is a pointer to a multi-method, presumably the one   currently running; we look up the next in line in inheritance order   and invoke it with the given argument list. <p>
</div>
<a name="_multiMethodInherit"></a>
<table class=decl><tr><td><code>_multiMethodInherit (fromFunc, prop, args)</code><td align=right><code><a href="../file/multmeth.t.html">multmeth.t</a>[<a href="../source/multmeth.t.html#291">291</a>]</table><div class=desc>   Select the INHERITED version of a multi-method.  This takes a   particular version of the multi-method, and finds the next version in   inheritance order. <p>   This is basically a copy of _multiMethodSelect(), with a small amount   of extra logic.  This code repetition isn't good maintenance-wise, and   the two functions could in principle be merged into one.  However,   doing so would have an efficiency cost to _multiMethodSelect(), which   we want to keep as lean as possible. <p>
</div>
<a name="_multiMethodInheritMain"></a>
<table class=decl><tr><td><code>_multiMethodInheritMain (ctx, fromFunc, prop, args)</code><td align=right><code><a href="../file/multmeth.t.html">multmeth.t</a>[<a href="../source/multmeth.t.html#301">301</a>]</table><div class=desc><i>no description available</i><p>
</div>
<a name="_multiMethodRegister"></a>
<table class=decl><tr><td><code>_multiMethodRegister (baseFunc, func, params)</code><td align=right><code><a href="../file/multmeth.t.html">multmeth.t</a>[<a href="../source/multmeth.t.html#495">495</a>]</table><div class=desc>   Register a multi-method. <p>   The compiler automatically generates a call to this function during   pre-initialization for each defined multi-method.  'baseFunc' is a   pointer to the "base" function - this is a stub function that the   compiler generates to refer to the whole collection of multi-methods   with a given name.  'func' is the pointer to the specific multi-method   we're registering; this is the actual function defined in the code   with a given set of parameter types.  'params' is a list of the   parameter type values; each parameter type in the list is given as a   class object (meaning that the parameter matches that class), nil   (meaning that the parameter matches ANY type of value), or the string   '...' (meaning that this is a "varargs" function, and any number of   additional parameters can be supplied at this point in the parameters;   this is always the last parameter in the list if it's present). <p>
</div>
<a name="_multiMethodSelect"></a>
<table class=decl><tr><td><code>_multiMethodSelect (prop, args)</code><td align=right><code><a href="../file/multmeth.t.html">multmeth.t</a>[<a href="../source/multmeth.t.html#205">205</a>]</table><div class=desc>   Resolve a multi-method binding.  This function takes a binding   property ID (the property we assign during the registration process to   generate the binding tables) and a "remaining" argument list.  This   function invokes itself recursively to traverse the arguments from   left to right, so at each recursive invocation, we lop off the   leftmost argument (the one we're working on currently) and pass in the   remaining arguments in the list. <p>   We look up the binding property on the first argument in the remaining   argument list.  This can yield one of three things: <p>   - The trivial result is nil, which means that this binding property   has no definition on the first argument.  This doesn't necessarily   mean that the whole function is undefined on the arguments; it only   means that the current inheritance level we're looking at for the   previous argument(s) has no binding.  If we get this result we simply   return nil to tell the caller that it must look at an inherited   binding for the previous argument. <p>   - If the result is a function pointer, it's the bound function.  This   is the final result for the recursion, so we simply return it. <p>   - Otherwise, the result will be a new property ID, giving the property   that resolves the binding for the *next* argument.  In this case, we   use this property to resolve the next argument in the list by a   recursive invocation.  If that recursive call succeeds (i.e., returns   a non-nil value), we're done - we simply return the recursive result   as though it were our own.  If it fails, it means that there's no   binding for the particular subclass we're currently working on for the   first argument - however, there could still be a binding for a parent   class of the first argument.  So, we iterate up to any inherited   binding for the first argument, and if we find one, we try again with   the same recursive call.  We continue up our first argument's class   tree until we either find a binding (in which case we return it) or   exhaust the class tree (in which case we return nil). <p>
</div>
<a name="getMultiMethodPointer"></a>
<table class=decl><tr><td><code>getMultiMethodPointer (baseFunc, [args])</code><td align=right><code><a href="../file/multmeth.t.html">multmeth.t</a>[<a href="../source/multmeth.t.html#153">153</a>]</table><div class=desc>   Get a pointer to a resolved multi-method function.  This takes a   pointer to the base function for the multi-method and a list of actual   argument values, and returns a function pointer to the specific   version of the multi-method that would be invoked if you called the   multi-method with that argument list. <p>   For example, if you want to get a pointer to the function that would   be called if you were to call foo(x, y, z), you'd use: <p> <br>    local func = getMultiMethodPointer(foo, x, y, z); <p>   We return a pointer to the individual multi-method function that   matches the argument list, or nil if there's no matching multi-method. <p>
</div>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 28/03/2016 from adv3Lite version 1.5</div>
</body>
</html>

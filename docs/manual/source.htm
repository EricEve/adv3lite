<html>
<!-- DERIVED FILE - DO NOT EDIT -->

<head>
<title>Actions &mdash; Action Reference</title>
<link rel="stylesheet" href="sysman.css" type="text/css">
</head>
<body>
<div class="topbar"><img src="topbar.jpg" border=0></div>
<div class="nav">
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="action.htm">Actions</a> &gt;
Source
<br><span class="navnp"><a class="nav" href="actionref.htm"><i>Prev:</i> ActionReference</a> &nbsp;&nbsp;&nbsp; <i>Next:</i> <a class="nav" href="actionref.htm">ActionReference</a> &nbsp;&nbsp;&nbsp;</span>

</div>
<div class="main">
<h1>Source Reference</h1>

<p>This file contains <em>extracts</em> from various library source files, intended for reference from the <a href="actionref.htm">Action Reference</a>. It is not a complete listing. For complete listings please see the actual source files.</p>

 <p><div class="code"><pre>
<h2>action.t</h2>
/* 
 *   A <a name="TravelAction">TravelAction</a> is one that moves (or at least tries to move) the player
 *   character from one place to another via a command like GO NORTH, or EAST.
 */

class TravelAction: Action
    
    baseActionClass = TravelAction
    
    <span class="comment">/* 
     *   Use the inherited handling but first make a note of the direction the
     *   actor wants to travel in.
     */</span>
    execCycle(cmd)
    {
        <span class="comment">/* 
         *   Obtain the direction from the verbProd of the current command
         *   object, unless this TravelAction already defines its direction
         */</span>
        if(!predefinedDirection)
           direction = cmd.verbProd.dirMatch.dir; 
        
        IfDebug(actions, 
                    &quot;[Executing &lt;&lt;actionTab.symbolToVal(baseActionClass)&gt;&gt; 
                    &lt;&lt;direction.name&gt;&gt;]\n&quot; );
        
        <span class="comment">/* Carry out the inherited handling. */</span>
        inherited(cmd);
    }
    
    
    <span class="comment">/* 
     *   Does this TravelAction already define a set direction on its direction
     *   property (so we don't need to look to what direction object the command
     *   refers)?
     */</span>
    predefinedDirection = nil
    
    <span class="comment">/* 
     *   Execute the travel command, first carrying out any implicit actions
     *   needed to facilitate travel
     */</span>
    
    execAction(cmd)
    {        
        
        <span class="comment">/* 
         *   If the actor is not directly in the room, treat OUT as a request to
         *   get out of the immediate container.
         */</span>
        if(!gActor.location.ofKind(Room) &amp;&amp; direction == outDir)
        {
            replaceAction(GetOff, gActor.location);
            return;
        }
             
        <span class="comment">/* 
         *   If the actor is not directly in the room, make him/her get out of
         *   his immediate container(s) before attempting travel.
         */</span>
        
        while(!gActor.location.ofKind(Room))
        {
           <span class="comment"> /* Note the actor's current location. */</span>
            local loc = gActor.location;
            
            <span class="comment">/* 
             *   Try to get the actor out of his/her current location with an
             *   implicit action.
             */</span>
            tryImplicitAction(GetOff, loc);
            
            <span class="comment">/* Note and if necessary display the implicit action report. */</span>
            &quot;&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;&quot;;
            
            
           <span class="comment"> /*
             *   if the command didn't work, quit the loop or we'll be stuck in
             *   it forever.
             */</span>
            if(gActor.location == loc)
                exit;
            
        }
        
        <span class="comment">/* 
         *   Note and if necessary display any other implicit action reports
         *   that may have been generated prior to executing this action.
         */</span>
        &quot;&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;&quot;;
              
        <span class="comment">/* Carry out the actual travel. */</span>
        doTravel();
    }
    
    <span class="comment"><a name="TravelAction:doTravel">/*</a> 
     *   Carry out travel in direction. For this purpose we first have to define
     *   what the corresponding direction property of the actor's current
     *   location refers to. If it's nil, no travel is possible, and we simply
     *   display a refusal message. If it's an object we execute its travelVia()
     *   method for the current actor. If it's a double-quoted string or a
     *   method we execute it and make a note of where the actor ends up, if the
     *   actor is the player character. If it's a single-quoted string we
     *   display it.
     *
     *   Note that we only display the various messages announcing failure of
     *   travel if the actor is the player character. We presumably don't want
     *   to see these messages as the result of NPCs trying to move around the
     *   map.
     */</span>
    
    doTravel()
    {
        <span class="comment">/* Note the actor's current location. */</span>
        local loc = gActor.getOutermostRoom;
        local conn;
        
        <span class="comment">/* 
         *   Note whether the current location is located, or whether it permits
         *   travel in the dark (in which case we treat it as illuminated for
         *   the purposes of allowing travel).
         */</span>
        local illum = loc.allowDarkTravel || loc.isIlluminated;
        
        
        <span class="comment">/* 
         *   Find out what's attached to the direction property of the direction
         *   in which the actor wants to travel and respond accordingly.
         */</span>
        switch (loc.propType(direction.dirProp))
        {
            <span class="comment">/* 
             *   If there's nothing there, simply display the appropriate
             *   message explaining that travel that way isn't possible.
             */</span>
        case TypeNil:
            if(illum &amp;&amp; gActor == gPlayerChar)
                loc.cannotGoThatWay(direction);
            else if(gActor == gPlayerChar)
                loc.cannotGoThatWayInDark(direction);            
            break;
            
           <span class="comment"> /* 
             *   If the direction property points to an object, assume it's some
             *   kind of TravelConnector (which also includes Rooms and Doors)
             *   and then attempt travel via that object.
             */</span>
        case TypeObject:     
            <span class="comment">/* Note our connector */</span>
            conn = loc.(direction.dirProp);
            
            <span class="comment">/* 
             *   If the connector is apparent to the actor then attempt travel
             *   via the connector.
             */</span>
            if(conn.isConnectorApparent)
                conn.travelVia(gActor);
            
           <span class="comment"> /* 
             *   Otherwise if there's light enough to travel and the actor is
             *   the player character, display the standard can't travel message
             *   (as if the connector wasn't there.
             */</span>
            else if(illum &amp;&amp; gActor == gPlayerChar)
                loc.cannotGoThatWay(direction);
            
            <span class="comment">/* 
             *   Otherwise if the actor is the player character, display the
             *   standard message forbidding travel in the dark.
             */</span>
            else if(gActor == gPlayerChar)
                loc.cannotGoThatWayInDark(direction);
            break;       
            
            <span class="comment">/* 
             *   If the direction property points to a double-quoted method or a
             *   string, then provided the illumination is right, we display the
             *   string or execute the method. Otherwise show the message saying
             *   we can't travel that way in the dark.
             */ </span>           
        case TypeDString:
        case TypeCode:
            if(illum)
            {            
                <span class="comment">/* 
                 *   Call the before travel notifications on every object that's
                 *   in scope for the actor. Since we don't have a connector
                 *   object to pass to the beforeTravel notifications, we use
                 *   the direction object instead.
                 */</span>
                Q.scopeList(gActor).toList.forEach({x: x.beforeTravel(gActor,
                    direction)});
                                   
                <span class="comment">/*  
                 *   If going this way would take us to a known destination
                 *   that's a Room (so that executing the travel should take the
                 *   actor out of his/her current room) notify the current room
                 *   that the actor is about to depart.
                 */</span>                
                local dest;
                
                if(loc.propType(direction.dirProp) == TypeCode)                
                    dest = libGlobal.extraDestInfo[[loc, direction]];
                else
                    dest = nil;
                
                if(dest &amp;&amp; dest.ofKind(Room))
                    loc.notifyDeparture(gActor, dest);
                                   
                <span class="comment">/*  
                 *   Then execute the method or display the double-quoted
                 *   string.
                 */</span>             
                loc.(direction.dirProp);
                
                <span class="comment">/* 
                 *   If we've just executed a method, it may have moved the
                 *   actor to a new location, so if the actor is the player
                 *   character note where the method took the actor to so that
                 *   the pathfinder can find a route via this exit.
                 */</span>
                if(gActor == gPlayerChar)
                    libGlobal.addExtraDestInfo(loc, direction,
                                           gActor.getOutermostRoom);
            }
            else if(gActor == gPlayerChar)
                loc.cannotGoThatWayInDark(direction);
            break;
            
            <span class="comment">/* 
             *   If the direction property points to a single-quoted string,
             *   simply display the string if the illumination is sufficient,
             *   otherwise display the message saying we can't go that way in
             *   the dark. If the actor isn't the player character, do nothing.
             */</span>
        case TypeSString:
            if(gActor == gPlayerChar)
            {
                conn = loc.(direction.dirProp);
                if(illum)
                {
                    say(conn);
                    libGlobal.addExtraDestInfo(loc, direction,
                                               gActor.getOutermostRoom); 
                }
                else
                    loc.cannotGoThatWayInDark(direction);
            }    
            break;
            
        }       
    }
    
    <span class="comment">/* 
     *   The direction the actor wants to travel in. This is placed here by the
     *   execCycle method and takes the form of A Direction object, e.g.
     *   northDir.
     */</span>
    direction = nil
    
    <span class="comment">/* It's generally possible to undo a travel command. */</span>
    canUndo = true
;
</pre></div>

<h2>actions.t</h2>

 <p><div class="code"><pre>
DefineSystemAction(<a name="Again">Again</a>)
    
    exec(cmd)
    {
        if((gameMain.againRepeatsParse &amp;&amp; libGlobal.lastCommandForAgain is in
           ('',nil)) || (!gameMain.againRepeatsParse &amp;&amp; libGlobal.lastCommand is
           in ('', nil)))
        {
            DMsg(no repeat, 'Sorry, there is no action available to repeat. ');
        }
        else if (gameMain.againRepeatsParse)
        {
            Parser.parse(libGlobal.lastCommandForAgain);
        }
        else
        {
            libGlobal.lastCommand.exec();
        }
    }
    
    clearForAgain()
    {
        libGlobal.lastAction = nil;
        libGlobal.lastCommand = nil;
    }
    
;

</pre></div>

 <p><div class="code"><pre>
DefineIAction(<a name="Continue">Continue</a>)
    execAction(cmd)
    {
        local path;
        path = defined(pcRouteFinder) ? pcRouteFinder.cachedRoute : nil;
        if(path == nil)
        {
            DMsg(no journey, '{I}{\'m} not going anywhere. ');
        }
        
        local idx = path.indexWhich({x: x[2] == gActor.getOutermostRoom});
        
        if(idx == nil)
        {
            path = defined(pcRouteFinder) ?
                pcRouteFinder.findPath(gActor.getOutermostRoom,
                                       pcRouteFinder.currentDestination) : nil;
            
            if(path == nil)
            {
                DMsg(off route, '{I}{\'m} no longer on {my} route. Use the GO TO
                    command to set up a new route. ');
                return;
            }
            else
                idx = 1;                
        }
        
        if(idx == path.length)
        {
            DMsg(already there, '{I}{\'m} already there. ');
            return;
        }
        
        local dir = path[idx + 1][1];
        
        takeStep(dir, path[path.length][2]);
        
        
    }
    
    takeStep(dir, dest)
    {
        DMsg(going dir, '(going {1})\n', dir.name);
        
        gActor.getOutermostRoom.(dir.dirProp).travelVia(gActor);
        
        if(!gActor.isIn(dest))
        {
            local contMsg = BMsg(explain continue, 'To continue the journey
                use the command
                &lt;&lt;aHref('Continue','CONTINUE','Continue')&gt;&gt; or C. ');
            htmlSay(contMsg);
        }
    }
    
;
</pre></div>


 <p><div class="code"><pre>
DefineSystemAction(<a name="ExitsColour">ExitsColour</a>)
    execAction(cmd)
    {
        if(gExitLister == nil)
        {
             DMsg(no exit lister, 'Sorry, that command is not available in this
                game, since there\'s no exit lister. ');
            return;
        }
        
        if(cmd.verbProd.on_ != nil)
        {
            statuslineExitLister.highlightUnvisitedExits = 
                (cmd.verbProd.on_ == 'on');
            
            DMsg(exit color onoff, 'Okay, colouring of unvisited exits is now
                {1}.&lt;.p&gt;', cmd.verbProd.on_);
        }
        
        if(cmd.verbProd.colour_ != nil)
        {
            statuslineExitLister.unvisitedExitColour = cmd.verbProd.colour_;
            statuslineExitLister.highlightUnvisitedExits = true;
            DMsg(exit color change, 'Okay, unvisited exits in the status line
                will now be shown in {1}. ', cmd.verbProd.colour_);
        }
    }
;
</pre></div>

 <p><div class="code"><pre>
DefineIAction(<a name="GoBack">GoBack</a>)
    execAction(cmd)
    {
        local pathBack = nil;
        
        if(libGlobal.lastLoc == nil)
        {
            DMsg(nowhere back, '{I} {have} nowhere to go back to. ');
            return;            
        }
        
        pathBack = defined(routeFinder) ? 
             routeFinder.findPath(gActor.getOutermostRoom,
                libGlobal.lastLoc) : nil;
               
        
        if(pathBack == nil)
        {
            DMsg(no way back, 'There{dummy}{\'s} no way back. ');
            return;
        }
        
        if(pathBack.length == 1)
        {
            DMsg(already there, '{I}{\'m} already there. ');
            return;
        }
        
        local dir = pathBack[2][1];
        
        DMsg(going dir, '(going {1})\n', dir.name);
        
        gActor.getOutermostRoom.(dir.dirProp).travelVia(gActor);
        
    }
;
</pre></div>

 <p><div class="code"><pre>
<a name="GoIn">GoIn</a>: <a href="#TravelAction">TravelAction</a>
    direction = inDir
    predefinedDirection = true
;

<a name="GoOut">GoOut</a>: <a href="#TravelAction">TravelAction</a>
    direction = outDir
    predefinedDirection = true
    
    execAction(cmd)
    {
        if(!gActor.location.ofKind(Room))
            replaceAction(GetOff, gActor.location);
        else
        {
            "&lt;&lt;buildImplicitActionAnnouncement(true)&gt;&gt;";
            <a href="#TravelAction:doTravel">doTravel</a>();
        }
    }
;
</pre></div>

 <p><div class="code"><pre>
<a name="Hello">Hello</a>: IAction
    baseActionClass = Hello
    
    execAction(cmd)
    {
        <span class="comment">/* first build the scope list so we know which actors are in scope */</span>
        buildScopeList();
        
        <span class="comment">/* 
         *   if the pc isn't already talking to someone then this is an attempt
         *   to engage a new interlocutor in conversation.
         */</span>
        if(gPlayerChar.currentInterlocutor == nil)
        {
            <span class="comment">/* 
             *   Ascertain how many actors other than the player char are in
             *   scope (and thus potentially greetable.
             */</span>

            local greetList = scopeList.subset(
                    { x: x.ofKind(Actor) &amp;&amp; x != gPlayerChar });
            
            local greetCount = greetList.length;
            
            <span class="comment">/* If there are no other actors in scope, say so. */ </span>           
            if(greetCount == 0)
            {
                DMsg(no one here, 'There{dummy}{\'s} no one {here} to talk to.
                    ');
            }
            <span class="comment">/* 
             *   Otherwise construct a list of all the actors in scope and greet
             *   all of them (rather than asking the player to disambiguate -
             *   after all the pc may have just said 'hello' to a room full of
             *   people and there's no reason why they shouldn't all respond).
             */</span>
            else
            {               
                foreach(local greeted in greetList)
                {
                    curObj = greeted;
                    greeted.sayHello();
                }
            }
        }
        <span class="comment">/* 
         *   If the player char is currently talking to someone, say so and
         *   carry out a repeat greeting.
         */</span>
        else
        {
            DMsg(already talking, '{I}{\'m} already talking to {1}. ',
                 gPlayerChar.currentInterlocutor.theName);
            
            gPlayerChar.currentInterlocutor.sayHello();
        }
    }
    
    curObj = nil  
;
</pre></div>



 <p><div class="code"><pre>
class <a name="ImplicitConversationAction">ImplicitConversationAction</a>: TopicAction
    execAction(cmd)
    {
        if(cmd.iobj == nil &amp;&amp; cmd.dobj != nil)
        {
            if(cmd.dobj.ofKind(ResolvedTopic))
                topics = cmd.dobj.topicList;
            else
                topics = cmd.dobj;
        }
        else if (cmd.dobj == nil && cmd.iobj != nil)
        {
            if(cmd.iobj.ofKind(ResolvedTopic))
                topics = cmd.iobj.topicList;
            else
                topics = cmd.iobj;
        }
        
        if(gPlayerChar.currentInterlocutor == nil ||
           !Q.canTalkTo(gPlayerChar, gPlayerChar.currentInterlocutor))	
            DMsg(not talking, '{I}{\'m} not talking to anyone. ');
        else
        {
            resolvePronouns();
            curObj = gPlayerChar.currentInterlocutor;
            gPlayerChar.currentInterlocutor.handleTopic(topicListProperty, 
                topics);
        }
    }
    
    <span class="comment">/* 
     *   This is a bit of a kludge to deal with the fact that the Parser doesn't
     *   seem able to resolve pronouns within ResolvedTopics. We do it here
     *   instead.
     */</span>
    
    resolvePronouns()
    {
        local actor = gPlayerChar.currentInterlocutor;
        for(local cur in topics, local i = 1;; ++i)
        {
            if(cur == Him &amp;&amp; actor.isHim)
                topics[i] = actor;
            
            if(cur == Her &amp;&amp; actor.isHer)
                topics[i] = actor;
            
            if(cur == It &amp;&amp; actor.isIt)
                topics[i] = actor;
        }
    }
    
    
    topicListProperty = nil
    topics = nil
;
</pre></div>

 <p><div class="code"><pre>
DefineIAction(<a name="Inventory">Inventory</a>)
    execAction(cmd)
    {
        <span class="comment">/* 
         *   If splitListing is true, we potentially need to display two lists,
         *   one of what the actor is wearing and one of what the actor is
         *   carrying.
         */</span>
        if(splitListing)
        {
            <span class="comment">/* Construct a list of what the actor is wearing */</span>
            local wornList = gActor.contents.subset({o: o.wornBy == gActor });
            
            <span class="comment">/* Construst a list of what the actor is carrying */</span>
            local carriedList = gActor.contents.subset({o: o.wornBy == nil });

            <span class="comment">/* 
             *   If anything is being worn, get a list of it minus the final
             *   paragraph break and then display it.
             */</span>
            if(wornList.length &gt; 0)
            {               
                wornLister.show(wornList, 0, nil);
                
                <span class="comment">/* 
                 *   If nothing is being carried, terminate the list with a full
                 *   stop and a paragraph break.
                 */</span>
                if(carriedList.length == 0)
                    &quot;.&lt;.p&gt;&quot;;
                
                <span class="comment">/*  
                 *   Otherwise prepare to append the list of what's being
                 *   carried.
                 */</span>
                else
                    DMsg(inventory list conjunction, ', and \v');
                
            }
            <span class="comment">/* 
             *   If something's being carried or nothing's being worn, display
             *   an inventory list of what's being carried. If nothing's being
             *   worn or carried, this will display the &quot;You are empty-handed&quot;
             *   message.
             */</span>
            if(carriedList.length &gt; 0 || wornList.length == 0)
                inventoryLister.show(carriedList, 0);
        }
        else
        {
            inventoryLister.show(gActor.contents, 0);
        }
        
       <span class="comment"> /* Mark eveything just listed as having been seen. */</span>
        gActor.contents.forEach({x: x.<a href="#Thing:noteSeen">noteSeen</a>()});
    }
   
    <span class="comment">/* Do we want separate lists of what's worn and what's carried? */</span>
    splitListing = true
;
</pre></div>


 <p><div class="code"><pre>
DefineIAction(<a name="Listen">Listen</a>)
    execAction(cmd)
    {
        <span class="comment">/* 
         *   I may be able to hear things that aren't technically in scope,
         *   since they may be hidden in containers that allow sound through.
         */</span>        
        local s_list = gActor.getOutermostRoom.allContents.subset(
            {x: Q.canHear(gActor,x) &amp;&amp; x.isProminentNoise});
        
        s_list = s_list.getUnique();
        
        local r_list = getRemoteSoundList().getUnique() - s_list;
        
        <span class="comment">/* 
         *   Create a local variable to keep track of whether we've displayed
         *   anything.
         */</span>
        local somethingDisplayed = nil;
        
        foreach(local cur in s_list)
        {
            if(cur.displayAlt(&amp;listenDesc))
                somethingDisplayed = true;
        }
        
        if(listRemoteSounds(r_list))
            somethingDisplayed = true;
        
        
        if(!somethingDisplayed)
            DMsg(hear nothing listen, '{I} hear{s/d} nothing out of the
                ordinary.<.p>');

        
    }
    
    <span class="comment">/* Do nothing in the core library; senseRegion.t will override if present */</span>
    getRemoteSoundList() { return []; }
    
    <span class="comment">/* Do nothing in the core library; senseRegion.t will override if present */</span>
    listRemoteSounds(lst) { }
;
</pre></div>

 <p><div class="code"><pre>
DefineTAction(<a name="PushTravelDir">PushTravelDir</a>)
    execAction(cmd)
    {
        local conn;
    
        <span class="comment">/* Note whether travel is allowed. This can be adjusted by the dobj */</span>
        travelAllowed = nil;
        
        <span class="comment">/* Get the direction of travel from the command */</span>
        direction = cmd.verbProd.dirMatch.dir;
        
        <span class="comment">/* 
         *   Carry out the inherited handling, including calling <a href="#Thing:PushTravelDir">dobjFor(PushTravelDir)</a>)
         *   on the dobj
         */</span>
        inherited(cmd);
        
        <span class="comment">/* Proceed to carry out the travel if the dobj allows it */</span>
        if(travelAllowed)
        {
            <span class="comment">/* Note the old location, which is the actor's current room. */</span> 
           local oldLoc = gActor.getOutermostRoom; 
            
           <span class="comment">/*  
            *   If the relevant direction property of the actor's current room
            *   points to an object, then try pushing the dobj via that object
            *   (e.g. up the stairs or through the door).
            */</span> 
           if(oldLoc.propType(direction.dirProp) == TypeObject)
           {
               <span class="comment"> /* Note the connector object in the relevant direstion */</span>
                local conn = oldLoc.(direction.dirProp);
                
                <span class="comment">/*  
                 *   If the connector object defines a PushTravelVia action,
                 *   then replace the current action with that PushTravelVia
                 *   action (e.g. PushTravelGoThrough or PushTravelClimbUp).
                 */</span>
                if(conn.PushTravelVia)
                    replaceAction(conn.PushTravelVia, gDobj, conn);
                               
                <span class="comment">/* 
                 *   Otherwise, if the travel barriers would not allow the dobj
                 *   to pass, stop the action here.
                 */</span>
                if(!conn.checkTravelBarriers(curDobj))
                {                    
                    return;
                }
                
            }
            
            <span class="comment">/* 
             *   If the direction property isn't attached to an object, the
             *   chances are that travel won't be allowed, so in that case we
             *   don't want to display a message about attempting to push the
             *   direct object anywhere, but if it is, then the chances are that
             *   travel is possible (unless it's already been ruled out) so we
             *   display a suitable message.
             */</span>
            if(oldLoc.propType(direction.dirProp) == TypeObject)
                gDobj.beforeMovePushable(conn, direction);
            
            /* 
             *   Temporarily set the isHidden property of the direct
             *   object to true so we don't see it listed in its old location if
             *   there's a sight path to it there from the actor's new location.
             */
            
            local wasHidden;
            try
            {
                wasHidden = gDobj.propType(&amp;isHidden) is in (TypeCode, TypeFuncPtr) ?
                    gDobj.getMethod(&amp;isHidden) : isHidden;
                
                gDobj.isHidden = true;
                
                <span class="comment">/* 
                 *   Carry out the standard handling of TravelAction to move the
                 *   actor in the appropriate direction
                 */ </span>
                delegated <a href="#TravelAction">TravelAction</a>(cmd);
            }
            finally
            {
                if(dataTypeXlat(wasHidden) is in (TypeCode, TypeFuncPtr))
                    gDobj.setMethod(&amp;isHidden, wasHidden);
                else
                    gDobj.isHidden = wasHidden;
            }
            
            
            /* 
             *   If the actor has moved to a new location, move the dobj to that
             *   location and report what's happened.
             */
            if(oldLoc != gActor.getOutermostRoom)
            {
                curDobj.moveInto(gActor.getOutermostRoom);
                curDobj.describeMovePushable(conn, gActor.getOutermostRoom);
            }
        }
            
    }
    
    travelAllowed = nil
    direction = nil
    
    doTravel() { delegated <a href="#TravelAction:doTravel">TravelAction</a>(); }
;
</pre></div>

 <p><div class="code"><pre>
DefineIAction(<a name="Smell">Smell</a>)
    execAction(cmd)
    {
        <span class="comment">/* 
         *   Build a list of all the objects in scope that both (1) define a
         *   nsmellDesc property that will display something and (2) whose
         *   isProminentSmell property is true
         */</span>
        local s_list = gActor.getOutermostRoom.allContents.subset(
            {x: Q.canSmell(gActor, x)  &amp;&amp;  x.isProminentSmell});
        
        local r_list = getRemoteSmellList().getUnique() - s_list;
        
       <span class="comment"> /*  Obtain the corresponding list for remote rooms */</span>
        local r_list = getRemoteSmellList();
        
        <span class="comment">/* 
         *   Create a local variable to keep track of whether we've displayed
         *   anything.
         */</span>
        local somethingDisplayed = nil;
        
        <span class="comment">/* 
         *   Display the smellDesc of every item in our local smell list,
         *   keeping track of whether anything has actually been displayed as a
         *   result.
         */</span>
        foreach(local cur in s_list)
        {
            if(cur.displayAlt(&amp;smellDesc))
                somethingDisplayed = true;
        }
        
        <span class="comment">/* Then list any smells from remote locations */</span>
        if(listRemoteSmells(r_list))
            somethingDisplayed = true;
        
        
        <span class="comment">/*  If nothing has been displayed report that there is nothing to smell */ </span>       
        if(!somethingDisplayed)            
            DMsg(smell nothing intransitive, '{I} {smell} nothing out of the
                ordinary.<.p>');
    }
    
    <span class="comment">/* Do nothing in the core library; senseRegion.t will override if present */</span>
    getRemoteSmellList() { return []; }
    
    <span class="comment">/* Do nothing in the core library; senseRegion.t will override if present */</span>
    listRemoteSmells(lst) { }
;
</pre></div>


 <p><div class="code"><pre>
<a name="Travel">Travel</a>: <a href="#TravelAction">TravelAction</a>
    direction = (dirMatch.dir)
;
</pre></div>

<h2>debug.t</h2>

 <p><div class="code"><pre>
DefineSystemAction(<a name="Debug">Debug</a>)
    execAction(cmd)
    {
        gLiteral = cmd.dobj.name.toLower;
        switch(gLiteral)
        {
        case 'messages':
        case 'spelling':
        case 'actions':
        case 'doers':
            DebugCtl.enabled[gLiteral] = !DebugCtl.enabled[gLiteral];
            <span class="comment">/* Deliberately omit break to allow fallthrough */</span>
        case 'status':
            DebugCtl.status();
            break;
        case 'off':
        case 'stop':    
            foreach(local opt in DebugCtl.all)
                DebugCtl.enabled[opt] = nil;
            DebugCtl.status();
            break;
        default:
            "That is not a valid option. The valid DEBUG options are DEBUG
            MESSAGES, DEBUG SPELLING, DEBUG ACTIONS, DEBUG DOERS,
            DEBUG OFF or DEBUG STOP (to turn off all options) or
            just DEBUG by itself to break into the debugger. ";
        }
        
    }
;
</pre></div>

<h2>thing.t</h2>
 <p><div class="code"><pre>
class Thing:  ReplaceRedirector, Mentionable

   
    
   <span class="comment"> <a name="Thing:checkInsert">/*</a>  
     *   Check whether an item can be inserted into this object, or whether
     *   doing so would either exceed the total bulk capacity of the object or
     *   the maximum bulk allowed for a single item.
     */</span>
    checkInsert(obj)
    {
        <span class="comment">/* Create a message parameter substitution. */</span>
        gMessageParams(obj);
        
        <span class="comment">/* 
         *   If the bulk of obj is greater than the maxSingleBulk this Thing can
         *   take, or greater than its overall bulk capacity then display a
         *   message to say it's too big to fit inside ue.
         */</span>
        if(obj.bulk &gt; maxSingleBulk || obj.bulk &gt; bulkCapacity)
            DMsg(too big, '{The subj obj} {is} too big to fit {1} {2}. ', 
                 objInPrep, theName);
        
        <span class="comment">/* 
         *   Otherwise if the bulk of obj is greater than the remaining bulk
         *   capacity of this Thing allowing for what it already contains,
         *   display a message saying there's not enough room for obj.
         */</span>
        else if(obj.bulk &gt; bulkCapacity - <a href="#Thing:getBulkWithin">getBulkWithin</a>())
            DMsg(no room, 'There {dummy} {is} not enough room {1} {2} for {the
                obj). ', objInPrep, theName);            
    }
    


    <span class="comment">/* 
     *   Attempt to display prop appropriately according to it data type
     *   (single-quoted string, double-quoted string, integer or code )
     */</span>
    <a name="Thing:display">display</a>(prop)    
    {
        switch(propType(prop))
        {
            <span class="comment">/* 
             *   If prop is a single-quoted string or an integer, simply display
             *   it.
             */</span>
        case TypeSString:
        case TypeInt:    
            say(self.(prop));
            break;
            
            <span class="comment">/* If prop is a double-quoted string, display it by executing it. */</span>
        case TypeDString:
            self.(prop);
            break;
            
            <span class="comment">/* if prop is a method, execute it. */</span>
        case TypeCode:
            <span class="comment">/* 
             *   In case prop is a method that returns a single-quoted string,
             *   note the return value from executing prop.
             */</span>
            local str = self.(prop);
            
            <span class="comment">/* If it's a string, display it. */</span>
            if(dataType(str) == TypeSString)
                say(str);
            break;
        default:
            <span class="comment">/* do nothing */</span>
            break;
        }
    }
    
    <span class="comment">/* 
     *   Additional information to display after our desc in response to an
     *   EXAMINE command.
     */ </span>
    <a name="Thing:examineStatus">examineStatus</a>()
    {        
        <span class="comment">/* First display our stateDesc (our state-specific information) */</span>
        <a href="#Thing:display">display</a>(&amp;stateDesc);
        
       <span class="comment"> /* 
         *   Then display our list of contents, unless we're a Carrier (an actor
         *   carrying our oontents) or our contentsListedInExamine is nil.
         */</span>
        if(contType != Carrier && contentsListedInExamine)        
        {          
            <span class="comment">/* 
             *   Start by marking our contents as not mentioned to ensure that
             *   they all get listed.
             */</span>
            <a href="#Thing:unmention">unmention</a>(contents);
            
            <span class="comment">/* Then list our contents using our examineLister. */</span>
            listSubcontentsOf(self, examineLister);            
        }           
           
    }
    
     <a name="Thing:getBulkWithin"><span class="comment">/*   Calculate the total bulk of the items contained within this object. */</span></a>
    getBulkWithin()
    {
        local totalBulk = 0;
        foreach(local cur in contents)
            totalBulk += cur.bulk;
        
        return totalBulk;
    }
    
    <span class="comment"><a name="Thing:getCarriedBulk">/*</a>  
     *   Calculate the total bulk carried by an actor, which excludes the bulk
     *   of any items currently worn or anything fixed in place.
     */</span>
     getCarriedBulk()
    {
        local totalBulk = 0;
        foreach(local cur in directlyHeld)
        {           
            totalBulk += cur.bulk;
        }
        
        return totalBulk;
    }
    
    <span class="comment">/* 
     *   Basic <a name="Thing:moveInto">moveInto</a> for moving an object from one container to another by
     *   program fiat.
     */</span>
    
    moveInto(newCont)
    {
        <span class="comment">/* If we have a location, remove us from its list of contents. */</span>
        if(location != nil)            
            location.removeFromContents(self);
           
        <span class="comment"> /* Set our new location. */</span>           
        location = newCont;
         
        <span class="comment">/* 
         *   Provided our new location isn't nil, add us to our new location's
         *   list of contents.
         */</span>         
        if(location != nil)
            location.addToContents(self);        
    }
    
    <span class="comment">/* <a name="Thing:actionMoveInto">Move into generated by a user action</a>, which includes notifications */</span>
    actionMoveInto(newCont)
    {
        <span class="comment">/* 
         *   If we have a location, notify our existing location that we're
         *   about to be removed from it.
         */</span>
        if(location != nil)
            location.notifyRemove(self);            
        
        <span class="comment">/* 
         *   If the location we're about to be moved into is non-nil, notify our
         *   new location that we're about to be moved into it. Note that both
         *   this and the previous notification can veto the move with an exit
         *   command.
         */</span>
        if(newCont != nil)
            newCont.notifyInsert(self); 
        
        <span class="comment">/* Carry out the move. */</span>
        moveInto(newCont);
        
        <span class="comment">/* Note that we have been moved. */</span>
        moved = true;
        
        <span class="comment">/* If the player character can now see us, note that we've been seen */</span>
        if(Q.canSee(gPlayerChar, self))
            <a href="#Thing:noteSeen">noteSeen</a>();
    }
    
    <span class="comment">/* 
     *   Receive notification that obj is about to be removed from inside us; by
     *   default we do nothing.
     */</span>
    notifyRemove(obj) { }
    
    <span class="comment">/* 
     *   Receive notification that obj is about to be inserted into us; by
     *   default we do nothing.
     */</span>
    notifyInsert(obj) { }
    
    

    <span class="comment">/* <a name="Thing:noteSeen">Note that we've been seen</a> and where we were last seen */    </span>
    noteSeen()
    {
        gPlayerChar.setHasSeen(self);
        lastSeenAt = location;
    }  
    
    <span class="comment">/*
     *   Have we been seen?  This is set to true the first time the object
     *   is described or listed in a room description or the description of
     *   another object (such as LOOK IN this object's container).  
     */</span>
    seen = nil

    <span class="comment">/*
     *   The last location where the player character saw this object.
     *   Whenever the object is described or listed in the description of a
     *   room or another object, we set this to the object's location at
     *   that time.  
     */</span>
    lastSeenAt = nil
    
    <span class="comment">/* 
     *   <a name="Thing:unmention">Mark everything</a> item in lst as not mentioned , and carry on down the
     *   containment tree marking the contents of every item in lst as not
     *   mentioned.
     */</span>
    unmention(lst)
    {
        foreach(local obj in lst)
        {
            obj.mentioned = nil;
            
            <span class="comment">/* If obj has any contents, unmention every item in is contents */</span>
            if(obj.contents.length > 0)
                unmention(obj.contents);
        }
    }
    
   <span class="comment"> /********************************************
     *   CLOSE
     ********************************************/</span>
    
    <span class="comment">/* <a name="Thing:Close">By default something is closeable if it's openable</a> */</span>         
    isCloseable = (isOpenable)
    
    dobjFor(Close)
    {
        preCond = [touchObj]
        
        remap()
        {
            if(!isCloseable &amp;&amp; remapIn != nil &amp;&amp; remapIn.isClosable)
                return remapIn;
            else
                return self;
        }
        
        
        verify()
        {
            if(!isCloseable)
                illogical(cannotCloseMsg);
            if(!isOpen)
                illogicalNow(alreadyClosedMsg);
            logical;
        }
           
        
        action()
        {            
            <a href="#Thing:makeOpen">makeOpen</a>(nil);
        }
        
        report()
        {
            DMsg(report close, 'Done |{I} {close} &lt;&lt;theName&gt;&gt;. ');
        }
    }
    
    cannotCloseMsg = BMsg(not closeable, '{The subj dobj} {is} not something
        that {can} be closed. ')
    alreadyClosedMsg = BMsg(already closed,'{The subj dobj} {isn\'t} open. ')
    
    <span class="comment"> /********************************************
     *   DOFF
     ********************************************/</span>
    
    <span class="comment">/*<a name="Thing:Doff"> By default we assume</a> that something's doffable if it's wearable */</span>
    isDoffable = (isWearable)
    
    dobjFor(Doff)
    {
        
        verify()
        {
            if(wornBy != gActor)
                illogicalNow(notWornMsg);
                        
            if(!isDoffable)
                illogical(cannotDoffMsg);
        }
        
        check()
        {
            <a href="#Thing:checkRoomToHold">checkRoomToHold</a>();
        }
        
        action()  {   makeWorn(nil);  }
        
        report()
        {
            DMsg(okay doff, 'Okay, {I}{\'m} no longer wearing {1}. ', 
                 gActionListStr);
            
        }
    }
    
  
    cannotDoffMsg = (cannotWearMsg)
    
    notWornMsg = BMsg(not worn, '{I}{\'m} not wearing {the dobj}. ')
    
    <span class="comment"> /********************************************
     *   DROP
     ********************************************/</span>
    
    dobjFor(<a name="Thing:Drop">Drop</a>)
    {
        preCond = [objNotWorn]
        
        verify()
        {
            <span class="comment">/* I can't drop something I'm not holding */</span>
            if(!isDirectlyIn(gActor))
                illogicalNow(notHoldingMsg);
            
            <span class="comment">/* 
             *   Even if something is directly in me, I can't drop it if it's
             *   fixed in place (since it's then presumably a part of me).
             */</span>
            else if(isFixed)
                illogical(partOfYouMsg);
            
            <span class="comment">/*  
             *   And I can't drop something that game code has deemed to be not
             *   droppable for some other reason.
             */</span>
            else if(!isDroppable)
                illogical(cannotDropMsg);
            
            logical;
        }
                
        
        action()
        {           
            <a href="#Thing:actionMoveInto">actionMoveInto</a>(gActor.location.dropLocation);
        }
        
        report()
        {
            DMsg(report drop, 'Dropped. |{I} {drop} {1}. ', gActionListStr);            
        }
    }
    
    notHoldingMsg = BMsg(not holding, '{I} {amn\'t} holding {the dobj}. ')
    partOfYouMsg = BMsg(part of me, '{The subj dobj} {is} part of {me}. ')
    
    <span class="comment">/* By default we can drop anything that's held */</span>
    isDroppable = true
    
    cannotDropMsg = BMsg(cannot drop, '{The subj dobj} {can\'t} be dropped. ')
    
   <span class="comment"> /* The location in which something dropped in me should land. */</span>
    dropLocation = self
    
    <span class="comment"> /********************************************
     *   EXAMINE
     ********************************************/</span>
    
    dobjFor(<a name="Thing:Examine">Examine</a>)
    {
        preCond = [objVisible]
        
        verify() 
        { 
            if(isDecoration)
                logicalRank(70);
            else
                logical; 
        }
        
        check() { }
        
        action()
        {
            <span class="comment">/* 
             *   Display our description. Normally the desc property will be
             *   specified as a double-quoted string or a routine that displays
             *   a string, but by using the display() message we ensure that it
             *   will still be shown even desc has been defined a single-quoted
             *   string.
             */ </span>
            <a href="#Thing:display">display</a>(&amp;desc);
            
            <span class="comment">/*   
             *   Display any additional information, such as our stateDesc (if
             *   we have one) and our contents (if we have any).
             */</span>
            <a href="#Thing:examineStatus">examineStatus</a>();
            
            <span class="comment">/*   Note that we've now been examined. */</span>
            examined = true;
            "\n";
        }
    }
    
    
    <span class="comment"> /********************************************
     *   GONEAR
     ********************************************/</span>
    
    <span class="comment">/* 
     *   The GoNear action allows the player character to teleport around the
     *   map.
     */</span>
    dobjFor(<a name="Thing:GoNear">GoNear</a>)
    {
        verify()
        {
            if(getOutermostRoom == nil)
                illogicalNow(cannotGoNearThereMsg);
            
            if(ofKind(Room))
                logicalRank(120);
        }
        
        action()
        {
            DMsg(gonear, '{I} {am} translated in the twinkling of an
                eye...&lt;.p&gt;');
            getOutermostRoom.travelVia(gActor);
        }
    }
    
     
    
    cannotGoNearThereMsg = BMsg(cannot go there, '{I} {can\'t} go there right
        {now}. ')

    <span class="comment"> /********************************************
     *   GOTO
     ********************************************/</span>
    
    <span class="comment">/* 
     *   The GoTo action allows the player character to navigate the map through
     *   the use of commands such as GO TO LOUNGE.
     */</span>
    dobjFor(<a name="Thing:GoTo">GoTo</a>)
    {
        verify()
        {
           <span class="comment"> /* 
             *   If the actor is already in the direct object, there's no need
             *   to move any further.
             */</span>
            if(gActor.isIn(self))
                illogicalNow(alreadyThereMsg);
            
            <span class="comment">/*  
             *   If the direct object is in the actor's location, there's no
             *   need for the actor to move to get to it.
             */</span>
            if(isIn(gActor.getOutermostRoom))
                illogicalNow(alreadyPresentMsg);
                
            <span class="comment">/*  
             *   It's legal to GO TO a decoration object, but given the choice,
             *   it's probably best to let the parser choose a non-decoration in
             *   cases of ambiguity, so we'll decorations a slightly lower
             *   logical rank.
             */</span>
            if(isDecoration)
                logicalRank(90);    
        }
        
        <span class="comment">/* 
         *   The purpose of the GO TO action is to take the player char along
         *   the shortest route to the destination. The action routine
         *   calculates the route and takes the first step.
         */</span>
        action()
        {
            <span class="comment">/* 
             *   Calculate the route from the actor's current room to the
             *   location where the target object was last seen, using the
             *   pcRouteFinder to carry out the calculations if it is present.
             */</span>
            local route = defined(pcRouteFinder) &amp;&amp; lastSeenAt != nil 
                ? pcRouteFinder.findPath(
                gActor.getOutermostRoom, lastSeenAt.getOutermostRoom) : nil;
            
            <span class="comment">/*  
             *   If we don't find a route, just display a message saying we
             *   don't know how to get to our destination.
             */</span>
            if(route == nil)            
                sayDontKnowHowToGetThere();
                
            <span class="comment">/*  
             *   If the route we find has only one element in its list, that
             *   means that we're where we last saw the target but it's no
             *   longer there, so we don't know where it's gone. In which case
             *   we display a message saying we don't know how to reach our
             *   target.
             */</span>    
            else if(route.length == 1)
                sayDontKnowHowToReach();
                    
            <span class="comment">/*  
             *   If the route we found has at least two elements, then use the
             *   first element of the second element as the direction in which
             *   we need to travel, and use the Continue action to take a step
             *   in that direction.
             */</span>        
            else
            {
                local idx = 2;
                local dir = route[2][1];
                local oldLoc = gPlayerChar.getOutermostRoom();
                
                local commonRegions =
                    gPlayerChar.getOutermostRoom.regionsInCommonWith(dest);
                
                local regionFastGoTo = 
                    commonRegions.indexWhich({r: r.fastGoTo }) != nil;
                
                local fastGo = regionFastGoTo || gameMain.fastGoTo;
                
                Continue.takeStep(dir, getOutermostRoom, fastGo);                
                
                
                <span class="comment">/* 
                 *   If the fastGoTo option is active, continue moving towards
                 *   the destination until either we reach it our we're
                 *   prevented from going any further.
                 */</span>
                while((fastGo)
                      &amp;&amp; oldLoc != gPlayerChar.getOutermostRoom 
                      &amp;&amp; idx &lt; route.length)
                {
                    local dir = route[++idx][1];
                    Continue.takeStep(dir, getOutermostRoom, true);
                }               
            }
        }
    }
    
    alreadyThereMsg = BMsg(already there, '{I}{\'m} already there. ')
    alreadyPresentMsg = BMsg(already present, '{The subj dobj} {is} right
        {here}. ')    
        
        
    <span class="comment">/* 
     *   The <a name="Thing:lockability">lockability</a> property determines whether this object is lockable and
     *   if so how. The possible values are <strong>notLockable</strong>, <strong>lockableWithoutKey</strong>,
     *   <strong>lockableWithKey</strong> and <strong>indirectLockable</strong>.
     */</span>
     
    <span class="comment">/* 
     *   Note: we don't use isLockable, because this is not a binary property;
     *   there are different kings of lockability and defining an isLockable
     *   property in addition would only confuse things and might break the
     *   logic.
     */</span>    
    lockability = notLockable
    
    <span class="comment">/* Is this object currently locked */</span>
    isLocked = nil
    
    <span class="comment">/* 
     *   <a name="Thing:makeLocked">Make us locked or ublocked</a>. We define this as a method so that
     *   subclasses such as Door can override to produce side effects (such as
     *   locking or unlocking the other side).
     */</span>    
    makeLocked(stat)
    {
        isLocked = stat;
    }    
        
    <span class="comment"> /********************************************
     *   LOCK
     ********************************************/</span>    
        
        
    dobjFor(<a name="Thing:Lock">Lock</a>)
    {
        preCond = [objClosed, touchObj]
        
         <span class="comment">/* 
          *   Remap the lock action to our remapIn object if we're not lockable
          *   but we have a lockable remapIn object (i.e. an associated
          *   container).
          */</span>
        remap()
        {
            if(<a href="#Thing:lockability">lockability</a> == notLockable &amp;&amp; remapIn != nil &amp;&amp;
               remapIn.lockability != notLockable)
                return remapIn;
            else
                return self;
        }
        
        verify()
        {
            if(<a href="#Thing:lockability">lockability</a> == notLockable || lockability == nil)
                illogical(notLockableMsg);
            
            if(lockability == indirectLockable)
                implausible(indirectLockableMsg);
            
            if(isLocked)
                illogicalNow(alreadyLockedMsg);            
        }
        
        check()
        {
            <span class="comment">/* 
             *   if we need a key to be unlocked with, check whether the player
             *   is holding a suitable one.
             */</span>
            if(lockability == lockableWithKey)            
                <a href="#Thing:findPlausibleKey">findPlausibleKey</a>();                
            
               
        }
        
        action()
        {
            <span class="comment">/* 
             *   The useKey_ property will have been set by the
             *   findPlausibleKey() method at the check stage. If it's non-nil
             *   it's the key we're going to use to try to lock this object
             *   with, so we display a parenthetical note to the player that
             *   we're using this key. (Note: the action would have failed at
             *   the check stage if useKey_ wasn't the right key for the job).
             */</span>
            if(useKey_ != nil)
                extraReport(withKeyMsg);
                
            <span class="comment">/* 
             *   Otherwise, if we need a key to unlock this object with, ask the
             *   player to specify it and then execute a LockWith action
             *   using that key.
             */ </span>    
            else
                askForIobj(LockWith);
            
            <span class="comment">/*  Make us locked. */</span>
            <a href="#Thing:makeLocked">makeLocked</a>(true);                        
        }
        
        report()
        {
            DMsg(report lock, okayLockMsg, gActionListStr);
        }
    }
    
    okayLockMsg = 'Locked.|{I} {lock} {1}. '
    
    withKeyMsg = BMsg(with key, '(with {1})\n', useKey_.theName)
    
    <span class="comment">/* 
     *   Find a key among the actor's possessions that might plausibly lock or
     *   unlock us.
     */</span>
    <a name="Thing:findPlausibleKey">findPlausibleKey</a>(silent = nil)
    {
      
        useKey_ = nil;  
        local lockObj = self;        
        
       <span class="comment"> /* 
         *   First see if the actor is holding a key that is known to work on
         *   this object. If so, use it.
         */</span>
        foreach(local obj in gActor.contents)
        {
            if(obj.ofKind(Key) 
               &amp;&amp; obj.knownLockList.indexOf(self) !=  nil)
            {
                useKey_ = obj;
                return;
            }
        }
        
       <span class="comment"> /*  
         *   Then see if the actor is holding a key that might plausibly work on
         *   this object; if so, try that.
         */</span>
        foreach(local obj in gActor.contents)
        {
            if(obj.ofKind(Key) 
               &amp;&amp; obj.plausibleLockList.indexOf(self) !=  nil)
            {
                useKey_ = obj;
                break;
            }
        }
        
        <span class="comment">/*  
         *   If we haven't found a suitable key yet, check to see if the actor
         *   is holding one that might fit our lexicalParent, if we have a
         *   lexicalParent whose interior we're representing.
         *</span>/
        if(useKey_ == nil)
        {
            if(lexicalParent != nil &amp;&amp; lexicalParent.remapIn == self)
            {
                lexicalParent.findPlausibleKey();
                useKey_ = lexicalParent.useKey_;
                lockObj = lexicalParent; 
            }
        }
        
        <span class="comment">/*  
         *   If we've found a possible key but it doesn't actually work on this
         *   object, report that we're trying this key but it doesn't work.
         */</span>
        if(useKey_ &amp;&amp; useKey_.actualLockList.indexOf(lockObj) == nil &amp;&amp; !silent)
        {
            say(withKeyMsg);
            say(keyDoesntWorkMsg);            
        }
        
    }
    
    withKeyMsg = BMsg(with key, '(with {1})\n', useKey_.theName)
       
    keyDoesntWorkMsg = BMsg(key doesnt work, 'Unfortunately {1} {dummy}
        {doesn\'t work} on {the dobj}. ', useKey_.theName)
    
    useKey_ = nil
        
    <span class="comment"> /********************************************
     *   LOCKWITH
     ********************************************/</span>    
        
    dobjFor(<a name="Thing:LockWith">LockWith</a>)
    {
        preCond  = [objClosed, touchObj]
        
        <span class="comment">/* 
         *   Remap the lock action to our remapIn object if we're not lockable
         *   but we have a lockable remapIn object (i.e. an associated
         *   container).
         */</span>
        remap()
        {
            if(<a href="#Thing:lockability">lockability</a> == notLockable && remapIn != nil &&
               remapIn.lockability != notLockable)
                return remapIn;
            else
                return self;
        }
        
        verify()
        {
            if(lockability == notLockable || lockability == nil)
                illogical(notLockableMsg);
            
            if(lockability == lockableWithoutKey)
                implausible(keyNotNeededMsg);
            
            if(lockability == indirectLockable)
                implausible(indirectLockableMsg);
            
            if(lockability == lockableWithKey)
            {
                if(isLocked)
                   illogicalNow(alreadyLockedMsg);
                else                    
                    logical;
            }
        }
        
    }
    
    alreadyLockedMsg = BMsg(already locked, '{The subj dobj} {is} already
        locked. ')
    
    
    /* 
     *   Usually, if something can be used to unlock things it can also be used
     *   to lock them
     */
    canLockWithMe = (canUnlockWithMe)
       
    <span class="comment"> /********************************************
     *   LOOKBEHIND
     ********************************************/</span>    
    
    <span class="comment">/*   <a name="Thing:LookBehind"></a>
     *   By default we make it possible to look behind things, but there could
     *   be many things it makes no sense to try to look behind.
     */</span>
    
    canLookBehindMe = true    
    
    dobjFor(LookBehind)
    {
        preCond = [objVisible, touchObj]
        
        remap = remapBehind
        
        verify()
        {
            if(!canLookBehindMe)
                illogical(cannotLookBehindMsg);
        }
        
        
        action()
        {
            
            <span class="comment">/* 
             *   If we're actually a rear-type object, i.e. if our contType is
             *   Behind, try to determine what's behind us and display a list of
             *   it; if there's nothing behind us just display a message to that
             *   effect.
             */</span>
            if(contType == Behind)
            {                
                <span class="comment">/* 
                 *   If there's anything hidden behind us move it into us before
                 *   doing anything else
                 */</span>
                if(hiddenBehind.length > 0)                
                    <a href="#Thing:moveHidden">moveHidden</a>(&amp;hiddenBehind, self);                    
                
                <span class="comment">/* 
                 *   If there's nothing behind us, simply display our
                 *   lookBehindMsg
                 */</span>
                if(contents.length == 0)
                    <a href="#Thing:display">display</a>(&amp;lookBehindMsg); 
                else
                {
                    obj.<a href="#Thing:unmention">unmention</a>(contents);
                    
                    <span class="comment">/* 
                     *   It's possible that we have contents but nothing in our
                     *   contents is listable, so instead of just displaying a
                     *   list of contents we also watch to see if anything is
                     *   displayed; if nothing was we display our lookBehindMsg
                     *   instead.
                     */</span>
                    if(gOutStream.watchForOutput(
                        {: obj.listSubcontentsOf(self, lookInLister) }) == nil)                        
                        display(&amp;lookBehindMsg); 

                }
            }
            <span class="comment">/* 
             *   Otherwise, if we're not a rear-type object (our contType is not
             *   Behind), if there's anything in our hiddenBehind list move it
             *   into scope and display a list of it.
             */</span>
            else if(hiddenBehind.length > 0)            
                <a href="#Thing:findHidden">findHidden</a>(&amp;hiddenBehind, Behind);   

             <span class="comment">/*  Otherwise just display our lookBehindMsg */</span>
            else
                <a href="#Thing:display">display</a>(&amp;lookBehindMsg);           
            
            
        }
    }
    
    cannotLookBehindMsg = BMsg(cannot look behind, '{I} {can\'t} look behind
        {that dobj}. ')
    
    lookBehindMsg = BMsg(look behind, '{I} {find} nothing behind {the
        dobj}. ')
    
    <span class="comment">/* 
     *   If there's something hidden in the dobj but nowhere obvious to move it
     *   to then by default we move everything from the hiddenIn list to the
     *   actor's inventory and announce that the actor has taken it. We call
     *   this out as a separate method to make it easy to override if desired.
     */ </span>   
    <a name="Thing:findHidden">findHidden</a>(prop, prep)
    {
        DMsg(find hidden, '\^{1} {the dobj} {i} {find} {2}<<if findHiddenDest ==
              gActor>>, which {i} {take}<<end>>. ',
             prep.prep, makeListStr(self.(prop)));
        
        <a href="#Thing:moveHidden">moveHidden</a>(prop, <a href="#Thing:findHiddenDest">findHiddenDest</a>);        
    }
    
     
   
    <span class="comment">/* 
     *   <a name="Thing:findHiddenDest">If</a>  the actor finds something in a hiddenPrep list and there's nowhere
     *   obvious for it go, should he take it? By default the actor should take
     *   it if the object he's found it in/under/behind is fixed in place.
     */</span>
    autoTakeOnFindHidden = (isFixed)
    
    <span class="comment">/*   
     *   Where should an item that's been hidden in/under/behind something be
     *   moved to when its found? If it's taken, move into the actor; otherwise
     *   move it to the location of the object it's just been found
     *   in/under/behind.
     */</span>
    findHiddenDest = (autoTakeOnFindHidden ? gActor : location)
    
    
    
      
    <span class="comment"> /********************************************
     *   LOOKIN
     ********************************************/</span>  
      
    dobjFor(<a name="Thing:LookIn">LookIn</a>)
    {
        preCond = [objVisible, containerOpen]
        
        remap = remapIn        
        
        verify()
        {
            if(contType == In || remapIn != nil)
                logicalRank(120);
                        
            logical;
        }
        
        action()
        {
           <span class="comment">/* 
            *   If we're actually a container-type object, i.e. if our contType
            *   is In, try to determine what's inside us and display a list of
            *   it; if there's nothing inside us just display a message to that
            *   effect.
            */</span>
            if(contType == In)
            {            
                <span class="comment">/* 
                 *   If there's anything hidden inside us move it into us before
                 *   doing anything else
                 */</span>
                if(hiddenIn.length > 0)                
                    <a href="#Thing:moveHidden">moveHidden</a>(&amp;hiddenIn, self);                    
                
                
                <span class="comment">/* If there's nothing inside us, simply display our lookInMsg */</span>
                if(contents.length == 0)
                    <a href="#Thing:display">display</a>(&amp;lookInMsg);                    
                
                <span class="comment">/* Otherwise display a list of our contents */</span>
                else
                {
                    /* Start by marking our contents as not mentioned. */
                    <a href="#Thing:unmention">unmention</a>(contents);
                    
                    <span class="comment">/* 
                     *   It's possible that we have contents but nothing in our
                     *   contents is listable, so instead of just displaying a
                     *   list of contents we also watch to see if anything is
                     *   displayed; if nothing was we display our lookInMsg
                     *   instead.
                     */</span>
                    if(gOutStream.watchForOutput(
                        {: listSubcontentsOf(self, lookInLister) }) == nil)
                      display(&amp;lookInMsg);       

                }
            }
            
            <span class="comment">/* 
             *   Otherwise, if we're not a container-type object (our contType
             *   is not In), if there's anything in our hiddenIn list move it
             *   into scope and display a list of it.
             */</span>
            else if(hiddenIn.length > 0)            
                <a href="#Thing:findHidden">findHidden</a>(&amp;hiddenIn, In);                               
                        
            
            <span class="comment">/*  Otherwise just display our lookInMsg */</span>
            else
                <a href="#Thing:display">display</a>(&amp;lookInMsg);
        }
        
    }
    
    
    
    lookInMsg = BMsg(look in, '{I} {see} nothing interesting in {the
        dobj}. ')
    
    

    <span class="comment"> /********************************************
     *   LOOKUNDER
     ********************************************/</span>
    
    <span class="comment">/* 
     *   We can <a name="Thing:LookUnder">look under</a> most things, but there are some things (houses, the
     *   ground, sunlight) it might not make much sense to try looking under.
     */</span>
    canLookUnderMe = true
        
    
    dobjFor(LookUnder)
    {
        preCond = [objVisible, touchObj]
        
        remap = remapUnder
        
        verify()
        {
            if(!canLookUnderMe)
                illogical(cannotLookUnderMsg);       
        }
        
        
        action()
        {            
            <span class="comment">/* 
             *   If we're actually an underside-type object, i.e. if our
             *   contType is Under, try to determine what's under us and display
             *   a list of it; if there's nothing under us just display a
             *   message to that effect.
             */</span>                       
            if(contType == Under)
            {
                
                <span class="comment">/* 
                 *   If there's anything hidden under us move it into us before
                 *   doing anything else
                 */</span>
                if(hiddenUnder.length > 0)                
                    <a href="#Thing:moveHidden">moveHidden</a>(&amp;hiddenUnder, self);                    
                
                <span class="comment">/* If there's nothing under us, simply display our lookUnerMsg */</span>
                if(contents.length == 0)
                    <a href="#Thing:display">display</a>(&amp;lookUnderMsg);  
                
                <span class="comment">/* Otherwise display a list of our contents */</span>
                else
                {
                    <span class="comment">/* Start by marking our contents as not mentioned. */</span>
                    <a href="#Thing:unmention">unmention</a>(contents);
                    
                    <span class="comment">/* 
                     *   It's possible that we have contents but nothing in our
                     *   contents is listable, so instead of just displaying a
                     *   list of contents we also watch to see if anything is
                     *   displayed; if nothing was we display our lookUnderMsg
                     *   instead.
                     */</span>
                    if(gOutStream.watchForOutput(
                        {: listSubcontentsOf(self, lookInLister) }) == nil)
                        <a href="#Thing:display">display</a>(&amp;lookUnderMsg);  
                    
                }
            }
            
            <span class="comment">/* 
             *   Otherwise, if we're not an underside-type object (our contType
             *   is not Under), if there's anything in our hiddenUnder list move
             *   it into scope and display a list of it.
             */</span>
            else if(hiddenUnder.length > 0)            
                <a href="#Thing:findHidden">findHidden</a>(&amp;hiddenUnder, Under);      
            
            <span class="comment">/*  Otherwise just display our lookUnderMsg */</span>
            else
                <a href="#Thing:display">display</a>(&amp;lookUnderMsg);           
            
        }
    }
    
    cannotLookUnderMsg = BMsg(cannot look under, '{I} {can\'t} look under {that
        dobj}. ')
    
    lookUnderMsg = BMsg(look under, '{I} {find} nothing of interest under
        {the dobj}. ')
    
     
    
    <span class="comment"> /********************************************
     *   OPEN
     ********************************************/</span>
     
    <span class="comment">/* 
     *   Is this object openable. If this property is set to true then this
     *   object can be open and closed via the OPEN and CLOSE commands. Note
     *   that setting this property to true also automatically makes the
     *   OpenClosed State apply to this object, so that it can be referred to as
     *   'open' or 'closed' accordingly.
     */</span>
    isOpenable = nil
    
    <span class="comment">/* 
     *   Is this object open. By default we'll make Things open so that their
     *   interiors (if they have any) are accessible, unless they're openable,
     *   in which case we'll assume they start out closed.
     */</span>
    isOpen = (!isOpenable)
    
    <span class="comment">/* 
     *   <a name="Thing:makeOpen">Make us open or closed</a>. We define this as a method so that subclasses
     *   such as Door can override to produce side effects (such as opening or
     *   closing the other side).
     */</span>
    
    makeOpen(stat)
    {
        isOpen = stat;
    }
    
    dobjFor(<a name="Thing:Open">Open</a>)
    {
        
        preCond = [touchObj]
        
        <span class="comment">/* 
         *   If this object is not itself openable, but its remapIn property
         *   points to an associated object that is, remap this action to use
         *   the remapIn object instead of us.
         */</span>
        remap()
        {
            if(!isOpenable &amp;&amp; remapIn != nil &amp;&amp; remapIn.isOpenable)
                return remapIn;
            else
                return self;
        }
        
        verify()
        {
            if(isOpenable == nil)
                illogical(cannotOpenMsg);
            
            if(isOpen)
                illogicalNow(alreadyOpenMsg);
            
            logical;                          
        }
        
        <span class="comment">/* 
         *   An object can't be open if it's locked. We test this at check
         *   rather than verify since it may not be obvious that an object's
         *   locked until someone tries to open it.
         */</span>
        check()
        {
            if(isLocked)
                say(lockedMsg);
        }
        
        action()
        {
            <a href="#Thing:makeOpen">makeOpen</a>(true);
            if(!gAction.isImplicit)
            {              
                <a href="#Thing:unmention">unmention</a>(contents);
                
               <span class="comment">/* 
                *   If opening us is not being performed as an implicit action,
                *   list the contents that are revealed as a result of our being
                *   opened.
                */</span>
                listSubcontentsOf(self, openingContentsLister);
            }           
        }
        
        report()
        {
            DMsg(okay open, okayOpenMsg, gActionListStr);
        }
    }
    

    okayOpenMsg = 'Opened.|{I} {open} {1}. '
    
    cannotOpenMsg = BMsg(cannot open, '{The subj dobj} {is} not something {i}
        {can} open. ')
    alreadyOpenMsg = BMsg(already open, '{The subj dobj} {is} already open. ')
    lockedMsg = BMsg(locked, '{The subj dobj} {is} locked. ')
 
   
    
    <span class="comment"> /********************************************
     *   PUSH TRAVEL
     ********************************************/</span>
    
    <span class="comment">/* 
     *   Common handler for verifying push travel actions. The via parameter may
     *   be a preposition object (such as Through) defining what kind of push
     *   traveling the actor is trying to do (e.g. through a door or up some
     *   stairs).
     */</span>
    <a name="Thing:verifyPushTravel">verifyPushTravel</a>(via)
    {
       <span class="comment"> /* Note the mode of push travel (a preposition) for use in messages. */ </span>
        viaMode = via;
        
        if(!allowPushTravel)
            illogical(cannotPushTravelMsg);
        
        if(gActor.isIn(self))
            illogicalNow(cannotPushOwnContainerMsg);
        
        if(gIobj == self)
            illogicalSelf(cannotPushViaSelfMsg);
    }
        
    viaMode = ''
    
    cannotPushOwnContainerMsg = BMsg(cannot push own container, '{I} {can\'t}
        push {the dobj} anywhere while {he actor}{\'s} {1} {him dobj}. ',
                                     gDobj.objInPrep)
    
    cannotPushViaSelfMsg = BMsg(cannot push via self, '{I} {can\'t} push {the
        dobj} {1} {itself dobj}. ', viaMode.prep)
    
    <span class="comment">/* 
     *   By default we can't push travel most things. Push Travel means pushing
     *   an object from one place to another and traveling with it.
     */</span>
    allowPushTravel = nil
    
    <span class="comment"> /********************************************
     *   PUSHTRAVELDIR
     ********************************************/</span>
    
    <span class="comment">/* 
     *   PushTravelDir handles pushing an object in a particular direction, e.g.
     *   PUSH BOX NORTH
     */</span>
    dobjFor(<a name="Thing:PushTravelDir">PushTravelDir</a>)
    {
        preCond = [touchObj]
        
        verify()  {  <a href="#Thing:verifyPushTravel">verifyPushTravel</a>('');  }
        
        
        action()
        {
            <span class="comment">/* 
             *   Most of the action is carried out by the PushTravel Action. All
             *   we need to do here is to tell the action that we're allowing
             *   push travel and reveal any items that come to light as a result
             *   of moving this object.
             */</span> 
            gAction.travelAllowed = true;
            
           <span class="comment"> /*  
             *   Reveal items previously under or behind us that now become
             *   visible.
             */</span>
            <a href="#Thing:pushTravelRevealItems">pushTravelRevealItems</a>();            
        }
    }
    
    <a name="Thing:pushTravelRevealItems">pushTravelRevealItems</a>()
    {
        <span class="comment">/* 
         *   Check whether moving this object revealed any items hidden behind
         *   or beneath it (even if we don't succeed in pushing the object to
         *   another room we can presumably move it far enough across its
         *   current one to reveal any items it was concealing.
         */</span>
        revealOnMove();
        
        <span class="comment">/* 
         *   If moving this item did reveal any hidden items, we want to see the
         *   report of them now, before moving to another location./
         */</span>
        
        gCommand.afterReport();
        
        <span class="comment">/* 
         *   We don't want to see these reports again at the end of the action,
         *   so clear the list.
         */</span>
        gCommand.afterReports = [];   
    }
    
    <span class="comment">/* Display a message explaining that push travel is not possible */</span>  
    cannotPushTravelMsg()
    {
        if(isFixed)
            return cannotTakeMsg;
        return BMsg(cannot push travel, 'There{dummy}{\'s} no point trying to
            push {that dobj} anywhere. ');
    }
    
    <span class="comment">/*<a name="Thing:checkPushTravel"> Check the travel barriers</a> on the indirect object of the action */</span>
    checkPushTravel()
    {
        checkTravelBarriers(gDobj);
        checkTravelBarriers(gActor);
    }
    
    <span class="comment">/*  Carry out the <a name="Thing:doPushTravel">push travel</a> on the direct object of the action. */</span>
    doPushTravel(via)
    {
        <span class="comment">/* 
         *   Check whether moving this object revealed any items hidden behind
         *   or beneath it (even if we don't succeed in pushing the object to
         *   another room we can presumably move it far enough across its
         *   current one to reveal any items it was concealing.
         */</span>
        pushTravelRevealItems();       
        
        if(!gIobj.isLocked)
            describePushTravel(via); 
        
        <span class="comment">/*  
         *   We temporarily make the push traveler item hidden before moving it
         *   to the new location so that it doesn't show up listed in its former
         *   location when actor moves to the new location and there's a sight
         *   path between the two.
         */</span>
        local wasHidden;
        try
        {
            wasHidden = propType(&amp;isHidden) is in (TypeCode, TypeFuncPtr) ?
                    getMethod(&amp;isHidden) : isHidden;
            
            isHidden = true;
            
            gIobj.travelVia(gActor);
        }
        finally
        {
            if(dataTypeXlat(wasHidden) is in (TypeCode, TypeFuncPtr))
                setMethod(&amp;isHidden, wasHidden);
            else
                isHidden = wasHidden;
        }
        
        <span class="comment">/*   
         *   Use the travelVia() method of the iobj to move the iobj to its new
         *   location.
         */</span>        
        
        if(gActor.isIn(gIobj.destination))
        {
            gIobj.travelVia(gDobj);
            gDobj.describeMovePushable(self, gActor.location);
        }        
    }
    
    
    beforeMovePushable(connector, dir)
    {
        if(connector == nil || connector.ofKind(Room))
            DMsg(before push travel dir, '{I} push{es/ed} {the dobj} {1}. ',
                 dir.departureName);
        else
            describePushTravel(viaMode);      
        
    }
    
    describeMovePushable (connector, dest)
    {
        local obj = self;
        gMessageParams(obj, dest);
        DMsg(describe move pushable, '{The subj obj} {comes} to a halt. ' );
        
    }
    
    <span class="comment">/* 
     *   This message, called on the direct object of a PushTravel command (i.e.
     *   the object being pushed) is displayed just before travel takes place.
     *   It is used when the PushTravel command also involves an indirect
     *   object, e.g. a Passage, Door or Stairway the direct object is being
     *   pushed through, up or down. The via parameter is the preposition
     *   relevant to the kind of pushing, e.g. Into, Through or Up.
     */</span>
    describePushTravel(via)
    {
        <span class="comment">/* If I have a traversalMsg, use it */</span>
        if(gIobj &amp;&amp; gIobj.propType(&amp;traversalMsg) != TypeNil)
            DMsg(push travel traversal, '{I} push{es/ed} {the dobj} {1}. ',
                 gIobj.traversalMsg);
        else
            DMsg(push travel somewhere, '{I} push{es/ed} {the dobj} {1}
                {the iobj}. ', via.prep); 
    }
    
    
    <span class="comment"> /********************************************
     *   PUSHTRAVELTHROUGH
     ********************************************/</span>
   
    <span class="comment">/* 
     *   PushTravelThrough handles pushing something through something, such as
     *   a door or archway. Most of the actual handling is dealt with by the
     *   common routines defined above.
     */</span>
    dobjFor(<a name="Thing:PushTravelThrough">PushTravelThrough</a>)    
    {
        preCond = [touchObj]
        verify()   {   <a href="#Thing:verifyPushTravel">verifyPushTravel</a>(Through);   }
        
        action() { <a href="#Thing:doPushTravel">doPushTravel</a>(Through); }
    }
    
    iobjFor(PushTravelThrough)
    {
        preCond = [touchObj]
        verify() 
        {  
            if(!canGoThroughMe || destination == nil)
                illogical(cannotPushThroughMsg);
        }
        
        check() { <a href="#Thing:checkPushTravel">checkPushTravel</a>(); }
                
        
    }
    
    cannotPushThroughMsg = BMsg(cannot push through, '{I} {can\'t} {push}
        anything through {the iobj}. ')
    
    
    <span class="comment"> /********************************************
     *   PUSHTRAVELENTER
     ********************************************/</span>
    
    <span class="comment">/* 
     *   PushTravelEnter handles commands like PUSH BOX INTO COFFIN, where the
     *   indirect object is a Booth-like object. The syntactically identical
     *   command for pushing things into an Enterable (e.g. PUSH BOX INTO HOUSE
     *   where HOUSE represents the outside of a separate location) is handled
     *   on the Enterable class.
     */</span>
    dobjFor(<a name="Thing:PushTravelEnter">PushTravelEnter</a>)
    {
        preCond = [touchObj]
        verify()  {  <a href="#Thing:verifyPushTravel">verifyPushTravel</a>(Into);  }        
        
    }
    
    okayPushIntoMsg = BMsg(okay push into, '{I} {push} {the dobj} into {the
        iobj}. ')
    
    iobjFor(PushTravelEnter)
    {
        preCond = [containerOpen]
        verify() 
        {  
            if(!isEnterable)
                illogical(cannotPushIntoMsg);
        }
        
        check() 
        {             
            checkInsert(gActor);            
            checkInsert(gDobj);
        }    
        
        action() 
        {
            gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(self);
            gActor.<a href="#Thing:actionMoveInto">actionMoveInto</a>(self);
            if(gDobj.isIn(self))
                say(okayPushIntoMsg);
        }
    }
    
    cannotPushIntoMsg = BMsg(cannot push into, '{I} {can\'t} {push}
        anything into {the iobj}. ')
    
    <span class="comment"> /********************************************
     *   PUSHTRAVELGETOUTOF
     ********************************************/</span>
    
    
    dobjFor(<a name="Thing:PushTravelGetOutOf">PushTravelGetOutOf</a>)
    {
        preCond = [touchObj]
        verify()
        {
            <a href="#Thing:verifyPushTravel">verifyPushTravel</a>(OutOf);
            if(!self.isIn(gIobj))
                illogicalNow(notInMsg);
        }       
    }
    
    
    iobjFor(PushTravelGetOutOf)
    {
        preCond = [touchObj]
        
        verify() 
        {  
            if(!gActor.isIn(self))
                illogicalNow(actorNotInMsg);               
        }
        
        action()
        {
            gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(location);
            if(gDobj.location ==  location)
            {
                say(okayPushOutOfMsg);
                gActor.<a href="#Thing:actionMoveInto">actionMoveInto</a>(location);
            }
        }
       
    }
    
    okayPushOutOfMsg = BMsg(okay push out of, '{I} {push} {the dobj} {outof
        iobj}. ')
    
    <span class="comment"> /********************************************
     *   PUSHTRAVELCLIMBUP
     ********************************************/</span>
    
    dobjFor(<a name="Thing:PushTravelClimbUp">PushTravelClimbUp</a>)
    {
        preCond = [touchObj]
        verify()  {  <a href="#Thing:verifyPushTravel">verifyPushTravel</a>(Up);  }
        
        action() { <a href="#Thing:doPushTravel">doPushTravel</a>(Up); }
    }
    
    iobjFor(PushTravelClimbUp)
    {
        preCond = [touchObj]
        
        verify() 
        {  
            if(!isClimbable || destination == nil)
                illogical(cannotPushUpMsg);
        }
        
        check() { <a href="#Thing:checkPushTravel">checkPushTravel</a>(); }
    }
    
    cannotPushUpMsg = BMsg(cannot push up, '{I} {can\'t} {push}
        anything up {the iobj}. ')
    
    
    <span class="comment"> /********************************************
     *   PUSHTRAVELCLIMBDOWN
     ********************************************/</span>
    
    dobjFor(<a name="Thing:PushTravelClimbDown">PushTravelClimbDown</a>)
    {
        preCond = [touchObj]
        verify()  { <a href="#Thing:verifyPushTravel">verifyPushTravel</a>(Down);  }
        
        action() { <a href="#Thing:doPushTravel">doPushTravel</a>(Down); }
    }
    
    iobjFor(PushTravelClimbDown)
    {
        preCond = [touchObj]
        
        verify() 
        {  
            if(!isClimbDownable || destination == nil)
                illogical(cannotPushThroughMsg);
        }
        
        check() { <a href="#Thing:checkPushTravel">checkPushTravel</a>(); }
    }
    
    cannotPushDownMsg = BMsg(cannot push down, '{I} {can\'t} {push}
        anything down {the iobj}. ')
    
    <span class="comment"> /********************************************
     *   PUTBEHIND
     ********************************************/</span>
    
    dobjFor(<a name="Thing:dobjPutBehind">PutBehind</a>)
    {
        preCond = [objHeld, objNotWorn]
        
        verify()
        {
            if(gIobj != nil &amp;&amp; self == gIobj)
                illogicalSelf(cannotPutInSelfMsg);     
            
            if(isFixed)
                illogical(cannotTakeMsg);
            
            if(gIobj != nil &amp;&amp; (isDirectlyIn(gIobj)))
                illogicalNow(alreadyInMsg);
            
            if(gIobj != nil &amp;&amp; gIobj.isIn(self))
                illogicalNow(circularlyInMsg);           
            
                         
            logical;           
        }
        
        action()
        {
            <span class="comment">/* Handled by iobj */</span>
        }
        
        report()
        {
            DMsg(report put behind, '{I} {put} {1} behind {the iobj}. ', 
                 gActionListStr);
        }
        
            
    }
    
    iobjFor(<a name="Thing:iobjPutBehind">PutBehind</a>)
    {
        preCond = [touchObj]
        
        remap = remapBehind
        
        verify()
        {
            if(!canPutBehindMe)
                illogical(cannotPutBehindMsg);
            else
                logical;
        }
        
        check() 
        { 
            <span class="comment">/* 
             *   If we're actually a rear-like object (our contType is Behind),
             *   check whether there's enough room behind us to contain the
             *   direct object.
             */</span>
            if(contType == Behind)
                <a href="#Thing:checkInsert">checkInsert</a>(gDobj);
                
            <span class="comment">/*  
             *   Otherwise check whether adding the direct object to our
             *   hiddenBehind list would exceed the amount of bulk allowed
             *   there.
             */</span>   
             else if(gDobj.bulk &gt; maxBulkHiddenBehind - getBulkHiddenBehind)
                DMsg(no room in, 'There {dummy}{isn\'t} enough room for {the
                    dobj} behind {the iobj}. ');    
        }
        
        action()
        {
            <span class="comment">/* 
             *   If we're actually a rear-like object (i.e. if our contType is
             *   Behind) then something put behind us can be moved inside us.
             *   Otherwise, all we can do with something put behind us is to add
             *   it to our hiddenBehind list and move it off-stage.
             */</span>       
            if(contType == Behind)
                gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(self);               
            else
            {
                hiddenBehind += gDobj;
                gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(nil);
            }
        }
        
        
    }   
    
    cannotPutBehindMsg = BMsg(cannot put behind, '{I} {cannot} put anything
        behind {the iobj}. ')
    
    
    
    <span class="comment"> /********************************************
     *   PUTIN
     ********************************************/</span>
    
    dobjFor(<a name="Thing:dobjPutIn">PutIn</a>)
    {
        preCond = [objHeld, objNotWorn]
        
        verify()
        {
            if(gIobj != nil &amp;&amp; self == gIobj)
                illogicalSelf(cannotPutInSelfMsg);   
            
            if(isFixed)
                illogical(cannotTakeMsg);
            
            if(gIobj != nil &amp;&amp; isDirectlyIn(gIobj))
                illogicalNow(alreadyInMsg);
            
            if(gIobj != nil &amp;&amp; gIobj.isIn(self))
                illogicalNow(circularlyInMsg);    
            
            
            
            logical;
        }
        
              
        action()
        {                     
            <span class="comment">/* handled on iobj */</span>                          
        }
        
        report()
        {
            DMsg(report put in, '{I} {put} {1} in {the iobj}. ', gActionListStr);            
        }
    }
    
    
        
    iobjFor(<a name="Thing:iobjPutIn">PutIn</a>)
    {
        preCond = [containerOpen, touchObj]
        
        remap = remapIn 
        
        verify()
        {
            if(!canPutInMe)
                illogical(cannotPutInMsg);
            
            logical;
        }
        
        check()
        {   
            <span class="comment">/* 
             *   If we're actually a container-like object (our contType is In),
             *   check whether there's enough room inside us to contain the
             *   direct object.
             */</span>
            if(contType == In)
               <a href="#Thing:checkInsert">checkInsert</a>(gDobj);
               
            <span class="comment">/*  
             *   Otherwise check whether adding the direct object to our
             *   hiddenIn list would exceed the amount of bulk allowed there.
             */ </span>  
            else if(gDobj.bulk &gt; maxBulkHiddenIn - getBulkHiddenIn)
                DMsg(no room in, 'There {dummy}{isn\'t} enough room for {the
                    dobj} in {the iobj}. ');            
        }
        
        action()
        {
            <span class="comment">/* 
             *   If we're actually a container-like object (i.e. if our contType
             *   is In) then something put in us can be moved inside us.
             *   Otherwise, all we can do with something put in us is to add it
             *   to our hiddenIn list and move it off-stage.
             */</span>
            if(contType == In)
                gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(self);
            else
            {
                hiddenIn += gDobj;
                gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(nil);
            }  
        }      
    
    }
    
    cannotPutInMsg = BMsg(cannot put in, '{I} {can\'t} put anything in {the
        iobj}. ')
    
    
    <span class="comment"> /********************************************
     *   PUTON
     ********************************************/</span>
    
    dobjFor(<a name="Thing:dobjPutOn">PutOn</a>)
    {
        preCond = [objHeld, objNotWorn]
        
        verify()
        {
            if(gIobj != nil &amp;&amp; self == gIobj)
                illogicalSelf(cannotPutInSelfMsg);  
            
            if(isFixed)
                illogical(cannotTakeMsg);
            
            if(gIobj != nil &amp;&amp; isDirectlyIn(gIobj))
                illogicalNow(alreadyInMsg);
            
            if(gIobj != nil &amp;&amp; gIobj.isIn(self))
                illogicalNow(circularlyInMsg);               
            
            logical;
        }
        
        
        action()
        {          
            <span class="comment">/* Handled on iobj */  </span>                                  
        }
        
        report()
        {
            DMsg(report put on, '{I} {put} {1} on {the iobj}. ', gActionListStr);            
        }
    }
    
    alreadyInMsg = BMsg(already in, '{The subj dobj} {is} already {in iobj}. ')
    
    circularlyInMsg = BMsg(circularly in, '{I} {can\'t} put {the dobj} {in iobj}
        while {the subj iobj} {is} {in dobj}. ')
        
    cannotPutInSelfMsg = BMsg(cannot put in self, '{I} {can\'t} put anything
        {1} itself. ', gIobj.objInPrep)
    
    iobjFor(<a name="Thing:iobjPutOn">PutOn</a>)
    {
        
        preCond = [touchObj]
        
        remap = remapOn        
        
        verify()
        {
            if(contType != On)
                illogical(cannotPutOnMsg);
            
            logical;
        }
        
        check()
        {
            <a href="#Thing:checkInsert">checkInsert</a>(gDobj);
        }
        
        action()
        {
            gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(self);
        }      
    
    }
    
    cannotPutOnMsg = BMsg(cannot put on,'{I} {can\'t} put anything on {the
        iobj}. '   )
    
    
    
    <span class="comment"> /********************************************
     *   PUTUNDER
     ********************************************/</span>
    
    dobjFor(<a name="Thing:dobjPutUnder">PutUnder</a>)
    {
        preCond = [objHeld, objNotWorn]
        
        verify()
        {
            if(gIobj != nil &amp;&amp; self == gIobj)
                illogicalSelf(cannotPutInSelfMsg);     
            
            if(isFixed)
                illogical(cannotTakeMsg);
            
            if(gIobj != nil &amp;&amp; (isDirectlyIn(gIobj)))
                illogicalNow(alreadyInMsg);
            
            if(gIobj != nil &amp;&amp; gIobj.isIn(self))
                illogicalNow(circularlyInMsg);           
            
                         
            logical;           
        }
        
        action()
        {
            <span class="comment">/* Handled by iobj */</span>
        }
        
        report()
        {
            DMsg(report put under, '{I} {put} {1} under {the iobj}. ', 
                 gActionListStr);
        }
        
            
    }
    
    iobjFor(<a name="Thing:iobjPutUnder">PutUnder</a>)
    {
        preCond = [touchObj]
        
        remap = remapUnder
        
        verify()
        {
            if(!canPutUnderMe)
                illogical(cannotPutUnderMsg);
            else
                logical;
        }
        
        check() 
        { 
            <span class="comment">/* 
             *   If we're actually an underside-like object (our contType is
             *   Under), check whether there's enough room under us to contain
             *   the direct object.
             */</span>
            if(contType == Under)
               <a href="#Thing:checkInsert">checkInsert</a>(gDobj); 
               
            <span class="comment">/*  
             *   Otherwise check whether adding the direct object to our
             *   hiddenUnder list would exceed the amount of bulk allowed there.
             */</span>   
            else if(gDobj.bulk &gt; maxBulkHiddenUnder - getBulkHiddenUnder)
                DMsg(no room in, 'There {dummy}{isn\'t} enough room for {the
                    dobj} under {the iobj}. ');    
        }
        
        action()
        {
            <span class="comment">/* 
             *   If we're actually an underside-like object (i.e. if our
             *   contType is Under) then something put under us can be moved
             *   inside us. Otherwise, all we can do with something put under us
             *   is to add it to our hiddenUnder list and move it off-stage.
             */</span>
            if(contType == Under)
                gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(self);
            else
            {
                hiddenUnder += gDobj;
                gDobj.<a href="#Thing:actionMoveInto">actionMoveInto</a>(nil);
            }
        }
        
        
    }
    
    cannotPutUnderMsg = BMsg(cannot put under, '{I} {cannot} put anything under
        {the iobj}. ' )
    
    
    
    
    <span class="comment"> /********************************************
     *   TAKE
     ********************************************/</span> 
    
    dobjFor(<a name="Thing:Take">Take</a>)    
    {
        preCond = [touchObj]
        
        verify()
        {
            if(!isTakeable)
                illogical(cannotTakeMsg);
            
            if(isDirectlyIn(gActor))
                illogicalNow(alreadyHeldMsg);
            
            if(gActor.isIn(self))
                illogicalNow(cannotTakeMyContainerMsg);
            
            if(gActor == self)
                illogicalSelf(cannotTakeSelfMsg);
            
            logical;
        }
        
        check() 
        {
           <span class="comment"> /* 
             *   Check that the actor has room to hold the item s/he's about to
             *   pick up.
             */</span>
            <a href="#Thing:checkRoomToHold">checkRoomToHold</a>();
        }
        
        action()
        {
            <span class="comment">/* 
             *   If we have any contents hidden behind us or under us, reveal it
             *   now
             */</span>
            <a href="#Thing:revealOnMove">revealOnMove</a>();   

            <span class="comment">/* 
             *   move us into the actor who is taking us, triggering the
             *   appropriate notifications.
             */</span>            
            <a href="#Thing:actionMoveInto">actionMoveInto</a>(gActor);
        }
        
        <span class="comment">/* 
         *   Report that we've been taken. Note that if the action causes
         *   several items to be taken, this method will only be called on the
         *   final item, and will need to report on all the items taken.
         */</span>
        report()
        {            
            DMsg(report take, 'Taken. | {I} {take} {1}. ', gActionListStr);
        }
    }
       
     <span class="comment">/* By default a Thing is takeable if it's not fixed in place */</span>
    isTakeable = (!isFixed)   
       
    cannotTakeMsg = BMsg(cannot take, '{The subj dobj} {is} fixed in place.
        ')
    
    alreadyHeldMsg = BMsg(already holding, '{I}{\'m} already holding {the dobj}.
        ')
    
    cannotTakeMyContainerMsg = BMsg(cannot take my container, '{I} {can\'t}
        {take} {the dobj} while {i}{\'m} {1} {him dobj}. ', objInPrep)
    
    cannotTakeSelfMsg = BMsg(cannot take self, '{I} {can} hardly take {myself}. ')
    
    <span class="comment">/* 
     *   <a name="Thing:revealOnMove">List and move</a> into an appropriate location any item that was hidden
     *   behind or under us. We place this in a separate method so it can be
     *   conveniently called by other actions that move an object, or overridden
     *   by particular objects that want a different handling.
     *
     *   Note that we don't provide any handling for the hiddenIn property here,
     *   on the assumption that items hidden in something may well stay there
     *   when it's moved; but this method can always be overridden to provide
     *   custom behaviour.
     */</span>
    
    revealOnMove()
    {
        local moveReport = '';
        local underLoc = location;
        local behindLoc = location;
        
        <span class="comment">/* 
         *   If I don't want to leave items under me behind when I'm moved, and
         *   I am or have an underside, change the location to move items hidden
         *   under me to accordingly.
         */</span>
        if(contType == Under &amp;&amp; dropItemsUnder == nil)
            underLoc = self;
        else if(remapUnder != nil &amp;&amp; dropItemsUnder == nil)
            underLoc = remapUnder;
        
        <span class="comment"> /* 
          *   If I don't want to leave items behind me behind when I'm moved,
          *   and I am or have a RearContainer, change the location to move
          *   items hidden under me to accordingly.
          */</span>
        if(contType == Behind &amp;&amp; dropItemsBehind == nil)
            behindLoc = self;
        else if(remapBehind != nil &amp;&amp; dropItemsBehind == nil)
            behindLoc = remapBehind;
        
        
        <span class="comment">/* 
         *   If anything is hidden under us, add a report saying that it's just
         *   been revealed moved and then move the previously hidden items to
         *   our location.
         */</span>
        if(hiddenUnder.length &gt; 0)
        {
            moveReport += 
                BMsg(reveal move under,'Moving {1} {dummy} reveal{s/ed} {2}
                    previously hidden under {3}. ',
                     theName, makeListStr(hiddenUnder), himName);
                                
            <a href="#Thing:moveHidden">moveHidden</a>(&amp;hiddenUnder, underLoc);
            
        }
        
        <span class="comment">/* 
         *   If anything is hidden behind us, add a report saying that's just
         *   been revealed and then move the previously hidden items to our
         *   location.
         */</span>
        if(hiddenBehind.length &gt; 0)
        {
            moveReport += 
                BMsg(reveal move behind,'Moving {1} {dummy} reveal{s/ed} {2}
                    previously hidden behind {3}. ',
                     theName, makeListStr(hiddenBehind), himName);
                        
            <a href="#Thing:moveHidden">moveHidden</a>(&amp;hiddenBehind, behindLoc);            
        }
         

        local lst = [];
        
        <span class="comment">/* 
         *   Construct a list of anything left behind from under or behind us
         *   when we're moved.
         */</span>
        if(dropItemsUnder)
        {
            if(contType == Under)
                lst = contents;
            else if(remapUnder)
                lst = remapUnder.contents;                    
        }
               
        if(dropItemsBehind)
        {
            if(contType == Behind)
                lst += contents;
            else if(remapBehind)
                lst += remapBehind.contents;           
        }
        
        lst = lst.subset({o: !o.isFixed});
        
        if(lst.length &gt; 0)
        {
            foreach(local cur in lst)
                cur.moveInto(location);                
         
            moveReport +=
                BMsg(report left behind, '&lt;&lt;if moveReport == ''&gt;&gt;Moving {1}
                    &lt;&lt;else&gt;&gt;It also &lt;&lt;end&gt;&gt; {dummy} {leaves} {2} behind. ',
                     theName, makeListStr(lst));
        }
        
        <span class="comment">/* 
         *   If anything has been reported as being revealed, report the
         *   discovery after reporting the action that caused it.
         */</span>
        if(moveReport != '' )
            reportAfter(moveReport);
    }
    
    <span class="comment">/* 
     *  <a name="Thing:moveHidden"> Service method</a>: move everything in the prop property to loc and mark it
     *   as seen
     */</span>    
    moveHidden(prop, loc)
    {
        foreach(local cur in self.(prop))
        {
            cur.moveInto(loc);
            cur.noteSeen();
        }
        self.(prop) = [];
                
    }
    
    <span class="comment"><a name="Thing:checkRoomToHold">/*</a> 
     *   Check that the actor has enough spare bulkCapacity to add this item to
     *   his/her inventory. Since by default everything has a bulk of zero and a
     *   very large bulkCapacity by default there will be no effective
     *   restriction on what an actor (and in particular the player char) can
     *   carry, but game authors may often wish to give portable items bulk in
     *   the interests of realism and may wish to impose an inventory limit by
     *   bulk by reducing the bulkCapacity of the player char.
     */</span>    
    checkRoomToHold()
    {
        <span class="comment">/* 
         *   First check whether this item is individually too big for the actor
         *   to carry.
         */</span>
        if(bulk &gt; gActor.maxSingleBulk)
            DMsg(too big to carry, '{The subj dobj} {is} too big for {me} to
                carry. ');
                
        <span class="comment">/* 
         *   If the BagOfHolding class is defined and the actor doesn't have
         *   enough spare bulk capacity, see if the BagOfHolding class can deal
         *   with it by moving something to a BagOfHolding.
         */</span>
        if(defined(BagOfHolding) 
           &amp;&amp; bulk &gt; gActor.bulkCapacity - gActor.getCarriedBulk
           &amp;&amp; BagOfHolding.tryHolding(self));        
                
        /* 
         *   otherwise check that the actor has sufficient spare carrying
         *   capacity.
         */
        else if(bulk &gt; gActor.bulkCapacity - gActor.<a href="#Thing:getCarriedBulk">getCarriedBulk</a>())
            DMsg(cant carry any more, '{I} {can\'t} carry any more than
                {i}{\'m} already carrying. ');
    }
    
    <span class="comment"> /********************************************
     *   TAKEFROM
     ********************************************/</span>
    
    <span class="comment">/* 
     *   We treat TAKE FROM as equivalent to TAKE except at the verify stage,
     *   where we first check that the direct object is actually in the indirect
     *   object.
     */</span>
    dobjFor(<a name="Thing:dobjTakeFrom">TakeFrom</a>) asDobjWithoutVerifyFor(<a href="#Thing:Take">Take</a>)
    
    dobjFor(TakeFrom)
    {           
        verify()
        {
            if(!isTakeable)
                illogical(cannotTakeMsg);
            
            if(gIobj.notionalContents.indexOf(self) == nil)
                illogicalNow(notInMsg);
            if(self == gIobj)
                illogicalSelf(cannotTakeFromSelfMsg);
        }        
    }
    
    
    iobjFor(<a name="Thing:iobjTakeFrom">TakeFrom</a>)
    {
        preCond = [touchObj]
        
        verify()       
        {          
           <span class="comment"> /*We're a poor choice of indirect object if there's nothing in us */</span>
            if(notionalContents.countWhich({x: !x.isFixed}) == 0)
                logicalRank(70);
            
            <span class="comment">/* 
             *   We're also a poor choice if none of the tentative direct
             *   objects is in our list of notional contents
             */</span>
            if(gTentativeDobj.overlapsWith(notionalContents) == nil)
                logicalRank(80);        
        
        }      
    }
    
    notInMsg = BMsg(not inside, '{The dobj} {is}n\'t {in iobj}. ')
    cannotTakeFromSelfMsg =  BMsg(cannot take from self, '{I} {can\'t} take
        {the subj dobj} from {the dobj}. ')
    
    
    <span class="comment"> /********************************************
     *   UNLOCK
     ********************************************/</span>
    
    
    dobjFor(<a name="Thing:Unlock">Unlock</a>)
    {
        preCond = [touchObj]
        
        <span class="comment">/* 
         *   Remap the unlock action to our remapIn object if we're not lockable
         *   but we have a lockable remapIn object (i.e. an associated
         *   container).
         */</span>
        remap()
        {
            if(<a href="#Thing:lockability">lockability</a> == notLockable && remapIn != nil &&
               remapIn.lockability != notLockable)
                return remapIn;
            else
                return self;
        }
        
        verify()
        {
            if(lockability == notLockable || lockability == nil)
                illogical(notLockableMsg);
            
            if(lockability == indirectLockable)
                implausible(indirectLockableMsg);
            
            if(!isLocked)            
                illogicalNow(notLockedMsg);
            
        }
        
        check()
        {
            /* 
             *   if we need a key to be unlocked with, check whether the player
             *   is holding a suitable one.
             */
            if(lockability == lockableWithKey)
            {
                <a href="#Thing:findPlausibleKey">findPlausibleKey</a>();                
            }
               
        }
        
        action()
        {
            <span class="comment">/* 
             *   The useKey_ property will have been set by the
             *   findPlausibleKey() method at the check stage. If it's non-nil
             *   it's the key we're going to use to try to unlock this object
             *   with, so we display a parenthetical note to the player that
             *   we're using this key. (Note: the action would have failed at
             *   the check stage if useKey_ wasn't the right key for the job).
             */</span>
            if(useKey_ != nil)
                extraReport(withKeyMsg);
                
            <span class="comment">/* 
             *   Otherwise, if we need a key to unlock this object with, ask the
             *   player to specify it and then execute an UnlockWith action
             *   using that key.
             */</span>
            else
                askForIobj(UnlockWith);
            
            <span class="comment">/*  Make us unlocked. */</span>
            <a href="#Thing:makeLocked">makeLocked</a>(nil);                        
        }
        
        report()
        {
            DMsg(report unlock, okayUnlockMsg, gActionListStr);
        }
    }
    
    okayUnlockMsg = 'Unlocked.|{I} {unlock} {1}. '
    
    
    <span class="comment"> /********************************************
     *   UNLOCKWITH
     ********************************************/</span>
    
    dobjFor(<a name="Thing:UnlockWith">UnlockWith</a>)
    {
        
        preCond = [touchObj]
        
        <span class="comment">/* 
         *   Remap the unlock action to our remapIn object if we're not lockable
         *   but we have a lockable remapIn object (i.e. an associated
         *   container).
         */</span>
        remap()
        {
            if(<a href="#Thing:lockability">lockability</a> == notLockable &amp;&amp; remapIn != nil &amp;&amp;
               remapIn.lockability != notLockable)
                return remapIn;
            else
                return self;
        }
        
        verify()
        {
            <span class="comment">/* 
             *   If we're not lockable at all, we're a very poor choice of
             *   direct object for an UnlockWith action.
             */</span>
            if(lockability == notLockable || lockability == nil)
                illogical(notLockableMsg);
            
            <span class="comment">/*  
             *   If we're lockable, but not with a key (either because we don't
             *   need one at all or because we use some other form of locking
             *   mechanism) then we're still a bad choice of object for an
             *   UnlockWith action, but not so bad as if we weren't lockable at
             *   all.
             */</span>
            if(lockability == lockableWithoutKey)
                implausible(keyNotNeededMsg);
            
            if(lockability == indirectLockable)
                implausible(indirectLockableMsg);
            
            <span class="comment">/*  
             *   If we are lockable with key, then were a good choice of object
             *   for an UnlockWith action provided we're currently locked.
             */</span>
            if(lockability == lockableWithKey)
            {
                if(isLocked)
                    logical;
                else
                    illogicalNow(notLockedMsg);
            }
        }
    }
    
    notLockableMsg = BMsg(not lockable, '{The subj dobj} {isn\'t} lockable. ')
    keyNotNeededMsg = BMsg(key not needed,'{I} {don\'t need} a key to lock and
        unlock {the dobj}. ')
    indirectLockableMsg = BMsg(indirect lockable,'{The dobj} {appears} to use
        some other kind of locking mechanism. ')
    notLockedMsg = BMsg(not locked, '{The subj dobj} {isn\'t} locked. ')
        
    iobjFor(UnlockWith)
    {
        verify()
        {
            if(!canUnlockWithMe)
               illogical(cannotUnlockWithMsg);
            
            if(gDobj == self)
                illogicalSelf(cannotUnlockWithSelfMsg);
        }      
    }
    
   <span class="comment"> /* 
     *   Most things can't be used to unlock with. In practice there's probably
     *   little point in overriding this property since if you do want to use
     *   something to unlock other things with, you'd use the Key class.
     */</span>
    canUnlockWithMe = nil 
    
    cannotUnlockWithMsg = BMsg(cannot unlock with, '{I} {can\'t} unlock
        anything with {that dobj}. ' )
    
    cannotUnlockWithSelfMsg = BMsg(cannot unlock with self, '{I} {can\'t} unlock
        anything with itself. ' )
;




</pre></div>


 <p><div class="code"><pre>
 <span class="comment">/*  
 *   A Key is any object that can be used to lock or lock selected items whose
 *   lockabilty is lockableWithKey. We define all the special handling on the
 *   Key class rather than on the items to be locked and/or unlocked.
 */</span>
<strong>class Key: Thing</strong>

    <span class="comment">/* The list of things this key can actually be used to lock and unlock. */</span>    
    actualLockList = []
    
    <span class="comment">/* 
     *   The list of things this key plausibly looks like it might lock and
     *   unlock (e.g. if we're a yale key, we might list all the doors in the
     *   game that have yale locks here).
     */</span>
    plausibleLockList = []
    
    <span class="comment">/* 
     *   The list of all the things the player character knows this key can lock
     *   and unlock. Items are automatically added to this list when this key is
     *   successfully used to lock or unlock them, but game code can also use
     *   this property to list items the player character starts out knowing,
     *   such as the door locked by his/her own front door key.
     */</span>
    knownLockList = []
    
    <span class="comment">/*  
     *   Determine whether we're a possible key for obj (i.e. whether we might
     *   be able to lock or unlock obj).
     */</span>
    <a name="Key:isPossibleKeyFor">isPossibleKeyFor</a>(obj)
    {
        <span class="comment">/* 
         *   First test if we've been defined as a plausible or known key for
         *   our lexicalParent in the case that we're the remapIn object for our
         *   lexicalParent. If so return true. We do this because game code
         *   might easily define the plausibleKeyList and/or knownKeyList on our
         *   lexicalParent intending to refer to what keys might unlock is
         *   associated container (i.e. ourselves if we're our lexicalParent's
         *   remapIn object).
         */</span> 
        if(obj.lexicalParent != nil &amp;&amp; obj.lexicalParent.remapIn == obj
           &amp;&amp;(knownLockList.indexOf(obj.lexicalParent) != nil
              || plausibleLockList.indexOf(obj.lexicalParent) != nil))
            return true;
        
        <span class="comment">/* 
         *   Otherwise return true if obj is in either our knownLockList or our
         *   plausibleLockList or nil otherwise.
         */</span>
        return knownLockList.indexOf(obj) != nil ||
            plausibleLockList.indexOf(obj) != nil;
    }
    
    <span class="comment">/* A key is something we can unlock with. */</span>
    canUnlockWithMe = true
    
    iobjFor(<a name="Key:UnlockWith">UnlockWith</a>)
    {
        preCond = [objHeld]
        
               
        verify()
        {
            inherited;
            
            <span class="comment">/* 
             *   We're a logical choice of key if we're a possible key for the
             *   direct object.
             */</span>
            if(<a href="#Key:isPossibleKeyFor">isPossibleKeyFor</a>(gDobj))
                logical;
                
            <span class="comment">/* Otherwise we're not a very good choice. */ </span>   
            else
                implausible(notAPlausibleKeyMsg);            
        }
        
        check()
        {
            <span class="comment">/* 
             *   Check whether this key *actually* fits the direct object, and
             *   if not display a message to say it doesn't (which halts the
             *   action).
             *
             *   This is complicated by the fact that if the direct object is a
             *   SubComponent the game author may have listed the dobj's
             *   lexicalParent in our actualLockList property instead of the
             *   actual dobj (e.g. the fridge object itself instead of the
             *   SubComponent representing the interior of the fridge). So in
             *   addition to seeing if the dobj is included in our
             *   actuallockList we need to check whether, if the dobj has a
             *   lexicalParent of which it's the remapIn object, dobj's
             *   lexicalParent is in our actualLockList.
             */</span>
            if(actualLockList.indexOf(gDobj) == nil
               &amp;&amp; (gDobj.lexicalParent == nil
               || gDobj.lexicalParent.remapIn != gDobj
               || actualLockList.indexOf(gDobj.lexicalParent) == nil))
                say(keyDoesntFitMsg);              
        }
        
        action()
        {
            <span class="comment">/* Make the dobj unlocked. */</span>
            gDobj.<a href="#Thing:makeLocked">makeLocked</a>(nil);
            
            <span class="comment">/* If the dobj is not already in our knownLockList, add it there. */</span>
            if(knownLockList.indexOf(gDobj) == nil)
                knownLockList += gDobj;
        }
        
        report()
        {
            DMsg(okay unlock with, okayUnlockWithMsg, gActionListStr);
        }
        
    }
    
    okayUnlockWithMsg = '{I} {unlock} {the dobj} with {the iobj}. '
    
    iobjFor(<a name="Key:LockWith">LockWith</a>)
    {
        preCond = [objHeld]
        
        verify()
        {
            inherited;
            
            if(<a href="#Key:isPossibleKeyFor">isPossibleKeyFor</a>(gDobj))
                logical;
            else
                implausible(notAPlausibleKeyMsg);            
        }
        
        check()
        {
            <span class="comment">/* 
             *   Check whether this key *actually* fits the direct object, and
             *   if not display a message to say it doesn't (which halts the
             *   action).
             *
             *   This is complicated by the fact that if the direct object is a
             *   SubComponent the game author may have listed the dobj's
             *   lexicalParent in our actualLockList property instead of the
             *   actual dobj (e.g. the fridge object itself instead of the
             *   SubComponent representing the interior of the fridge). So in
             *   addition to seeing if the dobj is included in our
             *   actuallockList we need to check whether, if the dobj has a
             *   lexicalParent of which it's the remapIn object, dobj's
             *   lexicalParent is in our actualLockList.
             */</span>
             if(actualLockList.indexOf(gDobj) == nil
               &amp;&amp; (gDobj.lexicalParent == nil
               || gDobj.lexicalParent.remapIn != gDobj
               || actualLockList.indexOf(gDobj.lexicalParent) == nil))
                say(keyDoesntFitMsg);              
        }
        
        action()
        {
            <span class="comment">/*Make the dobj locked. */</span>
            gDobj.<a href="#Thing:makeLocked">makeLocked</a>(true);
            
            <span class="comment">/* If the dobj is not already in our knownLockList, add it there. */</span>
            if(knownLockList.indexOf(gDobj) == nil)
                knownLockList += gDobj;
        }
        
        report()
        {
             DMsg(okay lock with, okayLockWithMsg, gActionListStr);
        }
    }
    
    <span class="comment">/* The message to say that the actor has lock the dobj with this key. */</span>
    okayLockWithMsg = '{I} {lock} {the dobj} with {the iobj}. '
    
    <span class="comment">/* 
     *   The message to say that this key clearly won\'t work on the dobj
     *   (because it\'s the wrong sort of key for the lock; e.g. a yale key
     *   clearly won\'t fit the lock on a small jewel box).
     *</span>/
    notAPlausibleKeyMsg = '\^&lt;&lt;theName&gt;&gt; clearly won\'t work on &lt;&lt;gDobj.theName&gt;&gt;. '
    
    <span class="comment">/*  The message to say that this key doesn\'t in fact fit the dobj. */</span>
    keyDoesntFitMsg = '\^&lt;&lt;theName&gt;&gt; won\'t fit &lt;&lt;gDobj.theName&gt;&gt;. '   
    
    preinitThing()
    {
        inherited;
        
        <span class="comment">/* 
         *   Add the actualLockList to the plausibleLockList if it's not already
         *   there to ensure that this key will work on anything in its
         *   actualLockList.
         */</span>
        plausibleLockList = plausibleLockList.appendUnique(actualLockList);
    }
;
</pre></div>



</div>
<hr class="navb"><div class="navb">
<i>adv3Lite Library Manual</i><br>
<a class="nav" href="toc.htm">Table of Contents</a> | 
<a class="nav" href="action.htm">Actions</a> &gt; 
Source Reference
<br><span class="navnp"><a class="nav" href="actionref.htm"><i>Prev:</i> ActionReference</a> &nbsp;&nbsp;&nbsp; <i>Next:</i> <a class="nav" href="actionref.htm">ActionReference</a> &nbsp;&nbsp;&nbsp;</span>

</div>
</body>
</html>
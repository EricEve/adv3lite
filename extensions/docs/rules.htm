<html>
<!-- DERIVED FILE - DO NOT EDIT -->

<head>
<title>Rules</title>

<link rel="stylesheet" href="sysman.css" type="text/css">
</head>
<body>
<div class="topbar"><img src="../../docs/manual/topbar.jpg" border=0></div>
<div class="nav">
<a class="nav" href="../../docs/manual/toc.htm">Table of Contents</a> | 
<a class="nav" href="../../docs/manual/extensions.htm">Extensions</a> &gt; 
Rules
<br><span class="navnp"><a class="nav" href="roomparts.htm"><i>Prev:</i> Room Parts</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="sensory.htm"><i>Next:</i> Sensory</a> &nbsp;&nbsp;&nbsp; </span>

</div>
<div class="main">

<h1>Rules</h1>
<h2>Overview</h2>
<p>The purpose of the <a href="../rules.t">rules.t</a> extension is to allow game code to define Rules and RuleBooks. Rules are associated with RuleBooks, which may be invoked at any point in game code to carry out actions and/or return values to their caller.</p>

<p>In brief, calling the <strong>follow()</strong> method of a RuleBook causes it to call the <span class="code">follow()</span> method of each of its associated Rules in descending order of precedence (ignoring those Rules that don't match their conditions) until either one of these Rules stops the sequence or there are no more Rules to call. The value returned to the RuleBook by the last-executed Rule's <span class="code">follow()</span> method is then returned to the caller of the RuleBook's <span class="code">follow()</span> method.</p>

<p>Doers and TopicEntries (especially Doers) are standard classes in the main adv3Lite library that act a little like Rules, but the Rules extension allows you to generalize this kind of functionality into all sorts of other situations. It is most likely to be most useful in situations where otherwise a tangle of nested if statements and switch statements would be needed to code complex interactions, but you are, of course, free to use rules wherever you wish.</p>
<br>

<h2>New Classes, Methods and Properties</h2>
<p>In addition to a number of objects, properties and methods intended purely for internal use, this extension defines the following new classes, methods and properties:</p>
<ul>
<li><em>Classes</em>: <strong>Rule</strong> and <strong>RuleBook</strong>.</li>

<li><em>Properties/Methods on Rule</em>: <span class="code">follow()</span>, <span class="code">priority</span>, <span class="code">execAfter</span>, <span class="code">execBefore</span>, <span class="code">isActive</span>, <span class="code">activate()</span>, <span class="code">deactivate()</span>, <span class="code">addTo(rb)</span>, <span class="code">moveTo(rb)</span>, <span class="code">removeFrom(rb)</span>, <span class="code">stopValue</span>, <span class="code">where</span>, <span class="code">when</span>, <span class="code">who</span>, <span class="code">during</span>, <span class="code">action</span>, <span class="code">dobj</span>, <span class="code">iobj</span>, <span class="code">aobj</span>, and <span class="code">matchObj</span>.</li>
<li><em>Properties/Methods on RuleBook</em>: <span class="code">follow()</span>, <span class="code">actor</span>, <span class="code">contVal</span>, <span class="code">defaultVal</span>, and <span class="code">initBook()</span>.</li>
</ul>
<br>

<h2>Usage</h2>
<p>Include the rules.t file after the library files but before your game source files.</p>
<br>
<h3>Defining Rules and Rulebooks</h3>

<p>At its simplest a RuleBook can be defined simply by giving it a name and making it of the RuleBook class:</p>

 <p><div class="code"><pre>
 jumpRules: RuleBook
 ;
 </pre></div>

<p>Unless you need to refer to them in some other part of your code, rules can usually be defined as anonymous objects located in the RuleBook to which they belong by using the + property. The one method you must define on a Rule is its follow() method; for example:</p> 
 
 <p><div class="code"><pre>
 + Rule
    where = room
    
    follow()
    {
        "You jump pointlessly. ";        
    }
;

+ Rule 
    where = nextRoom
    
    follow()
    {
        "You jump fruitfully. ";        
    }    
;

+ Rule
    follow()
    {
        "You jump energetically. ";       
    }  
; 
 </pre></div> 

<p>In this case we could have defined these rules even more succinctly as:</p> 
 
  <p><div class="code"><pre>
 + Rule
    where = room
    
    follow = "You jump pointlessly. "
;

+ Rule 
    where = nextRoom
    
    follow = "You jump fruitfully. "        
;

+ Rule
    follow =  "You jump energetically. "          
; 
 </pre></div> 
 
 <p>We can do that here because in this RuleBook, the <span class="code">follow()</span> methods take no arguments. You can, however, define as many arguments to the <span class="code">follow()</span> method of a RuleBook as you like; precisely the same arguments will then be passed to the <span class="code">follow()</span> methods of any Rule it invokes, so you must make sure that the argument lists match, or you'll get a run-time error. If in doubt you can use the variable argument list notation to ensure that your Rules match any argument lists that are passed to them, for instance:</p>
 
  <p><div class="code"><pre>
 + Rule
    where = room
    
    follow([args])
    {
        "You jump pointlessly. ";        
    }
;

+ Rule 
    where = nextRoom
    
    follow([args])
    {
        "You jump fruitfully. ";        
    }    
;

+ Rule
    follow([args])
    {
        "You jump energetically. ";       
    }  
; 
 </pre></div> 
 
<br> 
 
<h3>Specifying Match Conditions on Rules</h3> 
 
<p>Rules are only useful for distinguishing what should happen under different circumstances. Most of the rules you define (with the possible exception of the odd catch-all rule) will need to specify the conditions under which they apply. This can be specified using one or more of the following properties:</p> 

<ul>
<li><strong>where</strong>: This can be the location either of the player character (the default) or of the current actor, depending on the value of the parent rulebook's actor <span class="code">property</span> (indeed it could be the location of whatever object is specified in the rulebook's actor property, but the intention is that this should normally be either <span class="code">gPlayerChar</span> or <span class="code">gActor</span>). The <span class="code">where</span> can be defined as a Room, a Region or a list of Rooms and/or Regions.</li>

<li><strong>when</strong>: This can be any condition that must be true for the Rule to be matched. This is for use when none of the other means of speficifying rule conditions will do the job.</li>

<li><strong>who</strong>: The current actor (<span class="code">gActor</span>): this can be specified as a single actor or as a list of actors.</li>

<li><strong>during:</strong> A Scene or a list of Scenes, one of which must be currently happening for this Rule to be matched.</li>

<li><strong>action</strong>: An action of list of actions, of one which must be the current action (<span class="code">gAction</span>) for the Rule to be matched.</li>

<li><strong>dobj</strong>: The direct object of the current action. This may be specified as an object, a class, or a list of objects and/or classes.</li>
<li><strong>iobj</strong>: The indirect object of the current action. This may be specified as an object, a class, or a list of objects and/or classes.</li>
<li><strong>aobj</strong>: The accessory object of the current action. This may be specified as an object, a class, or a list of objects and/or classes. Note that this property is only applicable when the <a href="tiaaction.htm">TIAAction</a> extension is included in your game.</li>
<li><strong>matchObj</strong>: an object or class or list of objects and/or classes one of which much match the first argument passed to the rulebook's <span class="code">follow()</span> method. For example if the rulebook is invoked with <span class="code">follow(helmetOfDoom)</span> the Rule would be matched if its <span class="code">matchObj</span> property was <span class="code">helmetOfDoom</span> or <span class="code">Thing</span> or <span class="code">[helmetOfDoom, pinkRabbit, cuddlyBear]</span> (or anything else that included the <span class="code">helmetOfDoom</span>). Note that while this condition is principally intended to be used with objects, it will in fact work with any kind of value, such as numbers and strings.</li>
</ul>

<p>Note that where any of the foregoing properties is specified as a list, the Rule will match if any of the items in the list matches (provided, of course, that any other conditions are also met).</p>

<p>For example, to write a Rule that matches when either Fred or Mary drops the crown jewels in either the hall or the lounge during the party scene when the queen can see them you might write:</p>
 
 <p><div class="code"><pre>
+ Rule
    follow()
    {
       "Oh dear! That was jolly embarrassing! Her Majesty does not look at all amused.&lt;.p&gt;";    
    }
    
    where = [hall, lounge]
    during = party
    who = [fred, mary]
    action = Drop
    dobj = crownJewels
    when = (queen.canSee(gActor))
;
 </pre></div> 
<p>(Assuming, that is, that we know that the player character will always be present in the same location, otherwise further conditions would need to be added).</p> 
 <br>
 
<h3>Rules' Order of Precedence</h3>
 
<p>We stated above that when RuleBooks are called, they run through their matching Rules in descending order of precedence. But how is that order of precedence determined?</p> 

<p>Left to its own devices, the Rules extensions orders rules according to their specificity (how specific their conditions are). The more conditions are specified (out of <span class="code">when</span>, <span class="code">where</span>, <span class="code">who</span>, <span class="code">during</span>, <span class="code">action</span>, <span class="code">dobj</span>, <span class="code">iobj</span>, <span class="code">aobj</span> and <span class="code">matchObj</span>) the more specific the Rule is considered to be. Also, a where condition referencing at least one Room is considered more specific that one that one references Regions, and a <span class="code">dobj</span>, <span class="code">iobj</span>, <span class="code">aobj</span> or <span class="code">matchObj</span> property that includes at least one object is considered more specific that one that only refers to classes. Finally, if two rules appear to be equally specific, precedence is given to the one defined later in your source code (it may at first sight seem counter-intuitive to do it this way round, but this is consistent with the way the library handles Doers and AltTopics). Normally this default ordering will give you what you want; a more specific rule will take precedence over a more general rule without your having to worry about it. Note, however, that the library has no way of judging how specific a <span class="code">when</span> condition is, which is why it's normally better to use the other condition properties when you can.</p>

<p>If for any reason you need to change the order of precedence there are a couple of ways you can do so. The first is to specify that the current rule must run either after or before one or more other specified rules (which would then need to be named so they can be referred to), by listing those other rules in the <strong>execAfter</strong> or <strong>execBefore</strong> properties respectively. For example, to ensure that your dangerousJumpRule executes after your dodgyJumpRule bur before your fatalJumpRule you might write:</p>
 
  <p><div class="code"><pre>
+ dangerousJumpRule: Rule
     action = 'Jump'
     follow = "I wouldn't jump here if I were you. "
     execAfter = [dodgyJumpRule]
     execBefore = [fatalJumpRule]
;  
  </pre></div>

<p>This will then override any other ordering the library would have made. Note, however, it is then your responsibility to ensure that any use you make of <span class="code">execAfter</span> and <span class="code">execBefore</span> is consistent. If the <span class="code">dodgyJumpRule</span> were specified in both the execAfter and the execBefore properties of the same rule, for example, this would be self-contradictory; in this case the library would resolve the contradiction by ignoring the execBefore specification. On the other were rule A to specify that it is to be run after rule B, while rule B specified that it was to run after rule A, the outcome would be unpredictable.</p>  
 
<p>The second method of reordering rules is to override their <strong>priority</strong> property. The default <span class="code">priority</span> is 100. The higher the priority, the higher the precedence, so that a Rule with a priority of 2000 will be run before a Rule with a <span class="code">priority</span> of 1. Changing the <span class="code">priority</span> to a very high or a very low value can thus be a useful way of ensuring that a Rule runs towards the beginning or the end of its RuleBook (or, provided you assign the <span class="code">priority</span> numbers with sufficient care) that it is either the very first or the very last Rule to be considered. Note that any rearrangement of rule ordering carried out via the <span class="code">execBefore</span> or <span class="code">execAfter</span> properties will take precedence over the setting of the <span class="code">priority</span> property, however. Apart from that, Rules with the same <span class="code">priority</span> will be ordered according to their specificity.</p> 

<p>A RuleBook resorts the rules it is considering each time its <span class="code">follow()</span> method is called, so that if you change the value of the <span class="code">priority</span>, <span class="code">execBefore</span> or <span class="code">execAfter</span> properties during the course of your game, these changes will take effect the next time the corresponding RuleBook is invoked. Normally, however, a rule's specificity is only calculated once, at preinit, so if you made any changes to a rule that might change its specificity you would need explicitly to issue the statement <span class="code">x.specificity = x.calcSpecificity()</span> (where <em>x</em> was the rule in question) for any reordering to take effect. Such dynamic changes to rules' precedence and conditions should only be needed very rarely and should be used very sparingly, otherwise your code is likely to become quite confusing.</p>

<br>

<h3>Starting and Stopping Rulebooks: Return Values and Parameters</h3>
<p>As we have seen, the way to start a RuleBook is to call its <strong>follow()</strong> method. This causes it to select all of the rules that belong to it that also match their various criteria, and then to run through them in descending order of precedence, calling each of their <span class="code">follow()</span> methods in turn until either there are no more rules to consider or one of the rules signals that no more rules should be considered after itself. But how does a rule signal that?</p>

<p>The default behaviour is for a RuleBook to stop iterating through its rules when one of its rules returns any value except <strong>null</strong>, where <span class="code">null</span> is an enum that has been defined for this purpose. Since TADS 3 considers a method that does not have an explicit return value to implicitly return <span class="code">nil</span> (and since <span class="code">nil</span> and <span class="code">null</span> are different values) this means that the default behaviour of a RuleBook is to execute the highest priority matching rule, and then stop iterating through any other rules that happen to match. Since the RuleBook returns whatever its last-executed rule returns, this means that by default it will simply return <span class="code">nil</span> to its caller (assuming it actually executes any rules). Often this behaviour may be just what you want, since if you simply want your RuleBook to execute the most appropriate Rule, you may not be interested in the return value, and you will probably want the RuleBook to stop at the first rule it finds (in order of precedence).</p>

<p>There may be occasions when you want to change this behaviour, however. First, it may that you want to define a Rule that doesn't stop its RuleBook. You can do that by ending the <span class="code">follow()</span> method of that rule with the <strong>nostop</strong> macro, for example:</p>

 <p><div class="code"><pre>
+ Rule
    priority = 1000
    follow()
    {
        "You tense yourself. ";
        nostop;
    }
;
 </pre></div>

<p>This rule will always run first (assuming there's no rule in the same RuleBook to which we've given a higher priority), but it won't stop the RuleBook. By the way we could have used  <span class="code">return null</span> rather than <span class="code">nostop</span> here, but not only is <span class="code">nostop</span> less typing (and perhaps clearer in meaning), for reasons we'll explain shortly it's also safer.</p>

<p>If you're defining a RuleBook in which you want the majority of Rules not to stop the processing of further Rules in that RuleBook, you can override the RuleBook's <strong>contValue</strong> (short for 'continuation value') to <span class="code">nil</span> instead of <span class="code">null</span>. The <span class="code">contValue</span> property defines the value a Rule must return if it is <strong>not</strong> to stop the processing of the RuleBook. Since (as we mentioned just above) a method with no explicit return value implicitly returns nil, this means that the RuleBook won't then stop at a rule with no explicit return value (and hence an implicit return value of nil). If you want some rules in such a RuleBook to stop the RuleBook from processing any more rules, you can make those rules return a non-nil value or use the <strong>stop</strong> macro to do this for you (by default <span class="code">stop</span> returns true, but you can change what it returns by overriding the RuleBook's <strong>stopVal</strong> property).</p>

<p>As has been mentioned before, if a Rule returns any value other than its RuleBook's <span class="code">contVal</span> value, the RuleBook will pass that value back to its caller. This may be useful simply as a way of telling the caller what the RuleBook did, but it could also be used if you wanted a RuleBook to calculate a value. Suppose, for example, you wanted to use a RuleBook to calculate the player character's happiness rating; you could do something like this:</p>

 <p><div class="code"><pre>
 happinessRules: RuleBook
    contVal = nil
    total = 0
    initBook()
    {
       total = 0;
    }
 ;
 
 + Rule
    priority = 0
    follow()
    {
       return rulebook.total;
    }
 ;
 
 + Rule
   when = (me.hasSeen(gertrude))
   follow()
   {
      rulebook.total += 3;
   }
 ;
 
 + Rule
   action = Kiss
   dobj = gertrude
   follow() { rulebook.total += 2; }
 ;

 + Rule
   action = Attack
   who = gertrude
   dobj = me
   follow() { rulebook.total -= 10; }
 ;

 + Rule
   when = (orbOfSatisfaction.isIn(me))
   follow() { rulebook.total += 6; }
 ;   
 ... 
 </pre></div>

 <p>Note how we here define a custom <span class="code">total</span> property on the RuleBook to keep track of the value we want to calculate. We can then use the <strong>initBook()</strong> method (which is called whenever we call the RuleBook's <span class="code">follow()</span> method) to reset the value of total to 0 before our rules go on to calculate. We also supply a Rule with a priority of 0 (which should ensure that it's the last rule to run) to return the value of rulebook.total once all the other Rules have had their chance to adjust it.</p>

</div>
<hr class="navb"><div class="navb">
<i>Adv3Lite Manual</i><br>
<a class="nav" href="../../docs/manual/toc.htm">Table of Contents</a> | 
<a class="nav" href="../../docs/manual/extensions.htm">Extensions</a> &gt; 
Room Parts
<br><span class="navnp"><a class="nav" href="roomparts.htm"><i>Prev:</i> Room Parts</a> &nbsp;&nbsp;&nbsp; <a class="nav" href="sensory.htm"><i>Next:</i> Sensory</a> &nbsp;&nbsp;&nbsp; </span>

</div>
</body>
</html>
